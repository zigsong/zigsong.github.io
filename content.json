{"pages":[{"title":"about","text":"🎓 서울대학교 인류학, 정보문화학 (졸업)📚 Frontend &amp; iOS를 공부하고 있습니다.🦁 서울대학교 멋쟁이사자처럼 7기 크루 &amp; 8기 운영진 🎰 2019.6 ~ 2019.8 기획 인턴 @vonvon🦄 2020.1 ~ 2020.4 외주 @dbdlab😇 2020.7 ~ 2020.9 프론트엔드 인턴 @엔젤스윙👥 2020.8 ~ 11 오픈소스 컨트리뷰션 TypeScript Korean Handbook &amp; TypeScript website🖥 2021.2 ~ 11 우아한테크코스 3기 프론트엔드✏️ 2021.7~ 글또 6기👩‍💻 2022.1~ 프론트엔드 엔지니어 @우아한형제들 📨 Contact mewldms5764@gmail.com","link":"/about/index.html"}],"posts":[{"title":"12월 1주차 기록","text":"새로운 시작 | 함수형 프로그래밍 | ES6의 블록 스코프 프론트엔드 공부함수형 프로그래밍🍀 여기서 읽기 자바스크립트의 실행 컨텍스트 - 블록 스코프?자바스크립트의 스코프는 ES6 이후 세 가지로 구분된다. 전역 스코프 함수 스코프 블록 스코프 여기서 전역 스코프와 함수 스코프는 익숙하다. 코드가 처음 실행되거나, 함수가 호출되어 함수 구문에 진입했을 때 각각 전역/함수 실행 컨텍스트가 생성되고 스코프가 형성된다. 블록 스코프는 어떻게 동작할까? 전역/함수 실행 컨텍스트와 비교를 통해 알아보자. (전역/함수 실행 컨텍스트의 동작 원리는 비슷하므로, 하나로 취급할 것이다.) 12345678var apple = 'apple';if (true) { var apple = 'banana'; console.log(apple); // banana}console.log(apple); // banana 전역 실행 컨텍스트에서는 하나의 변수 환경(Variable Environment)이 생성되므로, 두 번째로 선언한 apple은 첫 번째 apple을 덮어씌운다. 전역 실행 컨텍스트의 스코프에서 apple은 banana의 값을 갖게 된다. 블록 스코프는 어떨까? 12345678var apple = 'apple';if (true) { let apple = 'banana'; console.log(apple); // banana}console.log(apple); // apple 첫 번째 선언한 apple은 apple의 값으로 남게 되고, if문(블록) 안에 let으로 선언한 apple만 banana 값을 갖는다. 전역 실행 컨텍스트가 생성될 때, 자바스크립트 엔진은 두 번째 apple을 두 가지 이유로 건너뛰게 된다. let으로 선언된 변수기 때문에 블록 스코프에 있기 때문에 전역에 var로 선언된 변수에는 apple 값이 할당되어 있다. 그러나 코드가 if문(블록)에 진입하면, 중첩 컴파일링이 시작된다. 이때 if문 안의 apple은 변수 환경(Variable Environment)이 아닌 렉시컬 환경(Lexical Environment)에 추가된다. 렉시컬 환경은 스택과 같은 자료구조로 변수들을 관리하기 때문에, let으로 여러번 선언한 변수들은 서로 다르게 관리될 수 있다. 1234567891011121314var apple = 'global apple';let banana = 'global banana';{ let banana = 'block banana'; var grape = 'global grape'; let orange = 'block orange'; console.log(apple); // global apple console.log(banana); // block banana}console.log(banana); // global bananaconsole.log(grape); // global grapeconsole.log(orange); // 🚨 ReferenceError: orange is not defined 따라서 위 코드에서 전역에 생성된 banana와, 블록에 생성된 banana는 각각 독립적인 값을 유지할 수 있게 된다. ES5까지는 오직 함수 스코프를 따르는 var 키워드로 변수를 선언하는 방법밖에 없었다. 그러나 ES6에 등장한 let, const 키워드를 사용하여 블록 스코프에서 변수를 관리할 수 있게 되었다. 렉시컬 환경에서 관리되는 변수의 특성을 잊지 말자! Ref https://cabulous.medium.com/javascript-execution-context-lexical-environment-and-block-scope-part-3-fc2551c92ce0 React Virtualized뻔하디 뻔한(?) 리액트 앱 성능 개선에 관한 글을 읽다가, Virtualized List라는 것에 대해 알게 됐다. 어디서 들어본 것 같기는 한데… 아무래도 어디서 들었는지 모르겠다. 알아보자. List나 Grid와 같은 View가 있을 때, 엄청나게 많은 수의 아이템을 렌더링해야 한다면 스크롤을 내릴 때 렉이 걸릴 것이다. Virtual Rendering을 사용한다면 단지 아이템의 일부분만 렌더링할 수 있어, 성능상의 큰 개선을 이룰 수 있다. react-virtualized 라이브러리를 사용할 수도 있지만, react-virtualized 공식 레포에서는 조금 더 가벼운 버전인 react-window로 시작해보는 것을 추천하고 있다. react-virtualized 라이브러리의 기본적인 사용법은 아래와 같다. 1234567891011121314151617import { List, AutoSizer } from 'react-virtualized';const InfiniteScroll = () =&gt; { return ( &lt;AutoSizer&gt; {({ height, width }) =&gt; ( &lt;List height={height} rowCount={list.length} rowHeight={20} rowRenderer={rowRenderer} width={width} /&gt; )} &lt;/AutoSizer&gt; )} 이런 느낌? AutoSizer라는 HoC로 단일 자식 컴포넌트의 width와 height를 자동으로 조절한다. 제한된 범위 내에서 화면상에 보이는 아이템들만 실제로 렌더링하는 것 같다. AutoSizer의 자식인 List는 window된 아이템의 리스트를 렌더링한다. 내부적으로 Grid를 사용하여 행을 나열한다. 실제 아이템 각각은 List의 어트리뷰트인 rowRenderer를 사용하여 렌더링한다. 12345678910function rowRenderer({ index, isVisible, key, style }) { const user = list[index]; const content = isScrolling ? '...' : &lt;User user={user} /&gt;; return ( &lt;div key={key} style={style}&gt; {content} &lt;/div&gt; );} windowing은 목록을 가상화한다는 의미다. virtualize와도 같은 의미다. 사용자에게 실제로 보이지 않은 컴포넌트는 렌더링하지 않고 영역만 차지하고 있다가, 스크롤을 내리면 비로소 해당 위치에 있는 컴포넌트를 렌더링해서 보여주는 방식이다. 다음에는 virtualized list를 사용해서 인피니티 스크롤을 구현해봐야겠다. Refhttps://javascript.plainenglish.io/react-app-performance-optimization-the-definitive-guide-9b658be3b6e4https://github.com/bvaughn/react-virtualizedhttps://github.com/bvaughn/react-windowhttps://velog.io/@kimjh96/react-virtualized-렌더링-성능-최적화 기타20211202수요일은 팰린드롬 데이였다. 앞뒤가 정확히 대칭인 이런 날이 작년 2월, 그니까 20200202에도 한번 있었는데, 그때만큼의 희열(!)은 아니지만 언제 또 이런 날짜가 다시 올까. 근데 이런 것에 그만 의미 부여하자. 유치해 기술블로그 구독 서비스피들리라는 좋은 사이트가 있다! Ref https://feedly.com/ Dan 선생님과 함께 하는 인터뷰Ref https://www.youtube.com/watch?v=XEt09iK8IXs&amp;feature=youtu.be 구독하기 좋은 기술 뉴스레터 긱뉴스 https://news.hada.io/ 아웃스탠딩 https://outstanding.kr/newsletter 마무리우아한테크코스를 수료한 이후, ‘우테코 n주차 기록’이 아닌 오롯이 나를 위한 12월 첫주차 기록이다. 한 해의 마지막인 12월, 그 달의 첫 주가 지나간다. 그래도 다시 정신 차리고 뭐라도 하고 있다. 알고리즘 스터디도 다시(그치만 혼자), 타입스크립트 이펙티브 스터디도 시작하고, 크루들과 함께하는 유캔두도 시작했다. 건강한 SNS 보는 기분. 재밌다. 우테코 4기에 지원한 분들은 프리코스를 진행하고 있다. 괜히 궁금해서 레포에 들어가봤는데, 이미 다들 엄청난 실력과 스펙을 보유하고 계신다. 이미 나보다 잘하는 분들도 많다. 우테코 3기로 활동할 수 있어서 참 다행이다(?) 그리고 아직도 많은 회사들에선 연락이 없다. 숨막힌다 정말 😞 빨리 다시 코딩하고 싶다. React Native로 뭘 만들지 기획까지 해놓고서, 진도를 나가고 있지 못하다. 아이패드 에어 사서 일러스트 강의 들어야지. 갑자기 폴라로이드도 꽂혀서 중고 뒤지고 있는 중. 물욕 장난 아니다. 그치만 뭐라도 욕심이 있어서 다행이다.","link":"/2021/12/03/2021-12-week-1/"},{"title":"12월 2주차 기록","text":"인생은 회전목마 프론트엔드 공부자바스크립트는 왜 프로토타입을 선택했을까이미 다 아는 내용이라고 생각했는데, 철학적인 접근을 바탕으로 자바스크립트의 프로토타입, this, 호이스팅을 다루고 있는 점이 무척 흥미롭다. C++, Java 등 잘 알려진 객체지향 프로그래밍 언어의 class는 본질을 가리키는 이데아와 실존하는 현실을 구분하는 개념으로 이해하면 쉽다. 1234class Chair { ... }Chair myChair = new Chair(); Chair 클래스는 이데아에 존재하는 추상적인 개념이며, 현실세계에 실제 의자를 만들기 위해서는 new 키워드를 사용하여 구체적인 인스턴스를 생성해야 한다. 플라톤의 이데아 이론은 아리스토텔레스에 이어져 분류(Classification) 개념으로 정립된다. 개체의 속성이 동일한 경우 개체 그룹이 같은 범주에 속한다. 자바스크립트의 프로토타입은 이 ‘분류’ 이론을 정면으로 반박한다. ‘승리’와 ‘패배’와 같은 명확한 결론이 없는 것이다. 어떤 개체들의 공통 속성을 정의하는 대신, ‘의미’에 초점을 두었다. 의미사용이론은 비트겐슈타인 일생의 후기에 등장한 이론으로, ‘사용(use)’에 의해 ‘의미(meaning)’이 결정된다는 의미다. 즉 단어의 ‘진정한 본래의 의미’란 존재하지 않고 ‘상황과 맥락에 의해서 결정된다’는 것이다. 의미사용이론과 유사한 것이 바로 가족 유사성(Family Resemblance) 이다. 갈색 머리, 안경, 수염 등 한 가족이 공유하는 전형적인 특징들은 모든 가족 구성원에게 적용되는 특성은 아니지만, 우리는 이를 ‘가족’으로 분류한다. Rosch의 프로토타입 이론은 이를 바탕으로 한다. 우리는 사물을 분류할 때 가장 유사성이 높은 것부터 순서대로 등급을 매기는데, 이때 가장 높은 등급을 가진 객체가 바로 원형 즉 프로토타입이라는 것이다. 객체는 ‘정의’로부터 분류되는 것이 아니라 가장 좋은 보기(prototype)로부터 범주화된다. 이러한 분류 체계에서는 새로운 대상을 추가하여 분류해야 할 때, 새로운 대상의 몇 가지 특징만 원형(prototype)과 비교확인만 하면 된다. 여기서 또 중요한 것은, 같은 단어라 할지라도 누가 어떤 상황(context)에서 접하느냐에 따라 의미가 달라진다. 프로토타입 이론은 프로토타입 기반 객체지향 프로그래밍 언어인 자바스크립트에 구현되어 있다. 프로토타입 기반 OOP 언어의 특징은 다음과 같다. 개별 객체(instance) 수준에서 메소드와 변수를 추가 객체 생성은 일반적으로 복사를 통해 이루어짐 확장(extends)은 클래스가 아니라 위임(delegation) 현재 객체가 메시지에 반응하지 못할 때 다른 객체로 메시지를 전달할 수 있게 하여 상속의 본질을 지원 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일을 장려 프로토타입 프로그래밍은 일반적으로 분류하지 않고 유사성을 활용하도록 선택결과적으로 설계는 맥락에 의해 평가 변수의 의미는 어휘적인(lexical), 실행 문맥(execution context) 에서의 의미가 된다. 위 개념에 따라 자바스크립트에서는 호이스팅과 this 바인딩이 이루어진다. 프로토타입 기반 언어인 자바스크립트에서는 ‘단어의 의미가 사용되는 근처 환경’에서의 ‘근처’를 어휘적인 범위(lexical scope)로 정의한다. 자바스크립트 엔진은 코드가 로드될 때 실행 컨텍스트를 생성하고 그 안에 선언된 변수, 함수를 실행 컨텍스트의 최상단으로 호이스팅한다. 이 범위를 가리켜 렉시컬 스코프라고 한다. this 역시 실행 맥락에 따라서 결정된다. 어디에 ‘정의’되었는지가 아니라, 어디서 어떻게 ‘발화’되었는지에 따라 달라지는 것이다. 프로그래밍적으로는 실행(invoke)하는 ‘객체’에 중점을 두고 있다. 따라서 아래와 같이 발화(invoke)할 객체를 직접 정할 수 있다. 123foo.bar()bar.call(foo)const boundBar = bar.bind(foo) 저자는 프로토타입을 ‘클래스’의 다른 구현이 아닌, 완전히 새로운 인식 하에 만들어진 이론으로 보고 등장 배경을 철학적인 개념과 접목시켜 설명하고 있다. 프로토타입과 호이스팅, this로 이어지는 흐름까지 한번에 정리해볼 수 있는 재미있는 관점이다. 각 이론에 대한 구체적인 예시들은 아래 링크👇 에서 확인해보자! Ref https://medium.com/@limsungmook/자바스크립트는-왜-프로토타입을-선택했을까-997f985adb42 React Server Component서버 컴포넌트라니. 완전 새로운 논의다. 페이스북… 아니 메타에서 내놓은 소개 영상이 첨부되어 있다. 서버 컴포넌트는 말그대로 서버에서 내려주는 컴포넌트다. App.js가 아닌 App.server.js 등의 이름으로 서버 컴포넌트를 생성한다. 클라이언트에서 사용하는 컴포넌트는 물론 App.client.js라고 사용한다. 아무 postfix도 붙지 않은, App.js와 같은 컴포넌트는 서버와 클라이언트에서 모두 사용 가능한 공유 컴포넌트(Shared Component) 가 된다. 서버 컴포넌트에서 클라이언트 컴포넌트를 import해서 사용할 수도 있다. 이때 서버 컴포넌트에서 클라이언트 컴포넌트로 내려주는 props는 반드시 serializable해야 한다. 따라서 serialize가 불가능한 함수 등을 props로 내려줄 수는 없다. 서버 컴포넌트의 가장 큰 특징은, 서버 컴포넌트에서 사용하는 라이브러리들은 번들 파일에 포함되지 않는다는 것이다! 클라이언트에서 webpack이 할 일이 줄어든다. 번들 크기도 꽤나 획기적으로 감소한다. Dan 선생님이 말씀하시길, 발표 시점 29% 정도가 줄어들었다고 한다. ✅ 서버 컴포넌트 vs SSR기존의 SSR(Server-Side Rendering)과 달리 서버 컴포넌트는 유저 인터랙션 발생 시 클라이언트가 완전히 다시 그려지지 않는다. 서버 컴포넌트는 HTML이 아닌 특별한 포맷으로 된 파일을 렌더링하기 때문이다. SSR과 서버 컴포넌트는 별개의 개념으로, 두 가지를 함께 사용할 수도 있다. (성능 문제로 권장하지는 않는다) ✅ 파일 IOreact-fs 등의 라이브러리를 이용하여 서버 컴포넌트에서 파일을 미리 읽어 클라이언트에서 가공하여 렌더링할 수 있다. 이는 블로그처럼 정적 컨텐츠가 많은 앱에서 사용 시 편리하다. 어쩌면 Gatsby를 대체할 수도? ✅ DB Query서버 컴포넌트는 DB에 곧바로 접근할 수 있다. 물론 보안상 권장하지는 않는다. 이때 DB 데이터가 변경되어도 변경된 데이터에 따른 UI만 업데이트되고, 기존 클라이언트의 UI는 그대로 남아있다. ✅ Pending서버 컴포넌트는 Suspense와도 함께 잘 동작한다. 서버 컴포넌트는 완전한 HTML을 내려주는 것이 아니라, 스트리밍 기법으로 클라이언트에 데이터를 내려주기 때문이다. 클라이언트는 응답이 올 때까지 알아서 대기하며, 먼저 도착한 응답들을 먼저 받기도 한다. 또 응답을 받을 때까지 클라이언트가 처리할 유저 인터랙션들은 여전히 유효하다. 리액트에서 야심차게 내놓은 서버 컴포넌트의 등장 배경과 유효성을 살펴봤다. 정리해보면 다음과 같다. 서버 컴포넌트는 번들 크기를 줄여준다. 서버 컴포넌트를 사용하여 백엔드 자원에 직접 접근할 수 있다. 서버 컴포넌트를 사용하면 꼭 필요한 코드만 로드할 수 있다. 서버 컴포넌트는 모든 구체적인 use case에서 개발자에게 선택권을 준다. 데이터 요청이나 인터랙션을 어디서(서버/클라이언트) 할 것인지 개발자가 결정할 수 있으며, 공유 컴포넌트로도 사용 가능하다. 서버 컴포넌트를 사용하여 서버 중심의 현대적인 UX 멘탈 모델을 설계할 수 있다. 이제 클라이언트는 오로지 UI에만 집중할 수 있게 되었다. 리액트 팀은 서버 컴포넌트의 개발을 위해 현재 Next.js 팀 등과 협업하여 다양한 기능들을 발전시켜나가고 있다고 한다. 앞으로 여러 milestone들을 깨나갈 서버 컴포넌트에 관심을 가지고 지켜봐야겠다 😎 Ref https://github.com/reactwg/server-components 기타2021 당신의 일상생활을 바꾼 앱금융 1위가 업비트라니… 1, 2, 3위 모두 업비트-토스-카카오뱅크가 차지하고 있다니 진짜 금융권의 판도가 완전히 뒤바뀐 것이 실감난다. 소셜 앱에서 네이버 카페와 카카오스토리가 아직도 유효한 것도 신기하다. Ref http://jmagazine.joins.com/forbes/view/334960 프로그래머스 개발자 설문조사취업한 척 하고 슬며시 설문 참여 Ref https://programmers.co.kr/events/survey-2022 Tailwind CSS v3.0Tailwind CSS의 메이저가 업데이트되었다. Ref https://tailwindcss.com/blog/tailwindcss-v3 개발자라면 알아야 할 정규표현식Refhttps://yozm.wishket.com/magazine/detail/1197/https://regexlearn.com/?fbclid=IwAR2W5OPJ-OJNJiSSi6NtWY7mpxdvjHDzPL0DVJJGTW1_yRPOxZ087cc8oLo 오늘의집 MSA PhaseMSA(MicroService Architecture)란 작고, 독립적으로 배포 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임워크다. 반대 개념인 Monolithic Architecture는 소프트웨어의 모든 구성요소가 한 프로젝트에 통합되어 있는 형태를 가리킨다. 부분적인 장애 대응과 서비스의 변경을 유연하게 하고, 배포 시간의 단축을 위해서 MSA를 사용하는 것이 대세가 되고 있는 듯하다. 블로그에서는 오늘의집 기존 Rails 서버에서 클라이언트 코드를 분리하는 과정을 소개하고 있다. 클라이언트와 서버의 관심사를 분리하고, 클라이언트 코드가 독립적으로 움직일 수 있는 클라이언트 서버를 만들었다. git subtree를 사용하여 저장소의 히스토리를 보존하고, Github Actions를 활용하여 각 레포에 동기화 스크립트를 작성했다. 클라이언트 서버는 react-rails를 사용하여 React에서 핸들링 가능한 내용만 필터링하여 걸러내고, 아닌 것은 전부 Ruby 서버에서 처리하도록 했다. 개발 서버와 프로덕션 서버를 분리하여 개발 환경에서는 webpack을, 프로덕션 환경에서는 static provider를 사용하도록 구현했다. 싱글스레드로 동작하는 Node.js의 한계를 극복하기 위해 React를 렌더링하기 위한 스레드 풀을 구성하고, 렌더링을 할 때마다 잠시 빌려 쓰는 방식으로 동시 처리량을 늘렸다. Refhttps://www.bucketplace.co.kr/post/2021-12-03-오늘의집-msa-phase-1-프론트엔드-분리작업/https://wooaoe.tistory.com/57 ES Proposals언젠가 나도 Proposal을 올려보고 싶다. Ref https://www.proposals.es/ 새로운 React 프레임워크, Remix리액트의 오랜 불편함이었던 SSR, SEO, 라우팅 문제에 대한 대안을 제공한다. 어떤 기능들을 제공하는지 한번 살펴봐도 좋을 것 같다. 그런데 이름이 Remix라 서치하기가 너무 어렵다. 😵 Refhttps://remix.run/https://dev.to/ishubhamprakash/remix-a-new-react-framework-from-the-creators-of-react-router-5886 시니어가 주니어에게소프트웨어도 결국 사람을 돕기 위한 것이다. 다른 사람을 돕기 위한 마인드를 갖추자! 자기객관화와 자신감과 친절함은 덤. 그리고 뻔한 말이지만 본인만의 페이스로 차근차근, 덤덤하게. 지금의 나에게 아낌없이 투자하고, 조금이라도 더 행복하게 지내자. 취업이 안 되는 건 내 잘못이 아니다. 신기한 일은 자주 일어나지 않는다. Ref https://www.inflearn.com/pages/for-junior-developers-20211207 마무리쇼미더머니10의 ‘회전목마’라는 노래에 완전히 꽂혀서 매일 100번씩 듣고있다…🎠 올해가 2주 남았다. 괜히 몽글몽글해진다. 금요일에는 크루들과 함께 최근에 이사한 크루의 (강제)집들이를 갔다. 폴라로이드도 첫 개시하고, 밤늦게까지 신나게 놀다 나왔다. 아직도 면접, 지원, 코딩테스트, 과제전형의 연속이다. 하나 둘 취업에 성공하는 크루들이 생겨나고, 옛 친구들의 소식들도 들려온다. 이런지가 너무 오래돼서 그런지, 엄청나게 큰 타격은 없다. 우연히 ‘나미야 잡화점의 기적’을 읽기 시작했다. 아직까진 역시나 유치한 내용이지만, 그런 감성을 또 너무 좋아하는 걸 어떡해 🤷‍♀️","link":"/2021/12/12/2021-12-week-2/"},{"title":"12월 3주차 기록","text":"우아한형제들 합격 프론트엔드 공부우아한 타입스크립트🍀 1부 - 여기서 읽기🍀 2부 - 여기서 읽기 React Native드디어 조금씩 개발하는 중..!createBottomTabNavigator로 탭바를 만들고 커스터마이징을 했다. 기타TC39에 합류하게 된 Deno로고가 귀여워서(??) 개인적으로 내적 친밀감을 갖고 있었던 JavaScript의 새로운 런타임 Deno가 드디어 정식 합류하게 되었다! 문법 뿐만 아니라 런타임과 같은 개념도 올라가는구나. 신기하면서도 반갑다 Ref https://news.hada.io/topic?id=5548 React Conf 2021 Recap✔️ React 18 과 concurrentReact 18에서는 concurrent 기능들을 소개했다. 또 Suspense, Server Components, 새로운 React 워킹 그룹과 React Native를 위한 long-term many-platform 비전을 소개했다. ✔️ 앱 개발자들을 위한 React 18React 18 RC를 시작할 수 있다. React 18 RC에서는 createRoot를 사용한다. 123const container = document.getElementById('root');const root = ReactDOM.createRoot(container);root.render(&lt;App/&gt;); ✔️ Suspense로 스트리밍 서버 렌더링 구현하기Suspense를 이용하여 SSR의 성능을 향상시켰다. 앱을 작은 부분들로 나누어 서로 독립적으로 스트리밍할 수 있다. 이에 따라 유저는 컨텐츠를 더 빨리 보게 되고, 인터랙션 속도도 빨라진다. ✔️ 첫 번째 React 워킹 그룹다양한 전문가, 개발자, 메인테이너, 교육자들이 함께한 첫 번째 워킹 그룹을 만들었다. 여러 API들을 만들고 다듬는 중이다! ✔️ React 개발자 도구React DevTools를 새롭게 개편하고 Timeline Profiler를 만들었다. ✔️ memo 없는 React자동 메모이제이션(auto-memoizing)이 가능한 컴파일러를 소개했다. ✔️ React docs keynote Ref https://reactjs.org/blog/2021/12/17/react-conf-2021-recap.html CRA v5.0 출시Node 10과 Node 12에 대한 지원을 중단하고, 최신 LTS 버전만을 지원하게 되었다. 그밖에도 다양한 Breaking Changes와 Bug Fix, Enhancement 사항들을 확인해보자! Ref https://github.com/facebook/create-react-app/releases/tag/v5.0.0 소프트웨어 아키텍쳐의 중요성유명한 &lt;리팩토링&gt;의 저자 마틴 파울러 선생님… 인상이 굉장히 강렬하시다. 전문 개발자들이 공유하는 ‘아키텍쳐’라는 개념은 사회적인 것이다! 아키텍쳐 디자인은 우선적으로 진행되어야 한다. 올바른 결정은 더 빨리 내려지는 것을 원한다.(한번 시작한 이후에는 바꾸기 어렵기 때문이다) ‘지식을 공유하는 것’ 과 ‘바꾸기 어려운 것’ 이 합쳐졌을 때, 중요한 무언가가 탄생한다. 그리고, 품질! 일반적으로 품질과 비용은 트레이드오프의 대상이다. 그러나 소프트웨어의 품질은 그렇지 않다. 빠르게 개발하려고 적은 비용을 들인다면, 장기적인 관점에서 지속적으로 우리를 갉아먹게 된다. 프로젝트를 진행하면서 디자인이나 아키텍쳐에 대해 생각하지 않는다면, 시간이 지날수록 새로운 기능을 추가하기가 어려워진다. 이미 존재하는 소스코드를 수정하는 데 오래 걸리기 때문이다. 우리는 좋은 아키텍쳐를 가지고 지속적으로 관심을 가져야 한다. 그러면 기능 구현도 빨라지게 될 것이다. 이미 존재하는 소스코드가 ‘플랫폼화’되어 있기 때문이다. 경제학적 관점에서 좋은 아키텍쳐가 중요한 이유다. Ref https://www.youtube.com/watch?v=4E1BHTvhB7Y&amp;feature=youtu.be 개발자가 알아야 할 스톡옵션의 모든 것진짜 경제지식도 빠삭한 개발자들이 참 많다. 근데 작성하신 이 분도 토스 개발자셨다. 스톡옵션 킹 토스… 엄청 긴 글인데 그만큼 자세하고 핵심적인 내용들을 설명하고 있다. 이제 이런 것도 생각할 나이라니 🤦‍♀️ Ref https://evan-moon.github.io/2021/12/04/what-is-stock-options/ 마무리드디어 취준이 끝났다. 사실 아직 두 군데 남아있다. 근데 그냥 너무 지쳤다. 눈물 날 거라고 생각했는데 그 정도로 펑펑 울 줄은 몰랐다. 대학 합격했을 때도 펑펑 울었다. 그땐 기쁨 20%, 재수하지 않아도 된다는 안도감 80%이었는데 6년이 지난 지금은 좀 다르다. (6년이나 지났다니…) 안도감 5%, 그냥 너무 힘들었던 시간들이 떠올라서 95%, 기쁨은 1% 미만이다. 잘 안된 크루들도 있어서 신경이 많이 쓰인다. 면접 결과가 이해되지 않는 크루들도 있다. 금방 다들 좋은 곳들에 취업하길 바라지만, 나도 비슷한 시간들을 지난 몇 달 동안 겪었기 때문에 정말 힘겹고 어려운 일이라는 걸 안다. 그냥 그래서 답답한 마음이 다 가시진 않는다.","link":"/2021/12/19/2021-12-week-3/"},{"title":"12월 4~5주차 기록","text":"서러움 가득 변명같은 건 굉장히 싫어하는 편이다.그럼에도 4-5주차가 묶인 이유는… 코로나 집콕일기격리기간 동안 기존에 만들던 ‘단짝’ 앱을 잠시 미뤄두고, 같은 형태에 컨텐츠만 다른 앱을 후루룩뚝딱 만들고 있다. 로그인 로직React Navigation 공식문서에서 권장하는 대로, Auth 관련 로직을 React의 Context Provider를 이용하여 hook으로 사용하고 있다. 앱의 진입점이 될 AppStack 내부에서 isLoggedIn 여부에 따라 보여줄 Navigator를 달리한다. 로그인이 된 유저라면 MainNavigator를, 로그인되지 않은 유저라면 AuthNavigator를 띄운다. 12345678910111213const AppStack = () =&gt; { const { isLoggedIn } = useAuth(); return ( &lt;Stack.Navigator screenOptions={{ headerShown: false }}&gt; {isLoggedIn ? ( &lt;Stack.Screen name=&quot;Main&quot; component={MainNavigator} /&gt; ) : ( &lt;Stack.Screen name=&quot;Auth&quot; component={AuthNavigator} /&gt; )} &lt;/Stack.Navigator&gt; );}; 아래와 같이 렌더링된다. 지금은 별다른 로그인 절차없이 버튼만 누르면 넘어갈 수 있게끔 만들었다. AppStack이 Stack Navigator임에도 불구하고 한번 로그인이 된 이상 앱 전역에서 사용하는 isLoggedIn 값이 true기 때문에, MainNavigator의 스크린으로 간 이후에는 다시 로그인 화면으로 돌아올 수 없다. 중첩된 Navigator와 HoC메인 기능은 BottomTabNavigator를 중심으로 화면 전환이 가능한데, 그러는 와중에 각 스크린에서 우측 상단의 설정 버튼 터치 시 설정 화면으로 이동하길 바랐다. (애증의 당근마켓을 많이 참고했다. ㅎㅎ) 1234567891011121314151617181920212223242526const routes = [ { name: 'chart', // ... screen: ChartScreen, }, // ...];const Tab = createBottomTabNavigator();const MainNavigator = () =&gt; { return ( &lt;Tab.Navigator screenOptions={{ /* ... */ }} &gt; {routes.map((route) =&gt; ( &lt;Tab.Screen key={route.name} name={route.title} component={route.screen} options={{ /* ... */ }} /&gt; ))} &lt;/Tab.Navigator&gt; );}; createBottomTabNavigator로 기본적인 MainNavigator를 만들고, StackNavigator인 HeaderNavigator를 별도로 만들어 설정 관련된 스크린을 포함하도록 했다. 그리고 MainNavigator의 Screen에 들어갈 각 컴포넌트들을 withHeaderNavigator로 감싸주었다. HoC의 개념만 알고 제대로 사용해본 건 처음이라, 게다가 타이핑까지 해주느라 살짝 애를 먹었다. 12345678910111213141516171819const Stack = createStackNavigator();const HeaderNavigator = ({ component }: Props) =&gt; { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Root&quot; component={component} options={{ headerShown: false }} /&gt; &lt;Stack.Screen name=&quot;Settings&quot; component={SettingsScreen} options={{ title: '설정', ...headerOptions }} /&gt; &lt;/Stack.Navigator&gt; );};const withHeaderNavigator = &lt;P extends object&gt;(Component: React.ComponentType&lt;P&gt;) =&gt; () =&gt; &lt;HeaderNavigator component={Component} /&gt;; 1234567const ChartScreen = () =&gt; { return ( // ... )}export default withHeaderNavigator(ChartScreen); 아래와 같이 잘 동작한다! DatePicker처음에는 @react-native-community/datetimepicker를 선택했었다. 다운로드 수도 가장 많고, expo에서 공식 지원하는 문서가 있었기 때문이다. 그런데 해당 라이브러리는 날짜가 보이는 형식을 커스터마이징할 수가 없었다. 그리고 버튼을 눌렀을 때 하단 모달 형태로 DatePicker만 띄우길 원했는데, 한번 네이티브한 날짜 표기가 뜨고 그 이후에 다시 날짜를 눌러야만 DatePicker가 나와서 맘에 들지 않았다. 그래서 선택한 것은 react-native-modal-datetime-picker다. 다운로드 수도 꽤 되고, 내부적으로 @react-native-modal-datetime-picker를 사용한다고 하니 단순히 UI적으로만 간편하게 도움을 받을 수 있을 것 같았다. Chart library차트 라이브러리 선택이 정말 골칫덩어리였다. 우선 고려사항이었던 라이브러리들은 다음과 같다. react-native-svg-charts - 커스터마이징을 자유롭게 할 수 있지만, 너무나 날것이다. 빠르게 만들어 배포하기에는 적합하지 않다. react-native-charts-wrapper - 용량이 매우 커서 별로다. 그래서 가장 처음에 선택했던 react-native-chart-kits를 그대로 쓰기로 했는데, 커스터마이징이 정말 어렵다. 깃헙에 이슈도 엄청 많고, 그냥 돌아버린다. 그래도 차악이라 어쩔 수 없이 사용한다. 지금만 해도 bar의 backgroundColor 커스텀이나 topValue의 margin 설정, 숫자 포맷팅 등을 전혀 할 수 없다. 그래도 일단 그냥 두어야지 🤦‍♀️ TextInput의 onChangeTextReact Native의 TextInput에는 onChange와 onChangeText 속성 두 가지가 있다. 뭔지 몰라 각각의 타입 시그니처를 살펴봤다. 123onChange?: ((e: NativeSyntheticEvent&lt;TextInputChangeEventData&gt;) =&gt; void) | undefined;onChangeText?: ((text: string) =&gt; void) | undefined; 완전 좋다! 더 이상 구질구질하게 event.target.value와 같은 코드를 작성하지 않아도 된다. 아래처럼 바로 setState를 넘겨줄 수 있는 것이다! 1234567891011const SignInScreen = () =&gt; { const [name, setName] = useState(''); return ( &lt;TextInput value={name} onChangeText={setName} placeholder=&quot;이름을 입력해주세요&quot; /&gt; )} 왜 이런거 React에는 안 만들어줘 🤯 기타벨로그의 프론트엔드 작가https://velog.io/@teo 주니어를 넘어서, 성장하는 개발자의 길 위키 형식으로 블로그 관리하기 주어진 기회를 놓치지 않고, 먼저 나서서 일하기 코드리뷰하기 테스트코드 작성하기 일지에서 히스토리로, 히스토리에서 문서로 짝코딩으로 스스로의 문제 파악하기 내가 먼저 좋은 친구 되기 Refhttps://www.inflearn.com/pages/weekly-inflearn-38-20211228 플래시의 죽음에서 배우는 위기를 기회로 만드는 방법좋은 개발자는 특정 개발 언어를 깊게 파서 마스터하는 개발자가 아니라, 시장과 사용자가 요구하는 기술에 빠르게 대응할 수 있는 개발자다. 끊임없이 공부하고, 시대가 변하더라도 변하지 않는 내공에 집중하자. 개발의 목표는 개발 언어 공부 자체가 아니라, 그 결과물이다. Refhttps://www.youtube.com/watch?v=0WUXSPEp-cc 마무리코로나에 걸렸다.지난주는 내내 몸도 아팠고, 정신적으로도 스트레스가 너무 컸다.취업하자마자 아무것도 못하고 코로나라니. 격리기간에 크리스마스도 연말도 다 껴버리다니.연속으로 많은 회사들을 떨어졌을 때보다도 더 힘들었다.그리고 백신을 굉장히 불신하게 됐다. 맞으면 뭐하나. 가족 전부 다 걸리고 약을 다시 타 받아 먹을 정도로 증상도 꽤나 심했는걸. 이제 돌이킬 수 없는 폐를 갖게 됐다는 사실이 끔찍하다. 백신패스 때문에 부스터샷은 맞아야겠지만, 그냥 무능한 정부가 원망스럽다. 태어나서 가장 긴 기간 동안 외출하지 못한 채 아픈 상태로 혼자 지내면서, 끝없이 찾아오는 불행한 생각을 덜어내려고 앱을 만들기 시작했다. 격리되어본 사람만 알 수 있는 느낌을 가득 담고 있다. 그래도 주위 좋은 사람들 덕에 조금씩 이겨내고 있다. 애써 생각을 바꿔보려고 한다. 계속 불행하게만 생각하면 나아질 게 하나도 없는 건 맞다. 무척 속상한 건 맞지만, 인생이 무너질 정도의 재산적 피해나 삶을 송두리째 바꿔버릴 상실감, 그런 게 아니잖아. 분명 나는 젊고, 아직 할 수 있는 것들이 많이 있다.","link":"/2021/12/30/2021-12-week-4/"},{"title":"1월 첫주차 기록","text":"나름 시끌벅적한 새해의 시작 코로나 격리해제됐다. 내 세상이다. 코로나 집콕일기firebase RealTime database 헤매기firebase에 firestore 말고 RealTime database가 언제 생겼는지는 모르겠지만, 아무튼 생겼다고 한다. RealTime database는 여러 클라이언트에서 실시간으로 상태를 동기화해야 하는 모바일 앱을 위한 효율적이고 지연 시간이 짧은 솔루션이다. 하지만 경험해보니 그렇게 유용한지는 모르겠다. 사용 방법도 솔직히 불편하다. 여기에서 서비스의 특성에 맞게 firestore와 RealTime database 중에서 추천해준다고 하는데, 뭘 하든 그냥 RealTime database를 쓰라는 것 같다 😑 더군다나 react query와 함께 사용하려니 정말 거지같았다! 그래도 여차저차 포스팅을 참고해서 realTimeApi 클래스를 만들어보았다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445export class RealTimeApi { #firebase: FirebaseApp; constructor() { this.#firebase = initializeApp({ // ... }); } public fetch&lt;T&gt;(path: string): Promise&lt;T&gt; { return new Promise&lt;T&gt;((resolve, reject) =&gt; { const db = getDatabase(); const reference = ref(db, path); onValue(reference, (snapshot) =&gt; { const data = snapshot.val(); if (data) { resolve(data); } else { reject(new Error('firebase get error')); } }); }); } public post&lt;T&gt;(path: valueof&lt;typeof API_PATH&gt;, postBody: T): Promise&lt;void&gt; { return new Promise&lt;void&gt;((_, reject) =&gt; { const db = getDatabase(); const newPostKey = push(child(ref(db), path)).key; try { const updates: Record&lt;string, T&gt; = {}; updates[path + newPostKey] = { id: newPostKey, ...postBody }; return update(ref(db), updates); } catch (error) { reject(new Error('firebase post error: ' + error)); } }); }}export default new RealTimeApi(); react query hook에서 사용은 아래와 같이 하고 있다. 12345678910111213const fetchTalks = async () =&gt; { try { const data = await realTimeApi.fetch&lt;TalkContent[]&gt;(API_PATH.talk); return data; } catch (error) { console.error(error); }};const useLoadTalks = (options?: UseQueryOptions&lt;TalkContent[] | undefined, AxiosError&gt;) =&gt; { return useQuery&lt;TalkContent[] | undefined, AxiosError&gt;('confirmedData', fetchTalks, options);}; 타이핑이 아직 살짝 부족하다. 그래도 타입스크립트의 매력을 조금씩 더 알아가고 있다. 어쨌든, ‘이야기’ 탭의 글 작성과 불러오기에 성공했다. 어김없이 어거지 코딩이 조금씩 늘어나고 있긴 하지만 화면 하단 노란 에러는 흐린눈 할거다. JavaScript의 Date아직도 헤매면서 사용하고 있었다니! 정말 바보잖아. Date.now()와 new Date() 모두 현재 시점의 DateTime을 제공하지만, Date.now()는 number 타입의 timestamp를 반환하고, new Date()는 Date 객체를 반환한다. (엄밀히 말하면 타입은 그냥 ’object’지만, Date 객체를 따른다.) 12new Date(); // Sat Jan 08 2022 23:52:00 GMT+0900 (한국 표준시)Date.now(); // 1641653520000 new Date()로 생성한 Date 객체에서 getTime() 메서드를 호출하면 Date.now()와 같은 number 타입의 timestamp를 얻을 수 있다. 12const date = new Date();date.getTime(); // 1641653520000 Refhttps://ko.javascript.info/date 기타Dan abramov - a hundred things i learned working on the react team 매년 사용자는 바뀌고, 새로운 사용자는 과거의 문제를 이해하지 못한다. 이전 사용자는 흥미를 잃는다. 새로운 사용자는 다른 시각을 갖고 있다. 그에 맞춰 계획해야 한다. 문제를 고칠 때 문제를 우선 파악하는 것이 중요하다. 잘못된 문제 해결은 10가지의 새로운 문제를 낳는다. 대부분의 PR은 해결되기보다 더 많은 일을 낳는다. 코딩 자체보다는 결정을 내리는 데 무수한 시간이 들어가기 때문이다. 라이브러리의 PR description은 훌륭해야 한다. 몇 년 후 누군가가 버그를 발견하거나 변경을 할 때 매우 고마워할 것이다. 몇몇 트롤이 전체 토론장을 망칠 수 있다. 내부 실행 모듈에 유닛 테스트 대신 public API에 대한 테스트를 작성해라. 그러면 테스트를 이용하여 실행 코드를 얼마든지 다시 작성할 수 있다. 오래가는 브랜치는 썩는다. 죽은 코드를 제거하거나 배포 환경에서 feature flag changes를 배포할 수 있는 좋은 flag 메커니즘을 고안하자. 측정에 빨간불이 켜졌다면, 느려진 것이다. 그러나 다른 동작을 깨뜨리는 버그를 만들었거나, 측정이 로깅되는 방식이 바뀌었을 수도 있다. 측정은 어렵다. 사람들은 유명한 프로젝트에 PR을 올려 github을 꾸미고 싶어한다. 누군가는 이를 convert하고, 또 다른 누군가는 다시 convert한다. 스타일에서의 단순한 실수를 발견할 때까지는 merge되지 않을 것이다. 뭔가 고쳤다면, 실패하는 테스트를 만들어라. 그렇게 하지 않으면 누군가는 이를 다시 망가뜨려놓을 것이다. …제목의 ‘a hundred’를 주의했어야 했다. 진짜 백 개라니. 포기 🤮 Ref https://threadreaderapp.com/thread/1470613731071696896.html 하버드 CS50 새로운 버전Ref https://www.youtube.com/playlist?list=PLhQjrBD2T383f9scHRNYJkior2VvYjpSL 마무리코로나 격리해제됐다. 나름 잘 놀고 오고, 빡빡하게 친구들도 많이 만났다.그리고 내일모레면 이제 다시 수술실과 입원실로(…) 들어간다. 이건 예상에 있던 거니까 딱히 우울하진 않다. 입원하는 동안 조용히 할 것들이 많아서 설레기까지 한다(?) 우테코에서 우형으로 크루들 중 절반 정도가 이번주에 입사했다. 톡방이 매일같이 시끌시끌하더니, 금요일 저녁부터 조용해졌다. 벌써 지친게야 🤦‍♀️ 조잘조잘 말하는 내용들을 조금씩 주워담으며 입사 마음가짐을 해본다. 졸업한 주제에 학교 포털에서 여전히 SNUON 강의를 들을 수 있어서, 작년 1월에 절반쯤 듣다 우테코가 너무 빡세 포기했던 컴퓨터구조 강의를 다시 듣고 있다. CS에서 네트워크가 제일 중요하다고는 들었는데, 살짝 찍먹했던 컴퓨터구조 수업도 나름 흥미로웠다. 이때 아니면 언제 공부해보겠어. 아이패드 에어를 구매했다. 신학기 프로모션 열린 당일에 후닥 구매해서 애플스토어까지 가서 직접 픽업했다. 케이스는 맘에 드는 게 하나도 없지만 그래도 적당히 괜찮다 ㅎㅎ 열심히 공부해야지. 좋은 인연이었던 아이디어스에서 드로잉 클래스 수강권도 구매했다!","link":"/2022/01/08/2022-1-week-1/"},{"title":"1월 2~3주차 기록","text":"2주 순삭 2주차에 아무것도 못한 이유는?! 기타개발도 안 하고, 공부도 안 했다. 그래도 뭐 아주 엉망으로 살았던 건 아니다. 엉망으로 살기가 제일 어려운 새럼… 컴퓨터구조 강의SNUON은 졸업생에게도 열려있었다. 돈 한 푼 안 내고 나름 양질의 강의를 (음질은 정말 별로지만..) 꿀 빨며 듣고 있다. 물론 과제도 시험도 하나도 안 따라간 채로 설렁설렁, FE Conf 듣듯이 보고 있다. (그래도 필기는 한다) 나름 재미있는 것 같기도. 총 14강 중 작년 1월에 9강까지 들었는데, 드디어 마지막 강의다. 후후후… 해치워버리고 입사해야겠다. 드로잉 클래스그림을 그릴 수 있는 프론트엔드 개발자가 되겠다고, 야심차게 아이패드까지 새로 샀으니 그림을 그려야만 한다. 아이디어스 클래스가 꽤 맘에 들어서, 무제한 스트리밍권을 사서 수강했다. 야심차게 3개 강의의 준비물까지 받았으나, 1개만 듣고 그만 할래… 역시 그림은 내 스타일이 아니었다. 했으나 수강권 연장했다. 어차피 한 달은 운동도 못하니, 한 달만 더 그리고 그만둬야겠다.(?) 이런 그림들을 그렸다고 한다... 그래도 맨 처음보단 조금 는 것 같기도 하다. 착각이어도 내 마음이다. 재테크(?) 계획안 쓰는(또는 정체를 알 수 없는) 통장과 카드들을 모두 해지하고, 급여 통장을 개설하고, 새 카드를 만들고, 수중에 있는 돈을 모두 파악 후 적당히 나누었다. 청약금액도 늘리고, 미국주식도 시작해볼 계획이다. ISA도 개설해서 목돈을 모아볼 예정이다. 그리고 기부처를 정했다. 희망조약돌이라는 곳에 조금이나마 정기후원을 할 생각이다. 아직 구체적인 사업을 정한 건 아니지만, 국내 아동, 특히 학대피해아동들에게 도움이 될 수 있는 곳으로 후원을 하고 싶다. 연금저축이니, 신용카드니 하는 것들은 조금 사회생활 해본 후에 본격적으로 시작해야겠다. 아직은 섣부른 것 같다. 근데 복지카드 받으려면 신카 신청해야 하는 것 같다. 종합병원치과, 정형외과, 3차병원(수술), 대학병원(흉터치료) 총 4군데의 병원을 동시에 다니고 있었다. 거기다 얼마전 코로나까지 걸린 전적이… 다행히(??) 치과는 이제 졸업했다. 앞으로 벌어들일 돈의 대부분은 병원비로 나갈 걸 생각하니 정말 아찔하다. 이펙티브 타입스크립트 마무리이펙티브 타입스크립트를 혼자 1회독, 그리고 챌린져스 스터디를 통해 추가 1회독까지 마무리했다. 2번이나 읽었지만 응용해본 것은 많지 않아 아직도 갈 길이 멀다. 그래도 이전보단 확실히 뭔가 개념이 잡힌 것 같다. 또 업무에서 써가면서 실력을 늘려나가면 될 일이다. 마무리수술을 받고 왔다. 격리해제된지 열흘 만에 다시 일주일 간 격리라니 -_- 다행히 코로나 양성 받고 병원 들어갔드만 수술 이후에 열이 계속 안 내려서 코로나 검사 받고 병동 안에서도 격리 병실에 하루 있었다. 서러웠지만 모두 친절하게 다 해주셔서 생활 자체는 나쁘지 않았다. 취뽀 후 두 차례의 격리(…)를 거치고 어찌나 사람이 고팠던지… 다친 무릎을 이끌고 많은 사람들을 만나고 있다. 무릎은 아프고 날은 춥지만 맛있는 거 먹고 신나게 떠들 수 있을 때 많이 즐겨야지. 인생이 거의 단기 욜로가 됐다. 이제 진짜 입사다. 입사 안내 가이드도 왔다! 입사 후에도 일주일에 한 번씩 글을 쓸 수 있기를 바란다. 제발 😵","link":"/2022/01/20/2022-1-week-2-3/"},{"title":"1월 4주차 기록","text":"온보딩 온보딩웰컴키트가 도착했다. 엄마가 저거 오려놨다…🤦‍♀️ 다행히(?) 다른 크루들에 비해 상태가 굉장히 좋은 맥북이 도착했다. 디스플레이도 16인치로! 최신 맥북 수급이 이렇게 어려운 일이었다니 😵 애플 놈들은 빨리 맥을 내놓아라… 피플팀에서 너무나도 알차게 준비해준 온보딩 데이 덕에 동기 분들이랑도 재밌는 시간 보내고, 입사 시 필요한 내용들을 잘 준비할 수 있었다. 쿼카를 닮으신 귀여운 팀 돌보미님도 바쁘신 와중에 매일같이 섬세하게 잘 챙겨주셔서 편하게 이것저것 많이 질문했다. 거의 물음표 살인마… 차근차근 꼼꼼하게 익히고 정리해서 얼른 개발을 시작해보고 싶다. 새로운 툴 익히기처음 써보는 gitlab, jira와 confluence 등 회사에서 필요한 업무 툴들을 익히는 데 시간이 좀 걸릴 것 같다. 주변에서 강추했던 git kraken도 써봐야겠다. git은 항상 두려운 존재… iterm도 zsh의 기능들과 함께 이쁘게 꾸며놨다. 아무래도 매일 쓰는 게 예뻐야… 그리고 슬랙에 허들이라는 기능이 생겼다! (나만 몰랐나) 카카오톡 보이스톡같은 느낌인데, 화면공유도 할 수 있고 생각보다 음질도 괜찮다. &lt;객체지향의 사실과 오해&gt; 워크샵운 좋게도 입사한 주에 새로운 주제로 프론트엔드 워크샵이 시작됐다. 🍀 여기서 읽기 드로잉 클래스그림 너무 못 그리는 것 같아서 안 그리려고 했는데… 무제한 스트리밍권 무료이용권이 끝나고 3만원에 한 달만 연장해서 강의 하나 더 듣기로 했다. 아직 운동하긴 이르니까, 조만간 운동을 시작하기 전까지 정적인 취미생활로 치는 것이다. 이번 강의가 훨씬 더 좋은 것 같다! 작가님 말하는 스타일도, 그림 내용도, 그림체도 맘에 든다. 내게 필요했던 꿀팁들도 알려주셔서 좋당. 진짜 초딩같다. 마무리첫 이틀은 끝나자마자 뻗어버렸다. 세상에, 5시에 퇴근하는데 그래도 그동안 쉬었던 몸이 갑자기 초집중력을 발휘하려다보니 피곤했나보다. 그래도 이틀 만에 조금 마음이 진정됐는지, 온보딩 자료도 더 살펴보고 이것저것 하고싶은 것도 했다. 재택이라 집에만 있긴 하지만 그래도 사람들과 이야기하고 새로운 정보들을 마구마구 집어넣으니 좀 생동감 있게 살고 있는 것 같다. 우테코 4기 크루들이 슬랙에 초대됐다. 1년 단위로 이루어지다보니, 진짜 새내기 생활이 끝나고 후배를 맞는 기분이다. 이렇게 4기, 5기… 두 자리 수가 될 때까지 무한히 가려나? 그때쯤이면 나도 중니어 개발자 쯤은 되어 있으려나.","link":"/2022/01/29/2022-1-week-4/"},{"title":"2월 첫주차 기록","text":"뒹굴뒹굴 명절 배워가기이제 조금씩 회사 코드를 보고 있다. 오랜만에 보는 클래스 컴포넌트와 처음 써보는 mobx, 그리고 사용해보고 싶었던 graphQL까지 공부해야 할 것들이 아주 많다! 하나하나 차근차근 팀원 분들께 물어보면서 익혀나가고 있다. 이번주부터는 보안상 문제가 되지 않는 선에서(!) 새로 알게 되거나 고민해본, 개념적인 내용들 위주로 정리해보려고 한다. Node의 child_process노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는 빌트인 모듈이다. 노드가 가동되는 프로세스 외에 별도의 프로세스를 가동하여 명령을 수행하고 결과값을 노드 프로세스에 돌려준다. Refhttps://nodejs.org/api/child_process.htmlhttps://darrengwon.tistory.com/1195 처음 보는 webpack plugin들 BannerPlugin번들링된 파일의 상단에 배너(텍스트)를 달아주는 플러그인이다. 결과물에 빌드 정보나 커밋 버전 내용 등을 추가할 수 있다. ProvidePlugin모듈을 import 또는 require 할 필요 없이 자동으로 로드한다. 자주 사용되는 모듈을 미리 등록하여 매번 작성하지 않게 해준다. 1234new webpack.ProvidePlugin({ identifier: 'module1', // ...}); 프로젝트에서는 Buffer를 ProvidePlugin으로 사용하고 있는데, 왜 그런지 찾아봤다.webpack ver5 이후부터는 Node.js의 API를 자동으로 지원하지 않기 때문에 polyfill로 사용할 수 있도록 만들어주거나, 모듈을 전역 API로 사용할 수 있게끔 ProviderPlugin을 사용해야 한다. Refhttps://webpack.js.org/plugins/banner-plugin/https://velog.io/@cckn/웹팩-플러그인-사용법-및-주요-플러그인https://viglucci.io/how-to-polyfill-buffer-with-webpack-5 React가 제공하는 빌트인 함수/프로퍼티 React.Children.toArrayReact.Children은 불투명(Opaque) 자료 구조인 this.props.children를 다루는 유틸리티 함수들을 제공한다. 💡 불투명 자료구조라이브러리나 API에서 제공하는 자료형들은 대부분 구조체가 아니라, 그냥 메모리 주소만 담고 있는 포인터들이다. 객체 내부의 데이터 구조를 감추고 대신 이러한 객체를 다룰 수 있는 API 함수를 통해서만 객체를 조작하도록 하기 위해 사용된다. React.isValidElement() React.cloneElement() 12345React.cloneElement( element, [config], [...children]) element를 기준으로 새로운 React 엘리먼트를 복사하고 반환한다 config는 key와 ref 그리고 모든 새로운 props를 포함한다. 새로운 엘리먼트에는 원본 엘리먼트가 가졌던 props가 새로운 props와 얕게 합쳐진 뒤 주어진다. 새로운 자식들은 기존의 자식들을 대체한다. config에 key와 ref가 없다면 원본 엘리먼트의 key와 ref는 그대로 유지된다.부모 컴포넌트에서 받은 children prop을 추가하거나 수정하고 싶을 때 유용하게 사용할 수 있다. children prop을 여러번 반복해서 렌더링하거나 새로운 prop을 추가하고 싶을 때, 또는 Header와 같은 공용 컴포넌트에 서로 다른 children prop을 넘겨줄 때 사용한다. cloneElement()를 사용할 때 children을 새롭게 만드는 것은 아니라는 사실에 유의하자. Refhttps://ko.reactjs.org/docs/react-api.htmlhttps://soooprmx.com/cobjetive-c-불투명-타입/https://blog.logrocket.com/using-react-cloneelement-function/ JSX IntrinsicElementsJSX의 global namespace에 원하는 요소를 넣어 해당 요소들을 JSX 렌더링 시 태그처럼 활용할 수 있다. 12345678declare namespace JSX { interface IntrinsicElements { foo: any }}&lt;foo /&gt;; // 성공&lt;bar /&gt;; // 오류 Refhttps://typescript-kr.github.io/pages/jsx.html typescript abstract class추상 메서드나 추상 필드는 아직 실행(implementation)이 제공되지 않은 프로퍼티로, 반드시 추상 클래스(abstract class) 안에 있어야 한다. 일반 클래스에서 사용 시 자동으로 초기화가 되지 못하기 때문이다. 12345678910abstract class Base { abstract getName(): string; printName() { console.log(&quot;Hello, &quot; + this.getName()); }} const b = new Base();// 🚨 Cannot create an instance of an abstract class. 추상 클래스는 new 키워드로 인스턴스를 만들 수 없다. 클래스를 상속 받아 추상 멤버들을 구현해줘야 한다. 12345678class Derived extends Base { getName() { return &quot;world&quot;; }} const d = new Derived();d.printName(); 추상 클래스의 모든 추상 멤버들을 구현하지 않으면 에러가 발생한다. 12345class Derived extends Base { // ...}// 🚨 Non-abstract class 'Derived' does not implement inherited abstract member 'getName' from class 'Base'. 추상 클래스는 서브 클래스의 베이스 클래스로 쓰인다. 추상 멤버가 없는 클래스, 즉 일반적으로 사용하는 클래스는 굳이 칭하자면 구현 클래스(concrete class)라고 부른다. Refhttps://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members typescript의 isArrayLike()인자가 null이 아니고 Symbol.iterator 를 함수 프로퍼티로 갖고 있는지 확인한다. 12const isArrayLike = (obj) =&gt; obj != null &amp;&amp; typeof obj[Symbol.iterator] === &quot;function&quot;; 1234isArrayLike([1, 2, 3]); // trueisArrayLike(document.querySelectorAll(&quot;.className&quot;)); // trueisArrayLike(&quot;abc&quot;); // trueisArrayLike(null); // false 드로잉 클래스진짜 그만 그려야지. 강의 두 개 다 들었다 ㅎㅎ 이런 대작도 그려서 아이패드 배경화면도 하고, 움직이는 애니메이션도 따라 그려봤다. 이제 스스로의 창의성을 발휘할 때다. 과연… 기타슬기로운 개발생활Refhttps://github.com/dizy64/wise-developer-life [6월 우아한테크세미나] 디자인시스템이 가져온 변화Refhttps://www.youtube.com/watch?v=aVHLcQzcRbA&amp;t=4s React에서 Mobx 경험기 (Redux와 비교기)3년 전 글이라 지금은 사용되지 않는 기능들도 있지만, 확실히 Redux를 정말 싫어했던 나로써는 MobX도 시도해보고 싶은 방식이다. 글에서 기억에 남는 MobX의 특징들을 정리하자면 아래와 같다. 객체지향적이다. class를 제대로 사용할 수 있다. 렌더링할 state를 관찰대상으로 지정하고, state를 변경하면 리액트 컴포넌트가 리렌더링된다. state의 불변성을 유지하기 위한 노력이 불필요하다. state를 객체 리터럴로 사용하는 것이 아니라, class로 선언하기 때문에 프로퍼티를 동적으로 추가하기가 간편하다. 항상 같은 instance를 참조하기 위해서 store는 싱글톤으로 유지해야 한다. 모델 Layer를 분리하기 때문에(비즈니스 로직을 분리) 컴포넌트는 view의 렌더링에만 집중할 수 있다. 별도의 서드파티 라이브러리 없이 비동기 함수를 호출하는 도구를 제공한다. Refhttps://techblog.woowahan.com/2599/ 마무리일주일의 절반을 설 연휴로 날리고… 그저 뒹굴뒹굴 놀았다. 코로나 3만명 시대라니. 그동안 무념무상이었다가 다시 경각심이 생겨서 약속을 취소했다. 빨리 사무실 가보고 싶은데 😞 다시 코로나 걸리는 건 정말 싫다. 오미크론은 증상이 심하지 않다 해도, 격리생활 자체가 너무 싫다. 회사 코드를 보다보니 더 실감도 나고 빨리 티켓도 처리해보고 싶다. 또 하다보면 알 수 없는 에러들에 막혀 머리 아프고 삽질하는 시간들이 많겠지만, 그게 내가 선택한 길이니까 🤷‍♀️ 요즘 왜 기력이 남아도는지 모르겠다. 직장인 조와! 수술한 부위도, 무릎도 많이 괜찮아져서 드디어 필라테스도 등록했다. 거금을 들어 듀엣 필라테스로… 기력이 남아도는 걸 넘어서 짱 쎈 사람이 될거다.","link":"/2022/02/05/2022-2-week-1/"},{"title":"5월 1주차 기록","text":"휴일인듯 휴일아닌 휴일같은 날 배워가기앱 스킴(App Scheme)앱 스킴(App Scheme)은 **딥링킹(Deep Linking)**과 **액션(Action)**으로 이루어져있다. 딥링킹 - DeepLink를 통해서 앱 내, (혹은 다른 앱)의 특정 화면으로 이동하는 것 URI 인코딩이 필수적이다 화면의 이름은 Unique 해야한다 파라미터의 키 역시 Unique 해야한다 액션 - 딥 링킹을 제외한 특정 동작들을 수행하는 것 웹 뷰 화면 닫기 웹 뷰 리프레시 외부 웹 뷰로 이동하기 react hooks dependenciesreact hooks api에 dependencies가 필요한 이유는 클로저 때문이다. 클로저는 메모리 누수에 취약하다는 위험이 있다. 함수를 스코프 밖에서도 사용하게 되면 가비지 컬렉팅이 제대로 작동하지 않을 수도 있다. hooks에 deps를 선언하는 것은 프로그래머로 하여금 명시적으로 의존도를 관리하게끔 한다. 이때 hooks는 deps를 비교하기 위해서 Object.is() 메서드를 활용한다. Object.is() 연산은 non-primitive한 값들에 대해서는 메모리 레퍼런스를 비교한다. hook을 컴포넌트 밖으로 옮기고, dependencies에 primitive한 값들만 선언함으로서 대부분의 hook 관련 버그를 해결할 수 있다. 원링크(One Link) URL - 웹사이트의 페이지 주소 URI 스킴 - 앱의 페이지 주소 딥링크 - 앱에서 메인홈이 아닌 특정 페이지로 갈 수 있는 링크 앱이 설치되지 않은 사람을 그 페이지에 보낼 수 없을 때 사용하는 링크가 원링크 (또는 다이나믹 링크)이다. 앱을 설치한 사람은 바로 프로모션 페이지로 보내지고, 아니면 OS에 맞게 앱스토어로 보내고, 앱을 설치하고 앱열기를 클릭하면 해당 프로모션 페이지에 도달할 수 있게 한다. 앱스플라이어(Appsflyer)는 원링크를 만들어주는 도구이다. Ref http://minhyun0821.com/onelink/ AbortControllerAbortController는 하나 이상의 웹 요청을 취소할 수 있게 해준다. AbortController.signal이라는 것도 있다 (readonly). AbortSignal 객체 인터페이스를 반환하는데, 이를 fetch 함수의 RequestInit 옵션에 추가한 후 AbortController.abort() 함수로 요청을 취소할 수 있다. 123456789101112131415161718192021const controller = new AbortController();const signal = controller.signal;const downloadBtn = document.querySelector('.download');const abortBtn = document.querySelector('.abort');downloadBtn.addEventListener('click', fetchVideo);abortBtn.addEventListener('click', function() { controller.abort(); console.log('Download aborted');});function fetchVideo() { ... fetch(url, {signal}).then(function(response) { ... }).catch(function(e) { reports.textContent = 'Download error: ' + e.message; })} 요청을 취소(abort) 하면 AbortError 이름의 DOMException 으로 Promise가 reject 된다. 모든 응답, 스트림을 취소할 수 있기 때문에 다운로드 중 취소, 강제 타임아웃 에러 등 다양한 처리를 할 수 있다. Ref https://developer.mozilla.org/ko/docs/Web/API/AbortController/signal offsetHeight vs clientHeight vs scrollHeight offsetHeight - 요소의 높이로 패딩, 스크롤 바, border가 포함되고 마진은 제외된 값 clientHeight - 요소의 inner height로 padding 값은 포함되지만, 스크롤바, border, 마진 값은 포함하지 않는다. scrollHeight - 요소에 들어있는 컨텐츠 전체 높이 (overflow되어 보여지지 않는 내용들도 포함된 요소의 높이)로 패딩과 border는 포함되고 마진은 제외된 높이. 브라우저의 캐시브라우저에 캐시가 저장되면 만료될 때까지 캐시는 브라우저에 남아있게 된다. CDN Invalidation같은 작업이 있더라도 브라우저의 유효한 캐시는 사라지지 않는다. 캐시의 유효기간이 max-age=0 이어도 일부 모바일 브라우저에서 브라우저를 껐다 켜기 전까지 리소스가 만료되지 않는 경우가 있다. 이때는 no-store를 활용해서 캐시자체를 막아야된다. swimlane UI직역해서 ‘수영장 레인’이라고 생각했다. 그렇게 나쁜 해석은 아닌 것 같았다. 근데 영어 해석은 그렇지 않았나보다. 검색해보니 위키에서는 아래와 같이 설명하고 있다. swimlane은 비즈니스 프로세스의 하위 프로세스에 대한 작업 공유 및 책임을 시각적으로 구분하는 프로세스 플로우 다이어그램 또는 플로우 차트에 사용됩니다. swimlane은 수평 또는 수직으로 배열 될 수 있습니다. 이 무슨 재미없고 딱딱한 설명인가. dribble에서 검색 결과로 나온 것들은 아래와 같은 UI다. 뭘 설명하려는지 잘 모르겠다. 회사에서 이번에 새로운 광고상품이 나가면서 오픈리스트의 우리가게클릭 가게들을 swimlane UI로 바꿨다고 하는 것을 들었는데, 아래처럼 수평 정렬으로 늘어뜨린 것을 말한다고 그냥 생각해야겠다. p vs divp와 div 모두 대표적인 블록 요소인데, 각각 어떤 상황에 써야 할까? 복잡한 말은 말고, 심플하게만 알아보자. p 문자 단락 div를 포함할 수 없다 div 레이아웃 계층 나누기 p를 포함할 수 있다 Ref https://dasima.xyz/div-vs-span-vs-p-차이는-블록-요소와-포함-유무/ 이것저것 navigator의 clipboard API는 secure origin (HTTPS, localhost) 환경에서만 사용가능하다. Number wrapper는 string의 앞뒤 공백을 제거한 뒤 Number 타입의 값으로 캐스팅한다.123Number(' 44 ') =&gt; 44Number(' 44') =&gt; 44Number('44 ') =&gt; 44 302 Http Status Code OAuth 흐름에서 자주 사용된다. 302 코드는 요청된 리소스가 지정된 URL로 일시적으로 이동되었음을 나타낸다. 서버가 302를 반환하고 set-cookie가 설정되면 브라우저는 위치 이동을 시작하기 전에 현재 페이지 도메인 아래에 쿠키를 설정할 수 있다. (다른 도메인으로 이동하더라도) 유니코드 예전에 세계의 각 언어가 고유 인코딩 방식을 가지고 있었다. 그런데 이게 어떤 나라의 인코딩 방식이 다른 나라에서는 완전히 다른 언어로 인식되는 등 많은 문제가 있었다. 그래서 인코딩 방식에 대한 표준으로 나온 것이 유니코드이다. 프로젝트를 npm 으로 관리할 때 버전에 따라서 안에서 사용되는 서버의 변경을 관리할 수 있는지 고민하자. IDE와 워크스페이스에서 사용하는 패키지(ex. typescript)의 버전이 다를 수도 있다. 기타useEvent RFCReact에 추가될지도 모르는 useEvent hook은 가장 최신 상태의 props나 state를 읽지만, 항상 함수의 동일성을 유지한다(stable function identity). useEvent로 정의된 이벤트핸들러는 memoization의 룰을 깨지 않으며, effect를 다시 트리거하지 않는다. 많은 의견들이 달렸는데, hook 자체 기능에 대한 논의보다는 이름을 무엇으로 지을 것인가에 대한 의견이 분분하다. 역시 뭐든 새로 나올 때는 이름을 잘 짓고 봐야… Ref https://github.com/reactjs/rfcs/pull/220 &lt;dialog&gt; 엘리먼트를 기반의 다이얼로그 컴포넌트 제작기&lt;dialog&gt;는 대화 상자 요소로, 닫을 수 있는 경고, 검사기, 창 등 대화 상자 및 기타 다른 상호작용 가능한 컴포넌트를 나타낸다. 12345678&lt;dialog id=&quot;dialog&quot;&gt; &lt;form method=&quot;dialog&quot;&gt; &lt;p&gt;Hi, I'm a dialog.&lt;/p&gt; &lt;button&gt;OK&lt;/button&gt; &lt;/form&gt;&lt;/dialog&gt;&lt;button onclick=&quot;dialog.showModal()&quot;&gt;Open Dialog&lt;/button&gt; 기본으로 제공되는 &lt;dialog&gt; 요소에 여러 GUI적인 기능들을 덧붙여 커스텀한 다이얼로그 컴포넌트를 만든 과정을 소개하고 있다. 다이얼로그 모달의 크기에 따른 분류, 다이얼로그가 열렸을 때 포커싱, 다른 요소들 inactive시키기, ESC로 창 닫기 등 UX의 관점에서 섬세한 디테일들을 만들 수 있다. 근데 진짜 뭐가 많다. 진짜 광기… Ref https://developer.mozilla.org/ko/docs/Web/HTML/Element/dialog https://web.dev/building-a-dialog-component/#overview 마무리사내에서 하는 어떤 프로젝트(?)를 위해서 nest를 공부하고 있다. nest 자체는 크게 어렵지 않은데 (아직까지는…), typeORM을 해보겠다고 MySQL을 공부하고, 그러려고 docker를 배우고..! docker와 종일 싸우느라 nest는 멀어졌다. 어린이날에 친구들 만나고, 새벽에 갑자기 배가 너무 아파서 응급실에 다녀왔다. 뭐가 문제였는지도 모를 만큼 검사 결과는 다 정상이었고 (중대병원은 이미 내 신뢰를 잃었지만 ㅡㅡ) 수액과 진통제 맞고 2시간 만에 퇴원했다. 수납하면서 실비 보험서류 챙겨달라할 만큼 멀쩡해져서 나왔다. 다시 푹 자고 멀쩡히 출근해서 일했당. 근데 징크스가 생긴 것 같다. 5월엔 꼭 발을 다치고, 깁스를 하고, 그 상태로 응급실 갈 일이 생긴다는 것. 결코 평화롭지만은 않은 가정의달도 이렇게 슝슝 지나갈 것 같다.","link":"/2022/05/07/2022-5-week-1/"},{"title":"6월 1주차 기록","text":"꿈에 그리던 제주도 코딩(?) 배워가기이미지 로딩이 실패했을 때이미지 로딩이 실패 했을 때 대체 이미지를 띄우려면 onError 핸들러에서 currentTarget.src에 대체 이미지를 넣어줄 수 있다. 12345&lt;img src={originImg} onError={handleImgError} /&gt;const handleImgError = (e) =&gt; { e.target.src = defaultImg;} 타입스크립트 함수에서 void를 리턴하면123456function sayHi(): void { console.log('Hi!')} let speech: void = sayHi(); console.log(speech); // undefined 일반적으로 void는 함수가 아무것도 리턴하지 않을 때 사용한다. 그러나 함수의 실제 리턴 값은 undefined일 것이다. 타입스크립트 문서에는 다음과 같이 설명되어 있다. Contextual typing with a return type of void does not force functions to not return something. 리턴 타입으로 void를 명시한 함수에게 무언가를 리턴하도록 강제하지 않을 뿐, 실제로는 무언가 값을 리턴해도 상관없다. 따라서 함수의 리턴 타입을 void로 선언한 후 number, string[] 등의 값을 리턴한다고 해서 에러가 나지 않는다. 123const f1: () =&gt; void = () =&gt; { return 'foo'; // ✅ OK}; 사실 이는 타입체킹을 하지 않는 것이 아니라, 문자열을 반환해도 void를 반환하는 것과 다름없기 때문이다. 12declare const a: () =&gt; stringdeclare const b: () =&gt; void 1234function doSomething(): void { a() b()} 일반적으로는 string extends void는 유효하지 않지만, 함수 반환 타입에 있어서는 string이 void보다 넓은 타입, 즉 서브타입이라고 해도 무방하다. 공변과 반변에서, 반환 타입은 공변함을 알 수 있다. 아래와 같은 함수 타입을 정의했을 때, 1type F&lt;T&gt; = () =&gt; T 함수 a와 b는 각각 다음처럼 표현할 수 있다. 12type A = F&lt;string&gt;type B = F&lt;void&gt; string은 void보다 넓은 타입이기 때문에, b의 자리에 a를 넣는 것이 가능하다. 1234declare let a: Adeclare let b: Bb = a 그러면 아래와 같은 코드가 가능하다. 1let b: (() =&gt; void) = (() =&gt; 'dd') 그러나 리터럴 함수 정의문이 void 타입을 리턴한다면 해당 함수는 절대로 아무것도 리턴해서는 안 된다. 1234567function f2(): void { return true; // 🚨 Type 'boolean' is not assignable to type 'void'} const f3 = function (): void { return true; // 🚨 Type 'boolean' is not assignable to type 'void'}; 이는 그저 특이 케이스라고 하는데, 이럴 거면 그냥 void 타입은 아무것도 리턴하게 하지 말지. 괜히 헷갈리게.. 🤨 HTTP 상태코드 401 vs 403 401 Unauthorized 인증(Authentication) 거부 또는 인가(Authorization) 거부 클라이언트가 credential 정보를 보내지 않았거나 유효하지 않은 credential을 보낸 경우 예시 액세스토큰을 보내지 않음 =&gt; 로그인 안됨. 액세스토큰을 보냈는데 만료됨 =&gt; 로그인 만료됨. 스펙의 “If the reqeust already included Authorization credentials, then the 401 response indeicates that authorization has been refused for those credentials.“에 해당 403 Forbidden 인가(Authorization) 거부 클라이언트의 credential이 유효한데, 해당 자원에 접근할 권한이 없는 경우 예시 로그인은 되었는데 관리자 페이지 접근권한은 없음. Uniform Resource Identifier(URI)URI는 인터넷에 있는 자원을 나타내는 유일한 주소 encodeURIComponent - URI의 특정한 문자를 UTF-8로 인코딩한다. decodeURIComponent - encodeURIComponent, 또는 비슷한 방식으로 만들어진 URIComponent를 해독한다. react-redux v822년 4월 17일에 react-redux v8이 릴리즈되었다. 타입스크립트에서 useSelector의 state 인자의 기본타입이 DefaultRootState였는데 unknown 으로 바뀌었다. 기존에는 useSelector를 사용할 때 useSelector((state: RootState) =&gt; state.someReducer);와 같이 매번 RootState 써주기 번거로워 아래와 같이 작성 후, 123declare module 'react-redux' { interface DefaultRootState extends RootState {}} useSelector(state =&gt; state.someReducer);로 사용했었는데 이제 이런 코드는 유효하지 않게 되었다! 이유는 수많은 코드에서 라이브러리의 타입을 덮어씌우는 행위가 프로젝트와 Redux 라이브러리 간의 타입을 간섭하고 오염시킨다고 판단한 것 같다. 위 방법은 막혔지만, 아래처럼 useSelector 자체를 선언해버리면 된다. 123declare module 'react-redux' { export declare const useSelector: &lt;T&gt;(selector: (state: RootState) =&gt; T, equalityFn?: EqualityFn&lt;T&gt;) =&gt; T;} UTC, ISO 8601, RFC 3339 UTC 협정 세계시(Coordinated Universal Time) 라 하며 1972년 1월 1일 부터 시행된 국제 표준시. 영어권은 CUT, 프랑스어권은 TUC(Temps Universel Coordonne) 를 제안했는데 두 언어 모두 C, T, U 로 구성되어 있는것을 착안하여 UTC 를 약어로 결정했다. UTC는 그레고리력의 표기를 따른다. UTC+0은 그리니치 표준시를 토대로 한다. 그리니치시는 런던에 소재한 그리니치 천문대를 기준으로 하는 경도를 사용한다. (그리치니 천문대의 경도 = 0.00) ISO 8601 국제표준화기구(ISO) 에서 지정한 날짜와 시간의 표기에 관한 국제 표준 규격. YYYY-MM-DDThh:mm:ss.sssZ - T를 기준으로 왼쪽은 날짜, 오른쪽은 시간이며 Z는 zone offset 을 의미한다. (zone offset: UTC의 시차) 한국을 기준으로 UTC 시간대를 표기하면 2022-05-30T14:57:34.630Z UTC 외의 시간대에서는 2022-05-30T05:57:34+09:00 위 두 시간은 동일 RFC 3339 ISO 8601 을 인터넷 프로토콜로 어떻게 다룰 것인지를 규정한 RFC. ISO 8601 와의 차이점 중 하나는 T의 생략을 허용하지 않는 대신에 날짜와 시간 사이에 공백을 허용한다. 예) 2022-05-30 05:57:34+09:00 console 가지고 놀기console.log() 에 %c(치환 문자)를 사용하면 스타일을 설정할수 있다. console.log() 에 복잡한 객체를 출력할 때는 객체를 깊은 복사(Deep Copy) 해주어야 정확한 값이 출력된다. ([object object]로 출력되는 경우) 1console.log(JSON.parse(JSON.stringify(obj))) 객체는 참조형 데이터이기 때문에 console.log를 사용한 시점의 객체값을 보장할 수 없다. JSON 문자열로 변환(stringify)했다가 다시 객체로 변환(parse) 해줌으로써 객체에 대한 참조를 없앨수 있다. console.table() 을 사용하면 배열이나 JSON 형태의 값을 key-value 형태의 테이블 형식으로 보여준다. d.ts 파일 포함한 모듈 배포하기tsconfig.json에서 일반적으로 typeRoots에 node_modules/@types를 설정해놓기 때문에, .d.ts 파일을 포함한 모듈은 @types/~~로 배포해야 한다. 빌드된 모듈을 배포할 수도 있다. output: { ... libraryTarget: 'umd' ... }을 명시해주면, umd 로 패키지를 번들할 수 있다. 이때 모듈을 빌드된 상태로 배포를 하면, 트리셰이킹이 되지 않을 수 있다. 모듈을 사용하는 프로젝트의 번들 크기가 커질수 있으니, react와 같이 큰 라이브러리는 번들 대상에서 제외시켜주고 peerDependencies에 넣어주는 것이 좋다. Semantic VersioningSemantic Versioning은 버전을 표시할 때 자주 사용되는 규약 (npm, node 모두 이 규약을 따름)으로, MAJOR, MINOR, PATCH로 구분된다. MAJOR - 인터페이스가 변경되는 등의 하위버전과 호환성이 깨 질만한 큰 변경사항이 있는 버전 MINOR - 하위버전과 호환(backwards-compatible)이 되지만, 기능이 추가된 버전 PATCH - 하위버전의 버그를 수정한 버전 Dependencies에 기재된 버전에 붙은 ^(캐럿) 기호의 의미: MINOR나 PATCH 버전은 하위호환성이 보장되므로 업데이트를 한다. 1.0.2: &gt;=1.0.2 &lt;2.0 1.0: &gt;=1.0.0 &lt; 2.0 1: &gt;=1.0.0 &lt; 2.0 userEvent.click()userEvent.click() 을 사용할 때 해당 엘리먼트의 상위 엘리먼트에서 pointer-events: none 속성을 가지고 있다면 throw 에러를 발생시킨다. 1234567891011&lt;div className=&quot;App&quot;&gt; &lt;h2&gt;RTL Test Sample&lt;/h2&gt; &lt;div style={{ pointerEvents: &quot;none&quot; }}&gt; &lt;div&gt;{count}&lt;/div&gt; &lt;div style={{ pointerEvents: &quot;auto&quot; }}&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click Me!&lt;/button&gt; // userEvent.click() =&gt; throw Error(&quot;Unable to perform pointer interaction as the element inherits `pointer-events: none`&quot;) 이 때 skipPointerEventsCheck 옵션을 활성화시켜 엘리먼트를 클릭할 수 있다. 1userEvent.click(elem, undefined, { skipPointerEventsCheck: true }) :first-child 와 :first-of-type일반적으로 :first-child는 자식의 첫번째 요소를 의미하고, :first-of-type은 div:fist-fo-type 과 같이 어떤 태그의 첫번째 요소를 뜻한다. 태그 없이 :first-of-type 을 사용했을 때는, 모든 엘리먼트의 첫번째 요소들을 의미한다. 즉 기본 선택자 없이 :first-of-type을 사용하면 전체 선택자(*)가 암시된다. 12345678910111213141516171819const DSSample: React.FC&lt;SampleProps&gt; = (props) =&gt; { return ( &lt;Article&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;p&gt;Paragraph 1.&lt;/p&gt; &lt;h1&gt;h1&lt;/h1&gt; &lt;p&gt;Paragraph 2.&lt;/p&gt; &lt;p&gt;Paragraph 3.&lt;/p&gt; &lt;div&gt;hh&lt;/div&gt; &lt;/Article&gt; )}export const Sample = DSSampleconst Article = styled.article` &amp; :first-of-type { color: red; }` 무중단 배포운영중인 서비스를 중단하지 않고 신규 소프트웨어를 배포하는 기술이다. 무중단 배포의 핵심은 로드밸런서를 통해 연결된 서로 다른 인스턴스에 트래픽을 제어해 배포하는 것이다. 무중단 배포는 크게 세 종류로 나뉜다. 롤링 배포 사용중인 인스턴스 내에서 새 버전을 점진적으로 교체하는 가장 기본적인 무중단 배포 방식 배포가 진행되는 동안 구버전과 신버전이 공존할 수 있다. (호환성 문제 발생 가능성) 서비스 중인 인스턴스 하나를 로드밸런서에서 라우팅 하지 않게 닫는다. 새 버전 인스턴스를 실행, 다시 라우팅 되도록 열어준다. 라우팅 닫았던 old 인스턴스를 중지한다. 1번으로 가서 반복 블루-그린 배포 블루 = 구버전 / 그린 = 신버전 실제 운영환경에서 신버전을 미리 테스트할 수 있다. 시스템 자원이 두배가 필요하며 신버전에 대한 테스트가 전제되어야 한다. 구버전과 동일한 운영환경으로 신버전 인스턴스를 준비한다. 로드밸런서를 통해 신버전으로 모든 트래픽을 한번에 전환한다. 카나리 배포 블루-그린 배포 방식과 거의 유사 트래픽을 한번에 넘기는 것이 아닌 10%, 20%, 80%, 100% 등 점점 트래픽을 늘려가면서 적용한다. 소수의 유저에게만 배포 + 테스트를 해보면서 점차 많은 유저들에게 배포할 수 있다. 이것저것 @testing-library/react를 사용하는 경우 screen.debug()를 통해 현재 렌더되고 있는 JSDOM을 console로 확인할 수 있다. 테스트는 코드의 단위를 검증하는게 아니라 동작의 단위, 즉 문제 영역에 의미가 있는 것, 이상적으로는 비지니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 한다. VSC Jest 익스텐션은 Jest Config 설정에 따라 실제 테스트 결과와 다른 값을 반환할 수도 있다. 따라서 Jest Config에 따라 Jest Extension도 커스텀 해서 사용해야 하는 경우가 존재한다. 하나의 VirtualDOM에서 mobX 컨택스트를 multiple 하게 사용하려면 configure({ isolateGlobalState: true }) 설정이 필요하다. 기타크롬 개발자 도구의 Recorder 패널와! 정말 fancy하다. recording 버튼을 클릭하여 사용자 플로우를 그대로 녹화하고, 재생하고, 수정과 측정까지 가능하다. 구글에서 제공하는 coffee-cart 사이트에서 체험 가능하다. 기록 결과를 JSON이나 Puppeteer로 export도 가능하다고 한다! Ref https://developers.google.com/codelabs/devtools-recorder#0 달라지는 CSS아직도 CSS 잘 모르는데 이것저것 또 추가되고 바뀌고~! State of CSS 2022를 살펴보면 된다. 킹콜라스 선생님의 영상에서 간략하게 살펴볼 수도 있다. 상당히 fancy하고 그동안 왜 안 해줬나 싶었던 기능들이 포함됐다! :has라니.. 유용하게 사용할 수 있을 것 같다. @scope도 유사한 기능을 보여주고 있다. 그리고 css에도 중복 코드를 줄이기 위해 @nest 가 등장했다. 상당히 어색하지만 혁신적이다. 마무리지난주 엠티를 다녀오자마자 제주도 여행을 갔다. 사전투표하고 갔당. ㅎㅎ 개발자 남자친구와 함께 노트북까지 챙겨서 갔고, 남자친구가 일 좀 해야 한다고 했는데, 정작 남친 말고 내가 일했다 😭 바다가 보이는 카페에서 미팅도 참석하고, 방에 돌아와서 코드도 짰다. 그렇게 아주아주 나쁘진 않았다. 놀러가서도 일하는 개발자가 멋져보이는 아직 1년차 개발자… 하지만 나는 멋지지 않았다. 배포 전까지 요구사항이 조금씩 바뀌는데 그 점을 고려하지 못하고 휴가쓰고 갔다온 것 같다. 아직 이런 회사 업무와의 밸런스 조절이 어려운 것 같다. 그래도 평화롭게 (운전도 무사히 하고 ✌️) 잘 다녀왔더니 팀명이 바뀌어 있었다! 알고는 있었지만 뚝딱 바뀌어버리니 괜히 어색. 이름도 엄청 길당. fancy한 축약어가 나왔으면 좋겠다. 정말정말로 모든 팀원분들, 실장님까지 참석하신 프론트엔드 송별회 겸 회식에서 늦게까지 신나게 놀다왔다. 다들 알고보면 정말 재밌는 분들이다 내가 제일 조용할 지도 모른다 🤫","link":"/2022/06/04/2022-6-week-1/"},{"title":"6월 2주차 기록","text":"뭐가 그리 문제야 배워가기컴포넌트 인터페이스 설계컴포넌트 인터페이스를 설계할 때, “타입 강제” vs “어느정도 사용자에게 책임을 위임” 사이에서 적절히 줄다리기를 해야한다. 한 컴포넌트에서 많은 케이스들에 대응하기 위해, 상황별 타입을 강제하려다보면 인터페이스의 복잡성과 개발 리소스가 많이 들어가게 된다. 하나의 컴포넌트에서 케이스가 많을 때는 컴포넌트를 사용하는 사용자에게 어느정도 책임을 넘겨줌으로써, 적당한 타협점을 찾아야 효율적으로 개발이 가능할 수 있다. Node 타입 알아보기Node.nodeType을 이용하여 Node의 타입을 체크할 수 있다. elements, text, comments와 같은 노드 각각의 타입을 구분해준다. 구체적인 예시는 아래와 같다. Node.ELEMENT_NODE (1) - &lt;p&gt;나 &lt;div&gt;와 같은 Element node Node.ATTRIBUTE_NODE (2) - Element의 속성 Node.TEXT_NODE (3) - Element나 Attr 안에 있는 실제 Text 노드 … Node.DOCUMENT_NODE (9) - Document 노드 참고로, Document.documentElement는 문서의 루트 요소를 나타내는 Element를 반환한다. 예를 들면, &lt;html&gt; 요소가 있다. 1234document === document.documentElement // falsedocument.documentElement === document.querySelector(&quot;html&quot;) // truedocument.nodeType === 9 // truedocument.documentElement.nodeType === 1 // true 이벤트 리스너의 event.target은 기본적으로 EventTarget으로 추론되는데, nodeName과 nodeType으로 Element인지 여부를 판별할 때 위같은 방식을 활용할 수 있을 것이다. Ref https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType https://developer.mozilla.org/ko/docs/Web/API/Document/documentElement react-query의 옵션들enabled 옵션은 query에서 사용할 값이 유효할 때만 useQuery가 동작하도록 하는 옵션이다. 주로 다른 useQuery의 결과값을 사용해야 하는 useQuery의 경우, 먼저 실행되는 useQuery가 Hydration이 되어있지 않다면 첫 data가 undefined라서 무의미해져버리는 문제를 해결하기 위해 사용한다. refetchInterval은 주기적으로 refetch(polling)해주는 옵션이다. default 값이 있어서 주기적으로 refetch를 하는데,number를 넣어 주기를 조절할 수 있다. function을 넣으면 주기적으로 refetch한 결과값을 해당 function에 전달해서 호출한다. react-router-dom v65버전 이하에서는 Link에서 다음 페이지에 값을 넘길 때 넘길 때 사용하는 state가 to prop 안에 있었지만,6버전부터는 to와 같은 레벨로 위치가 변경되었다. 12345// before&lt;Link to={{ pathname: ‘’, state: { } }} /&gt; // after&lt;Link to={{ pathname: ‘’ }} state={{ }}/&gt; 타입스크립트의 d.ts 파일과 모노레포모노레포 공통 모듈의 extension.d.ts 파일은 어디까지나 공통 모듈만 사용할 수 있다. 프로젝트는 빌드될 때 각 프로젝트 환경 내에 있는 tsconfig 영역에 있는 declaration 파일만 사용하기 때문에, 프로젝트 외부에 있는 extension.d.ts 파일에서 declare한 타입을 사용하는 공통모듈을 사용할 경우, 프로젝트 extension.d.ts 파일에 동일한 타입을 declare해야한다.그렇게 하지 않으면 개발 중에는 타입체킹에 문제가 없지만, 빌드할 때 해당 타입을 찾을 수 없다는 에러가 발생한다. 메시지를 수신한다는 것어떤 메시지를 수신한다는 것은, listener라는 객체가 listener.listen('message')와 같은 방식으로 수신하고 있는 것이다. 아래 예시 코드에서, Sender가 전송자가 된다. 12345class Sender { send(listener) { listener.listen }} useRef vs createRefcreateRef는 함수로, 리렌더할 때마다 인스턴스를 만든다. 따라서 리렌더 간 값이 보장되지 않는다. 하지만! 이는 함수 컴포넌트에서 사용했을 경우다. 함수 컴포넌트는 인스턴스를 생성하지 않으며, 리렌더링할 때마다 매번 새롭게 함수를 생성한다. 함수 컴포넌트의 createRef는 리렌더링할 때마다 새로운 인스턴스를 만들기 때문에, 렌더링 전후 값을 보장해주지 않는다! 따라서 함수 컴포넌트에서 사용할 수는 있지만, 권장하지는 않는다. 그러나 클래스 컴포넌트는 리렌더링할 때마다 인스턴스를 새로 만드는 것이 아니기 때문에, 클래스 컴포넌트의 createRef는 리렌더링 전후에 값을 보장해준다. 클래스 컴포넌트는 unmount되지 않는 이상 계속 같은 인스턴스를 사용한다. 클래스 컴포넌트의 constructor에 console.log를 찍어서 확인할 수 있다! useRef는 이름에서도 알 수 있듯이 hook이며, 컴포넌트 생애주기 동안 유지된다. 리렌더링 시에도 값이 바뀌지 않는다. 매번 새로운 인스턴스를 생성하지 않기 때문이다. hook이기 때문에 함수 컴포넌트에서만 사용 가능하다. 기존의 createRef에, useMemo를 더한 느낌이다. Ref https://www.geeksforgeeks.org/difference-between-useref-and-createref-in-reactjs/ https://tecoble.techcourse.co.kr/post/2021-05-15-react-ref/ normalizenormalize() 메서드는 주어진 문자열을 유니코드 정규화 방식(Unicode Normalization Form)에 따라 정규화된 형태로 반환한다. 만약 주어진 값이 문자열이 아닐 경우에는 우선 문자열로 변환 후 정규화한다. 12345678910111213141516171819const name1 = '\\u0041\\u006d\\u00e9\\u006c\\u0069\\u0065';const name2 = '\\u0041\\u006d\\u0065\\u0301\\u006c\\u0069\\u0065';console.log(`${name1}, ${name2}`);// expected output: &quot;Amélie, Amélie&quot;console.log(name1 === name2);// expected output: falseconsole.log(name1.length === name2.length);// expected output: falseconst name1NFC = name1.normalize('NFC');const name2NFC = name2.normalize('NFC');console.log(`${name1NFC}, ${name2NFC}`);// expected output: &quot;Amélie, Amélie&quot;console.log(name1NFC === name2NFC);// expected output: trueconsole.log(name1NFC.length === name2NFC.length);// expected output: true 유니코드 등가성이란?유니코드 등가성(Unicode equivalence)은 특정한 일련의 코드포인트들이 반드시 동일 문자를 대표해야 하는 유니코드 문자 인코딩 표준의 사양이다. Ref String.prototype.normalize() - JavaScript | MDN 유니코드 등가성 - 위키백과, 우리 모두의 백과사전 WAF (웹 방화벽)WAF는 Web Application Firewall, 즉 웹 방화벽을 의미한다. 일반적인 네트워크 방화벽 (Firewall)과는 달리 웹 애플리케이션 보안에 특화되어 개발된 솔루션이다. 웹방화벽의 기본 역할은 SQL Injection, Cross-Site Scripting(XSS)등과 같은 웹 공격을 탐지하고 차단하는 것이다. 웹방화벽은 직접적인 웹 공격 대응 이 외에도, 정보유출방지솔루션, 부정로그인방지솔루션, 웹사이트위변조방지솔루션 등으로 활용이 가능하다. 웹방화벽은 사용자의 요구에 따라 1세대부터 3세대까지 점점 진화해왔다. 3세대 웹방화벽인 ‘지능형 웹방화벽’은 웹 공격 유형 별로 블랙리스트 탐지, 화이트리스트 탐지 및 웹 트래픽 컨텐츠 분석 등의 기법들을 결합하여 공격을 탐지하는 방식을 사용한다. Ref https://www.pentasecurity.co.kr/web-application-firewall/ 이것저것 타입스크립트에서 Partial 유틸 타입을 거치면 1-depth의 모든 필드가 optional이 된다. Date 타입의 인스턴스를 ‘yyyy-mm-dd’ 형태의 스트링으로 바꾸고자한다면 date.toLocaleDateString(‘en-CA’)로 바꿀 수 있다. React.cloneElement() - 지정한 Element를 복사해 반환한다. 추가적으로 children과 props를 같이 넘겨줄 수 있어서 필요 시에 부모에서의 자식으로 props를 전달해야 하는 경우 사용할 수 있다. ignore file에서 *.js 와 같이 모든 js 파일을 무시하고자 선언했을 때, 특정 파일은 무시하고 싶지 않을 때는 ![파일명]으로 선언하여 사용하면 된다. (ex !.eslintrc.js) ARIA: section role은 추상적인 role로 사용하지 않는걸 권장한다. react-scripts(CRA)로 test 실행 시, env에 아래와 같은 값이 기본으로 들어간다.123process.env.BABEL_ENV = 'test';process.env.NODE_ENV = 'test';process.env.PUBLIC_URL = ''; react-hook-form - shouldUnregister 옵션을 사용하면, register로 관리하던 name을 가진 DOM이 unmount되었을 때 react-hook-form에서 관리하던 값도 제거한다. (default는 false다.) 화살표 함수에서도 제네릭을 사용할 수는 있다. JSX를 사용하는 .tsx 파일에서만 안되는 것이었다. JSX 구문에서는 파싱할 때 헷갈려서 &lt;T, &gt;와 같은 방식으로 쓰면 사용할 수 있다고는 한다. 기타Lighthouse를 CI에 적용하기크롬에서 기본적으로 Lighthouse CI를 제공하고 있었다. 성능 측정 및 최적화를 위한 lighthouse를 주기적으로 활용하는 데 큰 도움이 될 것 같다! 설정도 간단한 편이고, 보고서도 잘 만들어준다. Lighthouse CI를 github actions와 연동하여 코드를 푸쉬할 때마다 CI를 돌릴 수 있다. Lighthouse CI에서 설정한 스코어에 도달하지 못하면 CI를 실패하도록 구성할 수 있다. Lighthouse 실행 점수도 바로 보여준다. Ref https://fe-developers.kakaoent.com/2022/220602-lighthouse-with-github-actions/ React-Query ver.4React-Query의 ver.4(베타) 문서가 등장했다. 레포 이름을 react-query에서 query로 바꾼 것으로 보아 React를 넘어 쭉쭉 뻗어나가려보다. Ref https://github.com/TanStack/query/releases/tag/v4.0.0-beta.1 https://github.com/TanStack/query https://react-query-beta.tanstack.com/ CSS 뷰포트 크기의 상대 단위CSS 뷰포트 크기의 상대 단위였던 vw, vh, 등등에서 나아가 svw, lvw, dvw, vw와 같은 세부적인 종류들이 추가되기 시작했다..! 지금 있는 것도 잘 모르는데. 머리가 터진다. 🤯 브라우저는 얘를 어떻게 아는 걸까. 불편한 대로 사는 나같은 사람은 자꾸 뭐가 이렇게 사용자 요구에 따라 세밀해지고 다양해지는 것에 거부감이 든다. 그치만 개발자란… 무슨 소릴 하는 건지 모르겠다. 나도 브라우저에 뒤쳐지지 않도록 공부해야겠다. Ref https://sorto.me/docs/Web/CSS/length/#뷰포트-상대-길이-단위 마무리월요일 현충일을 쉬고 오니 조금 나은 것 같다. 주4일제 조아… 주1회 출근 괜찮은 것 같다. 몸이 찌뿌둥해질 때쯤 이유를 가지고 밖에 나갈 수 있다! 모두가 만류하던 롯데타워 31층 밥은 맛있었다. 같이 간 팀원 두 분도 만족스러운 평을 남기셨다. 다음에 셋이 같이 또 가야겠다. 내가 커리어적으로 성공하고 싶은 건지, 아니면 그냥 내 삶의 반경에 있는 사람들과 평화롭고 즐겁게 살아가고 싶은 건지 모르겠다. 완전히 후자라고 생각했는데, 후자가 어느 정도 갖춰져서 그런 건지 자꾸 욕심이 생기는 것 같다. 아무튼 여전히 꿈은 없다. 그냥 하루하루 의미있고 재밌게 살면 된다! 언제 죽을지도 모르는데… 이럴 때는 김용명 아저씨의 ‘아무노래’를 떠올려본다.왜들 그리 다운돼있어~ 뭐가 그리 문제야~.","link":"/2022/06/11/2022-6-week-2/"},{"title":"6월 3주차 기록","text":"보란듯이 무너졌어… IE 배워가기리버스 프록시포워드 프록시의 반대 개념이다. 앱 서버의 앞에 위치하여 클라이언트가 서버를 요청할 때 리버스 프록시를 호출하고, 리버스 프록시가 서버로부터 응답을 전달받아 다시 클라이언트에게 전송하는 역할을 한다. 클라이언트는 애플리케이션 서버를 직접 호출하는 것이 아니라, 프록시 서버를 통해 호출하기 때문에 리버스 프록시는 애플리케이션 서버를 감추는 역할을 하게 된다. 리버스 프록시 뒤에 여러 개의 WAS를 두어서 사용자 요청을 분산할 수 있으며(로드밸런싱), 보안 상의 이유로 서버에 직접 접근하는 것을 막기 위해 DMZ같은 네트워크에 리버스 프록시를 구성하여 접근하도록 할 수 있다. 리버스 프록시의 예시로는 nginx, apache web server 등이 있다. Ref https://sujinhope.github.io/2021/06/13/Network-프록시(Proxy)란,-Forward-Proxy와-Reverse-Proxy.html 노드 모듈 해석 전략 상대경로일 때 (‘/‘, ‘./‘, ‘../‘ 세 가지 경우) 생각하는 것처럼 찾는다. 절대경로일 때 package/src/node_modules 에서 찾는다 없으면 package/node_modules에서 찾늗다. 없으면 node_modules 찾는다. 최상위까지 가서 찾아도 없으면 없다고 한다. 리액트 컴포넌트의 state리액트에서 state를 자식 컴포넌트가 아닌 부모 컴포넌트로 끌어올려 저장하고 자식 컴포넌트는 제어 컴포넌트로 만들어주는 것이 좋다. 부모가 자식컴포넌트의 state 를 요청하는 방식은 버그에 취약하며 리팩토링이 어렵기 때문이다. 또한 state 정의를 부모 컴포넌트에 할 경우 추후 자식 컴포넌트가 1개에서 여러 개로 늘어났을 때에도 자식 컴포넌트 간에 통신이 쉬워지고 부모 컴포넌트와의 동기화가 용이하다. cypress에서 api intercept하기cypress에서 api를 intercept하여 alias를 부여하고, 해당 alias에 wait를 걸면 api call을 기다릴 수 있다. 이때 wait에 배열 형식으로 alias를 넣으면 여러 개의 api call을 기다릴 수 있다. 1234cy.intercept('/api/...').as('card-attributes');cy.wait('@card-attributes');// 배열 : cy.wait(['@alias1', '@alias2', ...]); cypress clockcypress의 clock 기능을 통해 setTimeout, setInterval 등 시간과 관련된 함수에 대한 제어권을 cypress로 넘길 수 있다. 12345let seconds = 0setInterval(() =&gt; { $('#seconds-elapsed').text(++seconds + ' seconds')}, 1000) 1234567// test.tscy.clock()cy.visit('/index.html')cy.tick(1000)cy.get('#seconds-elapsed').should('have.text', '1 seconds')cy.tick(1000)cy.get('#seconds-elapsed').should('have.text', '2 seconds') jest에서도 시간 관련 함수를 mocking하는 기능을 제공한다. jest.useFakeTimers()로 사용할 수 있다. Ref https://docs.cypress.io/api/commands/clock https://jestjs.io/docs/timer-mocks 객체 key에서 특정 prefix만 골라내기keyof typeof을 사용하여 객체의 key만 골라낸 후, 그중에서 특정한 prefix를 가진 key만 다시 추출해보자. 12345678910111213const colorTheme = { bg_primary: 'blue', bg_secondary: 'red', fill_primary: 'blue', fill_secondary: 'red',}type ColorKey = keyof typeof colorTheme;type BgIncluded = `bg_${string}`;type BgKeys = Extract&lt;ColorKey, BgIncluded&gt;;const bg1: BgKeys = 'bg_primary'const bg2: BgKeys = 'fill_primary' // 🚨 Type '&quot;fill_primary&quot;' is not assignable to type 'BgKeys'. 객체의 key들에서 특정 prefix만 골라내고, 해당 prefix를 제거할 수도 있다. 1234567891011121314151617type Replace&lt; T extends string, S extends string, D extends string, A extends string = '',&gt; = T extends `${infer L}${S}${infer R}` ? Replace&lt;R, S, D, `${A}${L}${D}`&gt; : `${A}${T}`interface ColorSet { fill_primary: string fill_secondary: string fill_accent: string bg_accent: string}type Color = keyof ColorSettype ColorAsset = Extract&lt;Color, `fill_${string}`&gt; // fill_primary | fill_secondary | fill_accenttype Result = Replace&lt;ColorAsset, `fill_`, ''&gt; // primary | secondary | accent as const vs readonly객체를 as const로 선언해주면, 객체의 모든 프로퍼티가 readonly로 바뀌게 된다. 1234567const color = { white: '#FFFFFF', blue: '#0000FF', red: '#FF0000',} as const;color.white = '#000000'; // 🚨 Cannot assign to 'white' because it is a read-only property. readonly는 타입이나 인터페이스에 사용한다. 12345678type Color = { readonly white: string; readonly blue: string; readonly red: string;}const color: Color = { white: '#FFFFFF', blue: '#0000FF', red: '#FF0000' };color.red = 'red'; // 🚨 Cannot assign to 'red' because it is a read-only property. 만약 일부 타입의 속성들만 상수로 만들고 싶다면 해당 타입의 변수에만 readonly를 붙여주면 된다. JSX.Element propsrender props를 사용해 composition 형태로 props를 통해 컴포넌트를 주입받을 때, 컴포넌트의 props에 접근할 수 있다. prop으로 주입받는 타입을 JSX.Element로 선언하면 props와 type에 접근할 수 있다. 예를 들어, badge.type.displayName으로 접근하면 컴포넌트의 이름을 알 수 있다. 12345678910interface ButtonProps { badge?: JSX.Element}const Button = ({ badge }) =&gt; { const size = badge.props.size return &lt;Button&gt;{badge}&lt;/Button&gt;}&lt;Button badge={&lt;Badge size={14} /&gt;} /&gt; window.location.href vs history.push window.location.href 새로운 HTTP call을 만든다 (새로고침 O) 앱 상태 유지 불가 history.push 새로운 HTTP call을 만들지 않는다 (새로고침 X) 앱 상태 유지 💡 window.open - target = ‘_blank’처럼 동작한다 이것저것 CORS에러를 뚫어주는 Allow CORS extenstion은 서버로부터 응답을 받아 Access-Control-Allow-Origin: * 헤더를 추가해 다시 클라이언트에게 전송한다. React.Children.toArray() 함수는 children을 1차원 배열로 평탄화해서 리턴해준다. 1차원 배열로 변환하는 과정에서 Reconciliation, 렌더링 최적화를 위한 고유한 key 값을 각 요소의 키에 삽입해준다. 지면을 꾸미기 위해 사용된 이미지는 alt text를 빈 스트링으로 처리한다. 기타Zero Trust제로 트러스트(Zero Trust)는 ‘아무것도 신뢰하지 않는다’는 것을 전제로 한 사이버 보안 모델로, 사용자나 기기가 접근을 요청할 때 철저한 검증을 실시하고, 검증이 이뤄진 후에도 최소한의 신뢰만 부여해 접근을 허용하는 방식이다. ZTNA (Zero Trust Network Access)는 ‘초세분화 적응형 인증 및 컨텍스트(Context) 인식 정책’으로, 원격 위치 또는 단말기에 클라우드 혹은 기업 데이터 센터에서 호스팅 되는 프라이빗 애플리케이션을 안전하게 제공하는 방법이다. 기업은 주로 아래 4가지 중 하나를 해결하기 위해 ZTNA를 도입한다. 관리가 어려운 VPN 대체 멀티클라우드에 안전하게 액세스 외부사용자가 초래할 수 있는 위험 감소 M&amp;A 통합 가속화 Ref https://www.lgcns.com/blog/cns-tech/31963/?fbclid=IwAR0KT_wT4y13yGyluc2s_xB7S1di1ysFKIjWrsc7Php2ehPOfQSBcEr2HhQ Reactathon정말 별별 ‘-톤’이 나온다! ‘The third age of JavaScript’를 주제로 한 이 영상은 자바스크립트 연대기를 3단계로 나누어 빠르게 훑어준다. 자바스크립트 언어 자체, 빌드 툴, 프레임워크, 런타임의 지나온 역사까지 소개하고 있다. TLDR; 정리하자면 첫 번째 시기: 언어를 설계해나갔다. 두 번째 시기: 사용자들이 언어를 확장해나갔다. 세 번째 시기: 레거시를 제거했다. 여러 툴의 레이어를 무너뜨렸다. 결과적으로, 더 좋은 DX와 UX가 탄생했다고 한다. DX: 빠른 빌드, 산업 표준 툴 UX: 작은 번들, 빠른 배포 Ref https://www.youtube.com/watch?v=CGnlBU3K_eM IE 지원 종료2022년 6월 15일 수요일… 역사적인 날이다! Ref https://docs.microsoft.com/en-us/lifecycle/products/internet-explorer-11 앱과 웹뷰 간 통신에 protobuf 사용하기네이티브 앱 안에서 웹뷰를 돌리면 제한된 기능 때문에 필연적으로 네이티브 앱과 통신할 일이 생긴다.이때 양방향 통신이 안되는 불편이 있고, 만들때마다 일관성 없는 인터페이스가 생겨나기도 한다. Riid에서 앱과 웹뷰 사이 통신에 protobuf를 이용해서 서비스 인터페이스를 정의하는 방식을 소개하고 있다. Ref https://twitter.com/disjukr/status/1537034296959315968 마무리IE 지원이 공식적으로 종료됐다! 🥳 그날이 오긴 왔구나… 시간 참 빠르다. 이제 더 이상 프론트엔드 개발자가 크로스브라우징 이슈로 골머리 썩히는 일이 없으면 좋겠다. 싸이 흠뻑쇼 예매에 성공했다! 코로나 3년 만의 원기옥이 모여 정말 역대급 티켓팅이 아니었나 싶다… 오픈 3시간 만에 잡았는데도 서울 좌석이 절반 넘게 남아있었다. 인터파크 도라이 놈들… 사실 내가 아닌 동생이 성공해줬다. 후후후… 다쥬겄다. 주 1회 출근하는 게 점점 익숙해져 간다. 하루 나가는 날은 잡담 시간이 굉장히 많아진다. 4일 일하고 하루는 사내 개발자 분들과 잡담 떨고, 어느 정도 적당한 밸런스인 것 같다.","link":"/2022/06/18/2022-6-week-3/"},{"title":"7월 3주차 기록","text":"밀린 일이 많다! 배워가기storybook global cssstorybook에서 preview 에 그려지는 태그들 스타일을 global css파일로 초기화 할 수 있다. 그렇기 때문에 storybook에서 보여지는 컴포넌트들과 실제로 라이브러리에서 배포되어 보여지는 컴포넌트에서 차이가 발생할 수 있다. 별 다른 요구가 없다면 이러한 결과를 방지하기 위해서 storybook에 global css를 배제하여 환경별로 다르게 보이는 경우가 없게 주의하자. 타입스크립트의 호출 시그니처 (call signatures)호출 시그니처 (call signatures)는 함수를 어떻게 호출해야 하는지와, 반환이 어떻게 되는지 알려주는 정보이다. 12type Add = (a: number, b: number) =&gt; number;const add: Add = (a, b) =&gt; a + b; 타입 지정과 함수 구현을 분리해서 작성할 수 있다. next/router 의 querynext/router 의 useRouter 훅을 통해 router.query 를 불러오려고 했지만 계속 빈 오브젝트 {}가 나오는 겨웅가 있다. 문서에 따르면 next 에서는 페이지에 getServerSideProps 또는 getInitialProps 가 없을경우 자동으로 정적 최적화(automatic-static-optimization) 을 시전하는데, 이 때 사전 렌더링될 동안 라우터의 query 가 없기 때문에 빈 오프젝트로 나온다고 한다. 그러나 getServerSideProps 를 사용하고 있을 경우, 다른 문제일 수 있다. 관련하여 next.js 깃헙 이슈가 오픈된적이 있다. 해결 방법 중 하나는 클라이언트에서 useRouter 인스턴스 존재를 보장하는 isReady 을 이용하여 query 를 안전하게 부를 수 있다고 한다. 123456const { query, isReady } = useRouter()useEffect(() =&gt; { if (!isReady) return console.log(query, ': query')}, [isReady]) 스크린리더 스크린리더 로터(rotor)로 머리말/단어/글자 단위를 이동할 수 있다. 모바일 스크린리더와 웹 스크린리더는 다르게 동작하다. author의 우선순위가 contents 보다 높다. &lt;a&gt;는 role=“link”를 암시적으로 가지고 있다. &lt;img&gt; 태그에 alt=“” 처럼 빈값으로라도 주는 이유는 안주면 src를 읽어버리기 때문이다. children presentational 자식요소의 accessible name을 모아서 contents로 사용한다 불필요하게 끊어읽지 않게 할 때 사용할 수 있다. Ref https://www.youtube.com/watch?v=tKj3xsXy9KM 스토리북 웹접근성 애드온 @storybook/addon-a11y 웹접근성 기준을 테스트해서 패스했는지 결과 알려준다. addon-screen-reader voiceover와 textover를 켜준다. Webpack5 와 BufferWebpack 4에선 브라우저에서 Node.js API를 사용하기 위한 Polyfill이 자동 적용되었지만, 5에선 이런 Polyfill들이 없기 때문에 별도로 polyfill을 설치해서 지원하는 작업이 필요하다. Ref https://viglucci.io/how-to-polyfill-buffer-with-webpack-5 FocusEvent의 relatedTargetFocusEvent 에는 relatedTarget 이라는 필드가 있어, FocusEvent와 관련된 요소를 알 수 있다. 예를 들어, input에 onBlur가 부착되어 있고, input에 포커스가 있다가 button으로 포커스를 옮겨서 onBlur가 호출된다면, onBlur의 인자로 할당되는 FocusEvent 의 relatedTarget 은 버튼이 된다. 1234&lt;form&gt; &lt;input type=&quot;text&quot; /&gt; &lt;button type=&quot;submit&quot; /&gt;&lt;/form&gt; 123456document.querySelector(&quot;input&quot;).onblur = (event) =&gt; { console.log(event.relatedTarget);}// input에 타이핑 후 tab 키를 눌러서 button에 포커스가 닿았다면// button[type=submit] 이 콘솔에 찍힌다 Ref https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/relatedTarget 싱글톤 패턴싱글톤 패턴은 instance 객체를 담을 변수와, 생성자를 private하게 만들어주고 인스턴스를 가져오는 getInstance 메서드를 public으로 사용하여 구현한다. 1234567class Singleton { private static instance: Singleton; private constructor() { ... } public static getInstance(): Singleton { ... 싱글톤은 유닛테스트하기가 어렵다. 모킹을 위한 인터페이스가 드러나지 않고, 각 TC에서도 싱글톤 인스턴스는 유일하기 때문이다. Ref https://refactoring.guru/design-patterns/singleton#:~:text=It%20may%20be,the%20Singleton%20pattern. react key보통 key는 map으로 JSX를 생성할 때 유니크한 값을 넣지만 map을 사용하지 않는 경우에도 필요하다는 것에 유의하자. index로 key를 사용하기도 하지만, 컴포넌트가 추가/삭제/수정되는 컴포넌트의 경우 예상치 못한 결과가 발생할 수 있기 때문에 권장되지 않는다. 다만, 형제요소일지라도 props의 종류가 다르면 key를 고려할 대상이 아니다. 보통 key에 데이터의 id값을 넣지만, id가 없을 때 두 가지 이상의 값을 조합해서 key에 넣을 유니크 키를 만들곤 한다. 여기서 조합한 key가 유니크한지 판단하기 위해 고려해야할 사항은 다음과 같다. 렌더링 될 컴포넌트의 최대 개수배열이라면 무한할 수 있지만, 개수가 정해진 배열일 수도 있고, 반드시 배열.map일 때만 key가 필요한 것은 아니므로, 최대 렌더링 수를 파악한다. 키를 만들기 위해 사용하는 값의 조합수가 그 최대 개수 이상일 수 있는지. (두 값이 직교한다고 표현한다)key={'${a}-${b}'}의 구조는 단순히 보면 a*b의 경우의 수 이지만 꼭 그런 것은 아니다. a와 b의 조합 경우의 수가 최대 렌더 개수 이하라면, 키 조합이 유니크할지라도 key로서 유효하지 않을 수 있다. Jest의 parsing errorjest로 테스트를 돌릴 때, 다음과 같은 에러가 나는 경우가 있다. 123Jest encountered an unexpected token Jest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax. build/ 디렉토리의 파일들이 테스트에 포함되어서 발생하는 문제일 수 있다. 해결책은, jest config에 modulePathIgnorePattterns를 넣어주면 된다. 1234// jest.config.jsmodule.exports = { modulePathIgnorePatterns: ['&lt;rootDir&gt;/build'],} package.json 대신 jest config를 수정하는 것이다. 1234// package.json&quot;transform&quot;: { &quot;\\\\.js$&quot;: &quot;&lt;rootDir&gt;/node_modules/babel-jest&quot;}, 이것저것 포팅(porting)이란 ‘이식’이라는 뜻으로, 컴퓨터 과학에서 실행 가능한 프로그램이 원래 설계된 바와 다른 컴퓨팅 환경에서 동작할 수 있도록 하는 과정이다. (여기서 다른 환경이라 함은 CPU, 운영 체제, 서드 파티 라이브러리 등을 가리킨다.) 제네릭은 일반화 (generalize) 한다는 의미를 가지고 있다. react-native 최신버전 0.69에서는 react18을 사용해야한다. 웹소켓은 CONNECTING-OPEN-CLOSING-CLOSED의 순서로 상태변화를 한다. (Ref) document.referrer를 사용하여 현재 페이지로 이동시킨, 이전 페이지의 URI 정보를 알아낼 수 있다. 폰트마다 기준선(baseline)이 달라서, 폰트 크기/행간/자간/상하좌우 간격에 상관없이 한쪽으로 치우쳐 보일 수 있다.(Ref) vertical-align은 inline 요소에만 동작한다. css의 width, height는 실제 DOM에 렌더링되는 값과 차이가 있을 수 있다. 실제 렌더링된 요소의 width, height를 얻으려면, .offsetWidth와 offsetHeight를 사용한다. 또는 getBoundingClientRect() 를 사용하는데, 이는 CSS 변환을 거쳐 floating-point 넘버가 된다. scroll smooth는 사파리와 IE에서 동작하지 않기 때문에 polyfill이 추가되어야 한다. 기타드디어 승인된 ES2022 살펴보기 클래스 필드 언어 자체에서 지원하는 프라이빗 접근 제어자 추가 퍼블릭 필드 및 정적 필드 선언 방식 개선 정적 초기화 블록 추가 in 연산자를 활용한 프라이빗 필드 체크1234567class MyClass { #field; static isMyField(myClass) { return #field in myClass; }} 정규표현식 플래그 d 매칭된 문자열의 인덱스 정보를 얻기 위해 추가된 속성이다.12const matchObj = /(a+)(b+)/d.exec('aaaabb');// ['aaaabb', 'aaa', 'bb', indices: [[0, 6], [0, 4], [4, 6]]] 모듈에서 최상위 레벨의 await 호출 가능 비동기 호출 후의 로직을 Promise.all()로 감싸, 모듈의 비동기 작업이 완전히 완료되기 전에 작업 결과에 접근하지 않도록 한다. .at() 문자열, 배열 등에서 음수 인덱싱을 가능하게 해준다. Object.hasOwn() 객체의 특정 속성이 프로토타입을 거치지 않은 객체 그 자신이 소유한 속성인지를 반환한다. Object.hasOwnProperty()와의 다른 점은, 정적 메서드로 구현되었기 때문에 특정 인스턴스의 프로토타입 상속 관계에 구애받지 않고 사용 가능하다는 것이다. Error.prototype.cause 에러 체이닝을 위해 도입된 속성이다. 발생한 오류를 다시 한번 감싸서, 추가적인 컨텍스트 메시지를 참조하게 만든 새 에러를 throw하는 방식으로 체이닝할 수 있다. 1234567891011121314151617181920212223function job1() { try { job2(); } catch (e) { console.log(e)l // Error: job2 Error throw new Error('job1 Error', { cause: e }); }}function job2() { throw new Error('job2 Error');}try { job1();} catch (e) { console.log(e); // Error: job1 Error console.log(e.cause); // Error: job2 Error} Ref https://yozm.wishket.com/magazine/detail/1570/ 마무리일요일에 흠뻑쇼 간다… 갔다와서 써야지 🤩","link":"/2022/07/16/2022-7-week-3/"},{"title":"ModalProvider 만들기","text":"ModalProvider 만들기 context API를 사용하여 Modal Provider를 만들어보자. (사실 페어가 다 했다!) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ModalProvider.tsxinterface Props { children: ReactNode;}interface ModalContext { openModal: (modalComponent: ReactNode) =&gt; void; closeModal: () =&gt; void;}export const Modal = React.createContext&lt;ModalContext | null&gt;(null);const modalRoot = document.getElementById('modal-root'); // Portal 삽입을 위한 root DOM 생성const ModalProvider = ({ children }: Props) =&gt; { const [modal, setModal] = useState&lt;ReactNode | null&gt;(null); const [isOpen, setIsOpen] = useState(false); const openModal = (modalComponent: ReactNode) =&gt; { setModal(modalComponent); setIsOpen(true); }; const closeModal = () =&gt; { setIsOpen(false); }; const modalElement: React.ReactNode = ( &lt;Styled.ModalContainer&gt; &lt;Styled.ModalInner&gt; &lt;Styled.CrossMarkButton onClick={closeModal}&gt; &lt;CrossMark width=&quot;16px&quot; /&gt; &lt;/Styled.CrossMarkButton&gt; {modal &amp;&amp; modal} &lt;/Styled.ModalInner&gt; &lt;/Styled.ModalContainer&gt; ); const contextValue = useMemo(() =&gt; ({ openModal, closeModal }), []); return ( &lt;Context.Provider value={contextValue}&gt; {children} {isOpen &amp;&amp; ReactDOM.createPortal(modalElement, modalRoot)} &lt;/Context.Provider&gt; );};export default ModalProvider; Context의 Provider에 openModal과 closeModal 메서드를 정의하여 Context의 API의 value로 내려주기 때문에 모달을 사용하는 곳마다 새롭게 open과 close에 대한 메서드를 정의해줄 필요가 없다. 이때 Context의의 Consumer에 해당하는 자식 컴포넌트들에서 openModal, closeModal등 Context의 value로 내려준 함수가 호출될 때마다 리렌더가 발생하기 때문에 Provider에서 해당 Context의 value들을 useMemo로 감싸 메모이제이션해준다. openModal의 인자로는 열고자 하는 모달 컴포넌트(ex. LoginModal 컴포넌트)를 넘겨준다. children은 modal이 열릴 베이스 페이지를 가리킨다. Home이라는 페이지 컴포넌트에서 로그인 모달이 열린다면, 여기서 children은 Home이 되는 것이다. 현재 앱에서는 로그인 모달을 사용하고 있으며, 로그인 모달은 페이지 어디서든 열릴 수 있어야 하기 때문에 App.tsx에서 전체 앱을 ModalProvider로 감싸준다. 12345678910111213141516171819// App.tsxconst App = () =&gt; { return ( &lt;QueryClientProvider client={queryClient}&gt; &lt;GlobalStyle /&gt; &lt;Router&gt; &lt;Switch&gt; &lt;&gt; &lt;ModalProvider&gt; // 여기! &lt;main&gt; // .. &lt;/main&gt; &lt;/ModalProvider&gt; &lt;/&gt; &lt;/Switch&gt; &lt;/Router&gt; &lt;/QueryClientProvider&gt; );}; useModal이라는 hook을 만들어주면 더욱 편리하게 사용할 수 있다. useContext로 방금 전 생성한 Context의 현재 값을 반환 받고, 그 값을 리턴하는 hook을 만들어 컴포넌트에서 사용할 수 있다. 이때 예상치 못한 상황으로 Context Provider 외부에서 해당 함수가 호출됐다면 간단하게 에러를 던져준다. 1234567891011121314151617// useModal.tsximport { useContext } from 'react';import { Modal } from 'components/@common/ModalProvider';const useModal = () =&gt; { const context = useContext(Modal); if (!context) { throw new Error('ModalProvider 내부에서만 useModal hook을 사용할 수 있습니다.'); } return context;};export default useModal; 컴포넌트에서 useModal을 통해 ModalProvider의 context value들을 내려받을 수 있으며, 각 상황에 맞는 커스텀한 modal 컴포넌트를 열고 닫을 수 있다. 12345678910111213141516// Header.tsxconst Header = () =&gt; { const modal = useModal(); const openLoginModal = () =&gt; { modal.openModal(&lt;LoginModal /&gt;); }; return ( // ... &lt;Styled.SignInButton onClick={openLoginModal}&gt; Sign In &lt;/Styled.SignInButton&gt; // ... )} 페어가 어디서 이런 아이디어를 가져왔는지는 모르겠지만, 얼마 후 Kent C Dodds.의 글을 보다가 같은 내용을 발견했다! 사용하는 쪽에서 편리한, 꽤나 유용한 코드 스트럭쳐라고 생각한다. Refhttps://ko.reactjs.org/docs/hooks-reference.html#usecontext","link":"/2021/07/18/fe-Modal-Provider/"},{"title":"애플 클론코딩(을 빙자한 복제)","text":"새로 알게된 CSS 속성들 우테코 Lv4 마크업 미션으로 애플 클론코딩을 진행했다. 14일 화요일에 미션이 주어졌는데, 제출일은 16일 아침까지고, 한국 시간 15일 새벽 2시에 애플 신제품 발표로 홈페이지가 리뉴얼되면서 (ㅎ) 알면서도 곤혹을 치뤘다. 또 모든 크루들이 그랬겠지만, 17일에 있었던 데모데이 준비까지 겹쳐 이틀 밤을 거의 새다시피 하고 몸이 엉망진창이… 일부 섹션을 생략한 완성작은 여기에… HTML tags&lt;aside&gt;문서의 주요 내용과 간접적으로만 연관된 부분을 나타낼 때 사용한다. 주로 사이드바 혹은 콜아웃 박스로 표현한다. &lt;article&gt; vs &lt;section&gt;article 블로그 포스트, 신문 기사 등 하나하나를 가리킨다. 자체만으로 독립적으로 다른 페이지에 보여져도 문제가 없을 때 사용한다. main과 상관 없는 독립적인 정보를 제공한다. section 연관 있는 내용들을 하나로 묶어줄 때 사용한다. &lt;img /&gt; vs background-image많은 경우 습관적으로 &lt;img /&gt; 태그를 사용하는데, 아래의 상황들에서는 background-image를 사용하는 것이 바람직하다. 문서의 내용과는 별개로, 스타일 목적으로 사용되는 경우 이미지가 없어도 문서를 읽는 데 지장이 없는 경우 실제로 애플 공홈에서도 각 섹션별 이미지를 background-image 속성으로 설정하고 있었다. (그새 홈페이지가 또 바뀌었다..) Refhttps://developer.mozilla.org/ko/docs/Web/HTML/Element/asidehttps://www.youtube.com/watch?v=T7h8O7dpJIg CSS attributesbackground-position말 그대로 배경 이미지의 위치를 정하는 속성으로, x/y축을 통해 가로와 세로 위치를 정할 수 있다. float요소가 일반적인 흐름을 벗어나 어디에 ‘뜰’ 것인지를 정하는 속성이다. 웹 개발을 배우기 시작했을 때 접했는데, 거의(사실 한 번도) 사용하지 않고 있었다. 문서 흐름의 좌측이나 우측으로 배치되며 메인 콘텐츠의 흐름을 벗어나 사용한다. 애플 홈페이지에서는 footer의 일부 텍스트에 포함되어 있었다. 의미를 고려했을 때 유용하게 사용해볼 수 있을 것 같다. &lt;footer의 locale 정보만 우측으로 치우친 경우&gt; 👾 clear 속성에 대해서도 알아보자! margin vs padding각각 요소의 바깥 영역, 요소를 포함하는 영역이라는 차이는 당연히 알고 있다. 그러나 애플 공홈에서 너무나 제멋대로(?) 쓰고 있는 것을 보니, 역시 단지 취향 차이일 뿐일까? 🤔 will-change요소에 예상되는 변화의 종류에 관한 힌트를 브라우저에 제공한다. 실제 요소가 변화되기 전에 미리 브라우저는 적절하게 최적화할 수 있어, 성능 비용이 큰 작업을 미리 실행함으로써 페이지의 반응성을 증가시킬 수 있다. will-change를 사용하면 해당 레이어는 GPU에 업로드되어 처리된다. 👾 will-change에 묶인 최적화는 몇몇 많은 자원을 소모할 수 있으므로, 꼭 필요한 경우에만 사용하도록 한다. transform: matrix원근감(perspective)을 제외한 나머지 스타일을 일괄 적용시킬 수 있는 메소드로, 무려 6개의 값을 전달받는다. 1matrix (scaleX, skewX, skewY, scaleY, translateX, translateY) text-shadow글자에 그림자 효과를 주는 속성으로, font-weight hover 시 transition이 먹지 않아 대신 사용하게 되었다. text-shadow를 잘 활용하여 font-weight보다 편한 텍스트를 구현할 수 있을 것 같다. font-smoothing1234body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;} Webkit 기반의 Safari 및 Mac 등에서 완벽히 구현되며 이 외에는 제한적으로 사용된다고 한다. CRA의 기본 스타일로도 지정되어 있다고! flex-direction: row-reversereverse를 쓸 바에는 그냥 좌측에 와야 할 요소를 코드 상으로 먼저 적으면 되는 거 아닌가? 생각했었다. 그런데 아래와 같이 이미지와 텍스트가 좌우 배치되어있지만 웹 접근성을 고려했을 때 텍스트가 먼저 읽혀야 하는 경우(특히나 다른 섹션들은 텍스트가 이미지보다 좌측에 등장하여 일관성 유지가 필요하다.) row-reverse 값을 사용해야 한다는 것을 깨달았다. &lt;이미지와 텍스트가 보여지는 순서와 의미상 순서가 일치하지 않는 경우&gt; Refhttps://developer.mozilla.org/en-US/docs/Web/CSS/background-positionhttps://developer.mozilla.org/ko/docs/Web/CSS/floathttps://developer.mozilla.org/ko/docs/Web/CSS/will-changehttps://wit.nts-corp.com/2017/06/05/4571https://developer.mozilla.org/ko/docs/Web/CSS/transform-function/matrix()https://rgy0409.tistory.com/2990 Tipscss variables사용자 지정 속성을 사용하여 문서 전반에서 재활용할 수 있는 값들을 변수로 미리 등록해둘 수 있다. 두 개의 대쉬(--)로 시작하는 변수명으로 짓는 것이 일반적이다. 123element { --main-bg-color: brown;} :root psuedo class를 사용하여 HTML 문서 어디에서나 접근할 수 있는 속성을 정의할 수도 있다. 123:root { --main-bg-color: brown;} 사용은 아래처럼 var 키워드를 사용한다! 123body { background-color: var(--main-bg-color);} font src local123456@font-face { font-family: 'SF Pro Text'; font-style: normal; font-weight: 300; src: local('🍎'), url('../fonts/sf-pro-display_thin.woff2') format('woff2');} 맥 환경과 관련된 웹 폰트 이슈를 해결하기 위한 우회 코드로, 폰트 이름에 포함되어 있지 않을 법한 임의의 2바이트 유니코드 문자를 넣어서 로컬 폰트를 사용하지 않고 무조건 웹 폰트를 불러오게끔 하는 기법이라고 한다. 애플 코드에서는 원래 😃이 들어가 있다! 크루 체프가 귀여운 사과🍎로 바꾸어 놓아서 알게 된 정보. Refhttps://developer.mozilla.org/ko/docs/Web/CSS/Using_CSS_custom_propertieshttps://developer.mozilla.org/ko/docs/Web/CSS/var()https://www.paulirish.com/2010/font-face-gotchas/#smiley","link":"/2021/09/18/fe-apple-clone/"},{"title":"React의 setState에 await을 붙이면?","text":"React의 setState에 await을 붙이면? 한번도 생각해본 적 없었는데, 페어 미키가 어느 회사🥕 면접을 보고온 후 나온 질문인데 신기하다며 알려준 내용. setState에 await을 붙이면 setState가 동기적으로 동작한다? 🤔 리액트 컴포넌트는 일반적으로 하나의 이벤트 핸들러 함수 호출의 내부에서 동작하는 setState 메서드들을 모두 모아 한번에 업데이트를 수행한다(batch). 이는 렌더링 횟수를 줄여 최적화를 위한 것이다. 그리고 만약 setState가 여러번 호출되는 함수에서 첫 번째 setState 호출이 바로 상태 업데이트를 수행한다면, 컴포넌트가 리렌더링되어 다음 줄의 setState는 실행되지 않을 것이다. 따라서 아래와 같이 같은 state를 참조하는 setState를 여러번 호출하면 원하는 대로 값이 업데이트되지 않는다. setState의 동기적인 리액트에서 state의 업데이트가 비동기적일 수 있다고 하는 이유다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344export default class Counter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } decrease = async () =&gt; { this.setState({ count: this.state.count - 1 }); console.log(this.state.count); this.setState({ count: this.state.count - 1 }); console.log(this.state.count); this.setState({ count: this.state.count - 1 }); console.log(this.state.count); }; increase = async () =&gt; { this.setState({ count: this.state.count + 1 }); console.log(this.state.count); this.setState({ count: this.state.count + 1 }); console.log(this.state.count); this.setState({ count: this.state.count + 1 }); console.log(this.state.count); }; render() { return ( &lt;div className=&quot;container&quot;&gt; &lt;span className=&quot;count&quot;&gt;{this.state.count}&lt;/span&gt; &lt;div className=&quot;btn-group&quot;&gt; &lt;button onClick={this.decrease.bind(this)}&gt; &lt;strong&gt;-&lt;/strong&gt; &lt;/button&gt; &lt;button&gt; &lt;strong&gt;RESET&lt;/strong&gt; &lt;/button&gt; &lt;button onClick={this.increase.bind(this)}&gt; &lt;strong&gt;+&lt;/strong&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); }} decrease와 increase에서 발생하는 3번의 setState 호출들은 모두 업데이트 이전의 동일한 count 값을 참조하고 있기 때문에, 3씩 커지거나 작아지지 않는다. 그런데 setState 앞에 await을 붙인다고 한들 뭐가 될까? 123456789increase = async () =&gt; { await this.setState({ count: this.state.count + 1 }); console.log(this.state.count); await this.setState({ count: this.state.count + 1 }); console.log(this.state.count); await this.setState({ count: this.state.count + 1 }); console.log(this.state.count);};// increase도 마찬가지 정말 될까? 진짜 된다! 😮 한번에 3씩 값이 바뀐다. 동작하는 이유를 미키와 함께 의논해 보았다. (사실 거의 미키의 생각들이다! 정리해놨지만 확실하게는 잘 모르겠다.) 리액트 컴포넌트에서 async-await은 바벨에 의해 generator 함수로 바뀌게 된다. (블로그 이전 포스팅 참고) generator 함수는 yield를 사용하는데, yield는 실행 권한을 제너레이터 함수의 호출자에게 넘긴다. 따라서 클래스 컴포넌트의 렌더링 여부와 상관없이 두 번째, 세 번째 setState의 연속적인 호출은 독립적으로 작동하게 된다. setState가 async-await로 작동하는 것”처럼” 보이게 되는 것이다. 👾 이 놀라운(?) 동작은 클래스 컴포넌트에서만 가능하다! 함수 컴포넌트의 useState hook에서는 stale closure 문제가 발생하기 때문이다. 123456789101112131415const Counter = () =&gt; { const [count, setCount] = useState(0); const increase = async () =&gt; { await setCount(count + 1); await setCount(count + 1); await setCount(count + 1); }; // const decrease = async () =&gt; ... return ( // ... )} useState는 매번 새로운 클로저를 생성한다. 내부 구현은 아래 코드와 같은 느낌? (코드 출처: 지그의 Virtual DOM 미션을 변형) 1234567891011121314const React = (function () { // stale closure let _value; const useState = (initialValue) =&gt; { _value = _value || initialValue; const setState = (newValue) =&gt; { _value = newValue; }; return [getState, setState]; };})(); 각 setState 호출에 await을 붙였다한들, count는 여전히 현재 렌더링된 컴포넌트에서 모두 기존의 값을 참조하고 있기 때문에 즉각적인 상태의 업데이트를 반영하지 못한다. await을 사용한 setState 호출은 결국 아래와 같이 Promise를 사용한 then 체이닝으로 해석될 수 있다. 12345const increase = async () =&gt; { Promise.resolve(setCount(count + 1).then(() =&gt; setCount(count + 1) ).then(() =&gt; setCount(count + 1)));}; then 체이닝의 콜백으로 들어간 setCount 호출 함수는 비동기로 동작하기 때문에 마이크로태스크 큐에 담긴다. 이 비동기 콜백들은 자바스크립트 실행 환경에서 콜스택이 모두 빈 후에 호출되기 때문에, 결론적으로 함수 컴포넌트의 렌더링 이후에 동작한다. 이때 then 체이닝 내의 콜백들이 가리키는 count 값은 +1로 갱신된 값이 아닌, 함수 컴포넌트 가장 초기의 값을 그대로 가지고 있다. 함수 컴포넌트는 렌더링될 때마다 매번 재생성되기 때문에 stale closure 문제가 발생하지만, 클래스 컴포넌트의 경우에는 한 번 생성된 인스턴스를 재사용하기 때문에 await을 붙인 setState의 동기적 실행이 가능하다. 하지만 어쨌든 간에, setState 함수는 Promise를 반환하는 함수가 아니기 때문에 await을 사용하는 것은 좋지 않다. 굳이 사용하고 싶다면 아래와 같이 사용한다. 123456789101112131415updateState = () =&gt; { return new Promise((resolve, reject) =&gt; { this.setState({ count: this.state.count - 1 }, () =&gt; { resolve('updated') }); });};decrease = async () =&gt; { await this.updateState(); await this.updateState(); await this.updateState();} Ref https://muscardinus.tistory.com/196 https://hewonjeong.github.io/deep-dive-how-do-react-hooks-really-work-ko/","link":"/2021/10/16/fe-await-setstate/"},{"title":"Babel의 (조금) 모든 것","text":"Babel의 (조금) 모든 것 프로젝트를 수행하며 Babel에 대해 알고 싶은 내용들만 정리해보는 글 Babelbabel은 source-to-source compiler로, ES6 버전 이상의 JavaScript 코드를 ES5 코드로 변환하는 구문 변환(syntax transform)을 수행한다. JavaScript 언어를 컴퓨터 수준의 기계어로 바꾸는 것이 아니라 같은 레벨의 언어를 형태만 변환하는 것이므로 babel을 트랜스파일러(transpiler)라고 부르기도 하지만, 넓은 의미에서 컴파일러(compiler)라고 알려져 있다. babel 덕분에 개발자들은 최신 문법의 JavaScript로 편하게 개발을 할 수 있게 되었다. Babel 트랜스파일링 과정babel 컴파일 과정은 아래와 같다. 파싱(parsing) 단계 - babel이 소스코드를 파싱하여 AST를 생성한다. (이때 생성되는 트리는 JSON 형태와 비슷하다). AST에서 각각의 노드들은 관계를 형성한다. 변환(transform) 단계 - AST를 브라우저가 지원하는 코드로 변환한다. 이때 개발자가 설정한 plugin과 preset들에 의해서 컴파일된다. 생성(generate) 단계 - AST를 코드로 출력한다. 🤔 AST가 뭔가요?AST(Abstract Syntax Tree)란 프로그래밍 언어의 문법에 따라 소스코드 구조를 표시하는 계층적 프로그램 표현이다. HTML을 파싱할 때도 사용된다. babel 플러그인은 babel 컴파일 단계에서 AST(Abstract Syntax Tree)를 변형하는 역할을 수행한다. Babel은 플러그인이 변형시킨 AST를 가지고 타깃 코드를 생성한다. Ref https://gyujincho.github.io/2018-06-19/AST-for-JS-devlopers Babel configbabel 설정 파일을 만들어주는 방법에는 babel.config.json과 .babelrc.json이 있다. 각각은 사용하는 경우가 조금 다르다. 🌱 babel.config.jsonbabel 설정 파일을 root 폴더에 생성한다. 프로젝트 전체의 설정을 위해서 사용하며, 하나의 레포(monorepo)를 사용하고 있는 경우 권장된다. babel 6 까지는 .babelrc로 설정을 관리했지만, babel 7부터는 babel.config.json 파일을 사용하는 것을 권장한다. babel 공식 문서에서 제공하는 babel.config.json 파일의 내용은 다음과 같다. 123456789101112131415{ &quot;presets&quot;: [ [ &quot;@babel/env&quot;, { &quot;targets&quot;: { &quot;edge&quot;: &quot;17&quot;, &quot;firefox&quot;: &quot;60&quot;, &quot;chrome&quot;: &quot;67&quot;, &quot;safari&quot;: &quot;11.1&quot; } } ] ]} 🌱 .babelrc.jsonbabel 설정을 해당 파일이 속한 package에만 적용한다. 프로젝트의 일부에만 적용되는 설정 작성 시 사용하며, 특정 파일들에 대해서 컴파일을 할 때 유용하다. babel-loaderwebpack을 사용하고 있다면 babel을 webpack에서 실행시켜주는 도구인 babel-loader를 사용할 수 있다. babel-loader 설치 후 webpack config의 loader 목록에에 babel-loader를 넣고 필요한 옵션을 추가하면 된다. package.json에 명시한 scripts를 통해 webpack을 실행하면 번들링 과정에서 babel이 코드의 트랜스파일링을 진행한다. 현재 참여중인 프로젝트에서는 babel-loader 옵션에 꽤나 많은 preset과 plugins들을 사용하고 있다. 이때 node_modules는 트랜스파일링이 필요 없으므로 exclude 옵션으로 제외시켜 준다. 123456789101112131415161718// webpack.config.jsmodule.exports = { module: { rules: [ { test: /\\.(tsx|ts)$/, exclude: &quot;node_modules&quot;, use: { loader: &quot;babel-loader&quot;, options: { presets: ['@babel/preset-env', '@babel/preset-react', '@babel/preset-typescript'], plugins: ['@babel/plugin-transform-runtime', 'babel-plugin-styled-components'], }, }, }, ], },} Refhttps://babeljs.io/docs/en/configurationhttps://webpack.js.org/loaders/babel-loader/ plugin과 presetspluginbabel에서 코드의 변환은 plugin의 구성에 따라 결정된다. babel plugin은 babel 컴파일 단계에서 AST를 변형하는 역할을 한다. babel은 plugin이 변형시킨 AST를 가지고 타겟 코드를 생성한다. Ref https://tech.kakao.com/2020/12/01/frontend-growth-02/ presetspreset은 plugin들의 집합이다. plugin을 하나하나 추가해주는 대신, 적용할 규칙들을 그룹으로 묶은 preset으로 한번에 지정해줄 수 있다. 예를 들면 ES6 문법들을 모아둔 es2015 preset과 react에서 사용하는 문법들을 모아둔 react preset이 있다. preset들을 우선적으로 추가하고, 추가적으로 사용하고 싶은 plugin들을 기재해준다. babel이 제공하는 공식 babel preset들은 아래와 같다. @babel/preset-env @babel/preset-flow @babel/preset-react @babel/preset-typescript 이 중 @babel/preset-env은 타겟 환경에 필요한 구문 변환(syntax transform), 브라우저 폴리필(browser polyfill)을 제공하며, 나머지 항목들은 각각 flow, react, typescript 사용 시 babel에서 지원해주는 preset이다. Ref https://babeljs.io/docs/en/babel-preset-env Babel과 ReactReact에서 babel을 사용하면 JSX 문법을 트랜스파일링해줄 수 있다. 이때 @babel/preset-react이 필요하다. @babel/preset-react은 JSX 코드를 React.createElement 호출 코드로 바꿔준다. 123456789101112131415// babel 컴파일 전const profile = ( &lt;div&gt; &lt;img src=&quot;profile.png&quot; className=&quot;profile&quot; /&gt; &lt;h1&gt;{[user.firstName, user.lastName].join(&quot; &quot;)}&lt;/h1&gt; &lt;/div&gt;);// babel 컴파일 전const profile = React.createElement( &quot;div&quot;, null, React.createElement(&quot;img&quot;, { src: &quot;profile.png&quot;, className: &quot;profile&quot; }), React.createElement(&quot;h1&quot;, null, [user.firstName, user.lastName].join(&quot; &quot;))); Refhttps://babeljs.io/docs/en/#jsx-and-reacthttps://babeljs.io/docs/en/babel-preset-reacthttps://tech.kakao.com/2020/12/01/frontend-growth-02/ Babel과 TypeScript@babel/preset-typescript preset을 설치하여 babel을 TypeScript와 함께 사용할 수 있다. 하지만 babel은 타입 체크까지 해주지는 않는다. 타입 체킹은 TypeScript에게 맡기기 위해 webpack 설정에서 ts-loader를 사용할 수 있다. 다만 ts-loader는 속도가 느리기 때문에, babel-loader를 사용하는 것을 권장하고 있다. (ts-loader는 HMR도 지원하지 않는다!) babel-loader 단독으로는 타입 체킹을 해주지 않기 때문에, fork-ts-checker-webpack-plugin과 같은 별도의 타입 체크 plugin을 설치해준다. Ref https://babeljs.io/docs/en/#type-annotations-flow-and-typescript polyfillBabel을 사용한다고 해서 모든 JavaScript 최신 함수를 사용할 수 있는 것은 아니다. babel 문법을 변환해주는 역할만 한다. polyfill은 구형 브라우저에서 지원하지 않는 객체를 지원하도록 특별한 코드를 추가한다. babel은 컴파일 타임에 실행되고, babel-polyfill은 런타임에 실행된다. 🤔 Babel 트랜스파일링 시 polyfill은 어떻게 동작할까? .babelrc, .babelrc.json, package.json, 또는 babel.config.js에 명시된 browserslist의 타겟 브라우저를 탐색한다. 타겟 브라우저를 core-js와 매핑한다. 특정 문법을 지원하지 않는 구형 브라우저의 경우 polyfill을 주입한다. @babel/polyfill은 core-js와 regenerator-runtime을 포함하여 ES6 이상의 환경을 완전히 지원할 수 있다. babel/polyfill은 Promise, WeakMap과 같은 객체들을 전역 스코프에 추가해준다. 그러나 필요하지 않은 코드까지 불러와 번들 크기가 커진다는 단점이 있다. 또한 전역에 import로 모듈들을 불러오기 때문에, 전역 스코프를 오염시키는 문제가 있다. 이제 바벨은 위 방식 대신 @babel/plugin-transform-runtime과 core-js@3 plugin을 사용하여 설정 파일을 작성할 것을 권장한다. (webpack을 사용한다면 webpack 설정 파일에 추가해준다.) 123456789101112131415// webpack.config.js{ &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-runtime&quot;, { &quot;absoluteRuntime&quot;: false, &quot;corejs&quot;: 3, // corejs 설정 &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false } ] ]} 👾 @babel/plugin-transform-runtimebabel은 모든 helper 함수들을 매번 중복으로 생성하는 것을 방지하기 위해, babel 런타임을 별도의 모듈로 분리하고자 사용한다. 설정 시 헬퍼 함수들을 한 곳(@babel/runtime)에서 참조하여 코드의 크기를 줄일 수 있다. 또 내부적으로 regenerator-runtime과 core-js를 peerDependencies로 갖고 있어 따로 설정을 해주지 않고 필요한 polyfill을 사용할 수 있다. 👩‍🏫 정리! babel은 자바스크립트의 최신 문법을 자바스크립트 ES5 표준으로 바꿔주는 역할을 한다. polyfill은 자바스크립트 문법으로 인식은 하고 있지만 Promise, Set, Map처럼 구형 브라우저에서 지원하지 않는 객체들을 정의해주는 역할을 한다. Refhttps://medium.com/@makk.bit/babel-under-the-hood-63e3fb961243https://tech.kakao.com/2020/12/01/frontend-growth-02/https://babeljs.io/docs/en/config-files#project-wide-configurationhttps://ljs0705.medium.com/babel-이해하기-a1d0e6bd021ahttps://okchangwon.tistory.com/3 🤔 (추가) Babel에서 Promise를 처리하는 방식ES6에서 등장한 Promise는 구형 브라우저들에서는 이해하지 못하는 문법이다. 따라서 polyfill이 필요하다. Promise는 babel에서 아래와 같이 컴파일된다. &lt;ES6에서 Promise&gt; 1234567let promise = new Promise((resolve, reject) =&gt; { return resolve(1);});promise .then((value) =&gt; console.log(value)) .catch((e) =&gt; console.error(e)); &lt;babel로 변환된 Promise&gt; 12345678910var promise = new Promise(function (resolve, reject) { return resolve(1);});promise .then(function (value) { return console.log(value); }) [&quot;catch&quot;](function (e) { return console.error(e); }); Promise 자체는 코드의 변화는 크지 않다. 그렇다면 비동기 처리에서 Promise의 체이닝보다 간결하게 코드를 작성하기 위해 ES8에서 등장한 async~await 문법은 babel에서 어떻게 변환될까? &lt;ES6의 async-await&gt; 123456async function testFunc() { let value = await promise; console.log(`async ${value}`);}testFunc(); &lt;babel로 변환된 async-await&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); }}function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;next&quot;, value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;throw&quot;, err); } _next(undefined); }); };}function testFunc() { return _testFunc.apply(this, arguments);}function _testFunc() { _testFunc = _asyncToGenerator( /*#__PURE__*/ regeneratorRuntime.mark(function _callee() { var value; return regeneratorRuntime.wrap(function _callee$(_context) { while (1) { switch ((_context.prev = _context.next)) { case 0: _context.next = 2; return promise; case 2: value = _context.sent; console.log(&quot;async &quot;.concat(value)); case 4: case &quot;end&quot;: return _context.stop(); } } }, _callee); }) ); return _testFunc.apply(this, arguments);}testFunc(); async 키워드는 generator에, await 키워드는 yield에 대응된다. 하나의 로직이 종료될 때마다 이터레이터 객체의 메서드인 next를 호출하여 다음 로직을 수행한다. 이때 반환값이 완료(done) 상태라면 값을 성공적으로 반환(resolve)하고, 그렇지 않다면 다시 Promise를 재귀적으로 호출한다. 이때 generator도 ES5에 정의되지 않았기 때문에 babel은 regenerator 라이브러리를 사용하여 generator를 흉내낸 함수를 구현한다. 여기서는 _asyncToGenerator가 그 역할을 하고 있다. 👾 generator는 비동기적 패턴을 yield를 통해 동기적인 “모습”으로 바꾸어주고, promise는 generator로 만든 iterator를 반복해서 실행해주는 역할을 한다. await keyword에 사용하는 함수가 항상 Promise를 반환해야하는 이유다. Refhttps://www.tutorialspoint.com/babeljs/babeljs_babel_polyfill.htmhttps://betterprogramming.pub/how-polyfill-works-in-babel-b8cfbbc8351fhttps://velog.io/@ansrjsdn/Promise와-async-await은-ES5에서-어떻게-바뀔까","link":"/2021/09/05/fe-babel-almost/"},{"title":"babelrc와 webpack.config","text":"babelrc와 webpack.config webpack으로 React App 세팅을 설정해나가다가, TypeScript 설정을 위해 @babel/preset-typescript를 설치하게 되었다. babel 공식 문서를 따라 모듈을 세팅하다가, 123{ &quot;presets&quot;: [&quot;@babel/preset-typescript&quot;]} 위 코드의 presets가 .babelrc에 있어야 하는지, webpack.config.js에 있어야 하는지 알 수 없어 각 파일의 목적을 알아보았다. .babelrc는 babel의 설정을 위해 사용한다. 12345// .babelrc.json{ &quot;presets&quot;: [...], &quot;plugins&quot;: [...]} 물론 webpack.config.js는 webpack의 설정을 위해 사용한다. 프로젝트 파일의 번들링과 관련된 설정들을 작성해준다. 1234567891011121314151617181920212223242526272829// webpack.config.jsconst path = require('path');const HtmlWebPackPlugin = require('html-webpack-plugin');module.exports = { entry: './src/index.tsx', output: { ... }, module: { rules: [ { test: /\\.tsx$/, use: [ { loader: 'babel-loader', options: { presets: ['@babel/preset-env', '@babel/preset-react', '@babel/preset-typescript'], }, }, ], exclude: /node_modules/, }, // ... ], }, resolve: { ... }, plugins: [ ... ], mode: 'development',}; babel과 관련된 설정들을 .babelrc가 아닌 webpack.config.js에서 babel-loader를 설정한 부분에 작성해줄 수도 있다 결론은, babel의 presets는 webpack.config.js와 .babelrc 파일 둘 중 한 곳에만 있으면 된다! 그러나 babel cli를 이용하여 직접 코드 변환을 수행하거나 babel test 등을 돌릴 때에는 webpack을 거치지 않기 때문에 .babelrc에 작성하는 방식이 권장된다, 👾 babel.config vs .babelrcbabel.config은 여러 디렉토리를 포함하는 프로젝트 전체의 구성에 주로 사용된다..babelrc는 서브 디렉토리에서 특정한 플러그인 사용 시 유용하다. Refhttps://babeljs.io/docs/en/configurationhttps://webpack.js.org/configuration/https://stackoverflow.com/questions/43206062/why-do-i-have-to-put-babel-presets-inside-babelrc-and-webpack-config-jshttps://stackoverflow.com/questions/56463846/should-i-configure-babel-through-babelrc-or-webpackhttps://kschoi.github.io/cs/babel-config-js-vs-babelrc/","link":"/2021/07/11/fe-babel-webpack/"},{"title":"react query에서 debounce 쓰기","text":"react query에서 hook으로 debounce 쓰기 피드 업로드 시 기술스택을 등록할 때, 사용자가 input을 입력할 때마다 해당 문자로 시작하는 기술 스택을 가져오기 위한 auto complete 기능을 만들었다. 이때 모든 input마다 api request가 가는 것은 낭비일 뿐더러 화면이 매우 버벅이는 문제가 발생하기 때문에 debounce를 걸어 어느 정도 사용자의 입력이 끝나는 타이밍에 api를 호출해주기로 했다. 👾 debounce를 사용하면 특정 시간 동안 발생된 이벤트를 그룹화하여 가장 마지막 이벤트에 대해서만 동작을 실행할 수 있다. 그런데 http request에 react-query를 사용하고 있기 때문에 일반적인 방식의 debounce로는 api call 횟수를 조절하기가 어려웠다. 사용자 input에 따라 기술스택을 가져오는 기능의 query는 아래와 같다. 1234567// useTechs.tsexport default function useTechs(autoComplete: string) { return useQuery&lt;Tech[]&gt;(['techs', autoComplete], getTechs, { enabled: !!autoComplete, suspense: false, });} enabled 옵션을 걸어 사용자의 input에 해당하는 autoComplete이 변할 때마다 getTechs 함수를 다시 호출하는 dependency를 이미 사용하고 있다. 이곳에 새로 setTimeout 등을 이용한 debounce 조건을 붙여주기가 난감했다. 그래서 input의 value가 useTechs의 인자로 들어오기 전에 딜레이를 걸어주기로 했다. 우선 완성된 debounce hook 코드는 다음과 같다. 1234567891011121314151617181920// useQueryDebounce.tsimport { useState, useEffect } from 'react';const useQueryDebounce = (value: string, delay = 200) =&gt; { const [debounceValue, setDebounceValue] = useState(value); useEffect(() =&gt; { const handler: NodeJS.Timeout = setTimeout(() =&gt; { setDebounceValue(value); }, delay); return () =&gt; { clearTimeout(handler); }; }, [value, delay]); return debounceValue;};export default useQueryDebounce; 인자로 들어온 value, 즉 사용자의 input이 변할 때마다 hook 내부의 useEffect가 호출된다. 이때 지정한 delay가 지나야만 debounceValue가 바뀐다. 값을 사용하는 컴포넌트에서는 debounce로 한 차례 걸러낸 input(debouncedSearchInput)을 useQuery의 인자로 넘겨준다. 123456789// TechInput.tsxconst TechInput = () =&gt; { const debouncedSearchInput = useQueryDebounce(searchInput, 200); const { data: techs } = useTechs(debouncedSearchInput); return ( // ... )} 사용자가 한 글자씩 입력할 때마다 요청이 발생하는 것이 아니라, 잠시 기다린 후 요청이 발생하는 것을 확인할 수 있다. 모든 input change마다 request가 발생하지 않고 조금 delay를 두고 request를 보내기 때문에 네트워크 요청 횟수를 줄일 수 있다. Refhttps://dev.to/arnonate/debouncing-react-query-with-hooks-2ek6","link":"/2021/07/24/fe-debounce-query/"},{"title":"Error Boundary와 Suspense","text":"Error Boundary와 Suspense 지난 미션들을 거치며 기술 부채로 남겨놨던 비동기 에러 핸들링을 드디어 맘 먹고 도전해보았다! 페어가 있었기에 가능한 일이었다. 에러가 발생할 수 있는 경우들과 사용자에게 보여야 할 화면 또는 알림창을 제어하기 위해 이틀 간 코딩은 못하고 수많은 논의를 거친 끝에, 완벽하진 않지만 어느 정도 만족스러운 에러 핸들링 컨벤션에 다다랐다. 여기에 http 요청의 loading 상태까지 컨트롤할 수 있는 Suspense를 덧붙여 코드를 작성했다. 합의된 내용은 다음과 같다. 일반적인 에러를 다룰 CustomError 객체를 만든다. http 통신에서 발생하는 에러를 다룰 HttpError 객체를 만든다. 모든 에러는 최상위의 ErrorBoundary가 잡는다. http 통신이 발생하는 최소 단위의 컴포넌트를 ErrorBoundary와 Suspense를 결합한 AsyncBoundary로 감싸준다. 대부분의 http 통신 코드를 담당하는 react-query에서 에러 발생 시 해당 에러를 HttpError로 래핑한 후 다시 throw하여 AsyncBoundary의 경계에서 잡히게끔 한다. http 통신에서 에러 발생 시 AsyncBoundary의 error fallback 컴포넌트(즉, 에러 페이지)를 보여주기 전에 사용자에게 alert 등으로 알림 메시지를 띄워준다. 우선 Error를 상속받는 CustomError 클래스를 만들어준다. 디버깅용으로 콘솔에 찍어줄 message를 클래스 필드로 가지고 있다. 123456789// CustomError.tsexport default class CustomError extends Error { name: string; constructor(message?: string) { super(message); this.name = new.target.name; }} 그 다음 CustomError를 상속받는 HttpError 클래스를 만든다. statusCode가 추가된다. 123456789101112131415// HttpError.tsimport CustomError from &quot;./CustomError&quot;;class HttpError extends CustomError { statusCode: number; constructor(statusCode: number, message?: string) { super(message); this.name = 'HttpError'; this.statusCode = statusCode; }}export default HttpError; http 통신 에러 뿐 아니라 모든 에러를 잡을 ErrorBoundary의 코드는 react 공식 문서에서 가져왔다. 그런데 여기서 타입스크립트 타이핑이 너무나 어려웠다… 특히 constructor 대신에 아래처럼 state를 정의해주는 부분. 생각해보니 클래스 컴포넌트를 타입스크립트로 작성해본 적이 없었던 것이다! 1234567891011121314151617181920212223242526272829303132333435// ErrorBoundary.tsximport { Component, ErrorInfo, ReactNode } from 'react';interface Props { children: ReactNode; fallback: ReactNode;}interface State { hasError: boolean;}export default class ErrorBoundary extends Component&lt;Props, State&gt; { // TypeScript에서는 constructor 대신 이렇게 써줄 수 있다! // 이때 State 인터페이스를 반드시 명시해줘야 한다. state: State = { hasError: false, }; static getDerivedStateFromError(): State { return { hasError: true }; } componentDidCatch(error: Error, errorInfo: ErrorInfo) { console.error('Uncaught error in Error Boundary:', error, errorInfo); } render() { if (this.state.hasError) { return this.props.fallback; } return this.props.children; }} AsyncBoundary는 http 통신의 로딩과 에러를 모두 잡기 위해 위에서 작성한 ErrorBoundary와 Suspense를 모두 사용한다. 그리고 각 상황에서 보여줄 컴포넌트를 각각 rejectedFallback과 pendingFallback 인자로 넘겨준다. 이 부분에서도 타이핑이 꽤나 문제였는데, 우선 복잡한 타이핑은 걸러내고 우리가 사용할 수 있는 선에서 타이핑해주기로 결정했다. 123456789101112131415161718192021// AsyncBoundary.tsximport React, { Suspense } from 'react';import ErrorBoundary from './ErrorBoundary';import Loading from 'components/@common/Loading/Loading';interface Props { pendingFallback?: React.ReactNode; rejectedFallback: React.ReactNode; children: React.ReactNode;}const AsyncBoundary = ({ pendingFallback = &lt;Loading /&gt;, rejectedFallback, children }: Props) =&gt; { return ( &lt;ErrorBoundary fallback={rejectedFallback}&gt; &lt;Suspense fallback={pendingFallback}&gt;{children}&lt;/Suspense&gt; &lt;/ErrorBoundary&gt; );};export default AsyncBoundary; AsyncBoundary가 제 역할을 하려면 http 통신 코드에서 로딩과 에러를 구분해서 알려줘야 한다. Suspense와 ErrorBoundary를 함께 사용할 수 있으면 좋겠다. react-query에서 관련 옵션을 제공한다. useQuery에서 사용하는 http 요청이 각각 Suspense와 ErrorBoundary의 영역에 들어가게끔 하기 위해 App 전체를 감싸는 QueryClientProvider의 인자에 옵션을 넣어준다. 12345678910111213141516// App.tsxconst queryClient = new QueryClient({ defaultOptions: { queries: { suspense: true, useErrorBoundary: true, }, },});const App = () =&gt; { return ( &lt;QueryClientProvider client={queryClient}&gt; // ... &lt;/QueryClientProvider&gt; ) 물론 앱 전체의 global 옵션 대신 아래처럼 query마다 다르게 옵션을 지정해줄 수도 있다. 1useQuery&lt;Feed[], HttpError&gt;('hotFeeds', getHotFeeds, { suspense: false }); http 요청에 문제가 발생했다면, useQuery가 리턴한 에러를 HttpError로 감싸 다시 한번 throw해준다. 123456789101112131415161718192021222324252627// useHotFeeds.tstype ErrorType = 'feeds-001' | 'feeds-002';const getHotFeeds = async () =&gt; { try { const { data } = await api.get('/feeds/hot'); return data; } catch (error) { console.error(error); const { status, data } = error.response; const errorMap: Record&lt;ErrorType, string&gt; = { ['feeds-001']: '임시 에러 메시지 1', ['feeds-002']: '임시 에러 메시지 2', }; // 커스텀한 HttpError 인스턴스를 만들어 던져준다. // 이 에러는 AsyncBoundary에서 catch될 것이다. throw new HttpError(status, errorMap[data.error as ErrorType]); }};export default function useHotFeeds(option: UseQueryOptions&lt;Feed[], HttpError&gt;) { return useQuery&lt;Feed[], HttpError&gt;('hotFeeds', getHotFeeds, option);} 이때 컴포넌트에서 단순히 useQuery가 다시 throw한 에러를 던져 ErrorBoundary의 fallback 페이지를 보여주기 전에, alert로 사용자에게 먼저 경고를 띄워준다. (아래 alert는 추후 custom한 alert로 변경하였다.) 123456789const Home = () =&gt; { const { data: hotFeeds } = useHotFeeds({ onError: () =&gt; alert('에러가 발생했습니다.'), }); return ( // ... )} 마지막으로 http 요청을 사용하는 컴포넌트를 AsyncBoundary로 감싸준다. ErrorBoundary와 Suspense 내부에는 1개의 컴포넌트만 들어갈 수 있기 때문에, http 통신을 사용하는 컴포넌트의 부분 조각들을 모두 개별 컴포넌트 파일로 작성해주기로 했다. 12345return ( &lt;AsyncBoundary rejectedFallback={&lt;h1&gt;임시 에러 페이지&lt;/h1&gt;}&gt; &lt;Home /&gt; &lt;/AsyncBoundary&gt;) 길고 복잡했지만 뿌듯했던 에러 핸들링의 대장정 끝! Ref https://rinae.dev/posts/how-to-handle-errors-1 https://rinae.dev/posts/how-to-handle-errors-2 https://jbee.io/react/error-declarative-handling-1/ https://reactjs.org/docs/concurrent-mode-suspense.html https://ko.reactjs.org/docs/error-boundaries.html https://helloinyong.tistory.com/162 https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/error_boundaries/","link":"/2021/07/24/fe-error-suspense/"},{"title":"file input 다루는 법","text":"&lt;input type=&quot;file&quot; /&gt; 다루는 법 리액트 앱에서 다루기 어려운 것 중 하나가 바로 form이다. form 안의 input 값의 상태를 일일히 관리해주어야 하고, 각각 validation까지 해준다면 더욱 복잡해진다. 그래서 react-hook-form이라는 라이브러리를 사용했다. 한번에 form 안의 모든 input들의 값을 가져올 수 있었지만, file 타입의 input을 가져오는 일은 만만치 않았다. 또 디자인을 커스터마이징한 파일 선택 input에서 파일이 선택되었을 때 바로 옆에 선택된 파일의 이름이 뜨게끔 만들어야 했다. 파일 타입의 인풋은 애플리케이션 계층에서 관리가 되어야 합니다. 파일 선택을 취소할 수도 있고 FileList 객체도 있기 때문입니다. (출처: react-hook-form 공식 문서) 위와 같은 이유로 react-hook-form을 사용한 다른 input들과 같은 방식으로 file input을 작성할 수 없었다. 그리고 아래 이유로 value와 onChange 등을 이용하여 file input에 들어온 값을 바로 가져오기도 힘들었다. React에서 &lt;input type=&quot;file&quot; /&gt;은 프로그래밍적으로 값을 설정 할 수 없고 사용자만이 값을 설정할 수 있기 때문에 항상 비제어 컴포넌트입니다. (출처 - react 공식 문서) 실제로 React 공식문서에서 file input은 아래와 같이 ref를 걸어 비제어 컴포넌트로 사용하고 있다. 1234567891011121314151617181920212223242526class FileInput extends React.Component { constructor(props) { super(props); this.handleSubmit = this.handleSubmit.bind(this); this.fileInput = React.createRef(); } handleSubmit(event) { event.preventDefault(); alert( `Selected file - ${this.fileInput.current.files[0].name}` ); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; Upload file: &lt;input type=&quot;file&quot; ref={this.fileInput} /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); }} 정말 비제어 컴포넌트밖에 답이 없을까? 🤔 고민하던 중 react-hook-form의 watch라는 메서드를 발견했다.watch는 말 그대로 ‘지켜보고’ 있는 것과 같다. 인자로 원하는 input 이름을 넣어주면, 해당 input의 값을 관찰하여 값이 바뀔 때 업데이트된 값을 즉시 알아챌 수 있다. 123456789101112131415// Upload.tsxconst Upload = () =&gt; { const { register, handleSubmit, setValue, watch } = useForm&lt;FeedToUpload&gt;(); const watchThumbnailImage = watch('thumbnailImage'); return ( // ... &lt;FileInput fileName={watchThumbnailImage?.name} onChange={(event) =&gt; setValue('thumbnailImage', event.currentTarget.files[0])} /&gt; // ... )} 123456789101112// FileInput.tsxconst FileInput = ({ fileName, ...options }: Props) =&gt; { return ( &lt;Styled.Root&gt; &lt;Styled.Label&gt; &lt;input type=&quot;file&quot; {...options} /&gt; &lt;span&gt;파일 선택&lt;/span&gt; &lt;/Styled.Label&gt; &lt;Styled.FileNameText&gt;{fileName || '파일을 선택해주세요.'}&lt;/Styled.FileNameText&gt; &lt;/Styled.Root&gt; );};","link":"/2021/07/18/fe-file-input/"},{"title":"왜 forwardRef를 사용할까?","text":"왜 forwardRef를 사용할까? react-hook-form은 기본적으로 ref를 심어주는 비제어 컴포넌트를 사용한다. useForm에서 리턴 받은 register를 input의 ref에 담아, input의 이름으로 값을 가져온다. 123const { register } = useForm()&lt;input name=&quot;firstName&quot; ref={register} /&gt; 그런데 사용하는 input이 만약 React component로 커스터마이징한 input이라면, ref를 다시 해당 input 컴포넌트의 실제 input 태그로 전달해줘야 한다. 1234567891011// Upload.tsxconst { register, handleSubmit, setValue, watch } = useForm&lt;FeedToUpload&gt;();const Upload = () =&gt; { return ( &lt;Styled.VerticalWrapper&gt; &lt;Label text=&quot;제목&quot; required={true} /&gt; &lt;FormInput {...register('title', { required: true })} /&gt; &lt;/Styled.VerticalWrapper&gt; )} FormInput이 아래와 같이 구현되어 있을 때, 1234// FormInput.tsxconst FormInput = ({ ...options }) =&gt; { return &lt;Styled.Root {...options} /&gt;;}; Upload 페이지에서 사용하는 FormInput 컴포넌트에 스프레드({...options})해준 props로 ref가 자동으로 넘어갈 것이라고 생각했으나, 그렇게 작성하지 말라는(!) 오류가 발생한다. 일반적인 방식의 props가 아니라고 경고하는 것이다. 이때 아래와 같이 props를 다른 이름(여기서는 formRef)으로 내려주면 에러는 해결된다. 12345678const Upload = () =&gt; { return ( &lt;Styled.VerticalWrapper&gt; &lt;Label text=&quot;제목&quot; required={true} /&gt; &lt;FormInput name=&quot;title&quot; formRef={register} /&gt; &lt;/Styled.VerticalWrapper&gt; )} 하지만 우리는 ref의 값을 예측 가능하게끔 만들기 위해 ref라는 이름으로 내려주고 싶다! 여기서 forwardRef가 등장한다. forwardRef는 말 그대로 ref를 밀어준다(?)는 의미로, 부모 컴포넌트의 ref를 렌더링하는 자식 컴포넌트로 밀어준다. forwardRef를 사용하면 자식 컴포넌트는 함수의 두 번째 인자로 ref를 받게 된다. ref는 props와 별개로 취급되고 있다. 12345type Props = InputHTMLAttributes&lt;HTMLInputElement&gt;;const FormInput = React.forwardRef&lt;HTMLInputElement, Props&gt;(({ ...options }, ref) =&gt; { return &lt;Styled.Root ref={ref} {...options} /&gt;;}); TypeScript를 사용하는 경우 타이핑은 아래와 같이 작성해준다. 첫 번째 타입으로 RefType을, 두 번째 타입으로 PropsType을 넣어준다. 123const Component = React.forwardRef&lt;RefType, PropsType&gt;((props, ref) =&gt; { return someComponent;}); createRef vs useRef클래스 컴포넌트에서는 createRef로 ref를 생성한다. 보통 컴포넌트의 인스턴스가 생성될 때 ref를 프로퍼티로서 추가하고, 그럼으로서 컴포넌트의 인스턴스의 어느 곳에서도 ref에 접근할 수 있게 된다. 123456789class MyComponent extends React.Component { constructor(props) { super(props); this.myRef = React.createRef(); } render() { return &lt;div ref={this.myRef} /&gt;; }} 함수 컴포넌트에서도 createRef를 사용할 수는 있다. 하지만 함수 컴포넌트는 클래스형 컴포넌트와 달리 인스턴스를 생성하지 않기 때문에 리렌더링될 때마다 createRef 함수는 새로 호출될 것이며, 이에 따라 createRef로 생성된 ref 값이 새로 생성된다. 컴포넌트의 생애주기 내에서 값을 유지하지 못하는 것이다. 따라서 함수 컴포넌트에서는 useRef라는 hook을 사용하여 컴포넌트 생애주기 전체에서 값을 유지해준다. useRef로 생성한 ref 객체는 컴포넌트의 렌더링 시 ref.current의 값을 유지해주게 된다. 1234567891011121314151617181920function CustomTextInput(props) { const textInput = useRef(null); function handleClick() { textInput.current.focus(); } return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={textInput} /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={handleClick} /&gt; &lt;/div&gt; );} Refhttps://stackoverflow.com/questions/62931216/why-exactly-do-we-need-react-forwardrefhttps://kyounghwan01.github.io/blog/React/useRef-createRef/#함수형-컴포넌트https://woowacourse.github.io/tecoble/post/2021-05-15-react-ref/https://www.carlrippon.com/react-forwardref-typescript/","link":"/2021/07/18/fe-forward-ref/"},{"title":"리액트가 함수 컴포넌트와 클래스 컴포넌트를 구별하는 법","text":"Overreacted Dan abramov의 글, 리액트가 함수 컴포넌트와 클래스 컴포넌트를 구별하는 법을 내 스타일대로 정리해보았다. React는 함수 컴포넌트와 클래스 컴포넌트를 각각 어떻게 호출할까?React의 함수 컴포넌트는 다음과 같이 작성한다. 123function Greeting() { return &lt;p&gt;Hello&lt;/p&gt;;} 같은 코드를 클래스 컴포넌트로 작성하면 아래와 같다. 12345class Greeting extends React.Component { render() { return &lt;p&gt;Hello&lt;/p&gt;; }} Greeting 컴포넌트를 함수 컴포넌트로 작성하든, 클래스 컴포넌트로 작성하든 상관은 없다. 만약 Greeting이 함수라면, 리액트는 이를 내부적으로 아래와 같이 호출할 것이다. 1const result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt; 하지만 만약 Greeting이 클래스라면, 리액트는 이를 new 키워드를 통해 인스턴스를 만들고 render 메서드를 호출해야 한다. 123// Inside Reactconst instance = new Greeting(props); // Greeting {}const result = instance.render(); // &lt;p&gt;Hello&lt;/p&gt; 그런데, 리액트는 컴포넌트가 클래스인지 함수인지 어떻게 아는 걸까? 🤔 물론 이는 리액트가 알아서 해주기 때문에 사용하는 입장에서 반드시 알아야 할 필요는 없다. 하지만 궁금하지 않은가?! 추측 1: 모두 new 키워드로 인스턴스화 해준다.리액트가 모든 컴포넌트를 new 키워드로 인스턴스화해준다면 어떨까? 클래스 컴포넌트의 경우 인스턴스를 만드는 것이 기본이므로 문제없이 동작할 것이다. 1234567891011class Person { constructor(name) { this.name = name; } sayHi() { alert('Hi, I am ' + this.name); }}let fred = new Person('Fred');fred.sayHi(); JavaScript에서 클래스 문법의 전신(?)인 생성자 함수의 경우에도 new 키워드를 통해 인스턴스를 만들고, prototype method를 상속받아 사용할 수는 있다. 123456789function Person(name) { this.name = name;}Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name);}var fred = new Person('Fred');fred.sayHi(); 하지만 리액트 컴포넌트는 화살표 함수로도 선언이 가능하다는 점을 잊어서는 안 된다. 123const Greeting = () =&gt; &lt;p&gt;Hello&lt;/p&gt;;new Greeting(); // 🚨 Greeting is not a constructor 리액트 문법을 떠나서, JavaScript의 화살표 함수는 자체적인 this를 갖지 않는다. prototype도 생성하지 않으며, constructor가 없어 생성자 함수로 동작할 수도 없다. new 키워드를 통해 인스턴스를 만들 수 없는 것이다. 또, (약간 억지긴 하지만) instance object를 리턴하지 않는 함수가 있을 수도 있다. 123456function Greeting() { return 'Hello';}Greeting(); // ✅ 'Hello'new Greeting(); // 😳 Greeting {} Greeting을 마치 생성자 함수처럼 선언해 놓고, 인스턴스가 아닌 원시값을 리턴한다면 인스턴스를 반환하지 않게 된다. new 연산자를 사용하는 의미가 없다! 추측 2: 그렇다면 new 키워드 없이 그냥 함수 호출하듯 호출해준다면?안 된다. JavaScript의 클래스는 인스턴스를 만드는 것이 주요 목적이기 때문에, new 키워드를 통해 인스턴스를 생성해주지 않으면 에러가 발생한다. 1234567891011class Person { constructor(name) { this.name = name; } sayHi() { alert('Hi, I am ' + this.name); }}let george = Person('George');// 🚨 Uncaught TypeError: Class constructor Person cannot be invoked without 'new' 생성자 함수에서도 위험하긴 마찬가지다. 12345678function Person(name) { this.name = name;}Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name);}let george = Person('George'); Person 함수를 new 키워드 없이 호출할 수는 있지만, 인스턴스가 생성되지 않는다. 이때 this는 인스턴스가 아닌 window(또는 undefined)를 가리키게 된다. 정확한 동작을 예측할 수 없게 되는 것이다. 그래서, 컴포넌트의 형태를 어떻게 구분하는 걸까?컴포넌트를 클래스로 정의하면 React.Component를 상속(extends)받게 된다. 12345class Greeting extends React.Component { render() { return &lt;p&gt;Hello&lt;/p&gt;; }} 클래스를 상속한다는 것은, 부모 클래스의 prototype의 인스턴스가 된다는 말로도 이해할 수 있다. 1234class A {}class B extends A {}console.log(B.prototype instanceof A); // true 클래스나 생성자 함수를 new 키워드로 호출하여 생성한 인스턴스들은 해당 클래스(또는 함수)의 prototype을 상속받게 되는 것이다. 123456789function Person(name) { this.name = name;}Person.prototype.sayHi = function() { alert('Hi, I am ' + this.name);}var fred = new Person('Fred');// fred.__proto__ === Person.prototype 모든 클래스 컴포넌트는 React.Component를 상속받는다. 클래스 컴포넌트 내부에서 setState 등의 메서드를 사용할 수 있는 것도 이 때문이다. 즉 클래스 컴포넌트를 사용하면, 인스턴스의 __proto__ 체인이 클래스 계층 구조를 가리키게 된다. 12345678910// `extends` chainGreeting → React.Component → Object (implicitly)// `__proto__` chainnew Greeting() → Greeting.prototype → React.Component.prototype → Object.prototype 따라서 instanceof 메서드를 통해 현재 클래스 컴포넌트가 React.Component의 자식 객체, 즉 인스턴스인지 확인하는 방법을 사용할 수 있다. 컴포넌트의 형태를 확인하는 또 다른 방법으로, 리액트는 베이스 컴포넌트에 특별한 flag, isReactComponent를 추가했다. 1234567// Inside Reactclass Component {}Component.prototype.isReactComponent = {};// We can check it like thisclass Greeting extends Component {}console.log(Greeting.prototype.isReactComponent); // ✅ Yes React.Component를 상속받는 클래스의 경우 리액트는 프로토타입 체인 상에서 isReactComponent 프로퍼티를 찾게될 것이다. (isReactComponent의 값을 boolean이 아닌 object 타입으로 설정한 것은 Jest의 초기 버전에서 자동 mocking된 결과라고 한다.) 이 방법은 실제 리액트 코드에서 사용되고 있다. 😮 생각클래스 컴포넌트는 인스턴스를 생성하기 때문에, 컴포넌트에서 지속적으로 유지되는 상태를 만들 수 있다. 반면 함수 컴포넌트는 호출된 후 사라지며 렌더링할 때마다 다시 생성된다. 따라서 상태를 가질 수 없으며, 상태를 흉내내기 위해 컴포넌트와 별도로 구현한 것이 hook이다. 이렇듯 클래스 컴포넌트와 함수 컴포넌트는 리액트에서 호출되고 소멸하기까지의 과정에서 큰 차이가 있는데, 리액트에서 이 둘을 어떻게 구분하여 관리하는지는 생각해보지 못한 것 같다. 실제 내용은 생각보다 간단한 JavaScript의 기본 원리(프로토타입 체인, 클래스 상속)로 컴포넌트를 구분해서 호출하고 있었다. 역시 리액트를 잘 하려면 JavaScript에 대한 깊은 이해가 필요하겠다. 앞으로 더 많은 의심을 하고 궁금증을 갖는 개발자가 되자! 🤩 Ref https://overreacted.io/how-does-react-tell-a-class-from-a-function/","link":"/2021/11/16/fe-function-class-component/"},{"title":"react hook test","text":"react hook test custom hook으로 작성한 react query의 동작을 테스트하기 위해 react-hooks-testing-library를 사용했다. 기본적으로 renderHook이라는 메서드를 제공하여, hook 테스트를 위해 별도의 컴포넌트를 작성하여 hook을 호출할 필요가 없다. 내부적으로 HTTP request를 사용하는 hook이나, 복잡한 컴포넌트 로직 내에서 동작하는 hook의 경우에 react-hooks-testing-library를 사용하여 간단하게 테스트를 진행해볼 수 있다. renderHook에 테스트하고자 하는 hook 함수를 넘겨주고, 반환값인 result를 이용하여 hook 호출의 성공 여부(isSuccess)와 반환된 데이터(data)를 검사한다. 1234567891011121314import { renderHook } from '@testing-library/react-hooks';describe('useRecentFeeds 테스트', () =&gt; { it('최신 피드를 불러올 수 있다.', async () =&gt; { const { result, waitFor } = renderHook(() =&gt; useRecentFeeds({ filter: FilterType.PROGRESS }), ); await waitFor(() =&gt; result.current.isSuccess); expect(result.current.data).toEqual(mockFeeds); });}); hook 실행 후 일정 시간이 지나야 통과되는 비동기적인 실행이라면, renderHook에서 반환되는 waitForNextUpdate 함수를 통해 hook 내부 로직에서 변화가 발생하는 시점까지 기다린 후 expect문을 실행할 수 있다. 1234567891011121314151617181920import { renderHook } from '@testing-library/react-hooks';describe('useOAuthLogin 테스트', () =&gt; { it('github으로부터 액세스 토큰을 받아올 수 있다.', async () =&gt; { const { waitForNextUpdate } = renderHook(() =&gt; useOAuthLogin('github')); await waitForNextUpdate(); expect(localStorage.getItem('accessToken')).not.toBeNull(); }); it('google로부터 액세스 토큰을 받아올 수 있다.', async () =&gt; { const { waitForNextUpdate } = renderHook(() =&gt; useOAuthLogin('google')); await waitForNextUpdate(); expect(localStorage.getItem('accessToken')).not.toBeNull(); });}); 테스트에 사용된 hook들은 모두 서버 데이터를 가져오는 react query 코드였는데, 이때 msw(mock-service-worker)를 이용하여 실제 서버로 가는 요청을 가로채 지정한 응답을 반환해줬다. 실제 서버는 언제든지 터지거나 사이드 이펙트가 발생할 수 있기 때문에, 서버를 mocking하여 기대하는 결과값이 나오는지 검사해준다. 12345678rest.get(`${BASE_URL.production}/login/oauth/:type/token`, (req, res, ctx) =&gt; { return res( ctx.status(200), ctx.json({ accessToken: 'mock-access-token-abc-123', }), );}), 이밖에도 act 함수를 통해 hook 내부에 정의한 함수를 실행시켜줄 수도 있으며, renderHook에 전달되는 hook에 인자를 넘겨줄 수도 있다. 여러모로 유용하게 hook test를 작성할 수 있다! Refhttps://react-query.tanstack.com/guides/testinghttps://react-hooks-testing-library.com/https://kentcdodds.com/blog/how-to-test-custom-react-hookshttps://testing-library.com/docs/react-testing-library/example-intro/#mockhttps://mswjs.io/","link":"/2021/08/01/fe-hook-test/"},{"title":"npm은 어떻게 동작할까","text":"npm은 어떻게 동작할까 어느날 갑자기 눈뜨자마자 궁금해졌다. 꿈에서 이상한 계시를 받았나? 아무 생각없이 npm을 사용하고 있었는데, 만약 누군가 이게 대체 어떻게 돌아가는 건지 묻는다면 대답을 못할 것 같았다. 패키지가 뭘까? 패키지: package.json에 기재된 파일 또는 디렉토리 모듈: Node.js의 require() 문법으로 로드된 파일 또는 디렉토리. 일반 자바스크립트 파일 뿐 아니라 package.json에 main 필드를 포함하는 패키지도 모듈이 될 수 있다. 대부분의 npm 패키지들은 require로 로드되기 때문에 모듈에 해당한다. 하지만 npm 패키지들이 반드시 모듈일 필요는 없다. 하지만 main 필드가 없다면 모듈이 아니다. main 항목은 프로그램의 시작점이 되는 모듈의 ID다. ‘zig’라는 패키지가 있을 때, 이 패키지를 설치한 사용자가 require('zig')를 실행 시 main으로 지정한 모듈의 exports 객체가 반환된다. 파일과 디렉토리 이름package.json 파일은 패키지를 정의한다. node_modules 폴더는 Node.js가 모듈을 찾는 위치다. node_modules에 있는 파일이라도 package.json이 없다면 패키지가 아니다. 반대로 package.json이 있더라도 index.js나 main 필드가 존재하지 않는다면 모듈이 아니다. 따라서 require()의 인자로 사용할 수 없다. 의존성 지옥A와 B, C 모듈이 있을 때, A는 B v1.0을 필요로 하고, C는 B v2.0을 필요로 한다고 가정해 보자. 앱에 A와 C 모듈이 모두 필요하다면, 패키지 매니저는 B의 어떤 버전을 제공해야 할까? 이를 의존성 지옥이라고 한다. Node 모듈 로더대부분의 모듈 로더들은 메모리에 같은 모듈에 대해 2가지 버전을 로드할 수 없다. Node.js 모듈 로더는 이 문제를 해결한다! npm과 Node.js 모듈 로더는 의존성 관리를 위한 런타임에서 유용하게 동작한다. 😮 npm install 시 무슨 일이 일어날까?의존성 트리에 있는 모든 의존성들을 불러온다. 모든 의존성 파일들을 불러오는 대신, 특정 의존성의 이름과 버전, 또는 github url을 명시해줄 수도 있다. 구체적으로 살펴보자. npm install을 실행하면 node_modules 또는 package-lock.json 파일을 확인하고 의존성 트리(폴더 구조)를 따라 내려가며 트리를 복제한다. 이후 package.json에서 관련있는 의존성들을 가져와 트리 복제본에 추가한다. 그리고 원본 트리와 트리 복제본을 비교하며 의존성들을 원본 트리에 추가한다. 이때 의존성들은 트리의 다른 루트나 브랜치들과 충돌하지 않도록 추가된다. 마지막으로 원본 트리와 트리 복제본을 비교하여 node_modules에 새롭게 복제된 트리를 얻기 위한 동작들을 수행한다. package-lock.json의 역할A 패키지는 B@v1.0을, C 패키지는 B@v2.0을 필요로 할 때, 아래와 같이 npm package를 서로 다른 순서로 설치하는 두 가지 경우를 생각해보자. ✔️ 시나리오 1 12npm install Anpm install C ✔️ 시나리오 2 12npm install C npm install A 두 경우 모두 package.json은 아래와 같을 것이다. 123456{ &quot;dependencies&quot;: { &quot;A&quot;: &quot;1.0.0&quot;, &quot;C&quot;: &quot;2.0.0&quot; }} 하지만 의존성 트리를 표현하는 package-lock.json에는 차이가 발생한다. ✔️ 시나리오 1 123456789101112131415161718192021222324{ &quot;dependencies&quot;: { &quot;A&quot;: { &quot;version&quot;: &quot;1.0.0&quot;, &quot;requires&quot;: { &quot;B&quot;: &quot;1.0.0&quot;, } }, &quot;B&quot;: { &quot;version&quot;: &quot;1.0.0&quot;, }, &quot;C&quot;: { &quot;version&quot;: &quot;2.0.0&quot;, &quot;requires&quot;: { &quot;B&quot;: &quot;2.0.0&quot;, }, &quot;dependencies&quot;: { &quot;B&quot;: { &quot;version&quot;: &quot;2.0.0&quot;, } } } }} ✔️ 시나리오 2 123456789101112131415161718192021222324{ &quot;dependencies&quot;: { &quot;A&quot;: { &quot;version&quot;: &quot;1.0.0&quot;, &quot;requires&quot;: { &quot;B&quot;: &quot;1.0.0&quot;, }, &quot;dependencies&quot;: { &quot;B&quot;: { &quot;version&quot;: &quot;1.0.0&quot;, } } }, &quot;B&quot;: { &quot;version&quot;: &quot;2.0.0&quot;, }, &quot;C&quot;: { &quot;version&quot;: &quot;2.0.0&quot;, &quot;requires&quot;: { &quot;B&quot;: &quot;2.0.0&quot;, } } }} 만약 앱에서 B 패키지를 아래와 같이 로드한다면, 1const b = require('B'); 시나리오 1에서는 B@v1.0을 가리킬 것이며, 시나리오 2에서는 B@v2.0를 가리키게 된다. 따라서 프로젝트의 모든 팀원들이 같은 의존성 트리를 사용할 수 있도록 package-lock.json을 github에 올려야 한다. 🤔 nvm은 또 뭘까?nvm은 node-version-manager로, 서로 다른 node와 npm의 버전을 관리해준다. Refhttps://npm.github.io/how-npm-works-docs/https://programmingsummaries.tistory.com/385https://dev.to/shree_j/how-npm-works-internally-4012","link":"/2021/10/31/fe-how-npm-works/"},{"title":"TypeScript의 index signature","text":"TypeScript의 index signature 앱에서 사용하는 feed의 필드를 아래와 같이 정의했다. 1234567891011// types.tsexport interface Feed { id: number; author: User; title: string; content: string; techs: Tech[]; // custom type step: string; sos: boolean; thumbnailImage: File;} 그리고 사용자가 feed를 새로 업로드할 때, 하나의 form 안의 각각의 input에서 가져온 값을 FormData에 key-value 값으로 매핑하여 담아주고 싶었다. 12345678910// form의 event handlerconst uploadFeed = (data: Feed) =&gt; { const formData = new FormData(); Object.keys(data).forEach((key) =&gt; { formData.append(key, String(data[key])); }); uploadFeeds.mutate(formData);}; 그런데 formData에 append할 value로 들어가는 data[key]에서 문제가 발생했다. 🚨 Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type ‘Feed’. No index signature with a parameter of type ‘string’ was found on type ‘Feed’ TypeScript는 기본적으로 객체의 프로퍼티를 읽을 때, string 타입의 key 사용을 허용하지 않는다. TypeScript에서는 string literal 타입과 string 타입을 구분하기 때문이다. 아래 예제에서 a, b, c는 모두 같은 값을 가지지만 타입은 서로 다르다. 123const a = 'Hello world'; // 'Hello world' 타입 (string literal)let b = 'Hello world'; // string 타입const c: string = 'Hello world'; // string 타입 b 변수는 let으로 선언되어 언제든지 재할당이 가능하기 때문에 컴파일러는 이 변수를 string 타입으로 추론한다. c 변수는 명시적으로 string 타입으로 선언했기 때문에 그냥 string 타입이다. a 변수는 조금 특이하다. TypeScript 컴파일러는 이 변수를 string이 아닌 좁은 타입(narrowed type)으로 선언한 것으로 추론한다. 리터럴 타입, 말 그래도 ‘Hello world’ 타입이 된 것이다. 위에서 언급한 문제에서도, Object.keys(data)를 돌며 data의 인덱싱 값으로 사용하려 했던 key라는 변수가 Feed 타입의 필드 네임으로 정의되지 않은 문자열일 수도 있기 때문에 오류를 뱉는 것이다. index signature를 사용하여 이 문제를 해결했다. 원래 index signature는 객체에 대괄호([])를 통해 인덱싱하는 것을 의미한다. 123const foo = {};foo['zig'] = 'song';console.log(foo['zig']); // song TypeScript에서는 특정 객체에 인덱싱 값으로 사용할 수 있는 변수의 타입을 명시적으로 선언해주기 위해 index signature를 사용할 수 있다. 여기서는 index 타입으로 string을 사용했다. TypeScript의 index signature는 string이나 number 타입을 강제한다.(➕ Symbol 타입도 지원한다.) 1234567891011export interface Feed { [index: string]: number | User | string | Tech[] | boolean | File; id: number; author: User; title: string; content: string; techs: Tech[]; // custom type step: string; sos: boolean; thumbnailImage: File;} (index라는 네이밍은 편의를 위한 것이며, 얼마든지 바꿔도 된다. key 등의 네이밍도 괜찮다고 생각한다.) index signature의 타입을 string으로 강제했다. 또 index signature를 선언한 경우 모든 멤버가 그에 따라야 하므로, 멤버에 해당하는 모든 타입들을 index signature의 value 타입에 열거해준다. 이제 외부에서 Feed 타입의 객체를 순회할 때, index에는 string 타입의 값이 들어오며 value의 타입은 위와 같은 union type에 속한 타입들 중 하나에 해당한다는 것을 알 수 있다. string 타입의 key로 정상적으로 인덱싱을 할 수 있게 되었다! Refhttps://itmining.tistory.com/87https://soopdop.github.io/2020/12/01/index-signatures-in-typescript/","link":"/2021/07/18/fe-index-signature/"},{"title":"Inversion of Control (IOC)","text":"IOC | 제어의 역전 Kent C Dodds의 Inversion of Control을 내맘대로 번역한 글이다. 여러분은 리액트 컴포넌트나 hook 등 재사용할 수 있는 코드를 만들어봤을 것이다. 이후 누군가가 해당 코드가 필요하지만, 약간의 변형이 필요하다고 말한다면? 여러분은 그 코드에 argument/prop/option 및 관련된 로직을 추가할 것이고, 이 과정은 반복된다. 재사용 가능했던 코드는 이제 유지보수하기에 끔찍한 악몽이 되고 만다 😭 이 코드가 유지보수하기에 두려운 이유는 다음과 같다. 번들 사이즈와 성능상의 문제가 발생한다. 아무도 이 문제를 해결하기 위해 코드를 들여다봐주지 않을 것이다! 유지보수에 오버헤드가 발생한다. 코드를 사용할 때 수많은 variation이 존재하고, 문서화도 어려워진다. 사용 시 어떤 것이 옳은 접근 방식인지도 판단하기 어렵다. 실행이 복잡해진다. 수많은 arguments/options/props의 조합은 누가 사용하고 있는지조차 몰라 함부로 바꾸거나 없앨 수도 없다. API가 복잡해진다. 다양한 arguments/options/props들로 인해 문서가 복잡해지며, 이를 사용하는 사람들이 배워야 할 것이 많아진다. 도입: Inversion of Control단순한 추상화를 위한 효율적인 메커니즘의 원칙 중 하나가 ‘Inversion of Control’이다. 추상화를 거친 코드는 일을 적게 하고, 사용자가 더 일을 많이 하도록 한다. ‘추상화’라는 개념을, ‘복잡하고 반복되는 일들을 추상화함으로써 나머지 코드는 간단하고 깔끔하게 작성하는 방법으로 생각할 수도 있다. 하지만, 전통적인 개념의 추상화는 반드시 그렇게 동작하는 것은 아니다. Inversion of Control의 코드 예시굉장히 인위적인 아래 코드를 살펴보자. 12345678910111213141516// let's pretend that Array.prototype.filter does not existfunction filter(array) { let newArray = [] for (let index = 0; index &lt; array.length; index++) { const element = array[index] if (element !== null &amp;&amp; element !== undefined) { newArray[newArray.length] = element } } return newArray}// use case:filter([0, 1, undefined, 2, null, 3, 'four', ''])// [0, 1, 2, 3, 'four', ''] 전형적인 ‘추상화 생명주기’에 따라 관련 있어 보이는 use case들을 추가해보자. 1234567891011121314151617181920212223242526272829303132333435363738394041// let's pretend that Array.prototype.filter does not existfunction filter( array, { filterNull = true, filterUndefined = true, filterZero = false, filterEmptyString = false, } = {},) { let newArray = [] for (let index = 0; index &lt; array.length; index++) { const element = array[index] if ( (filterNull &amp;&amp; element === null) || (filterUndefined &amp;&amp; element === undefined) || (filterZero &amp;&amp; element === 0) || (filterEmptyString &amp;&amp; element === '') ) { continue } newArray[newArray.length] = element } return newArray}filter([0, 1, undefined, 2, null, 3, 'four', ''])// [0, 1, 2, 3, 'four', '']filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterNull: false})// [0, 1, 2, null, 3, 'four', '']filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterUndefined: false})// [0, 1, 2, undefined, 3, 'four', '']filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterZero: true})// [1, 2, 3, 'four', '']filter([0, 1, undefined, 2, null, 3, 'four', ''], {filterEmptyString: true})// [0, 1, 2, 3, 'four'] 이제 문맥상 6개의 use case를 갖게 되었지만, 이들을 조합하면 25개의 경우의 수가 탄생한다. 그리고 이는 일반적으로 간단한 편에 속한다. 하지만 시간이 지나고 다시 코드를 살펴본다면, 위 코드가 실제로 고려하고 있는 use case들을 더 간단하게 작성할 수 있다는 것을 깨닫게 될 것이다. 물론 위 코드가 제공하는 기존 기능들은 없애지 않으면서 말이다! 이제 생각을 좀 더 하고 이 함수를 추상화해보자. 여기서 모든 use case를 지원하기 위해 Inversion of control을 적용할 수 있다. 1234567891011121314151617181920212223242526272829303132333435// let's pretend that Array.prototype.filter does not existfunction filter(array, filterFn) { let newArray = [] for (let index = 0; index &lt; array.length; index++) { const element = array[index] if (filterFn(element)) { newArray[newArray.length] = element } } return newArray}filter( [0, 1, undefined, 2, null, 3, 'four', ''], el =&gt; el !== null &amp;&amp; el !== undefined,)// [0, 1, 2, 3, 'four', '']filter([0, 1, undefined, 2, null, 3, 'four', ''], el =&gt; el !== undefined)// [0, 1, 2, null, 3, 'four', '']filter([0, 1, undefined, 2, null, 3, 'four', ''], el =&gt; el !== null)// [0, 1, 2, undefined, 3, 'four', '']filter( [0, 1, undefined, 2, null, 3, 'four', ''], el =&gt; el !== undefined &amp;&amp; el !== null &amp;&amp; el !== 0,)// [1, 2, 3, 'four', '']filter( [0, 1, undefined, 2, null, 3, 'four', ''], el =&gt; el !== undefined &amp;&amp; el !== null &amp;&amp; el !== '',)// [0, 1, 2, 3, 'four'] 굿! 훨씬 간단하다. 제어권을 바꾼 것이다. filter 함수가 리턴하는 새로운 배열의 요소들을 결정하는 책임을 filter 함수의 호출부로 옮겼다. 이전 방식의 추상화도 그렇게 나쁘진 않았을 것이다. 하지만 제어를 역전함으로써 use case를 더 많이, 자유롭게 추가할 수 있게 되었다. 12345678910111213141516filter( [ {name: 'dog', legs: 4, mammal: true}, {name: 'dolphin', legs: 0, mammal: true}, {name: 'eagle', legs: 2, mammal: false}, {name: 'elephant', legs: 4, mammal: true}, {name: 'robin', legs: 2, mammal: false}, {name: 'cat', legs: 4, mammal: true}, {name: 'salmon', legs: 0, mammal: false}, ], animal =&gt; animal.legs === 0,)// [// {name: 'dolphin', legs: 0, mammal: true},// {name: 'salmon', legs: 0, mammal: false},// ] 더 나쁜 API?제어가 역전된 API에 대해 사람들이 일반적으로 하는 불평은, “이전보다 사용하기 더 어려워졌다”는 것이다. 다음 예시를 살펴보자. 12345678// beforefilter([0, 1, undefined, 2, null, 3, 'four', ''])// afterfilter( [0, 1, undefined, 2, null, 3, 'four', ''], el =&gt; el !== null &amp;&amp; el !== undefined,) 분명히 before의 코드가 사용하긴 더 쉬워보인다. 하지만 우리는 제어의 역전이 적용된 API를 사용하여 이전의 API를 간단하게 다시 사용할 수 있다. 1234567891011121314151617181920function filterWithOptions( array, { filterNull = true, filterUndefined = true, filterZero = false, filterEmptyString = false, } = {},) { return filter( array, element =&gt; !( (filterNull &amp;&amp; element === null) || (filterUndefined &amp;&amp; element === undefined) || (filterZero &amp;&amp; element === 0) || (filterEmptyString &amp;&amp; element === '') ), )} 위와 같이, 제어가 역전된 API의 상단부에 추상화를 설계하여 사람들에게 필요한 간단한 API를 제공할 수 있다. 또 만약 우리의 “간단한” API가 모든 use case를 다루기 충분하지 않다면, 더 복잡한 태스크를 해결하기 위해 비슷한 코드블럭을 쌓아나갈 수 있다. 아래 재미있는(!) 예시처럼 말이다. 1234567891011121314151617181920function filterByLegCount(array, legCount) { return filter(array, animal =&gt; animal.legs === legCount)}filterByLegCount( [ {name: 'dog', legs: 4, mammal: true}, {name: 'dolphin', legs: 0, mammal: true}, {name: 'eagle', legs: 2, mammal: false}, {name: 'elephant', legs: 4, mammal: true}, {name: 'robin', legs: 2, mammal: false}, {name: 'cat', legs: 4, mammal: true}, {name: 'salmon', legs: 0, mammal: false}, ], 0,)// [// {name: 'dolphin', legs: 0, mammal: true},// {name: 'salmon', legs: 0, mammal: false},// ] 이렇게 일반적인 use case를 사용하면서도 추가적으로 원하는 여러 태스크들을 조합할 수 있다. 실제로 사용되나?이런 추상화 방식이 좋아보이긴 하는데, 실제로 먹히는 컨셉일까? 아마 우리는 눈치채지 못한 새 제어가 역전된 API를 사용하고 있을지 모른다. 예를 들어, Array.prototype.filter 함수는 제어가 역전되었다. Array.prototype.map도 마찬가지다. 최애 패턴 두 가지는 ‘Compound Components‘와 ‘State Reducers‘이다. Compount ComponentsMenu 컴포넌트를 만들고 싶다고 해보자. 메뉴를 여는 버튼이 있고, 클릭했을 때 메뉴 아이템의 리스트를 보여준다. 아이템이 선택되면, 특정한 액션을 수행한다. 일반적으로 props를 만들어서 컴포넌트를 만들 것이다. 12345678910111213141516function App() { return ( &lt;Menu buttonContents={ &lt;&gt; Actions &lt;span aria-hidden&gt;▾&lt;/span&gt; &lt;/&gt; } items={[ {contents: 'Download', onSelect: () =&gt; alert('Download')}, {contents: 'Create a Copy', onSelect: () =&gt; alert('Create a Copy')}, {contents: 'Delete', onSelect: () =&gt; alert('Delete')}, ]} /&gt; )} 우리는 메뉴 아이템을 마음대로 커스터마이징할 수 있다. 하지만 메뉴 아이템 앞에 삭제 버튼을 추가해야 하면 어떨까? 아이템 객체에 옵션을 추가한다면? 🤯 API는 점점 꼬일 것이다. 좋은 API를 만들기 위해서는, if문이나 삼항 연산자 등의 남용은 자제해야 한다. 제어의 역전을 생각해 보자. 이 경우에, 단지 우리 메뉴에 대한 책임을 유저에게 넘기면 어떨까? 그게 리액트 컴포넌트의 조합이 갖고 있는 최고 강점 중 하나이니까! 1234567891011121314function App() { return ( &lt;Menu&gt; &lt;MenuButton&gt; Actions &lt;span aria-hidden&gt;▾&lt;/span&gt; &lt;/MenuButton&gt; &lt;MenuList&gt; &lt;MenuItem onSelect={() =&gt; alert('Download')}&gt;Download&lt;/MenuItem&gt; &lt;MenuItem onSelect={() =&gt; alert('Copy')}&gt;Create a Copy&lt;/MenuItem&gt; &lt;MenuItem onSelect={() =&gt; alert('Delete')}&gt;Delete&lt;/MenuItem&gt; &lt;/MenuList&gt; &lt;/Menu&gt; )} 위 코드의 특징 중 하나는 컴포넌트를 사용하는 곳에서는 ‘상태(state)’를 볼 수 없다는 것이다. 상태는 컴포넌트들 간에 암묵적으로 공유되고 있다. 이것은 컴포넌트의 조합(compound) 패턴의 핵심 가치다. 이를 이용해서 우리는 렌더링하는 제어권을 컴포넌트의 사용부에 넘길 수 있으며, 코드 추가도 쉽고 직관적으로 바뀐다. State Reducer이 패턴은 컴포넌트 로직을 커스터마이징하기 위한 것이다. 검색, 타이핑(typeahead), 자동완성 등이 가능한 Downshift라는 라이브러리를 추가했다. 이제 이 컴포넌트에서 아이템은 복수 선택이 가능하며, 아이템이 선택된 이후에도 메뉴가 계속 열려있어야 한다고 생각해 보자. 누군가는 closeOnSelection이라는 prop을 추가할 것이다. 하지만 이는 별로인 것 같다. 그 대신, 상태 변화를 제어하는 API를 떠올려 보자. 컴포넌트의 상태가 변할 때마다 호출되는 state reducer 함수를 만들 수 있다. 이 함수는 상태가 변화하려 할 때 개발자가 상태를 바꿀 수 있도록 해준다. 다음 예시를 살펴보자. 123456789101112131415161718function stateReducer(state, changes) { switch (changes.type) { case Downshift.stateChangeTypes.keyDownEnter: case Downshift.stateChangeTypes.clickItem: return { ...changes, // we're fine with any changes Downshift wants to make // except we're going to leave isOpen and highlightedIndex as-is. isOpen: state.isOpen, highlightedIndex: state.highlightedIndex, } default: return changes }}// then when you render the component// &lt;Downshift stateReducer={stateReducer} {...restOfTheProps} /&gt; 이 prop을 추가함으로써, 우리는 컴포넌트를 커스터마이징하는 요청을 획기적으로 줄일 수 있다. 이제 원하는 태스크의 추가를 자유자재로 간단하게 할 수 있다. Render Propsrender props 패턴은 완벽한 제어의 역전이다. 그러나 여기서는 다루지 않을 것임. 주의사항제어의 역전은 앞으로 use case를 추가할 수 있는 상황에 대비해서 재사용 가능한 코드를 작성하는 훌륭한 방식이다. 하지만 그전에, 몇몇 주의사항이 있다. 처음에 만났던 인위적인 코드의 예시를 다시 한번 보자. 12345678910111213141516// let's pretend that Array.prototype.filter does not existfunction filter(array) { let newArray = [] for (let index = 0; index &lt; array.length; index++) { const element = array[index] if (element !== null &amp;&amp; element !== undefined) { newArray[newArray.length] = element } } return newArray}// use case:filter([0, 1, undefined, 2, null, 3, 'four', ''])// [0, 1, 2, 3, 'four', ''] 만약 이것이 filter가 수행해야 하는 전부이며, null과 undefined를 제외하고 모든 것들을 필터링해야 한다면 어떨까? 이 경우 단 하나의 use case를 위해 제어의 역전을 적용하는 것은 더욱 코드를 복잡하게 만들 뿐이다. 모든 추상화는 항상 신중한 고려 후에 작성해야 한다. 시작 전에 AHA Programming의 원칙을 살펴보고, 성급한 추상화를 피하도록 하자! 생각막연하게 ‘제어의 역전’이라는 말을 어렵게만 생각하고 있었는데, 쉬운 예시를 들어가며 이해하기 쉽게 정리한 것 같다. 정말 자주 사용하는 Array의 filter나 map 등의 메서드도 제어의 역전으로 볼 수 있다니, 주어진 기술을 단지 생각없이 사용하는 것보다 ‘이게 왜 이렇게 탄생했는지?’ 생각해보는 연습이 중요한 것 같다. 추상화 단계를 조금 더 세분화해보면 filter라는 가장 추상화된 함수에서 filterByLegCount와 같은 또 다른 중간 단계의 추상화를 만들 수도 있으며, 개발자들이 정말 유연하게 사용할 수 있는 코드라는 것이 이런 지점에서 출발하는 것이 아닐까 생각이 든다. React의 컴포넌트 역시 이러한 추상화의 방식으로 컴포넌트를 분리하고, 이후 기능 추가에 대비해 유연하게 작성되어 있다는 점을 알 수 있었다. 제어의 역전은 어쩌면 선언형 프로그래밍과도 맥이 이어지는 방식이라고 생각한다. ‘어떻게’ 할 것인지에 초점을 두는 명령형 프로그래밍과는 달리 선언형 프로그래밍은 ‘무엇을’ 할지에 관심을 둔다. 하지만 선언형 프로그래밍은 단지 사용하는 쪽에서 코드를 최대한 단순하게 쓸 수 있도록 해야 한다는 생각에 사용부에서 많은 것을 알아야 하는 위 예시들과는 조금 다르다고 생각했다. 그러나 사용하는 쪽에서 ‘많이’ 알아야 하는 것이 잘못된 것은 아니다. 단순히 누가 많이 알고 적게 아는 것이 아니라, 함수가 온전하게 역할이 분리되어 있고 재사용 가능한 로직들을 적절하게 잘 분리했다면, 추상화한 함수 스스로 ‘무엇을’ 할 것인지에 대한 역할을 수행하고 있다고 생각한다. 함수를 분리하며 누가 제어권을 가져야 좋을지, 이후 유지보수 과정도 잘 생각해 보면서 코드를 짜는 연습을 해야겠다.","link":"/2021/10/23/fe-ioc/"},{"title":"자바스크립트 반응형","text":"자바스크립트 반응형 아래와 같은 코드가 있다. 12345let price = 5;let quantity = 2;let total = price * quantity;price = 20;console.log(total); // 10 price의 값을 20으로 바꿨으므로 price에 의존하는 total 값이 40으로 바뀔 것이라고 기대한다. 하지만 total을 찍어보면 여전히 10이 나온다. 자바스크립트는 반응형이 아닌 절차적(procedural) 언어이기 때문이다. 사실 total을 변수가 아닌 함수로 만든다면, 런타임에 값이 결정되기 때문에 반응형처럼 동작하게 만들 수도 있다. 123const total = () =&gt; price * quantity;price = 20;console.log(total()); // 40 하지만… 너무 노간지인걸… 위 코드를 옵저버 패턴을 구현하는 의존 클래스로 캡슐화해보자. 123456789101112131415class Dep { constructor() { this.subscribers = []; } depend() { if (target &amp;&amp; !this.subscribers.includes(target)) { this.subscribers.push(target) } } notify() { this.subscribers.forEach(sub =&gt; sub()) }} 써놓고 보니 lv1에서 순수 자바스크립트로 구현했던 코드와 매우 유사하다…!lv1 코드는 어땠길래 subscribers에 익명 함수를 저장하여, 상태들을 모아놓는 storage처럼 활용한다. depend 함수는 함수 실행에 앞서 바뀐 값을 저장하는 역할, notify는 값이 바뀌었을 때 실행되어야 할 동작이다. 사용은 아래처럼! 1234567891011121314const dep = new Dep();let price = 5;let quantity = 2;let total = 0;watcher(() =&gt; { total = price * quantity;})console.log(total); // 10price = 20;dep.notify();console.log(total); // 20 중간의 watcher 함수는 무슨 역할을 할까? watcher는 업데이트를 감지하는 익명 함수를 캡슐화한 것이다. 123456function watcher(myFunc) { target = myFunc; dep.depend(); target(); target = null;} watcher는 myFunc를 인자로 전달받고, 전역 변수인 target에 myFunc를 할당한다. 그리고 dep.depend()를 호출하여 target을 subscriber에 추가하고, target을 호출한 후 초기화한다. 그러나 우리는 price와 quantity 각각의 값을 Dep 클래스로 가지고 싶다. 우선 price와 quantity를 하나의 객체에 담는다. 1let data = { price: 5, quantity: 2 }; 이제 watcher의 실행부는 아래와 같이 바뀐다. 123watcher(() =&gt; { total = data.price * data.quantity;}) price와 quantity 각각의 subscriber에 연결된 dep.notify()의 호출시점을 지정하기 위해, Object.defineProperty로 getter와 setter를 조작해보자. price와 quantity의 접근자 프로퍼티에 원하는 동작을 hook의 형태로 걸어두는 것이다. 12345678910111213141516171819202122let data = { price: 5, quantity: 2 };Object.keys(data).forEach(key =&gt; { let internalValue = data[key]; const dep = new Dep(); Object.defineProperty(data, key, { get() { dep.depend(); return internalValue; }, set(newVal) { internalValue = newVal; dep.notify(); } })})total = data.price * data.quantity; // get()을 호출data.price = 20; // set()을 호출 1️⃣ data 객체를 돌며 각 속성(price, quantity)별로 Dep 클래스를 연결해줄 것이다.2️⃣ internalValue에 초기 데이터 값을 저장하고, 각 속성별로 Dep 클래스의 인스턴스를 생성한다.3️⃣ Object.defineProperty를 통해 각 속성의 getter와 setter를 새로 덮어씌운다.4️⃣ get()에서는 getter가 호출된 시점의 target을 기억할 수 있도록 dep.depend()를 호출하고, internalValue를 반환한다.5️⃣ set()에서는 internalValue의 값을 변경하고, 값이 바뀌었음을 알려주는 dep.notify()를 실행한다. 이제 watcher 함수에서 더 이상 dep.depend()를 호출할 필요가 없다. watcher 함수에 전달한 익명 함수는 price 또는 quantity 값이 변경될 때마다 재실행될 것이다. 123456function watcher(myFunc) { target = myFunc; // dep.depend(); // 삭제 target(); target = null;} 중간 과정에서의 코드는 많이 생략되어 있다. 전체 코드는 출처⬇️를 참고하면서 다시 공부해 보자! 참고로, 위 코드는 유명한 Evan You on Proxies 영상을 참조했다고 한다. Ref https://blog.rhostem.com/posts/2018-09-12-javascript-reactivity https://www.vuemastery.com/courses/advanced-components/evan-you-on-proxies/","link":"/2021/10/31/fe-js-reactivity/"},{"title":"프론트엔드 성능 분석 &amp; 기본 성능 개선","text":"성능 측정 | bundle 압축 | 이미지 리사이징 성능 분석은 처음이라, 어디서부터 시작해야 하는지 감을 잡을 수 없었다. 다행히 페어와 많은 크루, 코치님들의 도움을 받아 작은 것부터 차근차근 성능을 측정하고 개선점을 찾아보았다. 아래 기준으로 환경을 세팅 후 측정했다. 1234🌐 Network | Fast 3G🏃‍♀️ Performance | CPU 4x throttling🖱 Disable Cache🤫 Chrome Secret Mode ✅ Performance 측정사용자들의 웹 경험에서 중요한 공통 집합인 Core Web Vitals는 아래와 같다. Largest Contentful Paint: 인식되는 로드 속도를 측정하는 항목으로, 페이지의 주요 콘텐츠가 로드되었을 가능성이 높은 시점에 페이지 로드 타임라인에 점을 표시한다. First Input Delay: 응답성을 측정하는 항목으로, 사용자가 페이지와 처음 상호 작용하려고 할 때 느끼는 경험을 정량화한다. Cumulative Layout Shift: 시각적 안정성을 측정하는 항목으로, 눈에 보이는 페이지 콘텐츠의 예기치 않은 레이아웃 변화량을 정량화한다. 크롬 개발자 도구의 Performance 패널에서 확인 가능한 FCP(First ContentFul Paint) 와 LCP(Largest Contentful Paint), 추가적으로 Onload 이벤트가 실행되는 시점을 측정했다. 우리 서비스에서 hero element가 되는 중요한 요소들, 그리고 주요 기능이라고 생각하는 기능들에서의 인터랙션을 중심으로 성능을 측정했다. 이 역시 bundle 압축과 이미지 리사이징을 통해 시간을 많이 앞당길 수 있었다. 대부분의 Web Vitals는 아래와 같은 방식으로 개선이 가능하다. JavaScript 최소화 CSS 블로킹 최소화 리소스 최소화 network payload 최소화 polyfill 최소화 ✅ bundle.js 압축하기현재 프론트엔드 리소스는 CloudFront를 통해 받아오고 있다. 프론트엔드 스크립트의 번들링 결과인 bundle.js의 크기를 네트워크 탭을 통해 확인해 보니, 원본은 2.6MB에 달했으며 CDN을 통해 전송되는 용량도 571kB였다. 웹페이지를 로드하는 데 상당한 부분을 차지하는 만큼, 압축이 필요한 부분이다. AWS CloudFront는 Behaviors에 들어가서, Cache Policy를 새로 설정하거나 기존 옵션을 변경하면 된다. 화면의 View Policy에 들어가서, gzip과 brotli 설정을 Enabled해준다. 그러면 네트워크 탭 Response Header의 content-encoding 항목에 br(brotli)이 표시되는 것을 알 수 있다. 👾 최종 사용자가 gzip과 brotli 두 형식을 모두 지원하는 경우, CloudFront는 brotli를 사용한다. 그렇게 해서 줄어든 bundle.js의 용량은?! 원본 570kB, 실제 브라우저에서 203kB가 되었다. 이후에는 Code Splitting과 tree-shaking 등을 통하여 bundle 파일을 더욱 최적화해 나갈 예정이다. ✅ 이미지 리사이징아무래도 첫 화면부터 많은 이미지를 로드하고 있다보니, 초기 렌더링 속도가 아주아주 느렸다. 사용자가 정말 무거운 파일을 올리기라도 한다면, 로드해 오는 자원의 크기가 7MB를 넘을 정도. 서버 이미지 리사이징을 사용하여 이미지 용량을 줄일 수 있었다. 흔쾌히 도와준 백엔드 팀원들에게 감사하다는 말을 전한다. 🙇‍♀️ 일정 크기 이상의 이미지일 경우, 현재 최대 400px(너비, 높이 중 하나)로 이미지를 저장하여 받아온다. ✅ lighthouse 측정측정할 때마다 결과가 다르게 나오는 lighthouse지만, 그래도 참고용으로 기록해두기로 했다. &lt;bundle 압축, 이미지 리사이징 이전&gt; &lt;bundle 압축, 이미지 리사이징 이후&gt; 조금이나마 점수가 개선된 것을 확인할 수 있다. 우리 프로젝트의 FE 성능 리포트는 계속해서 업데이트 중!📜 성능 리포트 바로가기 Ref https://developers-kr.googleblog.com/2020/05/Introducing-Web-Vitals.html https://www.youtube.com/watch?v=cpE1dwJgS4c https://web.dev/lcp/ https://medium.com/wantedjobs/react-profiler를-사용하여-성능-측정하기-5981dfb3d934 https://ui.toast.com/weekly-pick/ko_202012101720 https://medium.com/myrealtrip-product/fe-website-perf-part1-6ae5b10e3433 https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822","link":"/2021/08/14/fe-performance-measurement/"},{"title":"자바스크립트 Proxy &amp; Reflect","text":"Object.defineProperty와 뭐가 다를까? Proxy자바스크립트의 Proxy는 특정 객체를 감싸 프로퍼티 읽기, 쓰기와 같은 객체에 가해지는 동작들을 중간에서 가로채는 객체다. Proxy 객체를 통해 객체 프로퍼티를 조작하는 명령들을 중간에서 커스텀할 수 있다. Proxy는 기본적으로 아래와 같이 작성한다. 1let proxy = new Proxy(target, handler) new 키워드를 붙여 Proxy 생성자 함수로 Proxy 객체를 생성하며, 첫 번째 인자로는 Proxy를 사용할 객체(target), 두 번째로는 가로챌 동작에 대한 핸들러(handler)를 전달해준다. Proxy를 사용하여 접근자 메서드인 [[Get]], [[Set]]의 호출을 대신하는 트랩을 만들 수 있다. get부터 살펴보자. 1234567891011121314let numbers = [0, 1, 2];numbers = new Proxy(numbers, { get(target, prop) { if (prop in target) { return target[prop]; } else { return 0; // 기본값 } }});console.log(numbers[1]); // 1console.log(numbers[123]); // 0 numbers 배열에서 존재하는 prop의 값을 읽으면 해당 target[prop]에 해당하는 값을 리턴하고, 존재하지 않는다면 0을 리턴한다. 그런데 이건 Object.defineProperty로도 할 수 있는 작업이 아닌가? …라고 생각했는데, Object.defineProperty는 객체의 특정 프로퍼티 하나하나에 대해서 적용하는 값이었다. 123456const obj = {};Object.defineProperty(obj, 'name', { value: 'zig', writable: false}); Proxy는 get() 메서드의 첫 번째 인자로 동작을 전달할 객체인 target, 그리고 두 번째 인자로 프로퍼티 이름에 해당하는 prop을 넣어 호출하기 때문에(세 번째 인자인 receiver는 뒤에서 설명한다), 객체의 특정 프로퍼티가 아닌 객체 전반에 접근할 때 동작을 가로챌 작업을 작성해줄 때 유용하다. Proxy의 set() 트랩은 아래와 같이 작성한다. 123456789101112131415161718let numbers = [];numbers = new Proxy(numbers, { set(target, prop, val) { if (typeof val == 'number') { target[prop] = val; return true; } else { return false; } }});numbers.push(1); // truenumbers.push(2); // trueconsole.log(numbers.length); // 2numbers.push(&quot;test&quot;); // Error: 'set' on proxy Proxy의 set() 메서드는 첫 번째 인자로 동작을 전달할 객체인 target, 그리고 두 번째 인자로 프로퍼티 이름에 해당하는 prop, 세 번째 인자로 프로퍼티 값에 해당하는 value를 넣어 호출한다. (네 번째 인자인 receiver는 뒤에서 설명한다.) 이때 push나 unshift 같이 배열에 값을 추가해주는 메서드들은 내부에서 [[Set]]을 사용하고 있기 때문에 메서드를 오버라이드하지 않아도 프락시가 동작을 가로채고 값을 검증해준다. 🚨 set 트랩을 사용할 땐 값을 쓰는 게 성공했을 때 반드시 true를 반환해줘야 한다. true를 반환하지 않았거나 falsy한 값을 반환하게 되면 TypeError가 발생한다. 이밖에도 Proxy가 가로챌 수 있는 동작들의 목록은 MDN에서 확인할 수 있다. Proxy와 ReflectReflect는 Proxy와 같이 JavaScript 명령을 가로챌 수 있는 메서드를 제공하는 내장 객체이다. Object를 대신하는 namespace로 사용되며, Proxy의 모든 트랩을 Reflect의 내장 메서드가 동일한 인터페이스로 지원한다. 🤔 그렇다면, Reflect 객체는 굳이 왜 필요할까? Reflect.get은 아래와 같이 작성한다. 1Reflect.get(target, prop [, receiver]) Reflect.get은 기본적으로 target[prop] 값을 반환한다. 이때 target이 객체가 아닌 경우 TypeError가 발생한다. Reflect를 통해 에러를 명확하게 확인할 수 있다. 12345const obj = { prop: 1 };Reflect.get(obj, 'prop'); // 1'a'['prop']; // undefinedReflect.get('a', 'prop'); // Uncaught TypeError: Reflect.get called on non-object Reflect.set은 아래와 같이 작성한다. 1Reflect.set(target, prop, value [, receiver]) target 객체의 prop에 할당할 value를 세 번째 인자로 넘겨준다. 이때도 target을 찾을 수 없는 경우 명백한 TypeError를 발생시킨다. 123456const obj = { prop: 1 };Reflect.set(obj, 'prop', 2); // trueobj.prop === 2; // true'a'['prop'] = 1; // 1Reflect.set('a', 'prop', 1); // Uncaught TypeError: Reflect.set called on non-object 🤔 그래서, Proxy와 무슨 상관? 위에서 Proxy를 설명하면서 계속 트랩의 마지막 인자로 전달할 수 있는 receiver 인자를 그냥 넘겨왔었다. 이제 Reflect를 통해 receiver 인자의 역할을 알아보자. receiver는 프로토타입 체이닝 속에서, 최초로 작업 요청을 받은 객체가 무엇인지 알 수 있게 해준다. Reflect의 get/set 트랩에서는 receiver 매개변수를 통해 속성 접근 요청을 받은 객체를 컨트롤할 수 있게 된다. Reflect.get과 Reflect.set의 receiver는 target[prop]이 getter나 setter일 때 this의 컨텍스트로 동작한다. 즉 receiver를 통해 this 바인딩을 조절할 수 있다. 아래 예제를 살펴보자. 123456789101112const obj = { a: 1, b: 2, get sum() { return this.a + this.b; }};const receiverObj = { a: 2, b: 3 };Reflect.get(obj, 'sum', obj); // 3Reflect.get(obj, 'sum', receiverObj); // 5 마치 Function.prototype.call이나 Function.prototype.apply처럼 마지막 인자에 this에 바인딩할 객체를 넣어, 호출할 메서드 내부에서 this가 가리키는 객체를 조절할 수 있다. 자바스크립트는 getter/setter일 때 프로토타입 체이닝을 하더라도 최초 속성 접근 요청을 받은 객체를 receiver에 담아 유지하고 있는데, Reflect의 get/set 트랩에서는 receiver 매개변수를 통해 이를 컨트롤할 수 있게 된 것이다. 이제 Proxy에서 Reflect를 사용하게 된 이유도 슬슬 감이 잡힌다. Proxy를 사용하여 자바스크립트를 반응형으로 흉내낼 수 있는데, 이때 Reflect를 사용하지 않고 일반적인 Proxy의 트랩을 작성한다면 현재 일어나는 탐색의 주체를 알 수 없어 사이드 이펙트가 발생할 수 있다. 1234567891011121314151617181920212223242526function reactive(target) { const proxy = new Proxy( target, { get(target, key, receiver) { const res = target[key]; // 변경 // do something... return res; }, set(target, key, value, receiver) { const oldValue = target[key]; target[key] = value; // 변경 if (oldValue !== value) { // do something... } return value; } } ) return proxy;} Proxy 인스턴스를 반환하는 위 reactive 함수를 아래와 같이 사용해 보자. 12345678910111213const child = { birthYear: 2019};const parent = { birthYear: 1981, get age() { return new Date().getFullYear() - this.birthYear; }};const reactivityParent = reactive(parent);child.__proto__ = reactivityParent; child 객체의 프로퍼티를 읽거나 새 값을 할당한 결과는 다음과 같다. 12345678child.age; // (2021년 기준) 40child.job = 'unemployed';child.hasOwnProperty('job'); // falsechild.job; // 'unemployed'reactivityParent.hasOwnProperty('job'); // truereactivityParent.job; // 'unemployed' ✔️ get 트랩 child에서 age를 조회하면 프로토타입 체인을 통해 프록시 객체로 탐색을 이어간다. parent의 [[Get]]이 호출되면, Proxy의 get 트랩이 트리거 되고, 트랩 내 target은 parent이기 때문에 target[key]를 조회하게 되면, 단순히 parent.age의 평가와 똑같아지므로 this는 parent가 된다. ✔️ set 트랩 child에서 job이란 속성에 ‘unemployed’를 할당하면, 프로토타입 체인을 통해 프록시 객체로 탐색을 이어간다. parent의 [[Set]]이 호출되면, Proxy의 set 트랩이 트리거되고, target[key]는 결국 parent['job']이기 때문에 parent에 job 속성이 추가되고 값이 할당된다. 이제 Proxy의 get/set 트랩 내 Reflect를 사용하고 receiver를 전달하여 실제 작업 요청받은 객체를 this 컨텍스트로 사용하여 사이드 이펙트를 없애보자. 1234567891011121314151617181920212223242526272829303132333435363738function reactive(target) { const proxy = new Proxy( target, { get(target, key, receiver) { const res = Reflect.get(target, key, receiver); // ✅ // do something... return res; }, set(target, key, value, receiver) { const oldValue = target[key]; const res = Reflect.set(target, key, value, receiver); // ✅ if (oldValue !== res) { // do something... } return res; } } ) return proxy;}const child = { birthYear: 2019};const parent = { birthYear: 1981, get age() { return new Date().getFullYear() - this.birthYear; }};const reactivityParent = reactive(parent);child.__proto__ = reactivityParent; child 객체에 프로퍼티 값 읽기/쓰기가 올바르게 동작하는지 확인해보자. 12345678child.age; // (2021년 기준) 2child.job = 'unemployed';child.hasOwnProperty('job'); // truereactivityParent.hasOwnProperty('job'); // falsechild.job; // 'unemployed'reactivityParent.job; // undefined Reflect와 receiver를 이용하여 Proxy의 트랩에 동작이 트리거될 객체를 명확하게 전달할 수 있다! Ref https://ko.javascript.info/proxy https://ui.toast.com/weekly-pick/ko_20210413 https://www.vuemastery.com/courses/advanced-components/evan-you-on-proxies/","link":"/2021/10/31/fe-proxy/"},{"title":"React 18 톺아보기","text":"React 18의 새로운 feature loadable components에서 SSR로 마이그레이션하다가, 🚨 Error: ReactDOMServer does not yet support Suspense. 위 에러에 부딪혀서 돌고 돌아 결국 React 18을 선택하게 되었다. 정식 버전도 배포가 되지 않은, 실험 단계의 버전이지만 나 역시 실험적인 교육생이므로(?) 일단 설치하고 무엇이 있는지 알아보도록 한다. 심지어 @alpha 태그를 붙여서 사용해야 할 만큼 새 버전이다! (그나저나 아래 공식 문서 링크는 ‘ko’가 붙었는데 왜 번역이 안 됐는지 😑 내가 하고 싶다.) React 18은 다음 기능들을 제공한다. ✅ 1. Automatic batching리액트에서는 여러 개의 setState 호출을 묶어서 한 번에 실행한다. ‘batch’는 하나로 묶는다는 뜻으로, setState를 호출할 때마다 리렌더링이 발생하는 것은 비효율적이기 때문에, 상태 업데이트들을 모아서 하나의 리렌더링으로 처리하는 것이다. 현재 리액트는 click과 같은 브라우저 이벤트에 대해서만 batch를 진행하기 때문에, 이벤트가 호출된 이후 상태의 업데이트가 발생하는 아래와 같은 예제에서는 batch가 동작하지 않는다. 1234567891011121314151617181920function App() { const [count, setCount] = useState(0); const [flag, setFlag] = useState(false); function handleClick() { fetchSomething().then(() =&gt; { // React 17 and earlier does NOT batch these because // they run *after* the event in a callback, not *during* it setCount(c =&gt; c + 1); // Causes a re-render setFlag(f =&gt; !f); // Causes a re-render }); } return ( &lt;div&gt; &lt;button onClick={handleClick}&gt;Next&lt;/button&gt; &lt;h1 style={{ color: flag ? &quot;blue&quot; : &quot;black&quot; }}&gt;{count}&lt;/h1&gt; &lt;/div&gt; );} createRoot를 사용하는 React 18부터는, 모든 상태 업데이트들이 자동으로 batch된다. timeout, promise, 네이티브 이벤트 핸들러와 같은 모든 종류의 이벤트들이 동일하게 동작한다. 이를 통해 렌더링을 더욱 효율적으로 할 수 있다. 1ReactDOM.createRoot(rootElement).render(&lt;App /&gt;); batch를 사용하고 싶지 않은 경우 ReactDOM.flushSync를 사용할 수 있다. flushSync 메서드는 상태 업데이트를 강제한다. (사용을 권장하진 않는다!) 123456789101112import { flushSync } from 'react-dom'; // Note: react-dom, not reactfunction handleClick() { flushSync(() =&gt; { setCounter(c =&gt; c + 1); }); // React has updated the DOM by now flushSync(() =&gt; { setFlag(f =&gt; !f); }); // React has updated the DOM by now} ✅ 2. startTransition사용자와 인터랙션이 많은 경우, 스크린 상에서 많은 부분이 업데이트가 되어야 하는 경우 렌더링마다 페이지가 느려질 수 있다. 사실 인터랙션에는 중요하고 긴급하게 업데이트해야 할 경우도 있을 것이고, 조금 여유 있게 처리해도 되는 업데이트가 있을 것이다. 예를 들어, 사용자의 입력에 따라 input 필드의 값이 바뀌는 경우에는 UI가 즉각 리렌더링되어야 한다. 그러나 검색 결과를 보여주는 것은 긴급한 업데이트 항목이 아니다. 12345// Urgent: Show what was typedsetInputValue(input);// Not urgent: Show the resultssetSearchQuery(input); 지금까지 리액트는 모든 업데이트를 반영해 즉시 렌더링해왔다. 위 예제 코드의 상황에서 두 번의 상태 업데이트와 렌더링이 동시에 발생하면, 모든 것이 렌더될 때까지 사용자의 인터랙션은 차단된다. React 18의 startTransition은 이 문제를 해결한다. 12345678910import { startTransition } from 'react';// Urgent: Show what was typedsetInputValue(input);// Mark any state updates inside as transitionsstartTransition(() =&gt; { // Transition: Show the results setSearchQuery(input);}); startTransition으로 래핑된 업데이트는 급하지 않은 동작으로 처리되고, keyPress와 같이 즉시 처리되어야 하는 다른 동작들이 먼저 처리된다. 사용자와의 즉각적인 인터랙션들로 인해 startTransition으로 감싸진 동작이 stale해진다면, 중간 과정은 생략하고 가장 최신의 업데이트만 렌더링된다. 공식 문서에서는 즉각적인 업데이트(Urgent updates)와 트랜지션 업데이트(Transition updates)의 상황을 아래와 같이 구분한다. Urgent updates reflect direct interaction, like typing, clicking, pressing, and so on.Transition updates transition the UI from one view to another. setTimeout을 이용한 throttling이나 debouncing과도 비슷해보일 것이다. 그러나 setTimeout과 다른 점은, startTransition은 스케쥴링되지 않는다는 것이다. startTransition은 즉시 실행되고, startTransition에 전달된 함수는 동기적으로 동작한다. 다만 그 함수에서 발생하는 업데이트가 ‘transition’으로 마킹될 뿐이다. 리액트는 업데이트에 따른 렌더링을 할 때 이 정보를 활용한다. setTimeout보다는 빠를 수밖에 없다. 속도가 빠른 디바이스에서는 업데이트들 사이의 딜레이가 더 적을 것이다. 또 setTimeout 내부에 만약 화면상의 큰 변화가 발생하는 업데이트가 있을 때 해당 콜백을 실행하는 동안 다른 인터랙션들은 블로킹되지만, startTransition은 블로킹되지 않는다. startTransition에 전달되는 함수는 언제든지 간섭받을 수 있기 때문에, 그동안에 발생하는 유저 인터랙션들에 따라 중간 과정의 불필요한 렌더링은 자연스레 삭제되는 셈이다. 마지막으로 setTimeout이 단지 업데이트를 지연시킨다면, transition은 리액트가 pending 상태를 트래킹할 수 있도록 만들어 기다리는 동안 유저에게 피드백을 받을 수 있다. useTransition이 반환하는 isPending 상태값을 받아 transition에 따른 렌더링 결과를 분기쳐줄 수도 있다. 123import { useTransition } from 'react';const [isPending, startTransition] = useTransition(); 1{isPending &amp;&amp; &lt;Spinner /&gt;} startTransition은 리렌더링을 조절하고, 느린 네트워크에 대응하고자 하는 상황에서 유용하다. ✅ 3. New Suspense SSR Architecture리액트 팀이 정말 공을 들여 만든 기능이라고 한다! 리액트에서 SSR을 지원하기 위해 구조적인 개편을 이뤘다. 특히 Suspense를 지원함으로써 리액트 앱을 더욱 작은 단위들로 분리하고, 서버에서 필요한 자원을 받아 화면을 렌더링하는 과정이 각 컴포넌트 단위별로 독립적으로 동작함으로써 앱 전체를 무너뜨리지 않게끔 해준다. 👾 React.lazy에서도 SSR을 쓸 수 있게 되었다고 한다! 기존 SSR의 문제기존 SSR의 문제점은, 서버에서 모든 데이터를 불러와야 한다는 점이었다. 데이터를 모두 불러올 때까지 클라이언트 단의 리액트는 hydrating를 시작하지 못한 채 서버를 기다려야 했다. 또, 인터랙션이 가능해지기 전에 모든 컴포넌트가 hydrate될 때까지 기다려야 한다는 문제가 있었다. 리액트의 hydrate는 이벤트핸들러를 붙여주는 역할을 하는데, 서버에서 HTML이 다 불러와져야 오류 없이 이벤트핸들러를 붙여줄 수 있기 때문이다. 이 문제점들은 리액트 앱의 기존 SSR 방식의 ‘waterfall’한 흐름 때문이었다. fetch data (server) → render to HTML (server) → load code (client) → hydrate (client). 각 단계의 작업은 이전 단계가 끝나야지만 시작될 수 있었다. React 18은 이 단계들을 독립적으로 분류하여, 앱 전체가 아닌 화면의 각 부분들로 쪼개는 방법을 고안했다. React 18에서 SSR을 위해 제공하는 두 가지 기능은 다음과 같다. Streaming HTML on the server Selective Hydration on the client HTML 스트리밍기존의 SSR은 아래와 같이 모든 HTML을 한번에 렌더링한다. 123456789101112131415&lt;main&gt; &lt;nav&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; &lt;/nav&gt; &lt;aside&gt; &lt;a href=&quot;/profile&quot;&gt;Profile&lt;/a&gt; &lt;/aside&gt; &lt;article&gt; &lt;p&gt;Hello world&lt;/p&gt; &lt;/article&gt; &lt;section&gt; &lt;p&gt;First comment&lt;/p&gt; &lt;p&gt;Second comment&lt;/p&gt; &lt;/section&gt;&lt;/main&gt; 이때 페이지의 상태는 ‘아예 안 보이거나’, ‘완전히 다 보이거나’ 둘 중 하나가 될 것이다. React 18에서는 Suspense를 사용할 수 있다. 컴포넌트를 분리하고, 필요에 따라 &lt;Suspense&gt;로 감싼다. 12345678910&lt;Layout&gt; &lt;NavBar /&gt; &lt;Sidebar /&gt; &lt;RightPane&gt; &lt;Post /&gt; &lt;Suspense fallback={&lt;Spinner /&gt;}&gt; &lt;Comments /&gt; &lt;/Suspense&gt; &lt;/RightPane&gt;&lt;/Layout&gt; Suspense로 감싸진 Comments 컴포넌트는, 해당 부분의 HTML이 모두 그려질 때까지 기다리는 대신 fallback 컴포넌트를 반환한다. (프론트)서버에서 Comments에 필요한 데이터 fetching이 완료되면, 리액트는 같은 stream으로 추가적인 HTML을 전달한다. 이렇게 뒤늦게 HTML을 쑤셔 넣는(?) 것을 ‘pop in‘이라고 한다. 각 컴포넌트는 서로 다른 컴포넌트의 데이터가 완전히 로드될 때까지 기다릴 필요가 없다. 클라이언트 단의 Selective Hydration은 데이터를 모두 불러올 때까지 페이지의 다른 부분들이 블로킹되는 문제를 해결한다. 리액트는 로드되는 순서대로 부분적으로 hydration을 진행한다. 선택적 hydrationReact 18은 코드 스플리팅을 하는 경우에도 잘 동작한다. Suspense를 사용하면 HTML이 모두 로드되기 전에 hydrate를 시작할 수 있다. 123456789import { lazy } from 'react';const Comments = lazy(() =&gt; import('./Comments.js'));// ...&lt;Suspense fallback={&lt;Spinner /&gt;}&gt; &lt;Comments /&gt;&lt;/Suspense&gt; Suspense로 필요한 컴포넌트를 감싸면, 다른 컴포넌트들의 스트리밍이나 hydrating 과정을 블로킹하지 않는다. 컴포넌트가 hydrate되기 전 인터랙션React 18은 정말 똑똑하다. 두 개의 독립적인 컴포넌트 A, B에서 hydration이 수행되고 있다고 가정해 보자. 이때 컴포넌트 B에서 click 이벤트가 발생한다면, 리액트는 해당 이벤트를 기록해두고 B 컴포넌트의 hydration을 먼저 진행한다. 그리고 hydration이 끝나면, 기록해두었던 click 이벤트를 다시 실행시켜 인터랙션에 대한 응답을 반환한다. 자동으로 우선순위을 조정하여 hydration을 진행하는 것이다! (이건 정말 대박인 것 같다 😮) Ref https://github.com/reactwg/react-18/discussions/21 https://github.com/reactwg/react-18/discussions/41 https://github.com/reactwg/react-18/discussions/37","link":"/2021/10/03/fe-react-18/"},{"title":"react hook은 왜 조건문 안에서 쓰면 안 될까?","text":"react hook은 왜 조건문 안에서 쓰면 안 될까? react 공식 문서에 따르면 react hook을 사용하는 규칙 중 아래와 같은 내용이 있다. 최상위(at the Top Level)에서만 Hook을 호출해야 합니다 React는 Hook이 호출되는 순서에 의존하기 때문에 모든 렌더링에서 Hook의 호출 순서를 동일하게 보장해줘야고 한다는데, 이게 도통 무슨 말인지 알수가 없다. useState와 useEffect를 직접 만들어 보면서 React의 Hook 호출 방식을 살펴보자. useState클로저를 활용하여 useState 함수를 구현할 수 있다. _value의 형태로 함수 내부에 private한 변수를 정의하고, 해당 값을 리턴해주는 변수 state와 그 값을 변경시킬 수 있는 유일한 함수인 setState를 배열로 담아 리턴해준다. 12345678910111213141516function useState(initialValue) { let _value = initialValue; const state = _value; const setState = (newValue) =&gt; { _value = newValue; }; return [state, setState];}const [count, setCount] = useState(1);console.log(count); // 1setCount(2);console.log(count); // 1 하지만 이렇게 해서는 setCount 호출 이후에도 값이 변하지 않는다. count는 useState 함수를 처음 호출할 때 한번 반환되고 끝나버린 값이기 때문이다. 따라서 내부에서 업데이트된 값을 가져올 수 있도록 state의 값을 함수 형태로 바꿔준다. 기존의 변수명 state는 함수로 사용하기 위해 getter 느낌을 살려 getState로 바꿔주었다. 1234567891011121314151617function useState(initialValue) { let _value = initialValue; // 호출할 때마다 값을 가져오기 위해 함수 형태로 사용 const getState = () =&gt; _value; const setState = (newValue) =&gt; { _value = newValue; }; return [getState, setState];}const [getState, setCount] = useState(1);console.log(getState()); // 1setCount(2);console.log(getState()); // 2 이렇게 하면 외부에서 useState 함수 내부 변수인 _value의 값에 접근하거나 값을 변경할 수 있다. 이제 컴포넌트에 붙여보자! MyReact라는 가상의 리액트 모듈을 만들고, render 메서드를 통해 실제 DOM 렌더링을 대체했다. 123456789101112131415161718192021222324252627282930313233const MyReact = (function () { function useState(initialValue) { let _value = initialValue; const state = _value; const setState = (newValue) =&gt; { _value = newValue; }; return [state, setState]; } function render(Component) { const C = Component(); C.render(); return C; } return { useState, render };})();function Counter() { const [count, setCount] = MyReact.useState(1); return { render: () =&gt; console.log(count), click: () =&gt; setCount(count + 1), }}var App = MyReact.render(Counter); // 1App.click()var App = MyReact.render(Counter); // 1 여기서 click 전후의 count의 값은 초기값 그대로 변하지 않는다. useState를 호출할 때마다 내부 변수인 _value의 값이 다시 1로 초기화되기 때문이다. (_value를 가져오는 방식을 함수로 변경해도 마찬가지다.) useState 함수가 동일한 _value 값을 가리킬 수 있도록 _value의 위치를 MyReact 내부로 끌어올린다. 1234567const MyReact = (function () { let _value; function useState(initialValue) { const state = _value || initialValue; // ... } 하나의 컴포넌트 안에서 _value의 값이 유지되기 때문에 useState가 정상적으로 동작하는 것을 확인할 수 있다. 그렇다면 컴포넌트 안에 여러 개의 상태를 선언하고 싶다면 어떨까? 12345678910111213141516function Component() { const [count, setCount] = MyReact.useState(1); const [text, setText] = MyReact.useState('apple'); return { render: () =&gt; console.log({ count, text }), click: () =&gt; setCount(count + 1), type: word =&gt; setText(word), }}var App = MyReact.render(Component); // { count: 1, text: 'apple' }App.click();var App = MyReact.render(Component); // { count: 2, text: 2 }App.type('banana');var App = MyReact.render(Component); // { count: 'banana', text: 'banana' } count와 text 두 가지로 선언한 상태값이 모두 동일한 값으로 덮어씌워진다! count와 text 모두 MyReact 컴포넌트 내의 같은 변수 _value에 저장하고 있기 때문이다. 여러 개의 상태가 독립적인 값을 유지하게끔 하기 위해 각 state 값을 배열에 담아 관리한다. 123456789101112131415161718192021222324const MyReact = (function() { let hooks = []; let idx = 0; function useState(initialValue) { const state = hooks[idx] || initialValue; const _idx = idx; // 이 hook이 사용해야 하는 인덱스를 붙잡아둔다. const setState = newValue =&gt; { hooks[_idx] = newValue; } idx++; // 다음 hook은 다른 인덱스를 사용하도록 한다. return [state, setState]; } function render(Component) { idx = 0; // 렌더링 시 hook의 인덱스를 초기화한다. const C = Component(); C.render(); return C; } return { useState, render }})() 하나의 컴포넌트 내 여러 개 생성된 상태들은 hooks라는 배열 안에서 각각의 독립적인 인덱스를 가지고 있고, 이 인덱스를 통해 자신의 상태 업데이트 이전의 값을 참조할 수 있다. 따라서 조건부로 hook이 호출되거나 loop 안에서 hook이 호출된다면 인덱스의 순서를 보장할 수 없고, 상태의 관리도 보장할 수 없다. useEffectuseEffect의 실행 방식은 아래와 같다. 사이드 이펙트를 실행하는 함수를 useEffect의 첫 번째 인자로 넘겨주고, 두 번째 인자로는 그 사이드 이펙트의 실행 여부를 결정할 의존성 배열을 넣어준다. 의존성 배열의 요소 중 하나라도 변경이 발생하면 useEffect 내의 사이드 이펙트가 실행된다. 12345678function Component() { const [count, setCount] = MyReact.useState(1); const [text, setText] = MyReact.useState('apple'); MyReact.useEffect(() =&gt; { console.log('side effect'); }, []);} 앞서 만든 MyReact 모듈 안에 useEffect hook을 작성한다. 컴포넌트를 렌더링할 때마다 이미 저장되어 있는 의존성 배열의 값들과 새로운 의존성 배열의 값들을 비교하여 하나라도 다르다면 인자로 넘겨준 콜백 함수를 실행한다. 12345678910111213141516171819202122const MyReact = (function() { let hooks = []; let idx = 0; function useEffect(cb, depsArray) { const oldDeps = hooks[idx]; // 이미 저장되어 있는 의존성 배열이 있는지 확인한다. let hasChanged = true; if (oldDeps) { hasChanged = depsArray.some((dep, i) =&gt; !Object.is(dep, oldDeps[i])); } if (hasChanged) { cb(); } hooks[idx] = depsArray; idx++; } // ...} 👾 Object.is는 === 비교 연산자와 동일하지만, NaN, -0 및 +0에 대한 특수 처리를 수행하지 않는다. 1234NaN === NaN; // falseObject.is(NaN, NaN); // true+0 === -0; //trueObject.is(+0, -0); // false useEffect의 두 번째 인자로 넘겨주는 의존성 배열도 같은 컴포넌트 내에서 hooks 배열의 인덱스로 관리되고 있기 때문에, 호출 순서를 보장해야 한다. react hook을 조건문 안에서 쓰면 안 되는 이유React는 hook이 호출되는 순서에 의존한다. 모든 렌더링에서 hook의 호출 순서는 같다고 보장되어야 한다. 이때 각각의 hook 호출이 이전의 hook 상태들 중 자신이 참조해야 할 값을 알 수 있는 방법은 바로 🔥hook 호출의 순서🔥에 달려있다. hook을 조건부로 실행한다면, 렌더링 간에 hook을 건너 뛰기 때문에 hook의 호출 순서는 달라지고, hook의 호출이 하나씩 밀리면서 버그를 발생시킨다. 리액트 공식 문서의 다음 예제를 살펴보자. (편의를 위해 useEffect의 두 번째 인자로 빈 배열을 각각 추가해주었다.) 123456789101112131415function Form() { const [name, setName] = useState('Mary'); useEffect(function persistForm() { localStorage.setItem('formData', name); }, []); const [surname, setSurname] = useState('Poppins'); useEffect(function updateTitle() { document.title = name + ' ' + surname; }, []); // ...} 모든 렌더링에서 hook의 호출 순서는 같기 때문에 위 예시는 올바르게 동작한다. 12345678910// 첫 번째 렌더링useState('Mary') // 1. 'Mary'라는 name state 변수를 선언한다. -&gt; hooks[0] = 'Mary'useEffect(persistForm) // 2. 폼 데이터를 저장하기 위한 effect를 추가한다. -&gt; hooks[1] = []useState('Poppins') // 3. 'Poppins'라는 surname state 변수를 선언한다. -&gt; hooks[2] = 'Poppins'useEffect(updateTitle) // 4. 제목을 업데이트하기 위한 effect를 추가한다. -&gt; hooks[3] = []// 두 번째 렌더링useState('Mary') // 1. name state 변수를 읽는다.(인자는 무시된다) -&gt; hooks[0] = 'Mary'useEffect(persistForm) // 2. 폼 데이터를 저장하기 위한 effect가 대체된다. -&gt; hooks[1] = []useState('Poppins') // 3. surname state 변수를 읽는다.(인자는 무시된다) -&gt; hooks[2] = 'Poppins'useEffect(updateTitle) // 4. 제목을 업데이트하기 위한 effect가 대체된다. -&gt; hooks[3] = [] 만약 hook의 호출이 다음과 같이 조건문 안에서 발생한다면, 12345if (name !== '') { useEffect(function persistForm() { localStorage.setItem('formData', name); });} 렌더링 간에 hook을 건너뛰면서 각 hook이 이전 값을 참조하는 과정에서 문제를 일으킨다. 1234useState('Mary') // 1. name state 변수를 읽는다. (인자는 무시된다) -&gt; hooks[0] = 'Mary'의 값을 읽어온다// useEffect(persistForm) // 🔴 Hook을 건너뛰었다! useState('Poppins') // 🔴 2 (3이었던). surname state 변수를 읽는 데 실패한다. -&gt; hooks[1] = []의 값을 읽어온다.useEffect(updateTitle) // 🔴 3 (4였던). 제목을 업데이트하기 위한 effect가 대체되는 데 실패한다. -&gt; hooks[2] = 'Poppins'의 값을 읽어온다. 따라서 결론은, react hook의 규칙을 잘 지켜서 컴포넌트의 최상단에서 사용하도록 하자! 👾 setState의 로직을 state와 setter를 분리해서 생각한 다음 글도 참고해보면 좋다. Refhttps://ko.reactjs.org/docs/hooks-rules.html#explanationhttps://it-eldorado.tistory.com/155https://rinae.dev/posts/getting-closure-on-react-hooks-summary","link":"/2021/08/28/fe-react-hooks-no-conditional/"},{"title":"React App s3 &amp; Cloudfront로 배포하기","text":"React App s3 &amp; Cloudfront로 배포하기 리액트로 만든 앱을 s3와 Cloudfront를 이용해 배포해 보자! 1. s3 bucket 생성s3 bucket을 생성하고, 모든 퍼블릭 액세스를 차단해준다. 이후 생성할 cloudfront에서만 해당 버킷으로 접근이 가능하도록 설정해줄 것이다. (필요 시) 2. 정적 웹 사이트 호스팅 활성화s3 버킷의 [속성]에서 정적 웹 사이트 호스팅을 활성화 해준다. 사실 cloudfront를 이용하여 정적 웹 사이트를 호스팅할 경우 필요하지 않은 부분이다. cloudfront를 이용하지 않고 s3 버킷의 도메인을 이용해서 정적 웹 사이트 호스팅을 해준다면 정적 웹 사이트 호스팅을 활성화해준다. 이때 도메인 접속을 위해 퍼블릭 액세스 차단을 모두 해제하거나 버킷 정책을 따로 만들어 설정해줘야 한다. 3. 빌드 후 번들 파일 업로드yarn build 후 생성된 dist 폴더 안의 파일들을 업로드해준다. 4. Cloudfront distribution 생성cloudfront를 통해 방금 만든 s3 버킷에 접근해보자. 우측 [배포 생성] 버튼을 누른다. 원본 오리진으로 앞서 만든 s3 버킷을 선택해주고, 새 OAI를 생성한다. OAI는 Origin Access Identity의 약자로, CloudFront에서 OAI를 사용하여 버킷의 파일을 액세스해 사용자에게 제공할 수 있도록 S3 버킷 권한을 구성할 수 있다. 그러면 현재 cloudfront에 연결된 s3 버킷에 자동으로 버킷 정책이 추가된다. 자동 객체 압축은 Yes로, 뷰어 프로토콜 정책은 Redirect HTTP to HTTPS로 설정해 준다. (cloudfront에서 제공하는 기본 보안 정책이다.) 5. 캐시 정책 설정cloudfront는 aws에서 제공하는 CDN으로, 오리진 서버까지 가지 않고 리소스를 가져오는 캐시 기능을 사용할 수 있다. 기본으로 제공되는 CachingOptimized를 선택해주었다. 이렇게 하면 cloudfront 기본 설정은 끝난다. [확인] 버튼을 눌러준다. 6. 기본 객체 루트 및 오류 페이지 응답 편집cloudfront 대시보드의 일반 → 설정 → 편집에서 기본값 루트 객체를 리액트 앱의 진입점인 index.html로 설정해 준다. 마지막으로 cloudfront 대시보드의 [오류 페이지] 탭에서 오류 시 돌아갈 응답 페이지를 입력해준다. (react로 SPA 개발 시 router를 사용한다면 체크해줘야 할 부분이다.) 7. 확인!이제 cloudfront 도메인을 통해 사이트를 확인할 수 있다 👾","link":"/2021/08/28/fe-s3-cloudfront/"},{"title":"TypeScript type guard","text":"TypeScript type guard 서버 데이터를 가져오는 과정에서 에러 핸들링을 하면서 TypeScript와의 굉장한 싸움에 시달렸다. 그러던 중 type guard에 대해서 알게 되었다. type guard를 사용하면 조건문에서 객체의 타입을 좁혀나갈 수 있다. typeof, instanceof, in 등 기본으로 제공하는 타입 가드 연산자를 사용할 수도 있지만, 사용자 정의 type guard를 작성할 수도 있다. 사용자 정의 type guard 함수는 단순히 어떤 인자명은 어떠한 타입이다라는 값을 리턴하는 함수다. 12345678910111213141516interface Foo { foo: number; common: string;}interface Bar { bar: number; common: string;}/** * 사용자 정의 Type Guard! */function isFoo(arg: any): arg is Foo { return arg.foo !== undefined;} arg is Foo는 사용자가 정의한 type predicate에 해당한다. parameterName is Type에서 parameterName은 현재 함수 시그니처의 인수 이름과 같아야 한다. 여기서는 arg라는 인자가 Foo 타입이라고 예측하여 넘겨준 다음, 정말 Foo 타입이 맞는지를 검사해서 반환한다. 1234567891011121314// 사용자 정의 Type Guard 사용 예시function doStuff(arg: Foo | Bar) { if (isFoo(arg)) { console.log(arg.foo); console.log(arg.bar); // Property 'bar' does not exist on type 'Foo' } else { console.log(arg.foo); console.log(arg.bar); // Property 'foo' does not exist on type 'Bar' }}doStuff({ foo: 123, common: '123' }); // 123 undefineddoStuff({ bar: 123, common: '123' }); // undefined 123 프로젝트에서는 에러 응답 형식을 구분하여 알맞은 방식으로 처리해주기 위해 아래처럼 type guard를 사용했다. 우선 사용한 인터페이스는 다음과 같다. 123456789101112// types.tsxexport interface ErrorResponse { status: number; data: unknown;}export interface HttpErrorResponse extends ErrorResponse { data: { message: string; errorCode: ERROR_CODE_KEY; };} isErrorResponse, isErrorCode, isHttpErrorResponse 세 가지 방식으로 에러 응답의 타입을 확인해주었다. 123456789101112131415161718192021222324252627282930313233343536373839// typeGuard.tsexport const isErrorResponse = (response: any): response is ErrorResponse =&gt; { if (typeof response.status !== 'number') { return false; } if (response.data === undefined) { return false; } return true;};export const isErrorCode = (data: unknown): data is keyof typeof ERROR_CODE =&gt; { if (typeof data !== 'string') { return false; } return Object.keys(ERROR_CODE).some((key) =&gt; key === data);};export const isHttpErrorResponse = (errorResponse: any): errorResponse is HttpErrorResponse =&gt; { if (!isErrorResponse(errorResponse)) { return false; } const { data } = errorResponse; if (typeof (data as any).message !== 'string') { return false; } if (!isErrorCode((data as any).errorCode)) { return false; } return true;}; 완벽하지 않을 수 있지만, 사용할 때 보다 안전하게 타입 체킹을 한 후 에러 핸들러를 작성할 수 있게 되었다! Refhttps://radlohead.gitbook.io/typescript-deep-dive/type-system/typeguardhttps://www.typescriptlang.org/docs/handbook/advanced-types.html","link":"/2021/08/01/fe-ts-type-guard/"},{"title":"CRA 없이 svg 사용하기","text":"CRA 없이 svg를 React component로 사용하기 그동안은 CRA로만 리액트 앱을 만들어왔는데, webpack 설정부터 하나하나 하고 보니 svg가 먹통이었다. 원래 svg는 따로 설정을 해줘야 하는데, CRA에서는 알아서 해주고 있던 것이었다. 이제 스스로… 하나하나 해결해 보자. 1. @svgr/webpack 설치1yarn add -D @svgr/webpack CRA에서는 svg를 자동으로 처리해주지만, CRA를 사용하지 않은 경우 webpack config를 통한 사용 설정이 필요하다. 12345678910// webpack.config.jsmodule: { rules: [ // ... { test: /\\.svg$/, use: ['@svgr/webpack'], }, ],}, 2. custom.d.ts 생성TypeScript는 svg 확장자를 알지 못하기 때문에, 타입 정의가 필요하다. 1234declare module '*.svg' { const content: string; export default content;} tsconfig.json에도 해당 파일을 추가해준다. 12345// tsconfig.json{ // ... &quot;include&quot;: [&quot;src&quot;, &quot;custom.d.ts&quot;]} 이제 아래와 같이 svg 파일을 React Component로 import하여 사용할 수 있다. 123456789// Card.tsximport Flag from 'assets/flag.svg';const StretchCard = () =&gt; { return ( &lt;Flag /&gt; )} 그런데 이렇게 하면 svg 파일을 React component로밖에 사용하지 못한다.아래 두 가지 방법 모두 사용할 수 있다면 좋을 텐데, custom.d.ts에 svg 모듈을 어떻게 두 가지 방식으로 설정해야 하는지 마땅한 해결책을 아직 찾지 못했다. 12345678// 1. svg를 React component로 사용하는 방법import { ReactComponent as Flag } from 'assets/flag.svg';const StretchCard = () =&gt; { return ( &lt;Flag /&gt; )} 12345678// 2. svg를 React component로 사용하는 방법import flag from 'assets/flag.svg';const StretchCard = () =&gt; { return ( &lt;img src={flag} /&gt; )} storybook 설정storybook의 fileLoader 기본 설정 rule에서 svg를 제거하고, svgr 모듈을 사용하도록 수정한다. modules 배열은 사용하는 라이브러리를 오른쪽에서부터 읽기 때문에, override할 라이브러리를 unshift로 가장 앞에 넣어준다. 123456789101112// .storybook/main.jswebpackFinal: (config) =&gt; { const fileLoaderRule = config.module.rules.find((rule) =&gt; rule.test &amp;&amp; rule.test.test('.svg')); fileLoaderRule.exclude = /\\.svg$/; config.module.rules.unshift({ test: /\\.svg$/, use: ['@svgr/webpack'], }); return config;}, Refhttps://blog.doitreviews.com/development/2020-05-08-react-svg-usage-with-webpack/https://bogmong.tistory.com/19","link":"/2021/07/11/fe-svg-without-cra/"},{"title":"Web Server와 WAS 간단 정리","text":"Web Server와 WAS 간단 정리 Static Pages vs Dynamic PagesStatic PagesWeb Server는 파일 경로 이름을 받아 경로와 일치하는 파일 컨텐츠를 반환한다. 이때 항상 동일한 페이지를 반환하게 된다.ex) image, html, css, javascript 파일과 같이 컴퓨터에 저장되어 있는 파일들 Dynamic PagesWeb Server에 의해서 실행되는 프로그램을 통해서 만들어진 결과물로, 인자의 내용에 맞게 동적인 컨텐츠를 반환한다. Web Server vs WASWeb Server웹 서버는 소프트웨어와 하드웨어로 구분된다. 하드웨어 - Web 서버가 설치되어 있는 컴퓨터 소프트웨어 - 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램 또한 웹 서버는 HTTP 프로토콜을 기반으로 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스하는 기능을 담당한다. 요청에 따라 아래의 두 가지 기능 중 적절하게 선택하여 수행한다. 기능 1) 정적인 컨텐츠 제공 - WAS를 거치지 않고 바로 자원을 제공한다. 기능 2) 동적인 컨텐츠 제공을 위한 요청 전달 - 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다. 이때 클라이언트는 일반적으로 웹 브라우저를 의미한다. → 웹 서버는 일반적으로 클라이언트에 정적 컨텐츠(HTML, CSS, JS) 를 제공한다. WAS WAS = Web Server + Web Container WAS는 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버로, HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다. WAS는 “웹 컨테이너(Web Container)” 혹은 “서블릿 컨테이너(Servlet Container)”라고도 불리는데, 여기서 Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다. 즉, WAS는 JSP, Servlet 구동 환경을 제공한다. 🤔 (Java) Servlet?자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 “서블릿”이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다. WAS는 주로 DB 서버와 같이 수행되며, 클라이언트로부터 웹 서버가 요청을 받으면 애플리케이션에 대한 로직을 실행하여 웹 서버로 다시 반환해준다.(현재는 WAS가 가지고 있는 Web Server도 정적인 컨텐츠를 처리하는 데 있어서 성능상 큰 차이는 없다.) WAS의 주요 기능 프로그램 실행 환경과 DB 접속 기능 제공 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능 업무를 처리하는 비즈니스 로직 수행 WAS의 예ex) Tomcat, JBoss, Jeus, Web Sphere 등 (👾 현재 프로젝트에서는 Tomcat이 nginx(Web Server)와 Spring server를 연결해주고 있다.) 왜 Web Server와 WAS를 분리할까?Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다. 그리고 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다. WAS는 Web Server 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시되었으며, 분산 트랜잭션/ 보안/ 메시징/ 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용된다. Web Server와 WAS를 분리하여 얻을 수 있는 구체적인 이점들은 다음과 같다. 기능을 분리하여 서버 부하 방지 WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다. WAS는 기본적으로 동적 컨텐츠를 제공하기 위해 존재하는 서버이다. 만약 정적 컨텐츠 요청까지 WAS가 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도가 느려진다. 즉, 이로 인해 페이지 노출 시간이 늘어나게 될 것이다. 물리적으로 분리하여 보안 강화 SSL에 대한 암복호화 처리에 Web Server를 사용한다. 사용자들에게 WAS는 공개될 필요가 없으며, DB 서버를 관리하는 WAS의 경우 외부에 노출되어서는 안 된다. 여러 대의 WAS를 연결 가능 Load Balancing을 위해서 Web Server를 사용한다. fail over(장애 극복), fail back 처리에 유리하다. 특히 대용량 웹 어플리케이션의 경우(여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다. 예를 들어, 앞 단의 Web Server에서 오류가 발생한 WAS를 이용하지 못하도록 한 후 WAS를 재시작함으로써 사용자는 오류를 느끼지 못하고 이용할 수 있다. 여러 웹 어플리케이션 서비스 가능 예를 들어, 하나의 서버에서 PHP Application과 Java Application을 함께 사용하는 경우 기타 접근 허용 IP 관리, 2대 이상의 서버에서의 세션 관리 등도 Web Server에서 처리하면 효율적이다. → 자원 이용의 효율성 및 장애를 극복하고, 배포 및 유지보수의 편의성을 극대화시킨다 Web Service Architecture일반적으로 아래의 구조로 데이터를 주고 받는다. 1Client → Web Server → WAS → DB Ref https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html https://goldsony.tistory.com/37 https://ko.wikipedia.org/wiki/자바_서블릿","link":"/2021/09/12/fe-web-server-was/"},{"title":"글또 6기를 시작하며","text":"글또 6기를 시작하며 수다쟁이 문과생이과반은 없었던 외국어고등학교 3년을 지나 사회과학계열 학과에 진학했다. 한국어든 영어든 글을 읽고 쓰기만 하는 날들이 반복됐다. 물론 글쓰기가 싫었던 건 아니다. 오히려 좋아하는 편에 속했다. 그렇지만 무의미한 글을 양산해내던 주전공 수업의 글쓰기는 항상 싫어했다. 주전공을 그토록 싫어했음에도 불구하고 대학을 다니는 내내 글쓰기는 점차 몸에 배어갔다. 대학에서의 마지막 수업을 종강한지 한 달, 그리고 행정상의 대학 졸업을 한 달 남짓 남겨둔 시점이기도 한 지금, 돌이켜보면 지난 수 년 간 배운 것이라곤 글쓰기 뿐이었다. 다행히 무엇인가를 읽는 것도, 쓰는 것도 좋아한다. 내 얘기를 하는 것도 좋아하고, 수도 없이 떠오르는 잡생각을 쏟아내듯 글을 써내려가기도 한다. 책을 읽고 (다른) 블로그에 리뷰를 남기기도 하고, 3년 째 하루도 빼먹지 않고 쓰는 일기는 매번 노트의 자리가 부족해진다. 뭐든 말하고 기록하지 않으면 조금은 불안하다. 하루하루 지나가는 20대를 아쉬워하며 사는데, 이 시간들을 그냥 흘러보내기엔 때때로 궁상을 떨거나 치열하게 고민하고 생각한 지금의 모습들이 온전히 남아있지 않은 느낌이다. 이도저도 아닌 개발자뭐 하나 온전하지도, 완전하지도 않은 20대지만 어쨌든 이제는 개발 지망생이니 당연히 개발을 제일 잘 하고 싶다. 그런데 전공자도 아니고, 남들보다 늦게 시작했으니 아직 뛰어나지 않다는 것도 잘 안다. 문과생 출신이니 글쓰기 실력과 말솜씨는 그냥 공대생들보다 낫지 않을까? 영어도 잘 하지 않을까? 하는 기대들… …이 있었지만, 지금 상태는 이도저도 아닌 문과생 개발자가 된 것이다! 🤗 대학에서의 마지막 2년을 글쓰기 과제는 주제가 뭐였는지도 생각나지 않을 만큼 전부 대충 내버리고 나머지 시간을 학교 수업이 아닌 개발 공부에만 투자했으니 당연히 이런 결과가 나올 수밖에. 문과생 출신이지만 글도 어설프게 쓰고 개발 실력도 그냥저냥인 취준생이 되어버린 것이다. 그래도 개발 동아리에서 글 담당이던 때가 있었는데, 이제는 글도 못 쓰고 개발도 못하는 어정쩡한 취준생이라니! 절망스러웠다. 그러던 중 우아한테크코스 과정에서 다시 글쓰기가 시작되었다. 몇몇 크루들은 부담감 한 가득, 쓰기 싫다고 투덜거렸지만 내게는 왠지 글쓰기 과제가 그 어떤 과제보다 설레는 마음으로 다가왔다. 그토록 지워내려고 했던 문과생의 피는 속일 수 없던 것일까? 하라는 개발 미션은 미뤄두고 글을 쓰고 또 쓰고, 퇴고하고, 어떻게 써야 남들이 재밌다고 해줄까 고민하며 두 차례의 글을 써냈다. 물론 아주 만족스럽게 잘 쓰지는 못했지만, 쓰는 과정 자체가 재밌었으니 괜찮다. 가끔은 개발 이외에도 머리 식힐 시간이 필요하기도 하니까. 쓰는 일 뿐 아니라 남들이 내 글을 읽고 나를 알아보는 일도 꽤나 즐거운 경험이었다. 부끄럽지 않은 글쓰기우테코 글쓰기에서 겪은 그런 자그마한 즐거움의 감정 덕에 조금이나마 자신감을 되찾았던 걸까? 2년 전, 글또를 처음 알게 되었을 때 언젠가 꼭 참여해보리라 생각했다. 나는 글을 자주 썼던 사람이니 개발을 본격적으로 시작해도 글을 계속 써보면 좋겠다고 생각했다. 그 후 오랫동안 잊고 있었는데, 우테코 코치님을 통해 6기를 모집한다는 소식을 들었다. 사실 무척이나 고민됐다. 아무것도 모르는 취준생이 글을 쓰고 다른 사람들에게 보여줘도 되는 걸까? 내 글을 읽는 사람들은 시간 낭비 아닐까? 실은 자존감이 낮았던 것이다. 숨어있는 건 진짜 편하니까. 그런데 언제까지 숨어있기만 할 수는 없었다 누가 시키지 않아도 개발 블로그도 꾸준히 써왔으면서, 아무에게도 공개하지 않고 나만의 보물창고마냥 혼자 꽁꽁 숨겨놓고 있었다. 사는 동안 혼나는 걸 두려워하지 않았던 학생이었으면서, 뭐 하나 똑바로 못한 채 이도저도 아닌 취준생이라고 스스로를 질책하던 지난 수 년 간 혼나는 게 두려워졌나보다. 그래서 글또에 용감하게(!) 지원했다. 물론 이미 현업에 계신 분들이 많이 계시고, 학생인 분들도 개발 경력이 오래된 분들같아 보인다. 그렇지만 아무도 뭐라고 하지 않을 것이다. 그리고 사실 사람들은 생각보다 내 실력, 내 글에 관심이 없다. 내 수준에 맞는 글을 쓰면 된다. 이제는 억지로라도 내가 쓴 글을 남들에게 보여줘야 하지만, 그렇다고 ‘남들 보라고 쓰는 글’을 양산해낼 필요는 없다. 내게 필요한 글을 쓰되, 조금만 더 신경 쓰면 되는 것이다. 다른 사람들에게 글을 보여주는 것이 부끄러웠다면, 부끄러운 글을 쓰지 않으면 되는 일이다. 글쓰기 목표특별하게 달라질 것은 없다. 지금까지 써왔던 것처럼, 우아한테크코스 과정에 참여하며 배우는 내용들을 정리하여 글을 쓸 예정이다. 프론트엔드 개발을 공부하며 뗄 수 없는 react.js, javascript, typescript가 주요 주제가 될 것이며, 팀으로 진행 중인 프로젝트에서 마주하는 문제들을 풀어나갈 것이다. 한 가지 더욱 신경 쓸 점은, ‘내가 보기 위한 글’에서 나아가 ‘누군가에게 설명할 수 있는 글’을 작성하고 싶다는 것이다. 유명 개발 블로그를 운영하시는 분들, 아니 적어도 우테코 글쓰기 근로를 하는 크루들을 보면 글의 내용이 아무리 많더라도 분명 얻어갈 수 있는 부분들이 있다. 내가 맞닥뜨리는 문제를 글을 통해 조금이나마 해결할 수 있다. 그러나 내 글은 누군가에게 도움을 주기엔 어려웠다. 어떤 문제에 부딪혀 관련 내용을 정리해놨어도, 다음에 똑같은 문제로 다시 찾아보면 잘 이해가 되지 않았다. 시간에 쫓기듯이, 꾸준해야 한다는 약간의 강박감에 글을 쓰느라 급마무리된 글들도 많았다. 그래서 이제는 친절하게 글을 써보려고 한다. 시간을 조금 더 투자하더라도, 정말 공들인 글. 개발을 모르는 우리 엄마(…)까지는 아니더라도, 우리 우테코 크루들에게 보여준다면 쏙쏙 이해가 잘 될 글, 담백하면서도 쭉쭉 읽어내려갈 수 있는 흡입력을 갖춘 글. 그런 글을 쓰는 게 내 장점이었으니까. 아무리 딱딱한 개발 포스팅이라 할지라도 글에서 그런 인간미를 갖추는 건 나만의 엣지가 될 수도 있을 테니까. 😎","link":"/2021/07/25/geultto-1/"},{"title":"TypeScript declare","text":"TypeScript declare 놀토 프로젝트에서 사용하는 Kakao API를 TypeScript와 함께 사용하기 위해서는 아래처럼 Kakao API를 초기화해주는 작업이 필요하다. 1window.Kakao.init(process.env.KAKAO_API_KEY); 이때 TypeScript는 window에서 Kakao를 찾지 못하므로, 직접 window 객체에 Kakao를 정의해줘야 한다. Type declare의 방식을 사용했다. 123456789// global.d.tsexport {};declare global { interface Window { // eslint-disable-next-line @typescript-eslint/no-explicit-any Kakao: any; }} 또한 svg 확장자 파일을 사용하기 위해서도 해당 확장자에 대한 declare를 선언해줘야 한다. 123456// custom.d.tsdeclare module '*.svg' { const content: ({ fill, width, height }: SVGProps) =&gt; JSX.Element; export default content;} 🤔 declare는 무엇이고, 왜 사용하는 걸까? xxx.d.ts 파일은, TypeScript를 지원하지 않는 서드파티 라이브러리를 사용할 때 타입을 직접 선언해주기 위해 필요하다. 해당 파일은 구현부가 아닌 선언부만을 작성하는 용도로, JavaScript 코드로 컴파일되지 않으며 TypeScript 컴파일러에게 타입 정보를 알려주기만 한다. xxx.d.ts 파일을 만든 후 tsconfig.json에도 해당 declare 파일을 쓸 것이라고 알려준다. 인스톨 시 @types/로 시작하는 라이브러리를 함께 설치하는 경우 별도의 타입 선언이 필요하지 않다. TypeScript는 기본적으로 @types/로 시작하는 패키지들을 컴파일에 포함한다. 해당 패키지들은 DefinitelyTyped에 의해 선언부가 정의되어 있다. 1234567// tsconfig.json{ &quot;compilerOptions&quot;: { // ... }, &quot;includes&quot;: [&quot;src&quot;, &quot;global.d.ts&quot;, &quot;custom.d.ts&quot;]} 또는 typeRoots를 작성해줄 수도 있다. typeRoots를 지정하면, TypeScript는 typeRoots의 경로에 지정된 패키지만 컴파일 과정에 포함한다. 123456789{ &quot;compilerOptions&quot;: { // &quot;typeRoots&quot;: [ &quot;src/types&quot;, &quot;node_modules/@types&quot; ] }} xxx.d.ts 파일을 만들었다면, declare 키워드를 통해 모듈을 선언한다. declare를 이용한 모듈의 기본 선언 방식을 앰비언트 선언(ambient declaration) 이라고 한다. 이는 TypeScript 컴파일러에 JavaScript 구현 ‘환경’에 대한 정보를 알려주는 것으로, 구체적인 실행에 대한 내용 없이 선언부만 작성하기 때문에 ‘앰비언트’라고 한다. 아래처럼 변수를 선언할 수도 있으며, 1declare var hello: any; module 키워드를 사용해 엠비언트 모듈을 선언할 수도 있다. 이때 모듈 내에는 interface, class, function 등의 요소를 선언할 수 있다. 123declare module 'module1' { // ...} 또한 속기 선언 방식을 통해 선언부의 body 없이 빠르게 앰비언트 선언을 작성할 수 없다. 12// 와일드카드(*)를 사용한 속기 선언 방식declare module '*.png'; namespace도 정의해줄 수 있는데, 이때 namespace 키워드를 생략할 수 있다. 123declare namespace global { // ... } module과 namespace로 선언한 선언부의 경우 내부에 export를 붙인 필드만 외부에서 참조가 가능하다. 👾 module vs namespace module - import &amp; export로 사용하며, 코드와 선언부 모두를 포함한다. 모듈은 모듈 로더(ex. CommonJS 등)에 대한 의존성이나 ESModule이 제공하는 런타임을 가지고 있다. namespace - 전역 namespace에서 JavaScript 일반 객체로 컴파일된다. (declare 키워드로 선언 시 JavaScript로 컴파일되지 않는다.) IIFE 함수에 해당 객체를 전달하고 그 함수를 즉시 호출하는 방식으로 컴파일된다. 모듈과 달리 여러 개의 파일을 포함할 수 있다. 이렇게 작성한 선언들은 자동으로 export 키워드가 붙게 되며, 명시적으로 import하지 않고도 프로젝트의 모든 파일에서 전역적으로 사용할 수 있다. import-export를 사용하는 일반 모듈 파일들에서도 전역 참조가 가능한 선언부를 작성하고 싶을 때에는 global 키워드를 사용한다. 위에서 사용했던 Kakao API 사용을 위한 declare global이 여기에 해당한다. 👾 global 객체를 확장하려는 경우 ambient 또는 external module을 사용해야 하는데, ambient module을 사용할 수 없으므로(= module로 선언할 수 없으므로) export {}를 통해 external module로 만들어준다. 12345export {};declare global { // ... } Refhttps://it-eldorado.tistory.com/127https://soft91.tistory.com/74https://typescript-kr.github.io/pages/namespaces-and-modules.htmlhttps://typescript-kr.github.io/pages/modules.htmlhttps://elfi-y.medium.com/typescript-ambient-module-8816c9e5d426","link":"/2021/09/18/fe-typescript-declare/"},{"title":"webpack 설정 뜯어보기","text":"it’s 재정비 타임~ 놀토 프로젝트에서 사용하는 webpack 설정 재정비 중! ✅ webpack dev prod config 분리development와 production의 빌드 목표는 서로 다르다. development에서는 강력한 소스 매핑, localhost 서버에서는 라이브 리로딩이나 HMR(Hot Module Replacement) 기능을 원한다. production의 목표는 로드 시간을 줄이기 위해 번들 최소화, 가벼운 소스맵 및 에셋 최적화에 초점을 맞춰야 한다. 공식 문서에서는 webpack 설정을 분리하여 작성하는 것을 권장하고 있다. dev와 prod에서 공통으로 사용하는 설정들은 webpack.common.js에 작성하고, webpack-merge를 사용하여 common의 설정 내용을 dev와 prod에서 확장하여 사용할 수 있다. ✅ babel/preset-env의 target browserslist 설정하기앱을 만들 때 지원할 브라우저를 명시할 수 있다. ES6와 같은 최신 자바스크립트 문법을 사용할 때 browserslist를 명시해 주면, 트랜스파일러나 모듈 번들러가 현재 타겟으로 하는 브라우저를 알 수 있다. 최신 문법을 지원하지 않는 브라우저(IE 11버전 이하)를 그대로 사용한다면 별도의 polyfill을 설치해줘야 한다. 현재 프로젝트에서는 크롬 50버전 이상 또는 전체 브라우저의 최신 2개의 버전을 지원하며, IE 11 버전 이하의 브라우저는 지원하지 않기로 했다. 전체 query 목록은 여기서 확인할 수 있다. babel의 @babel/preset-env 설정에 browserslist를 명시해주는 방법도 있지만, 현재 패키지에서 확인하는 방법이 좋다고 생각하여 package.json에 작성 후 webpack에서 참조하도록 했다. 12345// package.json{ // ... &quot;browserslist&quot;: &quot;chrome &gt; 50 or last 2 versions and not ie &lt;= 11&quot;,} webpack에는 아래와 같이 적어주었다. browserslist 설정이 있다면 target 옵션은 디폴트로 해당 browserslist를 가리키게 된다. 12345// webpack.config.jsmodule.exports = { // ... target: 'browserslist',} 아래 명령어를 통해 현재 앱에서 타겟 환경으로 지정한 브라우저와 그 버전을 명시한 목록을 볼 수 있다. 1npx browserslist ✅ file-loader 대신 asset/resourcefile-loader 모듈은 개발 시 import/require 구문으로 사용되는 에셋 파일들을 번들 결과의 output 폴더에 생성해준다. webpack v5부터 deprecate되었으며, 현재는 asset/resource를 사용한다. generator 옵션을 사용하여 번들 이후 생성될 파일의 이름을 설정해줄 수 있다. 12345678910111213141516// webpack.config.jsmodule.exports = { // ... module: { rules: [ // ... { test: /\\.(png|jpe?g|gif|webp)$/i, type: 'asset/resource', generator: { filename: 'static/[name][ext]', }, }, ] }} ✅ 타입 체킹 기능 사용babel은 ES6 코드를 ES5 이하의 문법으로 컴파일해주지만, 타입 체크는 해주지 않는다. babel에서 기본으로 제공하는 @babel/preset-typecript preset은 타입스크립트 문법을 브라우저가 이해할 수 있게끔 해주는 역할만 수행할 뿐, 타입 체크를 해주지 않는다. 별도의 타입 체크를 위해 tsc와 같은 타입스크립트 컴파일러를 설치하여 타입 체크를 수행할 수 있지만, 그보다 webpack과의 결합도를 위해 fork-ts-checker-webpack-plugin을 사용하였다. fork-ts-checker-webpack-plugin은 babel 컴파일 과정에서 별도로 동작하여, 타입 체크와 babel 컴파일을 병렬적으로 수행할 수 있다는 장점이 있다. ts-loader를 사용하여 babel에서 타입 체크를 수행할 수 있지만, 혼자 트랜스파일링과 타입 체크를 모두 다 하게 되기 때문에 느리다는 단점이 있다. 공식 문서에서는 babel-loader의 사용을 권장한다. ✅ DefinePlugin컴파일 타임에 사용할 값들을 지정해준다. 구체적으로는 production mode에서 사용할 환경변수들을 가져와 정의해줄 수 있다. Github Actions나 Jenkins 등 CI/CD를 도와주는 툴에 secret variable로 앱에서 사용하는 API key 등의 환경변수를 설정하고, 빌드 시점에 해당 환경에서 필요한 변수를 취득하여 앱에 적용해 준다. production mode에서 SENTRY의 DSN을 불러와 사용해주기 위해 작성해주었다. DefinePlugin의 key-value 쌍에서 key값은 항상 아래처럼 문자열로 감싸줘야 하며, value도 JSON.stringify로 바꿔줘야 한다. 12345678910// webpack.config.jsmodule.exports = { // ... plugins: [ // ... new DefinePlugin({ 'process.env.SENTRY_DSN': JSON.stringify(process.env.SENTRY_DSN), }), ],} DefinePlugin과 유사하게 동작하지만, 환경 변수 전용으로 사용되는 EnvironmentPlugin이라는 플러그인도 있다. ✅ filename vs chunkfilename filename - 각 출력 번들의 이름을 결정하며, 각 번들에 대해 독립적이다. 단일 entry 지점의 경우 정적인 이름으로 설정할 수 있다. (ex. bundle.js) chunkFilename - 초기가 아닌 청크 파일의 이름을 결정하며, 런타임에서 파일 이름을 생성한다. 코드 스플리팅 시 webpack에 의해 자동 생성되는 파일 이름이다. (async chunk의 경우 chunkFilename 채택하는 듯하다. 그런데 아직 잘 안 된다 😵) 12345678910// webpack.config.jsmodule.exports = { output: { path: path.resolve(__dirname, './dist'), filename: '[name].[chunkhash].js', chunkFilename: '[id].js', publicPath: '/', }, // ...} ✅ Tree-shaking을 위한 sideEffects 설정tree-shaking은 사용하지 않는 코드를 제거함으로써 용량을 줄이는 방식을 말한다. webpack은 v5부터 terser 라이브러리를 통해 기본적인 tree-shaking을 수행하고 있다. 하지만 ESM의 import/export 키워드를 사용할 때, import한 모듈들을 아무 곳에서도 참조하지 않는 등의 상황이 발생하면 webpack의 tree-shaking 과정에서 문제가 생긴다. 따라서 tree-shaking 시 sideEffects가 발생하지 않을 것이라고 개발자가 webpack을 안심시켜줘야(?) 한다. package.json에 sideEffects: false 옵션을 명시해준다. 123456// package.json{ &quot;name&quot;: &quot;nolto&quot;, &quot;version&quot;: &quot;1.0.1&quot;, &quot;sideEffects&quot;: false,} import한 모듈을 사용하지 않는 경우 외에도 tree-shaking이 적용되지 않는 경우들은 아래와 같다. 전역 함수를 사용하는 경우 함수 실행 코드에서 멤버변수를 변경하고 반환하는 경우 static class properties를 사용하는 경우 class를 사용하는 경우 등 원래는 babel config에 “modules”: false 옵션까지 지정하여, babel이 import 구문까지 commonJS의 require로 바꿔주는 것을 방지했다. (webpack의 tree-shaking은 import문만 이해하기 때문) 하지만 해당 옵션은 default로 false가 적용된다고 한다. CommonJS의 require는 동기적으로 이루어진다. (원래 Node.js를 위한 것이며, 브라우저용으로 탄생한 방식이 아니다!) 반면 ESM은 가져온 스크립트를 바로 실행하지 않고 import/export 구문을 찾아서 스크립트를 파싱한다. 그리고 더 이상 import 것이 없어질 때까지 import를 찾은 다음 dependencies의 모듈 그래프를 만들어 낸다. ✔️ Refhttps://webpack.kr/guides/production/https://ui.toast.com/weekly-pick/ko_20191212https://github.com/browserslist/browserslisthttps://webpack.js.org/guides/asset-modules/https://webpack.js.org/plugins/define-plugin/https://www.debugbear.com/blog/bundle-splitting-components-with-webpack-and-reacthttps://github.com/styled-components/styled-components/issues/2254#issuecomment-560027361https://medium.com/naver-fe-platform/webpack에서-tree-shaking-적용하기-1748e0e0c365https://webpack.js.org/configuration/optimization/#optimizationsideeffectshttps://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1","link":"/2021/09/11/fe-webpack-refactor/"},{"title":"하브루타 스터디 - 10주","text":"하프 스터디 10주차: 프로토타입 with 피터 Q1. 아래 두 방식은 어떻게 서로 다를까요?1234567891011121314151617181920212223242526// 1번function Circle(radius) { this.radius = radius; this.getArea = function() { return Math.PI * this.radius ** 2; };} const circle1 = new Circle(1);const circle2 = new Circle(2);console.log(circle1.getArea === circle2.getArea); // false // 2번function Circle(radius) { this.radius = radius;}Circle.prototype.getArea = function() { return Math.PI * this.radius ** 2;}const circle1 = new Circle(1);const circle2 = new Circle(2);console.log(circle1.getArea === circle2.getArea); // true 1번 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다. 메모리의 불필요한 낭비, 퍼포먼스에 악영향을 끼친다. 2번 Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가한다. 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩된다. getArea 메서드는 단 하나만 생성한다. Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메서드를 상속받아 사용한다. 👾 생성자 함수가 생성할 모든 인스턴스는 별도의 구현 없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다 Q2. hasOwnProperty와 getOwnPropertyDescriptor를 사용해본 적 있나요? 언제 어떻게 사용하면 좋을까요?hasOwnProperty Object.prototype.hasOwnProperty 객체에 특정 프로퍼티가 존재하는지 확인한다. 인수로 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 리턴하며, 상속받은 프로토타입의 프로퍼티 키인 경우 false를 리턴한다. 123456const person = { name: 'Zig' };console.log(person.hasOwnProperty('name')); // trueconsole.log(person.hasOwnProperty('toString')); // falseconsole.log('toString' in person); // true 12console.log(Object.prototype.hasOwnProperty('hasOwnProperty')); // trueconsole.log(person.hasOwnProperty('hasOwnProperty')); // false 프로토타입 체인과 hasOwnProperty 123456function Person(name) { this.name = name;}const me = new Person('Zig');me.hasOwnProperty('name'); // true me 객체에서 hasOwnProperty 메서드를 검색한다. me에는 hasOwnProperty 메서드가 없으므로 프로토타입 체인을 따라, [Prototype]] 내부 슬롯에 바인딩되어 있는 프로토타입(Person.prototype)으로 이동하여 hasOwnProperty 메서드를 검색 hasOwnProperty가 있는 Object까지 프로토타입 체인을 타고 올라간다. Object에서 hasOwnProperty를 호출한다. 이때 hasOwnProperty는 me를 바인딩한 형태로 호출된다. 즉 Object.prototype.hasOwnProperty.call(me, 'name') getOwnPropertyDescriptor Object.getOwnPropertyDescriptor(obj, prop) 주어진 객체 자신의 속성(즉, 객체에 직접 제공하는 속성, 객체의 프로토타입 체인을 따라 존재하는 덕택에 제공하는 게 아닌)에 대한 속성 설명자(descriptor)를 반환한다. value, writable, get, set, configurable, enumarable 12345678910var obj = {};// 새로운 속성을 정의Object.defineProperty(obj, &quot;prop&quot;, { value: &quot;Hello&quot;, writable: false});console.log(Object.getOwnPropertyDescriptor(obj, &quot;prop&quot;));// &gt; {&quot;value&quot;:&quot;Hello&quot;,&quot;writable&quot;:false,&quot;enumerable&quot;:false,&quot;configurable&quot;:false} enumerable = false이면 for..in 연산문에서 빠진다 123456789101112const person = { name: 'Zig', address: 'Seoul',}console.log('toString' in person); // truefor (const key in person) { console.log(key + ': ' + person[key]);}// name: Zig// addresss: Seoul Object.prototype.toString 프로퍼티의 [[Enumerable]] 값이 false이기 때문 12Object.getOwnPropertyDescriptor(Object.prototype, 'toString'); // {writable: true, enumerable: false, configurable: true, value: ƒ} writable이 false이면 read-only처럼 동작한다.(할당 연산자를 사용한 값의 재할당을 의미한다). 즉 writable이 false이면 할당연산자를 이용한 할당이 불가능하다. enumerable이 false이면 나열이 불가능하다.(for...in 문이나 Object.keys()로의 접근이 불가능하다.) configurable이 false이면 해당 속성을 설정하는 것이 더이상 불가능해진다. (defineProperty를 사용한 값의 재할당이 불가하다.) Q3. __proto__와 Object.getPrototypeOf 메서드는 어떻게 다를까요? __proto__ 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우 getPrototypeOf을 사용한다. __proto__ 프로퍼티에 접근하면 내부적으로 Object.getPrototypeOf가 호출되어 프로토타입 객체를 반환한다. 할당값이 객체인 경우에는 객체의 프로토타입이 바뀔 수 있어서 치명적인 버그가 발생할 수 있다. 버그 뿐 아니라, 프로토타입 객체를 직접 변경하는 연산은 프로퍼티 접근 관련 최적화를 망치기 때문에 퍼포먼스 이슈가 발생한다. getPrototypeOf은 readOnly → setPrototypeOf을 사용해서 프로토타입을 새로 할당한다. 123456789const obj = {};obj.__proto__ = null;obj.__proto__; // undefinedObject.getPrototypeOf(obj); // nullobj.__proto__ = 'peter';obj.__proto__; // peter -&gt; __proto__가 obj의 key값처럼 사용됨Object.getPrototypeOf(obj); // null이 유지됨 Ref https://ko.javascript.info/prototype-methods Q4. 객체 리터럴에 의해 생성된 객체의 프로토타입은 어떻게 만들어지나요?12345const obj = { x: 1 };console.log(obj.constructor === Object); // trueconsole.log(obj.__proto__ === Object.prototype); // trueconsole.log(obj.hasOwnProperty('x')); // true 객체 리터럴에 의해 생성된 객체는 내부적으로 Object 생성자 함수를 사용해서 생성된 객체이다. 🔫 리터럴로 선언한 객체는 추상 연산 OrdinaryObjectCreate에 의해 생성된다. 추상 연산 OrdinaryObjectCreate을 호출하여 빈 객체를 생성하고 프로토타입을 추가한다. 이때 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다. 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부 슬롯에 할당한 다음, 생성한 객체를 반환한다. → 👾 프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다! 12345obj1 = new Object(123);console.log(obj1); // Number {123}obj2 = new Object('abc');console.log(obj2); // String {'abc'} 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 프로토타입으로 갖게 되며, 이로써 Object.prototype을 상속받는다. Ref(Q1~Q4) 모던 자바스크립트 Deep Dive Q5. 프로토타입 패턴에 대해 설명해주세요. 자바스크립트를 이루고 있는 거의 ‘모든 것’은 객체이다. 객체: 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조 프로토타입 객체는 객체 간 상속을 구현하기 위해 사용된다. 원본 객체가 존재하며, 그 객체를 복제해서 새로운 객체를 생성한다. Q6. 그렇다면, 자바스크립트가 Prototype을 사용하는 이유는 무엇인가요? 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거할 수 있다. new 키워드를 사용하여 객체지향 패턴을 흉내낼 수는 있지만, 실제로 자바스크립트의 상속이나 오브젝트간의 연결은 프로토타입으로 구현한다. JavaScript에서는 함수를 이용하여 객체를 만든다. 함수가 생성될 때 자동으로 그 함수의 프로토타입 객체도 함께 생성되며, 해당 함수의 prototype 프로퍼티와 연결된다 함수의 프로토타입 객체를 복제하는 것이다. 1234function Person() {}const zig = new Person();console.log(zig); // Person { __proto__: Object } 👾 옛날 이야기!Prototype을 이용하면 객체의 생성 비용을 효과적으로 줄일 수 있기 때문이다. 자바스크립트가 처음 도입되던 옛 환경에서는 메모리가 부족했다. 그래서 객체의 생성비용을 효과적으로 줄일 수 있는 프로토타입 디자인 패턴이 도입되었다. 또한, 당시에는 웹 브라우저가 등장한 지 얼마 안됐던 시기였고, HTML과 CSS를 이용해서 웹 사이트를 만드는 것이 굉장히 쉬웠기 때문에 기존에 다른 개발을 경험해보지 않고 웹 개발부터 시작한 사람들이 많았다. 이런 사람들은 메모리 관리나 프로그래밍에 대한 이해가 부족했기 때문에, 그런 사람들이 아무렇게나 짜도 최대한 효율적으로 코딩이 가능하도록 언어를 만드는 게 중요했다. 그래서 크게 신경을 쓰지 않고도 프로토타입을 통해 메모리가 더 효율적으로 관리되는 Prototype을 사용하게 된 것이다. 하지만 지금에 와서는 메모리도 충분하고 객체의 생성 비용을 옛날만큼 신경쓸 필요가 없어졌다! 👾 ES6의 class - prototype을 이용한 syntactic sugar! Q7. [[Prototype]] 객체에 접근할 수 있는 방법에는 어떤 것들이 있을까요?[[Prototype]] 내부 슬롯에는 직접 접근이 불가하다. __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있다. __proto__는 getter/setter라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다. __proto__는 객체가 직접 소유하는 프로퍼티가 아닌 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 Object.prototype.__proto__ 접근자 프로퍼티를 사용할 수 있다. 123456789const person = { name: 'Zig' };console.log(person.hasOwnProperty('__proto__')); // falseconsole.log(Object.prototype.hasOwnProperty('__proto__')); // trueconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));// {enumerable: false, configurable: true, get: ƒ, set: ƒ}console.log(person.__proto__ === Object.prototype); // true Object.getPrototypeOf 1234const obj = {};const parent = { x: 1 };Object.getPrototypeOf(obj); // obj.__proto__; obj.prototype 프로퍼티를 이용한 접근 (생성자 함수) Q8. 위와 같이, [[Prototype]] 객체에 접근할 수 있는 방법이 다양한 이유는 무엇인가요?모든 객체가 __proto__ 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다.(ex. 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 경우) (Object.create 메서드는 프로토타입 체인의 종점에 위치하는 객체를 생성) → 프로토타입 체인의 종점에 위치하는 객체는 Object.prototype의 빌트인 메서드 사용 불가 12345const obj = Object.create(null);// Object.create(null)로 객체를 만들면 __proto__ getter와 setter를 상속받지 않는다.consoe.log(obj.__proto__); // undefinedconsole.log(Object.getPrototypeOf(obj)); // null 12// Object.prototype의 빌트인 메서드는 아래와 같이 간접적으로 호출하는 것이 좋다 console.log(Object.prototype.hasOwnProperty.call(obj, 'a'); 👾 짚고 넘어가기! - 정적 메서드 12345// Object.create는 정적 메서드const obj = Object.create({ name: 'Zig' });// Object.prototype.hasOwnProperty는 프로토타입 메서드obj.hasOwnProperty('name'); // false 👾 비하인드 스토리 생성자 함수의 &quot;prototype&quot; 프로퍼티는 아주 오래전부터 그 기능을 수행하고 있었다. 그런데 2012년, 표준에 Object.create가 추가되었다. Object.create를 사용하면 주어진 프로토타입을 사용해 객체를 만들 수 있긴 하지만, 프로토타입을 얻거나 설정하는것은 불가능했다. 그래서 브라우저는 비표준 접근자인 __proto__를 구현해 언제나 프로토타입을 얻거나 설정할 수 있도록 했다. 이후 2015년에 Object.setPrototypeOf와 Object.getPrototypeOf가 표준에 추가되면서 __proto__와 동일한 기능을 수행할 수 있게 되었다. 그런데 이 시점엔 __proto__가 모든 곳에 구현되어 있어서 사실상 표준(de-facto standard)이 되어버렸다. 표준의 부록 B(Annex B)에 추가되기도 하였습니다. 이 부록에 추가되면 브라우저가 아닌 환경에선 선택사항이라는것을 의미한다. Ref https://ko.javascript.info/prototype-methods#ref-271","link":"/2021/06/06/havruta-week-10/"},{"title":"하브루타 스터디 - 4주","text":"하프 스터디 4주차: 함수 with 카일 Q1. js 내의 함수는 일급 객체로 다루어진다고 하는데, 일급 객체의 특징에는 무엇이 있을까요?특정 언어의 ‘일급 객체’란 보통 다른 객체들에게 적용 가능한 연산을 모두 지원하는 객체를 말한다. 👾 JavaScript가 일급 객체인 이유 함수 할당하기 변수에 할당하기 1const func1 = function() {} 객체의 값에 할당하기 1234567const student = { name: 'zig', grade: 5, study: function() { console.log(`${this.name} is studying`); }} 함수를 호출하지 않고 변수에 할당하기 1234const add = function(a, b) { return a + b }const newAdd = add;newAdd(2, 3); // 5 함수를 다른 함수의 인자로 전달하기 12345678const test = function(func) { func(); // 파라미터로 받은 함수 호출}// test() 함수에 다른 함수를 파라미터로 넣어 호출test(function() { console.log('javascript');}); 함수 반환하기 (→ 클로저) 12345678function add(a) { return function(b) { return a + b; }}const add5 = add(5);add5(5); // 10 이름이 있는 함수를 리턴하는 것도 가능하다. 재귀함수 등 자기 자신을 참조하는 경우에는 이름이 있는 것이 편리하다. 여기에 12- 런타임(runtime) 생성이 가능하다 // new Function()으로 생성 시 (bad case) - 익명(anonymous)으로 생성이 가능하다 위 조건들까지 붙은 것이 ‘일급 함수(=일급 객체)’라고 보는 의견도 존재한다. Refhttps://soeunlee.medium.com/javascript에서-왜-함수가-1급-객체일까요-cc6bd2a9ecachttps://frontsom.tistory.com/3 Q2. 클래스의 필드 문법으로 메서드를 선언할 때, regular function 과 arrow function 중 무엇을 선호하는지, 또 그 이유를 들어볼 수 있을까요?class의 constructor에 정의된 값들은 class의 인스턴스를 생성해도, prototype chaining을 통해서 참조된다.아래와 같이 class를 작성한 후, class의 인스턴스를 생성하여 콘솔에서 확인이 가능하다. 1234567class MyClass { a = 1; // 인스턴스 객체의 프로퍼티 func1 = () =&gt; {} // 인스턴스 객체의 메소드 func2() {} // 프로토타입 객체의 메소드}const test = new MyClass(); react class의 constructor에 선언한 메소드의 경우 모두 class 인스턴스에 매핑된다. 12345678910111213class MyClass { constructor() { this.a = 1; // 인스턴스마다 생성 this.method1 = () =&gt; {}; // 인스턴스마다 생성 } method2() { } // MyClass의 prototype에 생성 (인스턴스에서 호출 시 prototype chaining을 타고 올라가 참조) method3 = () =&gt; { } // 인스턴스마다 생성}const test = new MyClass(); 이때 method3()과 같은 선언 방식은 아래와 같은 문제들이 뒤따른다. 인스턴스마다 호출되기 때문에, 성능 저하의 문제가 있다. constructor에서 super()를 통한 상속이 불가하다. 인스턴스의 메서드로만 호출되기 때문에 자식 class로 상속되지 않는다. Refhttps://levelup.gitconnected.com/arrow-function-vs-regular-function-in-javascript-b6337fb87032https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/ Q3. IIFE 는 무엇이고, 어떤 경우에 사용하면 좋을까요?JavaScript의 즉시실행함수는 정의와 동시에 즉시 실행되는 함수를 의미한다.함수 리터럴 표현식을 통해 즉시 실행함수를 정의할 수 있다. 즉시실행함수는 함수 리터럴을 ()로 감싼 뒤 바로 실행한다. ✅ ()로 묶는 이유: 함수 선언문이 아닌 표현식임을 명확히 하기 위해 1234(function () { console.log('Hello World') })(); // Hello World IIFE를 변수에 할당하면 IIFE 자체는 저장되지 않고, 함수가 실행된 결과만 저장된다. (출처 - MDN) 1234567const result = (function () { const name = &quot;Zig&quot;; return name;})();// 즉시 결과를 생성한다.result; // &quot;Zig&quot; 👾 사용 예시전역 스코프를 오염시키지 않기 위해 즉시실행함수를 사용할 수 있다. 함수를 리턴하는 클로저와 함께 private 변수를 생성하여, 해당 변수를 외부에 노출시키지 않을 수 있다. 특정 데이터를 은닉시키는 것이다. 외부 코드에서 사용되지 않는, 단 한번 호출하는 코드에서도 유용하게 사용할 수 있다. 12345678910111213// 전체에서 단 한번 실행할 코드function init() { const operate = 'init'; console.log(operate)}init();// 즉시실행함수로 아래처럼 사용 (function init() { const operate = 'init'; console.log(operate)})() 123456789const uniqueId = (function() { let count = 0; return function() { return ++count; };})();console.log(uniqueId()); // 1console.log(uniqueId()); // 2 Refhttps://velog.io/@doondoony/javascript-iifehttps://medium.com/sjk5766/iife-immediately-invoked-function-expression-정리-53ab6543b828 Q4. 함수 표현식은 왜 사용하나요?12const square = function(number) { return number * number };const x = square(4) // x = 16 🤔 함수를 문으로 선언해도 똑같이 작동하는데(아래 예시), 함수 표현식을 쓰는 이유는 무엇일까요? 12345678910111213141516const multiply1 = function(num) { return num * 2};function multiply2(num) { return num * 2;}function calculate(f, arr) { const result = []; for (let i=0; i&lt;arr.length; i++) { result[i] = f(arr[i]); } return result;}console.log(calculate(multiply1, [1,2,3])); // [2,4,6]console.log(calculate(multiply2, [1,2,3])); // [2,4,6] 화살표함수를 쓰는 표현식은 function 키워드를 생략한다는 점이 장점일 수 있다. 인자 값을 보낼 때 ‘문’보다는 ‘식’으로 보내는 게 의미론적으로 자연스럽다. hoisting 가능 여부 (위에서부터 읽어내려가는 코딩 스타일) Q5. JavaScript에서 함수의 호이스팅은 어떻게 이루어지나요? (함수의 호출 범위)👾 호이스팅이란?함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것이다. 함수의 범위는 함수가 선언된 곳이거나, 전체 프로그램 에서의 최상위 레벨(전역)에 선언된 곳이다. 함수 호이스팅은 오직 함수 선언과 함께 작동하고, 함수 표현식에서는 동작하지 않는다. 함수선언문은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다 regular function을 사용하면 호출 시점에 따른 문제가 발생하지 않는다. 12345678910111213141516171819// regular function - workingfunction higher() { lower();}higher(); // 정상 작동function lower() { // ...}// arrow function - not workingconst higher2 = () =&gt; { lower2(); } higher2(); // ReferenceError: Cannot access 'lower2' before initializationconst lower2 = () =&gt; {} 그러나 함수표현식에서는 선언과 할당의 분리가 이루어지기 때문에, 호이스팅이 이루어지지 않는다. 표현식은 ‘변수 키워드 호이스팅’에 해당되기 때문이다. 컴파일 단계에서 선언과 초기화가 모두 이루어지는 기존의 var 키워드와 달리, ES6 문법인 let, const로 선언한 변수는 코드 실행 전 컴파일 단계에서 선언만 이루어진다. 메모리 자체에 등록되지 않는 것이다. 따라서 var 키워드로 선언한 함수표현식은 TypeError와 함께 호이스팅이 실패하고, let 또는 const 키워드로 선언한 함수표현식은 RefError와 함께 호이스팅이 실패한다. 123456789const higher2 = () =&gt; { lower2(); // TypeError lower3(); // RefError }higher2(); // 호출 var lower2 = () =&gt; {} // 할당 let lower3 = () =&gt; {} // 초기화 &amp; 할당 Q6. Array 내장 메소드(map, filter 등)가 내부적으로는 고차함수를 사용한다고 하는데, 그 작동 원리가 궁금합니다!함수를 리턴하는 것 뿐 아니라, 함수를 인자로 받는 것도 고차함수의 특징에 해당한다. map, filter 등의 인자값은 모두 콜백함수이므로, 함수를 인자로 받는 고차함수에 해당한다. 12345678910Array.prototype.customMap = function(fn) { const newArr = []; for (let i = 0; i &lt; this.length; i++) { newArr.push(fn(this[i])); } return newArr;}const multiple = [1,2,3].customMap((num) =&gt; num * 2);console.log(multiple); // [2,4,6] Refhttps://poiemaweb.com/js-array-higher-order-functionhttps://velog.io/@jakeseo_me/자바스크립트-개발자라면-알아야-할-33가지-개념-22-자바스크립트-자바스크립트-고차-함수Higher-Order-Function-이해하기","link":"/2021/04/18/havruta-week-4/"},{"title":"하브루타 스터디 - 5주","text":"하프 스터디 5주차: 변수와 데이터타입 with 곤이 Q1. 원시 값과 객체가 메모리에 할당되는 과정을 이야기해봐요 선언: 메모리에서 비어있는 공간을 확보하고 그 공간의 이름을 설정하는 것할당: 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 데이터를 저장하고 그 주소를 변수 영역에 저장하는 것 원시 타입: Boolean, Null, Undefined, Number, String, Symbol → 기본형참조 타입: 배열, 함수, Date, 정규표현식, Map, WeakMap, Set, WeekSet 등 → 참조형 참조형 데이터와 기본형 데이터의 변수 할당 과정의 차이는, 참조형 데이터는 객체의 변수(프로퍼티) 영역이 별도로 존재한다는 것이다. 이때 객체 변수 영역에 값들의 주소값을 가지고 있는 것이 아니라, 프로퍼티들을 저장하기 위해 별도로 마련한 영역의 주소를 가지고 있다. 원시 타입은 변수 값의 메모리 주소를 참조하는 식별자들이 여러 개 있을 수 있기 때문에, 해당 메모리 주소의 데이터가 변경되면 사이드 이펙트가 발생할 수 있다. 따라서 값이 변하지 않는다. (불변성) 원시타입의 경우 새로 만드는 동작에 의해서만 값이 변한다. 12345678let a = 10;let b = 10;console.log(a === b); // true - 같은 식별자값을 참조한다. b = 15; // 15라는 값을 새로운 주소에 할당해서 참조하기 때문에 a의 값은 영향 받지 않는다console.log(a); // 10 - 값이 바뀌지 않는다.console.log(b); // 15 할당된 값이 같다면 같은 메모리 영역을 참조하는 원시타입과 달리,객체를 생성할 때는 항상 새로운 주소값으로 할당된다. 1234const obj1 = { a: 1 } const obj2 = { a: 1 }obj1 === obj2; // false 객체는 동적으로 내부 값이 변경될 수 있으며, 이때 내부 값 참조하는 데이터 영역의 값 자체가 바뀌게 된다. 새로운 객체가 만들어지는 것이 아니라 기존 객체 내부의 값만 바뀌는 것이다. 123456789const obj1 = { a: 1, b: 'bb'} const obj2 = obj1;obj2.a = 2; // obj1.a가 참조하는 메모리 영역의 주소와 obj2.a가 참조하는 메모리 영역의 주소는 같다.console.log(obj1.a); // 2 Refhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Managementhttps://velog.io/@yujuck/JavaScript-데이터-타입-데이터-할당의-동작원리 Q2. 자바스크립트의 콜스택과 힙에는 각각 어떤 것들이 저장될까요? 그리고 자바스크립트는 왜 힙이라는 별도의 메모리 공간을 가질까요?콜스택 JavaScript에서 함수를 실행하면 콜스택에 쌓인다. 콜스택은 메모리에서 Last-In-First-Out으로 동작하는 영역이다. 실행 중인 코드를 트래킹하는 곳으로, 메모리 힙에서 작업 수행에 필요한 것들을 찾아서 작업을 수행한다. 콜스택의 각 단계를 Stack Frame이라고 하며, 콘솔에서 확인이 가능하다 (Stack Trace) 메모리 힙 정보를 저장하는 공간 (메모리 할당이 발생하는 공간) 간단한 변수들(원시값)은 스택에 저장될 수 있지만, 배열이나 객체 등 복잡한 자료구조의 경우 메모리 힙에 저장된다. 동적으로 메모리를 할당할 때 사용한다. (원시값은 타입에 따라 정해진 크기만큼 메모리를 확보하여 저장) 변수, 함수의 저장, 호출 등의 작업이 발생하는 공간 tilde(~) 로 표시되는 객체의 프로퍼티 데이터 주소값은 힙에 저장된다. 객체의 프로퍼티들이 참조하는 원시값은 다시 콜스택에서 참조 가능하다. 🤔 메모리 힙은 왜 필요할까? 긴 생명주기를 가지는 데이터들을 저장할 수 있다. (크기가 크고, 서로 다른 코드블럭들에서 공유되는 객체들의 경우) 런타임 시 메모리의 크기를 동적으로 결정할 수 있다. 👾 메모리 누수 메모리 힙이 제대로 관리되지 않을 경우 메모리 공간의 범위를 넘어서 정보들이 저장되는 경우가 발생 전역변수가 많을 경우/ 이벤트리스너를제거하지 않은 경우/ setInterval을 계속 사용하는 경우 등 Refhttps://medium.com/@allansendagi/javascript-fundamentals-call-stack-and-memory-heap-401eb8713204https://soldonii.tistory.com/53 Q3. 자바스크립트에서 호이스팅은 왜 일어나는 걸까요? 호이스팅: 함수(스코프) 안에 있는 선언들을 모두 끌어올려서 해당 함수(스코프) 유효 범위의 최상단에 선언하는 것 JavaScript 함수는 실행 전 함수 안에 필요한 변수값을 모두 모아 유효 범위의 최상단에 선언한다 JavaScript Parser가 함수 실행 전 해당 함수를 한번 훑어, 함수 안에 존재하는 변수/함수 선언 정보를 기억하고 있다가 필요 시 실행시킨다 실제 메모리에는 변화가 없으며, JavaScript Parser 내부적으로 끌어올려 처리한다. 유효 범위는 함수 블록 {} 내부 🤔 왜 발생할까?JavaScript 인터프리터가 소스코드의 실행을 2단계로 나누어 실행하기 때문이다. 변수와 함수 선언문들을 찾아 실행 컨텍스트의 렉시컬 환경에 등록한다.(이때 아래쪽에 선언된 변수가 끌어올려진다.) 실제 소스코드를 첫줄부터 차례로 실행하며 값을 할당하고 참조한다. Refhttps://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.htmlhttps://stackoverflow.com/questions/15005098/why-does-javascript-hoist-variables Q4. var, let, const의 호이스팅은 어떠한 차이가 있을까요? 그리고 TDZ는 무엇일까요?var에서만 호이스팅이 일어나며, let/const에서는 호이스팅이 발생하지 않는다. 12345console.log(name1); // undefinedconsole.log(name2); // ReferenceErrorvar name1; // 선언, 초기화 (기본값 undefined)let name2; // 선언 이때 선언만 호이스팅되며, 할당은 호이스팅되지 않는다.최초 선언 시 초기화한 경우에도 선언과 할당으로 분리하여 호이스팅한다. 12345// 선언부만 호이스팅되기 때문에, 초기값은 undefined이다.console.log(name1); // undefinedvar name1 = 'zig';console.log(name1); // zig 위 코드는 아래와 같이 실행된다. 12345var name1; // 변수 선언부만 끌어올려짐console.log(name1); // undefinedvar name1 = 'zig';console.log(name1); // zig TDZ (Temporal Dead Zone; 일시적 사각지대) 초기화되지 않은 변수가 있는 곳이다. let, const도 호이스팅되지만, TDZ에 영향을 받아 ReferenceError가 발생한다 변수가 초기화되는 순간 TDZ에서 빠져나온다. 다음은 TDZ에 갇힌 변수를 참조하려고 하는 상황이다. 1234567let name1;{ // name1이 TDZ에 영향을 받는다. console.log(name1); // 코드블럭 내의 lexical scope에서 가장 가까운 name1를 참조 한다. let name1 = 'zag'; // name1이 초기화되어 TDZ를 탈출한다.}// ReferenceError: Cannot access 'name1' before initialization 아래 경우는 어떨까? 12345let name2;{ console.log(name2); // undefined name2 = 'zig';} 콘솔을 찍는 시점에서 name2는 코드블럭 내부가 아닌 전역 스코프의 name2를 참조하기 때문에,아직 값이 할당되지 않은 상태의 name2(undefined)가 찍힌다. 한번 이것저것 테스트! 12345678let name3;{ name3 = &quot;kim&quot;; console.log(name3); // kim name3 = 'zig';}console.log(name3); // zig 명시적으로 선언한 블록({})이 아닌 전역에 변수를 등록하면,initialization(초기화) 에러가 아닌 not defined(선언) 에러가 발생한다. 123console.log(name4);let name4; // ReferenceError: name4 is not defined Refhttps://velog.io/@wrfg12/ES6-Hoisting-Temporal-Dead-ZoneTDZhttps://velog.io/@open_h/Hoisting-and-TDZ Q5-1. var, let, const 각각의 스코프는 어떻게 정의되나요?var 함수 레벨 스코프 (함수의 코드 블록만을 스코프로 인정) 전역 함수 외부에서 생성한 변수는 모두 전역 변수 (전역 변수를 남발할 가능성) for문의 변수 선언문에서 선언한 변수를 for문의 코드블록 외부에서 참조 가능 let 블록 레벨 스코프 (대부분의 프로그래밍 언어도 마찬가지) 모든 코드 블록 (함수, if문, for문, while문, try/catch문 등) 내에서 선언한 변수는 코드블록 내에서만 유효하며 코드블록 외부에서는 참조할 수 없다. 즉 코드블록 내부에서 선언한 변수는 지역 변수이다. 👾 var를 지양해야 하는 이유 1234567891011// 어떻게 될까요? for (let i = 0; i &lt; 5; i++){ console.log(i)}console.log(i)// 어떻게 될까요? for (var i = 0; i &lt; 5; i++){ console.log(i)}console.log(i) Refhttps://poiemaweb.com/es6-block-scopehttps://soldonii.tistory.com/63?category=862198https://discuss.codecademy.com/t/whats-wrong-with-var/224975/5 Q5-2. var, let, const 각 경우 변수는 언제 메모리에 할당되나요?변수선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 변수 선언의 과정은 3단계로 이루어진다 선언: 변수 객체에 변수를 등록. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다. 초기화: 변수 객체에 등록된 변수를 메모리에 할당한다. 이때 변수는 undefined로 초기화된다. 할당: undefined로 초기화된 변수에 실제값을 할당한다. var 선언 단계와 초기화(undefined를 할당) 단계가 한번에 이루어진다 스코프 체인이 가리키는 변수 객체에 변수가 등록되고 변수는 undefined로 초기화된다. let, const 선언, 초기화 단계가 분리 스코프에 변수를 등록(선언)하지만 초기화는 변수 선언문에 도달했을 때 이루어진다. 초기화 이전에 변수에 접근하려고 하면 변수가 아직 초기화되지 않았기 때문에 Reference Error가 발생한다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 TDZ라고 한다. Refhttps://poiemaweb.com/es6-block-scopehttps://poiemaweb.com/js-execution-context Q6. 원시 타입과 참조 타입이 복사되는 방식을 설명해주세요 원시 타입(기본형): 값이 담긴 주소값을 바로 복제한다.참조 타입: 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다. 어떤 데이터 타입이든 변수에 할당하기 위해서는 주소값을 복사해야 하기 때문에, 엄밀히 따지면 JavaScript의 모든 데이터 타입은 참조형 데이터일 수밖에 없다. 이때 기본형은 주소값을 복사하는 과정이 한번만 이루어지고, 참조형은 한 단계를 더 거친다. 1234567// a, b 모두 같은 데이터 영역의 주소값을 참조한다let a = 10;let b = a;// obj1, obj2 모두 같은 데이터 영역의 주소값을 참조한다let obj1 = { c: 10, d: 'zig' }let obj2 = obj1; 데이터 변경 시 기본형은 데이터 영역에서 참조하는 주소값이 달라져 원본에 영향을 주지 않지만,객체의 경우 객체 자체가 가리키는 값이 달라지지 않으며, 내부 프로퍼티의 값이 가리키는 주소가 변경되어 원본 객체의 프로퍼티가 참조하는 값도 함께 바뀐다. 12345678910111213141516let a = 10;let b = a;let obj1 = { c: 10, d: 'zig' }let obj2 = obj1;// 데이터 영역에서 참조하는 주소값이 달라진다b = 15; // 데이터 영역에서 참조하는 주소값이 달라지지 않으며,// 새로운 값(20)을 c 프로퍼티가 저장되어 있는 위치에 다시 저장한다obj2.c = 20;console.log(a); // 10console.log(b); // 15console.log(obj1); // { c: 20, d: 'zig' }console.log(obj2); // { c: 20, d: 'zig' } 아예 새로운 객체로 대체할 경우 데이터 영역에서 참조하는 주소값이 달라진다. 1234567let obj1 = { c: 10, d: 'zig' }let obj2 = obj1;obj2 = { c: 20, d: 'zag' }console.log(obj1); // { c: 10, d: 'zig' }console.log(obj2); // { c: 20, d: 'zag' } Ref https://velog.io/@yujuck/JavaScript-데이터-타입-데이터-할당의-동작원리#변수-복사 Q7. 다음의 두 코드는 어떤 차이가 있나요?12345// 1번const str1 = 'abc';// 2번const str2 = new String('abc'); 원시 래퍼 객체: String, Number, Boolean, Symbol 원시 래퍼 객체는 원시값을 감싸 객체화시켜주기 위해 사용된다. 아래 예제는, String 타입의 메소드 toUpperCase의 호출을 위해 string 자료형을 래퍼 객체로 임시 변환한다. 1'zig'.toUpperCase(); // ZIG 래퍼 객체의 valueOf() 메서드는 원시값을 반환한다. 12const str = new String('zig');str.valueOf(); // zig JavaScript는 String 오브젝트와 원형의 문자열을 다르게 취급한다. 12345new String('zig') === new String('zig'); // falsenew String('zig') == new String('zig'); // false'zig' == 'zig'; // true'zig' === 'zig'; // true 12345678typeof new String('zig'); // 'object';new String('zig') instanceof String; // truetypeof 'zig'; // 'string';'zig' instanceof String; // falsenew String('zig') == 'zig'; // truenew String('zig') === 'zig'; // false Refhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String#문자열_원형과_string_객체의_차이https://includestdio.tistory.com/26 Q8. null과 undefined에는 어떤 차이가 있나요?null 명시적으로 값이 비어있음을 나타낸다. null의 type은 object이다. 12345console.log(typeof null); // object// 😮 왜일까? let a = null;a.__proto__; // Uncaught TypeError: Cannot read property '__proto__' of null undefined데이터 타입이자 값으로 평가된다. 1console.log(typeof undefined); // undefined 값이 할당되지 않은 변수의 기본값으로 사용된다. 12let something;console.log(something); //undefined 😮 이건 뭘까? 12345undefined = 'zig'; // 'zig'null = 'zig'; // Ref Errorlet undefined = 1;// Uncaught SyntaxError: Identifier 'undefined' has already been declared","link":"/2021/04/25/havruta-week-5/"},{"title":"하브루타 스터디 - 6주","text":"하프 스터디 6주차: this with 디토 Q1. apply(), call() 메소드는 언제, 어떻게 사용할 수 있을까요? bind와의 차이점은 무엇인가요?관련 문제 12345678const person = { name: &quot;zig&quot; };function sayHi(age) { console.log(`${this.name} is ${age}`);}sayHi.call(person, 17); // zig is 17sayHi.bind(person, 17); // function apply()와 call() 모두 this 키워드를 참조하고자 하는 객체와 바인딩할 수 있다. call()은 인자로 인수 목록을 받지만, 최근에는 rest parameter로 대체할 수 있다.예전에는 유사배열을 배열로 변환시키기 위해 사용되었다. 첫 번째 인자로 바인딩할 this를 받고, 두 번째 인자로(선택) 함수를 호출할 때 필요한 인자를 받는다. 123456function func(){ const args = Array.prototype.slice.call(arguments); console.log(args); // [1, 2, 3]} func(1,2,3); ES6의 rest parameter로 대체할 수 있다. 12345function func(...args) { // rest parameter console.log(args); // [1, 2, 3]} func(1,2,3); apply() 역시 call과 같다. 하지만 두 번째 인자로 배열을 넘긴다는 점이 다르다. 배열로 넘기게 되면 배열 자체가 들어가지 않고, 풀어서 들어간다. 123const numbers= [1, 2, 3];Math.min.apply(null, numbers); // 1Math.min(1, 2, 3); // 1 최근에는 역시 spread 문법으로 대체할 수 있다. 1Math.min(...numbers); // 1 bind()는 함수의 복사본 을 리턴하지만, 즉시 실행되지 않는 ‘바인딩 콘텍스트’다. call()과 apply()는 함수를 즉히 호출하지만 bind()는 함수를 호출하지 않고 정보를 저장해둔다. 클로저 함수처럼 사용할 수 있는 것이다. 123456function func(...args) { console.log(args); // [1, 2, 3, 4]} const bindFunc = func.bind(null, 1, 2, 3); // 1, 2, 3을 인수로 저장bindFunc(4); // 호출 시 할당한 인수를 포함해서 함수를 실행 Q2. 아래 문제를 같이 풀어보아요.1234567891011121314function hello() { console.log(this.name)}var obj = { name: &quot;ditto&quot;, hello: hello,}helloFn = obj.helloname = &quot;global&quot;helloFn() // 'ditto'일까 'global'일까? obj 객체의 프로퍼티에 hello() 함수를 할당했지만, helloFn에 레퍼런스를 저장하는 순간 이것은 일반 함수가 된다. this는 함수 호출 단계에서 동적으로 결정된다. 따라서 일반함수 helloFn()을 호출하면 기본 바인딩 규칙을 따르게 된다. helloFn()을 호출한 시점에서는 this가 window에 바인딩된다. 함수를 실행하는 순간 글로벌 컨택스트가 this에 바인딩되고 this.name은 obj.name이 아닌 전역객체(window)의 name인 ‘global’를 가리키게 되는 것이다. 아래와 같이 setTimeout 등의 함수에 콜백으로 넘겨주는 경우도 마찬가지다. 123456789101112function hello() { console.log(this.name)}var obj = { name: &quot;ditto&quot;, hello: hello,}setTimeout(obj.hello, 1000) name = &quot;global&quot; 1초 뒤 setTimeout의 콜백 호출 시 obj.hello는 obj에 대한 바인딩을 잃어버린 상태다. ‘global’을 출력한다. Ref https://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html Q3. new 바인딩은 어떤 역할을 할까요?1234567891011function Person(firstName, lastName) { this.firstName = firstName; this.lastName = lastName;}const zig = new Person(&quot;Zig&quot;, &quot;Song&quot;);const ditto = Person(&quot;Ditto&quot;, &quot;Cheon&quot;);console.log(zig); // Person { firstName: &quot;Zig&quot;, lastName: &quot;Song&quot; } console.log(ditto); // undefined -&gt; 왜 undefined일까요? console.log(firstName); // Ditto 😮 생성자 함수가 가지고 있는 new 연산자를 사용하면 인스턴스를 생성할 수 있다. 이 경우 인스턴스에 this가 바인딩된다. new 연산자를 사용하는 경우 부모가 가진 prototype을 인스턴스의 __proto__에 그대로 할당하게 되기 때문에 부모가 가진 프로퍼티를 자신의 것처럼 사용할 수 있게 된다. ditto는 일반 함수로서 호출되었기 때문에 객체를 암묵적으로 생성하여 반환하지 않는다. 아래와 같이 new.target을 이용하여, 생성자 함수의 인스턴스가 생성되었는지 여부를 판단할 수 있다. 123456789101112function Person(firstName, lastName) { console.log(new.target) if (!new.target) { // return; return new Person(firstName, lastName); } this.firstName = firstName; this.lastName = lastName;}const zig = Person('Zig', 'Song'); 👩‍🏫 잠깐 정리! 👾 일반 함수를 호출하면 this는 전역객체에 바인딩되지만 new 연산자와 함께 생성자 함수를 호출하면 this는 생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩된다.👾 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다. Q4. React class 컴포넌트의 메소드에 this 바인딩이 필요한 이유는 무엇일까요?JSX에서 반환하는 컴포넌트의 이벤트 핸들러 콜백으로 넘겨주기 위해서는 해당 메소드가 현재 컴포넌트에 바인딩되었다는 것을 명확히 하기 위해 JSX 콜백 안에서 this의 사용에 주의해야 한다. JavaScript에서 클래스 메서드는 기본적으로 바인딩되어 있지 않다. 1234567891011121314151617181920212223class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // 콜백에서 `this`가 작동하려면 아래와 같이 바인딩 해주어야 한다. this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(state =&gt; ({ isToggleOn: !state.isToggleOn })); } render() { return ( &lt;button onClick={this.handleClick}&gt; {this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt; ); }} render() 내에서 this.handleClick을 바인딩하지 않고 onClick에 전달하였다면, 함수가 실제 호출될 때 this는 button이 아닌 undefined가 된다. 따라서 이벤트 핸들러를 넘겨주는 상황에서는 this 바인딩이 필요하다. 👾 이벤트핸들러에 () ⇒ method()의 형태로 넘겨주는 것은, 매번 함수를 새로 만드는 것이기 때문에 좋지 않다 또 자식 컴포넌트에 props로 메서드를 넘겨줄 때, this 바인딩이 필요하다. 12345678910111213141516171819202122232425class ParentComponent extends React.Component { // ... handleClick() { this.setState(state =&gt; ({ count: state.count + 1})); } render() { return ( &lt;ChildComponent onCounterClick={this.handleClick} /&gt; ) }}class ChildComponent extends React.Component { constructor() { super(props); } render() { return ( &lt;button onClick={props.onCounterClick}&gt;클릭&lt;/button&gt; ) }} this 바인딩을 하지 않으면 ChildComponent의 props.onCounterClick에서 this를 찾지 못한다.props로 넘겨주는 handleClick에서 호출하는 this.setState의 this를 찾을 수 없어 오류가 발생하는 것이다. Ref https://ko.reactjs.org/docs/handling-events.html Q5. 아래의 결과와 그 이유를 설명해주세요.12345678910111213141516171819202122232425262728293031323334353637383940414243444546const obj = { result1() { console.log(this); // obj 👉 호출한 객체 context에 바인딩 }, result2: () =&gt; { console.log(this); // window 👉 화살표 함수는 상위 스코프에 바인딩 }, inner: { result3() { console.log(this); // obj.inner 👉 호출한 객체 context에 바인딩 const innerInner1 = () =&gt; { console.log(this); // obj.inner 👉 화살표 함수는 상위 스코프에 바인딩 }; function innerInner2() { console.log(this); // window 👉 객체 메소드의 내부함수(중첩함수)일 경우 this는 전역객체에 바인딩 } innerInner1(); innerInner2(); }, result4: () =&gt; { // 실행 컨텍스트는 window console.log(this); // window 👉 result4라는 화살표 함수의 상위 스코프는 전역 const innerInner1 = () =&gt; { console.log(this); // window 👉 result4라는 화살표 함수의 상위 스코프는 전역 }; function innerInner2() { console.log(this); // window 👉 객체 메소드의 내부함수(중첩함수)일 경우 this는 전역객체에 바인딩 } innerInner1(); innerInner2(); }, },};obj.result1(); // 1번obj.result2(); // 2번obj.inner.result3(); // 3번obj.inner.result4(); // 4번 화살표 함수가 상위 scope (lexical scope)에 바인딩된다는 것은, 호출한 실행 컨텍스트를 타고 올라가는 것이다. 이때 객체는 실행 컨텍스트가 되지 못하며, 함수 호출만이 실행 컨텍스트에 해당한다. 실행 컨텍스트를 타고 window까지 올라가면서 중간에 this 바인딩할 곳을 만나면 그곳에서 멈추게 된다. JavaScript의 호출 스택을 생각하면 된다. Q6. 위의 경우에서 this가 원하는 대상을 바라보지 않는 경우, 어떻게 원하는 대상을 바라보게 할 수 있을까요? this를 원하는 대상에 바인딩 할 수 있는 메서드에 대해 설명해주세요!call(), apply(), bind()를 사용하는 문제 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const obj = { result1() { console.log(this); }, result2: () =&gt; { console.log(this); }, inner: { result3() { console.log(this); const innerInner1 = () =&gt; { console.log(this); }; function innerInner2() { console.log(this); } innerInner1.apply(obj); // obj.inner 👉 화살표 함수의 명시적 바인딩은 소용 X innerInner2.apply(obj); // obj innerInner1.apply(obj.inner); // obj.inner 👉 화살표 함수의 명시적 바인딩은 소용 X innerInner2.apply(obj.inner); // obj.inner innerInner1.apply(this); // obj.inner 👉 화살표 함수의 명시적 바인딩은 소용 X innerInner2.apply(this); // obj.inner }, result4: () =&gt; { console.log(this); const innerInner1 = () =&gt; { console.log(this); }; function innerInner2() { console.log(this); } innerInner1.apply(obj); // window 👉 화살표 함수의 명시적 바인딩은 소용 X innerInner2.apply(obj); // obj innerInner1.apply(obj.inner); // window 👉 화살표 함수의 명시적 바인딩은 소용 X innerInner2.apply(obj.inner); // obj.inner innerInner1.apply(this); // window 👉 화살표 함수의 명시적 바인딩은 소용 X innerInner2.apply(this); // window 👉 result4가 화살표 함수기 때문에 전역객체에 바인딩된 상태 }, },};obj.inner.result3();obj.inner.result4(); 👾 화살표 함수를 call(), bind(), apply()를 사용해 호출할 때 this의 값을 정해주더라도 무시한다. (언제나 상위 스코프의 this 바인딩 참조) 사용할 매개변수를 정해주는 건 문제 없지만, 첫 번째 매개변수(thisArg)는 null을 지정해야 한다. Q7. 일반 모드와 strict 모드에서의 this 바인딩은 어떤 차이점이 있는지 설명해주세요.1234567891011function f1() { return this;}function f2() { &quot;use strict&quot;; return this; }f1(); // windowf2(); // undefined strict 모드에서 this는 정의되지 않은 경우 window가 아닌 undefined가 된다.명시적 바인딩을 해주면 비엄격 모드일 때와 동일하게 바인딩된다. 12345678&quot;use strict&quot;;function fun() { return this; }console.assert(fun() === undefined); console.assert(fun.call(2) === 2); console.assert(fun.apply(null) === null);console.assert(fun.call(undefined) === undefined);console.assert(fun.bind(true)() === true); Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode Q8. this는 언제 어떻게 결정되는 것인지 설명해주세요.함수 호출 방식에 의해 this가 바인딩할 객체가 동적으로 결정된다. 1. 함수 호출 기본적으로 일반적인 함수 호출 시 this는 전역객체(window)에 바인딩 (브라우저 환경) 전역 함수, 내부 함수, 객체 메서드의 내부 함수, 콜백 함수 (setTimeout 등) 2. 메서드 호출 해당 메서드를 호출한 객체에 바인딩 프로토타입 객체에도 동일하게 적용 3. 생성자 함수 호출 this는 new 연산자에 의해 새롭게 만들어진 객체에 바인딩 4. apply/call/bind 호출 → 명시적 바인딩 사용자가 명시적으로 this에 바인딩될 객체를 지정하는 방법 Function.prototype에 정의되어 있다 (Function.prototype.call, …)","link":"/2021/05/02/havruta-week-6/"},{"title":"하브루타 스터디 - 8주","text":"하프 스터디 8주차: 에러 핸들링 with 썬 Q1. 클라이언트에서 마주하는 에러 종류에 따라 예외 처리를 어떻게 해주면 좋을까요? 같이 이야기해보아요1. 예상 X 해결 방법 O 네트워크 에러 일시적인 에러 표시, 다시 시도할 가이드 제공 👾 snackbar나 toast같은 noti를 사용하는 건 어떨까? 🌞 snackbar는 정상작동의 경우에만 사용 네트워크 에러 (ex. 상품 목록을 불러오는 데 실패할 경우) 보여줄 상품 목록이 없으므로 페이지 전체에 에러 표시하는 게 좋지 않을까? snackbar는 사라져 버리니까 사용자가 이유를 모를 수도 있음 사용자에게 동작을 요청할 만한 에러 2.예상 X 해결 방법 X 개발자 제어권 밖 고객 센터 문의 경로 제공 Sentry 등 3. 예상 O 해결 방법 X 보안 에러 사용자가 고의적으로 비정상적인 접근 CORS, XSS → 보안팀과 협력? 🌞 input 창에 ‘?’ 등 query에 사용되는 특문 사용 금지 innerHTML을 지양해야 하는 이유 cf) React dangerouslySetInnerHTML 4. 예상 O 해결 방법 O 400대 에러 비즈니스 로직 적절한 가이드, 별도 페이지 👾 권한이 없는 사용자일 때 에러 처리 어떻게? 🌞 토큰이 유효하지 않으면 login page로 redirect하는 건 사용자 입장에서 영문도 모른 채 쫓겨나는 기분 (ex. 우테코 LMS) session 만료되기 전에 (ex. 은행 페이지) 알려주는 방법 👾 수강신청 페이지! 👾 form input validation 어떻게? 🌞 이름 제한 또는 메시지 띄우는 방식 사용자 행동을 너무 강하게 제한하면, 사용자 경험이 안 좋아질 수도 있는 문제 이유를 알려주는 정도! ex) payments에서 이름 입력 시, 한글 이름이 안 쳐지는 경우! 에러 전파를 막기 위한 장치 → 👾 Error Boundary에 대한 생각? Jbee’s AsyncBoundary 🌞 여러 에러가 공존하는 경우 에러 난 부분에서만 처리하는 건 좋은 것 같음 fb 댓글창 버그의 경우 하던 동작이 날라가버리지 않기 위해 → 방지용으로 바운더리 설정 Ref https://jbee.io/react/error-declarative-handling-2/ Q2. Promise의 then~catch 체이닝에서 잡는 에러와, async-await 구문의 try~catch에서 잡는 에러는 어떤 차이가 있을까요?12345678910111213141516171819202122232425const makeRequest = () =&gt; { try { getJSON() .then(result =&gt; { // this parse may fail const data = JSON.parse(result) console.log(data) }) .ca tch((err) =&gt; { console.log(err) }) } catch (err) { console.log(err) }}const makeRequest = async () =&gt; { try { // this parse may fail const data = JSON.parse(await getJSON()) console.log(data) } catch (err) { console.log(err) }} → Promise의 then chaining 안에서 발생한 JSON.parse에러는 try~catch 문에서 잡히지 않는다. 🌞 400 error의 경우 catch에서 잡히지 않는다→ response.ok로 한번 더 잡아줌 + 👾 async-await에서 try-catch를 쓰는 게 무의미하다? (참고) → 최초로 fetch를 해오고, 다음 함수에서 JSON.parse하고, 다음 함수에서 사용해줄 때 중간에서 한 번 더 try~catch로 묶어줄 필요가 없다. 어차피 상위에서 내려오기 때문에 Error catch가 가능하다. Ref https://medium.com/@constell99/자바스크립트의-async-await-가-promises를-사라지게-만들-수-있는-6가지-이유-c5fe0add656c Q3. 장바구니 미션에서 redux를 사용하며 에러처리를 어떻게 했는지 함께 이야기해 봐요!12345678910111213141516171819202122// action creatorexport const getCartItemsRequest = () =&gt; async (dispatch: Dispatch&lt;GetCartItemsAction&gt;) =&gt; { dispatch({ type: GET_CART_ITEMS_REQUEST }); try { const response = await api.get('customers/zigsong/carts'); const cartItems = snakeToCamel(response.data); dispatch({ type: GET_CART_ITEMS_SUCCESS, cartItems }); } catch (error) { dispatch({ type: GET_CART_ITEMS_FAILURE, error }); }};// 사용처dispatch(addCartItemRequest(product)) .then(() =&gt; { enqueueSnackbar(MESSAGE.ADDED_CART_ITEM_SUCCESS); }) .catch((error: Error) =&gt; { enqueueSnackbar(error.message); }); Q4. ErrorBoundary를 사용해보거나, 고려해본 적이 있나요?Ref https://ko.reactjs.org/docs/error-boundaries.html Q5. finally를 사용해본 경험이 있나요? 어떤 상황에서 사용하면 좋을까요? 프로그램을 종료시키는 상황 Java에서는 파일을 열고 닫는 상황에서 사용 (IO) 파일을 열고 try 구문에서 제대로 읽었던, 파일을 썼던 상관 없이 finally에서는 닫아줘야 함 요청을 성공하든, 실패하든 loading 상태를 바꿔주기 위해 사용 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally Q6. 아래와 같은 리뷰를 받는다면 어떤 식으로 반영하실 건가요? 403, 500 과 같은 공통적으로 처리 할 수 있는 에러들은 미들웨어 같은 역할의 레이어에서 처리하도록 하여 매 함수마다 중복되는 코드를 제거 할 수 있습니다. axios 같은 라이브러리는 그런 기능을 지원하지만 fetch API 에는 그런 기능이 없기 때문에 별도로 만들어서 쓰거나 다른 라이브러리를 쓰거나 해야 합니다. React Query 예시코드 비동기 요청의 데이터 무결함에 대한 책임을 개발자가 아니라 React 앱 자체가 책임지게 하는 라이브러리 axios interceptor 링크 123456789101112131415161718axios.interceptors.response.use( response =&gt; { return response; }, error =&gt; { if (error.response.status === '400') { // 에러 핸들링 } return Promise.reject(err); },);const api = axios.create({ baseURL: 'https://shopping-cart.techcourse.co.kr/api/',});// 컴포넌트api.get('').then(() =&gt; {}); 깃헙 링크 🌞 500 에러의 경우 유용하게 사용할 수 있을 것 같다! 공통적으로 처리될 수 있는 에러 Q7. 지금까지 미션을 진행하며 가장 마음에 들었던 에러처리 사례를 하나 소개해주세요! 클라이언트단 에러 javascript-subway 미션의 setCustomValidity12345678910111213setInputValidity() { const validityState = this.$stationNameInput.validity; if (validityState.valueMissing) { this.$stationNameInput.setCustomValidity('역 이름을 입력해 주세요.🙀'); } else if (validityState.tooShort) { this.$stationNameInput.setCustomValidity('2글자 이상 입력해 주세요.👾'); } else if (validityState.patternMismatch) { this.$stationNameInput.setCustomValidity('공백, 특수문자를 제외한 한글을 입력해 주세요.🤓'); } else { this.$stationNameInput.setCustomValidity(''); }} 비동기 에러 처리 shoppingcart 미션에서의 리덕스 에러 핸들링 (dispatch~then chaining) 🌞 굳이 try~catch로 에러를 중간에서 한번 더 던져줄 필요도 없는 것 같다 (2번 질문의 링크 참조) 👾reponse.ok 도 잘 사용하기!","link":"/2021/05/23/havruta-week-8/"},{"title":"하브루타 스터디 - 9주","text":"하프 스터디 9주차: 브라우저 렌더링 with 하루 Q1. 브라우저의 Reflow, Repaint 과정을 줄일 수 있는 방법은 무엇이 있을까요? 사용하지 않는 노드에는 visibilty: invisible 보다 display: none을 사용하기 Reflow, Repaint 가 발생하는 속성 사용 피하기 영향을 주는 노드 줄이기 position: absolute 또는 fixed를 사용하면 reflow 연산 과정에 포함되지 않는다. 프레임 줄이기 Refhttps://boxfoxs.tistory.com/408https://csstriggers.com/ Q2. 브라우저 렌더 트리의 구성 요소 중 화면에 표현되지 않는 요소는 무엇이 있을까요? display: none 속성이 설정된 노드는 화면에 어떠한 공간도 차지하지 않기 때문에 Render Tree를 만드는 과정에서 제외된다. visibility: invisible 은 display: none과 비슷하게 동작하지만, 공간은 차지하고 요소가 보이지 않게만 하기 때문에 Render Tree에 포함된다. DOM과 CSSOM을 합쳐서 실제로 화면에 표현되는 것들로만 구성한 것이 Render Tree이다. opacity, visibility 등의 속성은 Render Tree에 포함되어 있어도 보이지 않지만, 화면에 차지되고 있기 때문에 다른 요소들에 영향을 받는다. 렌더 트리의 모든 것은 화면에 표현된다 DOM, CSSOM에 있는데 render tree에 안 들어가는 것들 script, meta 태그 등 display: none인 요소들➡️ html 문서에 있어도, 렌더 트리에는 들어가지 않는다! Q3. 최신 브라우저의 합성(compositing)이란 무엇일까요?합성은 웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화하고 컴포지터 스레드(compositor thread)라고 하는 별도의 스레드에서 웹 페이지로 합성하는 기술이다. 합성의 이점은 메인 스레드와 별개로 작동할 수 있다는 점이다. 컴포지터 스레드는 JavaScript 실행이나 스타일 계산을 기다리지 않아도 된다. 이것이 합성만 하는 애니메이션이 성능상 가장 부드럽다고 보는 이유이다. 크롬 개발자도구의 Layers 탭에 들어가보면 홈페이지가 어떠한 계층으로 이루어져 있는지 알 수 있다. Layout 과정을 거쳐 화면에 UI를 화면에 표현하기 위한 계산이 끝나면 Paint 과정을 거친다. Layout 과정에서 Render Layer가 2개 이상 생성되면 각각의 Layer를 Painting 한 뒤 하나의 이미지로 Composite하는 과정을 추가로 거쳐 브라우저에 표현한다. 페이지의 여러 부분이 잠재적으로 여러 레이어로 그려졌기 때문에 페이지가 정확히 렌더링되려면 정확한 순서로 화면에 그려야 한다. 실수로 한 요소가 다른 요소 위에 잘못 나타날 수 있기 때문에 이는 다른 요소와 겹치는 요소가 있는 경우에 특히 중요하다. (브라우저가 요소 순서 그대로만 화면을 그려내면 z-index가 적용되지 않는 문제) JS/CSS → 스타일 → 페인트 → 합성 Refhttps://d2.naver.com/helloworld/5237120https://cresumerjang.github.io/2019/06/24/critical-rendering-path/ Q4. 브라우저 렌더링 중 레이아웃(layout, reflow) 과정이 모두 일어나는 경우는 어떤 경우가 있을까요? 이 과정은 왜 주의해야 할까요?레이아웃이 발생하면 전체 픽셀을 다시 계산해야 하므로 부하가 크다.반면 리페인트는 이미 계산된 픽셀값을 이용해 화면을 그리기 때문에 레이아웃에 비해 부하가 작다. 요소에 기하학적인 영향을 주는 CSS 속성값 변경 CSS 속성값 : height, width, left, top, font-size, line-height 등 요소에 기하적인 영향을 주지 않는 CSS 속성값 변경 CSS 속성값 : background-color, color, visibility, text-decoration 등 🤔 border-bottom: style, color, width가 합쳐진 것 💙 border를 미리 1px solid transparent로 해 놓는 방안 고려! Q5. 우리가 만든 앱에서 초기 렌더링 속도를 줄이기 위해서는 어떤 점을 고려해볼 수 있을까요?https://ui.toast.com/fe-guide/ko_PERFORMANCEhttps://github.com/365kim/web_study/blob/6be90b8a44de24207c7d9354d81098c89dc27554/1_self_study_frontend/tutorial__css.md#3-1-이미지 Q6. 렌더링에 대해 공부하며 다음 용어를 처음 접했는데요. 이런 지표를 관리하는 것도 프론트엔드 엔지니어로서의 역할일까요? 그리고 관리가 정말 필요하다면 어떻게 관리하면 좋을까요?TTFB: Time to First Byte (첫 번째 바이트까지의 시간) 링크를 클릭한 후 처음으로 들어오는 콘텐츠 비트 사이의 시간 HTTP 요청에 걸리는 시간 + 서버의 요청 처리 시간 + 서버에서 클라이언트까지의 응답 시간 TTFB 속도는 서버의 프로세스와 연관되어 있습니다. 최적화 방법 호스팅 업체 변경 CDN 사용 서버 코드 경량화 FP: First Paint 픽셀이 처음으로 사용자에게 표시되는 시점 흰 화면에서 화면에 무언가가 처음으로 그려지기 시작하는 순간 FCP: First Contentful Paint 요청 콘텐츠(기사 본문 등)가 표시되는 시점 텍스트나 이미지가 출력되기 시작하는 순간 이 시점은 사용자가 이 웹 사이트가 실제로 동작한다고 인식하도록 해주기 때문에 중요. (사용자 이탈률) 최적화 방법 데이터 압축 HTTP/2 사용 리로드 할 필요 없는 콘텐츠를 캐싱 코드 경량화와 코드 스플릿팅(splitting) 라이브러리 정리 렌더링을 block 하는 리소스 제거 CSS minify 사용하지 않는 CSS 제거 FMP: First Meaningful Paint 사용자에게 의미 있는 콘텐츠가 그려지기 시작하는 첫 순간이다. 콘텐츠를 노출하는데 필요한 CSS, 자바스크립트 로드가 시작되고 스타일이 적용되어 주요 콘텐츠를 읽을 수 있다. 로딩이 끝날 때까지 흰 화면 대신 의미 있는 먼저 보여주어 사용자에게 긍정적인 인상을 줄 수 있다. 사용자 기준에서 성능을 좋게 하기 위해서 FMP를 앞당겨야 하고, 위에서 설명한 주요 렌더링 경로를 최적화하여 해결할 수 있다. 사용자는 이 시점에서 페이지가 완전히 로드가 되었다고 인식 최적화 방법 이미지 최적화 사진이 많은 웹 페이지일 때는 LazyLoading (예: Twitter, Instagram 등 스크롤을 내리면 추가 페이지 로딩) TTI: Time To Interactive 페이지가 상호작용 가능하게 될 때까지의 시간 (이벤트 발생 등). 자바스크립트의 초기 실행이 완료되어서 사용자가 직접 행동을 취할 수 있는 순간이다. 최적화 방법 FCP와 FMP를 최적화 JS minify Ref https://front-end.me/web/web-site-optimization/","link":"/2021/05/30/havruta-week-9/"},{"title":"legacy-peer-deps 너 뭐 돼?","text":"npm 트러블슈팅 해결기 프로젝트에서 패키지를 하나 업데이트하려고 시도했던 일이 시발점이 되어 무려 주말 포함 일주일을 나를 괴롭혔던 문제… 돌아버리는 줄 알았다. 새로 업데이트한 패키지가 잘 동작하지 않아 node_modules를 삭제하고 npm i를 했더니 처음 보는 오만가지 에러가 발생했다. 가장 먼저 발생한 문제는 node-sass가 설치되지 않는 것이었다. (이제는 재현할 수 없다…) node-sass 문서에는 node-sass가 deprecated되었으며, 이제는 sass를 사용하라고 한다. 여태까지 잘 써왔고, 다른 팀원 분들한테는 발생하지 않는 문제인데 😭 뭐 어쩔 수 없으니 node-sass를 지우고 sass를 설치해서 올려줬다. 그런데 변경된 코드 내역을 보니, package-lock.json 파일의 오만가지 패키지들에 &quot;dev&quot;: true 옵션이 붙어있었다. (devOptional이 dev로 바뀐 경우도 있었다.) 해당 옵션에 대한 설명은 다음과 같다. dev: devDependencies에 포함된 패키지의 경우 devOptional: optionalDependencies에 포함된 패키지의 경우 즉 npm install 시 devDependencies에 있는 패키지들에 &quot;dev&quot;: true가 붙는 것으로, 크게 문제될 일이 아니라 생각했다. 그런데 해당 MR을 다른 팀원 분들이 받아서 다시 npm i를 하는 순간, &quot;dev&quot;: true가 다시 다 사라진다! 😇… 결국 내 문제. node-sass는 어떻게 해결됐는지 모르겠지만 더 이상 에러가 뜨지 않았고, 어느 순간 python이 없다는 식의 에러메시지가 떴다. 1env: python: No such file or directory python을 깐 적은 없지만, Mac에는 기본적으로 설치되어 있는 것이 아닌가? 그런데… OS 12.3 이상에서는 python이 없다는 얘기가 있었다.(출처). 내 경우 실제로 python이 없었고, python3 버전을 깔아주었다. (삽질 결과 python 2 버전도 상관없었다.) python 때문이었는지는 모르겠지만, 어떻게 node-sass 문제를 해결했다. 그러고 npm i를 했더니, 다시 package-lock.json의 오만가지 dependencies에 &quot;dev&quot;: true가 붙어있었다. 악!!! 🤯 package-lock.json을 건드리지 않기 위해, npm ci나 npm install --no-save 옵션으로 패키지를 설치해주는 방법도 있었다. 실제로 그렇게 하면 잘 돌아갔다. npm 팀에서도 그렇게 쓰라고 했다는 사람도 있었다. (무능한 npm…) package-lock.json 기반으로 프로젝트의 패키지들을 설치하는 것이 아니라, 그러나 나의 경우처럼 새로운 패키지를 설치해야 하는 경우, 여전히 npm i를 사용해야 하고, 그러면 package-lock.json 파일이 바뀐다. 개똥!! 💩🚽 중간중간에 node도 npm도 지웠다 다시 깔아보고, npm cache clean도 해보고, 프로젝트도 몇 번이나 새로 clone 받고… 난리를 쳤지만 해결되지 않았다. OS 문제인가 싶기도 하고, 망할 npm 대신 yarn을 쓰자고 해보고도 싶고. 그러나 우리 팀에서는 yarn으로 바꿔보자 주장할 수 있었지만, 더 큰 문제가 있었지롱 디자인시스템을 개발하는 프로젝트에서도 (거의) 비슷한 문제가 발생한다는 것이었다. 😩 인생은 결코 호락호락하지 않구나… 그곳에서는 root에 있는 package.json의 peerDependencies에 기재된 리스트들이 깔리지 않아서 문제가 발생했다. 거기서 시작된 문제는 일파만파 커져서 typescript까지도 말썽을 일으키는 정말 촉법소년같은, 정신나간 에러가 됐다. 결국 주말인데도 불구하고 팀장님께 읍소하듯 ㅠㅠ 메시지를 보내놓고 애써 잊어보자고 (전남친도 아니고…) 다른 일 하자 하면서도 계속 붙잡고… 미련덩어리… 그러다가 내가 일주일 째 일을 못하는 상황을 “꿀빠네”라고 조롱했던 동기에게 도움을 요청했다. 그런데 다행히(!!!) 그 동기만 나와 똑같은 에러들이 발생하는 것이 아니겠는가. 눈물날 만큼 반갑고 기뻤다. 같은 에러가 터져서 기분 좋다는 날 보며 동기는 혀를 찼다… 자기는 node-sass 에러부터 난다며, 근데 에러 메시지에서 npm i 뒤에 legacy-peer-deps를 붙여보라고 한단다. 그랬더니 node-sass는 해결됐는데, package-lock.json에 &quot;dev&quot;: true들이 붙는다고 한다. ‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️ 그러면 내 PC에서 legacy-peer-deps가 npm 기본 옵션으로 설정되어 있는 게 아닌지 확인해보란다. ‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️‼️⁉️ 그랬었다… npm config에 그런 옵션이 true로 설정되어 있었다. 💩 우선 node-sass는 해결됐으니, 해당 옵션을 다시 false로 돌려주면 해결되지 않을까? 했고, 정말 해결이… 되었다… 흥분을 가라앉히고, legacy-peer-deps는 이런 것이라고 한다. npm 4-6 버전에서는 peerDependencies가 충돌하는 경우 경고만 뜨고 설치는 되었다. npm 7 버전에서는 peerDependencies를 자동으로 설치하고, 충돌이 있는 경우 에러를 던진다. --legacy-peer-deps 는 peerDependencies를 무시하는 방식 (npm 4-6에서 사용하던 방식) cf) --force: package-lock.json에 몇 가지 다른 의존 버전들을 추가한다. 즉 충돌하는 peerDependencies를 루트에 설치한다. (충돌을 우회한다.) 팀에서 npm은 버전 8을 사용하고 있었다. 그러니 legacy-peer-deps가 기본값 즉 false였을 때는, node-sass와 관련된 peerDependencies에서 충돌이 발생하여 에러를 던졌을 것이다. legacy-peer-deps를 true로 해준 것은 node-sass의 충돌 문제를 잠시 덮어두었던 것이었고, 실제 문제는 어떻게 python으로 해결했다. 그러나 중간에 설정해주었던 legacy-peer-deps=true는 여전히 남아있었고, 이 때문에 package-lock.json에 &quot;dev&quot;: true들이 생겨났을 것으로 추측한다. 또, legacy-peer-deps는 디자인시스템 레포에서, 여러 하위 패키지에서 동시에 사용하는 패키지의 버전을 맞춰주기 위해 root package.json에 작성했던 peerDependencies들에 있는 패키지들 역시 legacy-peer-deps=true 때문에 올바르게 설치가 되지 않았던 것이다. 이 일주일 간의 여정을 정리하자면 아래와 같다. node-sass가 계속 충돌하는 중에, legacy-peer-deps=true 를 붙여줬다. node-sass 문제가 해결됐다. (이유는 모르겠지만, python을 설치해서 해결된 것 같기도 하다.) 1에서 추가했던 legacy-peer-deps=true 때문에 락파일에 &quot;dev&quot;: true 들이 생겨났다. legacy-peer-deps=true 를 지워주니 모두 해결됐다. 물론 중간중간에는 위에 기재하지 않은 99개의 더 많은 과정과 삽질들이 생략되었다. 😇그래도 기쁘다. 너무 고마워서 배라 깊티 보내주니 헛소리를 하는 동기… 이름을 가리지 않아주면 더욱 좋아할 것 같다. 나와 비슷한 문제를 겪고 있는 분에게 답글도 달아주었다 ㅎㅎ 처음으로 생태계에 기여한 것 같아 기쁘다. 저 분도 해결되실진 모르겠지만… 대충 영어로 적어보고 파파고 돌려보니 얼추 맞는 소리인 것 같다. 아직 영어 실력 다 안 죽었네 중간중간에 우리 팀원들과 팀장님, 그리고 수많은 크루들, 또 node-sass와 노드 버전의 관계에 대한 글을 작성하신 저자 분께서 (같은 회사 같은 팀이라서) 며칠 간 많은 도움을 주셨다. 역시나 최종적으로 작은 문장 한 줄만 지워줘서 해결될 문제였지만, 이 수많은 사람들의 고통 나누기가 없었다면… 나는 아마 스트레스를 이기지 못하고 또 병을 얻어 입원하지 않았을까..? 싶기도 하고… 미쳐돌아가는 세상… 이제 세상이 환하다… ☀️","link":"/2022/07/10/npm-troubleshooting/"},{"title":"객체지향의 사실과 오해 - 1장","text":"협력하는 객체들의 공동체 객체지향의 목표는 실세계를 모방하는 것이 아니라 새로운 세계를 창조하는 것이다. 단순히 실세계를 소프트웨어 안으로 옮겨 담는 것이 아니라 고객과 사용자를 만족시킬 수 있는 신세계를 창조하는 것이다 협력하는 사람들 커피 공화국의 아침 카페테리어에서 커피를 주문하고 받는 과정에는 손님, 캐시어, 바리스타 사이의 암묵적인 협력 관계가 존재한다 커피 주문이라는 협력에 참여하는 모든 사람들은 각자 맡은 바 역할과 책임을 다하고 있다 요청과 응답으로 구성된 협력 사람들은 문제 해결에 필요한 지식을 알고 있거나 서비스를 제공해줄 수 있는 사람에게 도움을 요청한다 요청은 연쇄적으로 발생한다 요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서비스를 제공, 즉 요청에 응답한다 우리는 요청과 응답을 통해 다른 사람과 협력하여 문제를 해결한다 역할과 책임 역할은 협력 안에서 차지하는 책임이나 임무를 의미한다 특정한 역할은 특정한 책임을 암시한다 사람들은 협력을 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행한다 여러 사람이 동일한 역할을 수행할 수 있다 역할은 대체 가능성을 의미한다 책임을 수행하는 방법은 자율적으로 선택할 수 있다 (다형성) 한 사람이 동시에 여러 역할을 수행할 수 있다 역할, 책임, 협력 기능을 구현하기 위해 협력하는 객체들 사람 - 객체 에이전트의 요청 - 메시지 에이전트가 요청을 처리하는 방법 - 메서드 역할과 책임을 수행하며 협력하는 객체들 협력에 참여하는 각 개인은 책임을 수행하기 위해 다른 사람에게 도움을 요청하기도 하며, 이를 통해 연쇄적인 요청과 응답으로 구성되는 협력 관계가 완성된다 애플리케이션의 기능은 더 작은 책임으로 분할되고 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다 적절한 객체에게 적절한 책임을 할당해야 한다 역할은 관련성 높은 책임의 집합이다 협력 속에 사는 객체 협력 공동체의 일원으로서 객체는 다음 두 가지 덕목을 갖춰야 한다 객체는 충분히 ‘협력적’이어야 한다 객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답할 뿐이며, 어떤 방식으로 응답할지는 객체 스스로 판단하고 결정한다 객체는 충분히 ‘자율적’이어야 한다 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 자신의 행동을 스스로 결정하고 책임진다 상태와 행동을 함께 지닌 자율적인 객체 객체는 협력에 참여하기 위해 어떤 행동을 해야 하고, 그 행동을 하는 데 필요한 상태도 함께 지니고 있다. 객체는 객체의 내부와 외부를 명확하게 구분하여 자율성을 갖춘다. 객체지향 개발에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다 협력과 메시지 객체지향의 세계에서는 오직 한 가지 의사소통 수단인 ‘메시지’를 이용한다 객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로부터 메시지를 수시한다 메서드와 자율성 메서드 - 객체가 수신된 메시지를 처리하는 방법 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행된다 메시지와 메서드의 분리는 객체들 간의 자율성을 증진시킨다 (객체는 메시지에 응답하기 위해 자신만의 자율적인 방법을 택할 수 있다) cf) 캡슐화 객체지향의 본질 객체를 지향하라 클래스는 객체지향의 핵심을 이루는 중심 개념은 아니다 지나치게 클래스를 강조하는 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시키는 문제가 있다 객체지향 설계를 위해서는 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환해야 한다 → 객체의 역할, 책임, 협력에 집중하라! 🤓 DISCUSSION 리액트에서는? 컴포넌트도 객체라고 할 수 있다. 인터페이스 특정한 객체를 다른 컴포넌트에 전달하는, props같은 경우도 객체지향에서의 ‘메시지’ 메시지를 주고 받는 방식이 인터페이스로 정의되어 있다. 객체지향에서 인터페이스는 클래스가 구현해야 할 내용을 추상 메서드로 미리 정의해놓은 것과 유사하다. 인터페이스로 메서드 이름을 지정해놓고, 그 인터페이스를 확장해서 인터페이스에 지정된 메서드를 오버라이드 해서 쓰는 방식도 사용할 수 있다. 컴포넌트, element도 결국 하나의 객체다 🤔 생각해보기책에서 지적하고 있는대로, ‘객체지향’이라는 것을 단순히 클래스가 찍어내는 인스턴스들의 느낌으로만 이해하고 있었던 것 같다. 유명한 ‘붕어빵 틀’에 사로잡힌 코린이중 하나… 아직 메시지와 메서드가 어떤 차이가 있는 것인지, ‘인터페이스’가 어떻게 메시지와 메서드를 정의하는 것인지 확실하게 와닿지는 않는다. 인터페이스를 단지 컴포넌트에 넘겨주는 props를 사용자에게 알려주기 위해, ‘타입’의 관점에서 사용했던 느낌이 큰 것 같다. ‘객체지향’이라는 관점을 떠나서 ‘객체’를 생각해보았을 때, ‘메서드’와 ‘프로퍼티’로 이루어진 것이 ‘객체’라고 배우기는 쉽다. 그러나 아래 문장은 조금 낯설었다. 객체지향 개발에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다 일반적으로 사용했던 객체의 ‘프로퍼티’가 바로 데이터, ‘메서드’는 프로세스에 해당할 것이다. 데이터와 프로세스가 단순히 하나의 객체로 묶이는 것이 아니라, 그렇게 함으로써 객체의 내부와 외부를 명확하게 구분하여 객체의 자율성을 보장한다는 것은 새롭게 생각해보게 된 내용이었다. 객체의 역할, 책임, 협력에 집중하여 객체 각각이 아니라 전체의 큰 그림에서 객체들 간에 어떻게 메시지를 주고받는지에 집중하여 객체지향 프로그래밍을 익혀나가야겠다.","link":"/2022/01/29/oop-true-and-false-1/"},{"title":"객체지향의 사실과 오해 - 3장","text":"3장: 타입과 추상화 일단 컴퓨터를 조작하는 것이 추상화를 구축하고, 조작하고, 추론하는 것에 관한 모든 것이라는 것을 깨닫고 나면 (훌륭한) 컴퓨터 프로그램을 작성하기 위한 중요한 전제 조건은 추상화를 정확하게 다루는 능력이라는 것이 명확해진다. 초기 지하철 노선도는 실제와 유사한 물리적인 지형 위에 구불구불한 운행 노선과 불규칙적인 역 간의 거리를 사실적으로 묘사하고 있었지만, 이렇게 사실적인 정보는 오히려 지하철을 이용하는 승객들로 하여금 노선도를 이해하기 어렵게 만든다. 지하철 노선도 디자인에서 가장 중요한 것은 얼마나 사실적으로 지형을 묘사했느냐가 아니라 역과 역 사이의 연결성을 얼마나 직관적으로 표현했느냐다. 추상화를 통한 복잡성 극복현실은 복잡하며 예측 불가능한 혼돈의 덩어리다. 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화하는 전략을 따른다. 헨리 백의 지하철 노선도는 불필요한 지형 정보를 제거함으로써 단순함을 달성한 추상화의 훌륭한 예다. 진정한 의미에서 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이다. 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것이다. 💡 추상화어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다. 객체지향 패러다임은 객체라는 추상화를 통해 현실의 복잡성을 극복한다. 객체지향과 추상화✔️ 모두 트럼프일 뿐 정원에 들어선 앨리스 자신을 포함하여 앨리스가 마주하는 정원사, 클로버 병사들, 기타 등등은 모두 객체다. 객체는 제각기 독특한 모습과 행동 양식을 지니지만, 이들을 하나로 아우르는 ‘트럼프’라는 개념으로 단순화할 수 있다. ✔️ 그룹으로 나누어 단순화하기 정원 속 인물들은 다양한 측면에서 서로를 구별할 수 있는 독특한 특징이 있다. 이처럼 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물을 객체라고 한다. 한편 장면에 등장하는 다양한 인물들을 모두 ‘트럼프’라고 줄여 지칭할 수 있다. 모든 인물들은 공통적으로 ‘트럼프’라고 했을 때 떠오르는 일반적인 외형과 행동 방식을 지니고 있기 때문이다. ✔️ 개념 앨리스가 인물들의 차이점을 무시하고 공통점만을 취해 트럼프라는 개념으로 단순화한 것은 추상화의 일종이다. 이러한 공통점을 기반으로 객체들을 묶기 위한 그릇을 개념(concept) 이라고 한다. 개념을 이용하면 객체를 여러 그룹으로 분류(classification) 할 수 있다. 결국 각 객체는 특정한 개념을 표현하는 그룹의 일원으로 포함된다. 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다. ✔️ 개념의 세 가지 관점 개념은 특정한 객체가 어떤 그룹에 속할 것인지를 결정한다. 객체의 분류 장치로서 개념은 다음 세 가지 관점을 포함한다. 심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭 (ex. ‘트럼프’) 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다. (ex. 몸이 납작하고 두 손 두 발이 네모난 몸 모서리에 달려 있는 등장인물) 외연(extension): 개념에 속하는 모든 객체의 집합 (ex. 정원사, 병사, 신하…) ✔️ 객체를 분류하기 위한 틀 분류란 특정한 객체를 특정한 개념의 객체 집합에 포함시키거나 포함시키지 않는 작업을 의미한다. 분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다. 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다. ✔️ 분류는 추상화를 위한 도구다 추상화는 구체적인 사물 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순화하는 것이다. 추상화는 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거해 단순화하는 것이다. 타입✔️ 타입은 개념이다 타입은 공통점을 기반으로 객체들을 묶기 위한 틀이다. 타입은 개념과 동일하다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. ✔️ 데이터 타입 ‘타입이 없다(Untyped)’는 말은 메모리 안의 데이터를 다룰 수 있는 단 하나의 타입만이 존재한다는 것을 의미한다. 컴퓨터의 데이터를 목적에 따라 분류하기 시작하면서 프로그래밍 언어에 서서히 타입 시스템이 생겨났다. 타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다. 타입은 데이터가 어떻게 사용되느냐에 관한 것이다 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다. ✔️ 객체와 타입 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다. 그러나 객체는 데이터가 아니다. 객체에서 중요한 것은 행동이며, 이웃 객체와 협력하기 위해 어떤 행동을 할지를 결정하는 것이다. 객체의 타입은 다음과 같은 특징을 가진다 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. ✔️ 행동이 우선이다 동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다. 객체의 타입을 결정하는 것은 객체의 행동뿐이다. 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는 데 아무런 영향도 미치지 않는다. 타입이 데이터가 아니라 행동에 의해 결정된다는 사실은 객체지향 패러다임을 특징 짓는 중요한 몇 가지 원리원칙에 의미를 부여한다. 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 동일한 행동은 동일한 책임을 의미하며, 동일한 책임은 동일한 메시지 수신을 의미한다. 이처럼 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 다형성이라고 한다. 외부에 데이터를 감춰야 한다. 공용 인터페이스 뒤로 데이터를 캡슐화하는 것은 객체를 행동에 따라 분류하기 위한 기본적인 원칙이다. 객체가 내부적으로 관리하는 데이터가 아니라 객체가 외부에 제공하는 행동을 먼저 생각해야 한다. 이는 책임-주도 설계라고 부르는 객체지향 설계 방법이다. 객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. 타입의 계층✔️ 트럼프 계층 앨리스는 정원사, 병사, 신하 등을 ‘트럼프’가 아닌 ‘트럼프 인간’으로 봤다. 등장인물들의 외양은 트럼프와 유사하지만 행동 자체는 트럼프와 완벽하게 동일하지 않기 때문이다. 트럼프 인간 타입의 객체는 트럼프 타입의 객체가 할 수 있는 모든 행동(납작 엎드릴 수 있고 뒤집어질 수 있는 것)에 더해 걸어다니는 행동을 더 할 수 있다. 따라서 모든 트럼프 인간은 동시에 트럼프다. 트럼프 인간은 트럼프보다 좀 더 특화된 행동을 하는 특수한 개념이다. 이 두 개념 사이 관계를 일반화/특수화 관계라고 한다. ✔️ 일반화/특수화 관계 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다. 두 타입 간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 한다. 특수한 타입이란 일반적인 타입이 가진 모든 행동을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입을 가리킨다. ✔️ 슈퍼타입과 서브타입 좀 더 일반적인 타입을 슈퍼타입, 좀 더 특수한 타입을 서브타입이라고 한다. 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 한다. ✔️ 일반화는 추상화를 위한 도구다 추상화에서는 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거시켜 단순하게 만든다. 앨리스가 ‘기껏해야 트럼프에 불과해’라고 생각했을 때 앨리스는 머릿속에서 걸을 수 있는 트럼프 인간의 특수한 능력은 제거하고 종이 조각처럼 쉽게 뒤집어지는 트럼프의 특성에 집중했다. 객체지향 패러다임을 통해 세상을 바라보는 경우 분류와 일반화/특수화 기법을 동시에 적용하게 된다. 정적 모델✔️ 타입의 목적 앨리스의 키는 앨리스가 어떤 음식을 먹거나 어떤 행동을 할 때마다 시시각각 변한다. 하지만 모든 경우 앨리스는 앨리스일 뿐이다. 앨리스 객체의 상태는 변하지만 앨리스를 다른 객체와 구별할 수 있는 식별성은 동일하게 유지된다. 타입은 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. ✔️ 그래서 결국 타입은 추상화다. 어떤 시점에 앨리스에 관해 생각할 때 불필요한 시간이라는 요소와 상태 변화라는 요소를 제거하고 철저하게 정적인 관점에서 앨리스의 모습을 묘사할 수 있다. 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법이다. ✔️ 동적 모델과 정적 모델 객체를 생각할 때 우리는 두 가지 모델을 동시에 고려한다. 객체가 특정 시점에 구체적으로 어떤 상태를 가지는지 → 동적 모델(dynamic model) 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것 → 정적 모델(static model) 객체지향 애플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야 한다. ✔️ 클래스 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. 👩‍🏫 클래스 != 타입 클래스는 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나다. 결국 객체지향에서 중요한 것은 동적으로 변하는 객체의 ‘상태’와 상태를 변경하는 ‘행위’다. 🤔 생각해보기도입부에 지하철 노선도의 예시를 들면서, 정보 전달의 목적을 제대로 파악하는 것의 중요성을 느꼈다. 때로는 사실을 있는 그대로 구체적으로 표현하는 것이 필요하겠지만, 지하철 노선도처럼 복잡함을 제거하고 추상화한 형태로 정보를 제공하는 것이 더욱 효과적일 수도 있을 것이다. 이번 장에서는 객체지향을 추상화의 관점에서 다루고 있다. 대상들의 공통점과 차이점을 바탕으로 객체를 분류하고 ‘심볼’, ‘내연’과 ‘외연’이라는 세 가지 관점으로 객체의 분류 장치를 설명하고 있다. 객체를 타입 시스템에 연관지어서 설명한 것도 인상깊었다. 특히 타입스크립트를 사용하면서 ‘슈퍼타입’과 ‘서브타입’이 수학에서 다루는 일반적인 집합의 포함 관계와 달라 헷갈렸는데, 일반화/특수화의 관점에서 타입의 포함 관계를 생각해보니 이해하기가 편했다. 객체의 타입을 결정하는 것은 객체의 ‘데이터’가 아닌 ‘행동’이라는 것도 항상 염두에 두어야할 것이다.","link":"/2022/02/18/oop-true-and-false-3/"},{"title":"객체지향의 사실과 오해 - 4장","text":"역할, 책임, 협력 우리 모두를 합친 것보다 더 현명한 사람은 없다. ‘최후통첩 게임’에서 응답자와 제안자는 일반적으로 생각하는 합리적인 결정을 내리지 않았다. 인간이 가지고 있는 본연의 특성이라는 관점에서 인간은 이기적이고 합리적인 존재다. 그러나 타인과 관계를 맺는 과정 속에서 인간은 본연의 특성을 배제하고 자신의 이익을 최소화하는 불합리한 선택을 하게 된다. 인간이 어떤 본질적인 특성을 지니고 있느냐가 아니라 어떤 상황에 처해 있느냐가 인간의 행동을 결정한다. 즉, 각 개인이 처해 있는 정황 또는 문맥(context)이 인간의 행동 방식을 결정한다는 것이다. 인간의 행동을 결정하는 문맥은 타인과의 협력이다. 객체의 세계에서도 협력이라는 문맥이 객체의 행동 방식을 결정한다. 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력이다. 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다. 협력요청하고 응답하며 협력하는 사람들협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다. 협력은 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다. 누가 파이를 훔쳤지?&lt;이상한 나라의 앨리스&gt;에서, 하트 여왕이 만든 파이를 훔쳐 달아나다 붙잡힌 하트 잭에 대한 공판이 열리는 법정 속 장면을 객체지향의 패러다임에서 생각해보자. 이 이야기에 등장하는 객체들은 하트 잭의 재판이라는 동일한 목적을 달성하기 위해 협력하고 있다. 재판 속의 협력하트 잭의 재판 과정은 재판에 참여하는 많은 사람들이 요청하고 응답하는 과정 속에서 이뤄진다. 어떤 등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다. 그리고 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다. 책임객체지향의 세계에서는 어떤 객체가 어떤 요청에 대해 대답해줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다. 결국 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시한다. 책임의 분류책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 알아야 하는 정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다. 즉, 객체의 책임은 객체가 무엇을 알고 있는가(knowing) 와 무엇을 할 수 있는가(doing) 로 구성된다. 책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소다. 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것)와 외부에 제공해줄 수 있는 서비스(하는 것)의 목록이다. 따라서 책임은 객체의 공용 인터페이스를 구성한다. 책임과 메시지협력 안에서 객체는 다른 객체로부터 요청이 전송됐을 경우에만 자신에게 주어진 책임을 수행한다. 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)이라고 한다. 메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 방법이다. 송신자가 메시지를 전송할 수 있다는 사실은 수신자가 메시지를 수신할 수 있다는 사실을 암시한다. 책임과 메시지의 수준이 같지는 않다. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다. 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다. 역할책임의 집합이 의미하는 것어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다. 역할은 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이다. 판사와 증인모자 장수가 증언을 하는 과정을 묘사한 이야기와 요리사와 앨리스가 증언을 하는 과정을 묘사한 이야기는 재판이 이뤄지는 순차적인 과정들은 동일하다. 하지만 ‘왕’ 대신 ‘여왕’이, ‘모자 장수’ 대신 ‘요리사’나 ‘앨리스’가 협력에 참여한다는 것이 차이점이다. 역할이 답이다협력에 참여하는 등장인물들을 제외한 나머지 과정이 너무나도 유사하므로 하나의 협력으로 다루고 싶다. 재판이라는 협력 과정 속에서 하트 왕과 하트 여왕은 ‘판사’의 역할을, 모자 장수와 요리사, 그리고 앨리스는 ‘증인’의 역할을 수행하면 된다. ‘판사’와 ‘증인’이라는 역할(role) 을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다. 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다. 역할을 이용해 협력을 추상화했기 때문에 ‘판사’나 ‘증인’의 역할을 수행할 수 있는 어떤 객체라도 협력에 참여할 수 있다. 역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다. 따라서 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다. 동일한 역할을 수행하는 객체들은 동일한 메시지를 수신할 수 있기 때문에 동일한 책임을 수행할 수 있다. 역할은 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념이다. 협력의 추상화협력의 추상화는 설계자가 다뤄야 하는 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다. 대체 가능성역할은 다른 객체에 의해 대체 가능함을 의미한다. 객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다. 즉 객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 한다. 객체는 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다. 따라서 대부분의 경우에 객체의 타입과 역할 사이에는 일반화/특수화 관계가 성립한다. 객체의 모양을 결정하는 협력흔한 오류객체지향 입문자들은 협력이라는 문맥을 고려하지 않고 각 객체를 독립적으로 바라보기 때문이다 데이터나 클래스를 중심으로 애플리케이션을 설계하는 실수를 범한다. 객체는 행위를 수행하며 협력에 참여하기 위해 존재하며, 객체지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이다. 협력을 따라 흐르는 객체의 책임협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것을 의미한다. 협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 그 행동에 필요한 데이터를 고민해야 하며, 객체에게 필요한 데이터와 행동이 어느 정도 결정된 후에 클래스의 구현 방법을 결정해야 한다. 객체의 행위에 초점을 맞추기 위해서는 협력이라는 실행 문맥 안에서 책임을 분배해야 한다. 객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 창조하는 것이다. 객체지향 설계 기법역할, 책임, 협력의 관점에서 애플리케이션을 설게하는 유용한 세 가지 기법이 있다. 책임-주도 설계객체지향 설계의 핵심은 올바른 책임을 올바른 객체에게 할당하는 것이다. 현재 가장 널리 받아들여지는 객체지향 설계 방법은 레베카 워프스브록이 고안한 책임-주도 설계 방법이다. 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다. 객체는 책임을 수행하는 도중에 적절한 객체를 찾아 필요한 작업을 요청하고, 결과적으로 객체들 간의 협력 관계까 만들어진다. 책임-주도 설계는 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중한다. 결과적으로 객체는 충분히 자율적인 동시에 충분히 협조적인 객체들로 이뤄진 생태계를 구성하게 된다. 디자인 패턴디자인 패턴은 책임-주도 설계의 결과를 표현한다. 일반적으로 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된다. 디자인 패턴의 한 가지 예인 COMPOSITE 패턴은, 전체와 부분을 하나의 단위로 추상화해야 하는 경우에 사용할 수 있는 패턴이다. 따라서 디자인 패턴은 유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물이라고 할 수 있다. Component, Leaf, Composte이 역할이라는 사실은 실제로 구현 시에는 다양한 방식으로 역할을 구현할 수 있다는 사실을 암시한다. 디자인 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 테스트-주도 개발테스트-주도 개발의 기본 흐름은 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후, 리팩터링을 통해 중복을 제거하는 것이다. 테스트-주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다. 테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다. 테스트-주도 개발은 책임-주도 설계의 기본 개념을 따른다. 협력 안에서 객체의 역할과 책임이 무엇인지에 대한 감각을 갖춰야만 효과적인 테스트를 작성할 수 있다. 역할, 책임, 협력에 집중하고 객체지향의 원칙을 적용하려는 깊이 있는 고민과 노력을 통해서만 테스트-주도 개발의 혜택을 누릴 수 있다. 😮 Discussion이번 스터디에서는 라이브코딩을 진행했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263interface Witness { testify: () =&gt; string;}interface 대리 { callWitness: () =&gt; Witness;}interface Judge { start: () =&gt; void;}class God { judge: Judge; constructor(judge) { this.judge = judge; } main() { this.judge.start(); }}class King implements Judge { private 대리: 대리; constructor(대리: 대리) { this.대리 = 대리; } start() { const witness = this.대리.callWitness(); const message = witness.testify(); console.log(message); }}class Queen implements Judge { start() { }}class HatDealer implements Witness { testify() { return '증언'; }}class WhiteRabbit implements 대리 { private witness: Witness; callWitness() { return this.witness; }}const rabbit = new WhiteRabbit();const king = new King(rabbit);const god = new God(king);god.main(); 🚨 서로가 너무 의존하고 있는 코드가 되어버렸다! 현재 특정 객체의 인스턴스를 생성하기 위해서는 무조건 constructor의 인자가 있어야 한다. 예를 들면, King은 대리에 의존적이다. 서로가 서로를 몰라도 요청과 응답을 주고받을 수 있어야 한다. MessageQueue 등으로 메시지를 전달하면 좋겠다. 이를 Bridge 패턴이라고 한다. 각 인스턴스는 원래 없었던 애들이 아니다. 원래부터 있었는데, 안 보이고 있다가 king이 모이라고 할 때 모이는 형태여야 한다. 이때는 constructor나 멤버 변수(상태)가 필요 없다. 메서드에서 인자 두 개를 받아서 메서드 안에서 협력하고 왕은 그 결과만 도출해주면 된다. 지금 코드는 “태초에 토끼가 있었다”의 형태로, 이는 논리적으로 문제가 있다! 개선된 코드는 다음 시간에 계속…","link":"/2022/02/27/oop-true-and-false-4/"},{"title":"객체지향의 사실과 오해 - 6장","text":"6장: 객체 지도 유일하게 변하지 않는 것은 모든 것이 변한다는 사실 뿐이다. 여행 중 길을 찾는 방법은 크게 두 가지로 나눌 수 있다. 1️⃣ 기능적이고 해결책 지향적인 접근법 - 다른 사람에게 길을 물어본다. 올바른 길을 알려줬다면 원하는 곳으로 이동할 수 있겠지만, 이 방법은 일반적이지도, 재사용 가능하지도 않다. 또 중요한 랜드마크가 없다면 설명만으로 경로를 찾기 쉽지 않다. 2️⃣ 구조적이고 문제 지향적인 접근법 - 지도를 이용한다. 길을 찾는 데 필요한 풍부한 컨텍스트 정보가 함축돼 있으며, 길을 묻는 방법보다 쉽고 간단하다. 주변 지형을 추상적으로 표현하기 때문에 실세계의 환경과 우리의 지식을 밀접하게 연관 지을 수 있게 해준다. 지도는 다양한 목적을 위해 재사용될 수 있으며, 범용적이다. ‘기능’에 대한 요구사항이 계속 변해도 지도에 표시된 ‘구조’는 안정적이기 때문이다. 지도 은유의 핵심은, 기능이 아니라 구조를 기반으로 모델을 구축하는 편이 좀 더 범용적이고 이해하기 쉬우며 변경에 안정적이라는 것이다. 객체지향 개발 방법은 안정적인 구조에 변경이 빈번하게 발생하는 기능을 종속시키는 지도의 방법과 유사하다. 자주 변경되는 기능이 아니라 안정적인 구조를 따라 역할 책임, 협력을 구성하자. 기능 설계 대 구조 설계 기능 측면의 설계 - 제품이 사용자를 위해 무엇을 할 수 있는지에 초점 구조 측면의 설계 - 제품의 형태가 어떠해야 하는지에 초점 훌륭한 구조는 훌륭한 소프트웨어를 만들기 위한 필요조건이다. 훌륭한 설계는 불가능한 요구사항 변경에도 유연하게 대처할 수 있는 안정적인 구조를 제공해야 한다. 미래를 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경으을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다. 설계를 하는 목적은 나중에 설계하는 것을 허용하는 것이며, 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것이다. 객체지향 접근방법은 자주 변경되지 않는 안정적인 객체 구조를 바탕으로 시스템 기능을 객체 간의 책임으로 분배한다. 객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만든다. 기능이 변경되더라도 객체 간의 구조는 그대로 유지된다. 두 가지 재료: 기능과 구조 기능 - 사용자가 자신의 목표를 달성하기 위해 사용할 수 있는 시스템의 서비스 구조 - 시스템의 기능을 구현하기 위한 기반으로, 기능 변경을 수용할 수 있도록 안정적이어야 한다. 안정적인 재료: 구조도메인 모델사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다. 도메인 모델에서 모델이란 대상을 단순화해서 표현한 것으로, 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태다. 즉 도메인 모델은 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화한 것이다. 도메인 모델은 이해관계자들이 바라보는 멘탈 모델(Mental Model)이다. 소프트웨어 사용자들은 도메인에 존재하는 현상을 이해하고 현상에 반응하기 위해 도메인과 관련된 멘탈 모델을 형성한다. 도메인의 모습을 담을 수 있는 객체지향최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야 한다. 즉 애플리케이션은 도메인 모델을 기반으로 설계돼야 한다. 객체지향은 도메인 모델의 세 가지 측면(사용자, 디자인, 시스템 이미지)을 모두 모델링할 수 있는 거의 유일한 모델링 패러다임이다. 객체지향은 사람들이 만지고 느끼고 볼 수 있는 실체를 시스템 안의 객체로 재창조할 수 있게 해준다. 표현적 차이소프트웨어 객체는 현실 객체에 대한 추상화가 아니라, 은유를 기반으로 재창조한 것이다. 소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 표현적 차이 또는 의미적 차이라고 한다. 소프트웨어 객체는 그 대상이 현실적인지, 현실적이지 않은지에 상관없이 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 한다. 도메인 모델을 기반으로 설계하고 구현하는 것은 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있게 하며, 결과적으로 표현적 차이가 줄어들 것이다. 도메인 모델은 코드 안에 존재하는 미로를 헤쳐나갈 수 있는 지도를 제공한다. 불안정한 기능을 담는 안정적인 도메인 모델도메인 모델이 제공하는 구조는 상대적으로 안정적이다. 도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것이다. 본질적인 측면을 가장 잘 반영한 사용자 모델을 기반으로 설계와 코드를 만들면 변경에 쉽게 대처할 수 있을 가능성이 커진다. 결론적으로 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어의 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 만들 수 있다. 불안정한 재료: 기능유스케이스훌륭한 기능적 요구사항을 얻기 위해서는 목표를 가진 사용자와 사용자의 목표를 만족시키기 위해 일련의 절차를 수행하는 시스템 간의 ‘상호작용’ 관점에서 시스템을 바라봐야 한다. 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라고 한다. 유스케이스는 시스템의 이해관계자들 간의 계약을 행위 중심으로 파악한다. 산발적으로 흩어져 있는 기능에 사용자 목표라는 문맥을 제공함으로써 각 기능이 유기적인 관계를 지닌 체계를 이룰 수 있게 한다. 사용자 목표가 유스케이스의 핵심이다. 유스케이스는 공통의 사용자 목표를 통해 강하게 연관된 시나리오의 집합이다. 유스케이스의 특성첫째, 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 ‘텍스트’다. 유스케이스는 다이어그램이 아니다. 둘째, 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다. 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다. 시나리오를 유스케이스 인스턴스라고도 한다. 셋째, 유스케이스는 단순한 피처(feature) 목록과 다르다. 피처는 시스템이 수행해야 하는 기능의 목록을 단순하게 나열한 것이다. 유스케이스는 단순히 기능을 나열한 것이 아니라 이야기를 통해 연관된 기능을 함께 묶을 수 있다. 넷째, 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다. 유스케이스는 자주 변경되는 사용자 인터페이스 요소는 배제하고 사용자 관점에서 시스템의 행위에 초점을 맞춘다. 다섯째, 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다. 유스케이스는 설계 기법도, 객체지향 기법도 아니다.유스케이스는 단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다. 유스케이스로부터 시스템의 내부 구조를 유추할 수는 없다. 유스케이스와 객체의 구조 사이에는 커다란 간격이 존재하며, 이 간격을 자동으로 없앨 수 없다. 유스케이스는 객체의 구조나 책임에 대한 어떤 정보도 제공하지 않는다. 재료 합치기: 기능과 구조의 통합도메인 모델, 유스케이스, 그리고 책임-주도 설계변경에 유연한 소프트웨어를 만들기 위해서는 유스케이스에 정리된 시스템의 기능을 도메인 모델을 기반으로 한 객체들의 책임으로 분배해야 한다. 시스템은 사용자로부터 전송된 메시지를 수행하기 위해 책임을 수행하는 거대한 자율적인 객체다. 시스템 안에는 더 작은 규모의 객체들이 협력을 통해 구현된다. 시스템에 할당된 커다란 책임은 시스템 안의 작은 규모의 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화된다. 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택하고, 협력을 완성하는 데 필요한 메시지를 식별하면서 객체들에게 책임을 할당해 나간다. 마지막으로 협력에 참여하는 객체를 구현하기 위해 클래스를 추가하고 속성과 함께 메서드를 구현하면 시스템의 기능이 완성된다. 유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 함으로써 객체 간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공한다. 도메인 모델을 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공한다. 책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 유스케이스와 도메인 모델을 통합한다. 견고한 객체지향 애플리케이션을 개발하기 위해서는 사용자의 관점에서 시스템으 기능을 명시하고, 사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 변환하는 체계적인 절차를 따라야 한다. 유스케이스에서 출발해 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 재귀적 합성이라는 객체지향의 기본 개념을 잘 보여준다. 객체지향은 모든 것을 객체로 바라본다. 크기와 상관없이 모든 객체는 메시지를 전송하거나 수신할 수 있고 메시지에 응답하기 위해 자율적으로 메서드를 선택할 수 있다. 기능 변경을 흡수하는 안정적인 구조도메인 모델이 안정적인 이유는 두 가지가 있다. 첫째, 도메인 모델을 구성하는 개념은 비즈니스가 없어지거나 완전히 개편되지 않는 한 안정적으로 유지된다. 둘째, 도메인 모델을 구서하는 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지된다. 객체지향의 가장 큰 장점은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다는 점이다. 따라서 도메인 모델링에서 사용한 객체와 개념을 프로그래밍 설계에서의 객체와 클래스로 매끄럽게 변환할 수 있다. 객체지향의 이 같은 특성을 연결완전성이라고 한다. 연결완전성의 역방향 역시 성립한다. 즉 코드의 변경으로부터 도메인 모델의 변경 사항을 유추할 수 있다. 이것을 가역성이라고 한다. 안정적인 도메인 모델을 기반으로 시스템의 기능을 구현하고, 도메인 모델과 코드를 밀접하게 연관시키기 위해 노력하라.","link":"/2022/03/12/oop-true-and-false-6/"},{"title":"객체지향의 사실과 오해 - 7장","text":"7장: 함께 모으기 마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 대해 설명한다. 개념 관점(Conceptual Perspective) - 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다. 명세 관점(Specification Perspective) - 도메인이 아닌 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임 즉 객체의 인터페이스를 바라본다. 프로그래머는 객체가 협력을 위해 ‘무엇’을 할 수 있는가에 초점을 맞춘다. 구현 관점(Implementation Perspective) - 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다. 객체의 책임을 ‘어떻게’ 수행할 것인가에 초점을 맞춘다. 클래스는 세 가지 관점을 통해 설계와 관련된 다양한 측면을 드러낸다. 클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 커피 전문점 도메인커피 주문커피 전문점은 아주 간단한 도메인이다. 우리는 객체를 이용해서 손님이 커피를 주문하는 사건을 컴퓨터 안에 재구성해야 한다. 커피 전문점이라는 세상객체지향의 관점에서 메뉴판은 하나의 객체이며, 메뉴판을 구성하는 메뉴 항목들 역시 객체다. 손님 역시 객체로, 메뉴 항목 객체 하나를 선택해 바리스타 객체에게 전달한다. 바리스타는 자율적으로 커피를 제조하는 객체이며, 바리스타가 제조하는 커피 역시 객체다. 손님은 메뉴판을 알아야 하며, 이는 두 객체 사이에 관계가 존재함을 암시한다. 손님은 바리스타와도 관계를 맺으며, 바리스타는 자신이 만든 커피와 관계를 맺는다. 상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입의 인스턴스로 분류할 수 있다. 손님, 바리스타, 커피 객체 각각은 모두 ‘손님 타입’, ‘바리스타 타입’, ‘커피 타입’의 인스턴스다. 메뉴판 타입과 메뉴 항목 타입은 포함(containment) 또는 합성(composition) 관계다. 손님 타입과 메뉴판 타입은 포함 관계는 아니지만 서로 알고 있는 연관(association) 관계에 있다. 커피 전문점 도메인을 구성하는 타입들의 종류와 관계를 표현할 수 있다. 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 도메인 모델이라고 한다. 설계하고 구현하기커피를 주문하기 위한 협력 찾기협력을 설계할 때는 메시지가 객체를 선택하게 해야 한다. 첫 번째 메시지는 ‘커피를 주문하라’이다. 도메인 모델 안에 이 책임을 수행하기에 적절한 타입은 손님 타입으로, 이 메시지를 처리할 객체는 손님 타입의 인스턴스다. 이때 손님은 메뉴 항목에 대해서는 알지 못하며, ‘메뉴 항목을 찾아라’라는 새로운 메시지가 등장한다. 이때 메시지에 ‘메뉴 이름’이라는 인자를 포함해 함께 전송한다. 메뉴 항목을 찾을 책임은 메뉴 항목 객체를 포함하고 있는 메뉴판 객체에게 할당한다. 손님은 자신이 주문한 커피에 대한 메뉴 항목을 얻었으니 이제 ‘커피를 제조하라’라는 메시지를 만든다. 인자로는 메뉴 항목을 전달하고 반환값으로는 제조된 커피를 받아야 한다. 이 메시지는 바리스타 객체가 수신한다. 아메리카노를 만드는 데 필요한 지식은 바리스타의 상태로, 기술은 바리스타의 행동으로 간주할 수 있다. 이런 관점에서 바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재다. 인터페이스 정리하기객체가 수신한 메시지가 객체의 인터페이스를 결정한다. 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다. 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다. 객체 오퍼레이션 손님 커피를 주문하라 메뉴판 메뉴 항목을 찾아라 바리스타 커피를 제조하라 커피 생성하라 클래스를 이용하여 협력을 통해 식별된 타입의 오퍼레이션을 외부에서 접근 가능한 공용 인터페이스로 만들자. 123456789101112131415161718class Customer { public void order(String menuName) {}}class MenuItem {}class Menu { public MenuItem choose(String name) {}}class Barista { public Coffee makeCoffee(MenuItem menuItem) {}}class Coffee { public Coffee(MenuItem menuItem) {}} 구현하기클래스의 인터페이스를 식별했으므로 이제 오퍼레이션을 수행하는 방법을 메서드로 구현하자. 객체가 다른 객체에게 메시지를 전송하기 위해서는 먼저 객체에 대한 참조를 얻어야 한다. 123456class Customer { public void order(String menuName, Menu menu, Barista barista) { MenuItem menuItem = menu.choose(menuName); Coffee coffee = barista.makeCoffee(menuItem); }} 12345678910111213141516class Menu { private List&lt;MenuItem&gt; items; public Menu(List&lt;MenuItem&gt; items) { this.items = items; } public MenuItem choose(String name) { for (menuItem each : items) { if (each.getName().equals(name)) { return each; } } return null; }} 💡 객체의 속성은 객체의 내부 구현에 속하기 때문에 캡슐화돼야 한다.따라서 MenuItem의 목록을 Menu의 속성으로 포함시킨다. 123456class Barista { public Coffee makeCoffee(MenuItem menuItem) { Coffee coffee = new Coffee(menuItem); return coffee; }} 123456789class Coffee { private String name; private int price; public Coffee(MenuItem menuItem) { this.name = menuItem.getName(); this.price = menuItem.cost(); }} 1234567891011121314151617public class MenuItem { private String name; private int price; public MenuItem(String name, int price) { this.name = name; this.price = price; } public int cost() { return price; } public String getName() { return name; }} 인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능에 가깝다.설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라. 설계가 제대로 그려지지 않는다면 고민하지 말고 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라. 코드와 세 가지 관점코드는 세 가지 관점을 모두 제공해야 한다개념 관점에서 코드를 바라보면 Customer, Menu, MenuItem, Barista, Coffee 클래스가 있다. 이 클래스들은 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다. 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다. 명세 관점은 클래스의 인터페이스를 바라본다. 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스로, 외부 객체가 접근할 수 있는 유일한 부분이다. 최대한 변화에 안정적인 인터페이스를 만들기 위해 인터페이스 구현과 관련된 세부 사항이 드러나지 않게 해야 한다. 구현 관점은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성이 구현에 속하며, 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에 영향을 미쳐서는 안 된다. 메서드와 속성은 철저하게 클래스 내부로 캡슐화돼야 한다. 하나의 클래스 안에는 개념 관점, 명세 관점, 구현 관점을 모두 포함해야 한다. 도메인 개념을 참조하는 이유도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다. 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응할 수 있다. 인터페이스와 구현을 분리하라.명세 관점과 구현 관점을 분리해야 한다. 명세 관점은 클래스의 안정적인 측면을 드러내고, 구현 관점은 클래스의 불안정한 측면을 드러내야 한다. 🎠 Discussion 행동이 아닌, 상태가 변경되었을 때 값을 변경시키고 싶은 경우에는 어떻게 할까? getter/setter를 사용한다 MVC에서 Model, View, Controller는 객체인가? 객체는 협력 관점에서 중요하다. 객체의 협력을 위한 객체도 있지만, Model-View-Controller와 같은 객체도 존재한다. 사실 M-V-C들은 ‘레이어’에 가깝다 숙제 객체 vs 개체? 객체의 범위 인터페이스 정리하기 - 인터페이스와 클래스 두 개가 함께 쓰이면 좋은 경우/ 어떤 경우에 어떤 문법을 사용해야 하는가123456789101112131415161718interface Customer { public void order(String menuName) {}}interface MenuItem {}interface Menu { public MenuItem choose(String name) {}}interface Barista { public Coffee makeCoffee(MenuItem menuItem) {}}interface Coffee { public Coffee(MenuItem menuItem) {}} 본문에서 “왜 객체의 타입을 일반적으로 구현하는게 class다” 라고 말하고 있는가?","link":"/2022/03/20/oop-true-and-false-7/"},{"title":"객체지향의 사실과 오해 - 부록","text":"부록A: 추상화 기법 추상화 기법도메인에 존재하는 개념들을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용할 수 있다. 주요 추상화 기법의 종류들 분류와 인스턴스화 일반화와 특수화 집합과 분해 객체지향의 가장 큰 장점은 동일한 추상화 기법을 프로그램의 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있다는 점이다. 분류와 인스턴스화개념과 범주도로 위를 달리는 작은 승용차와 버스, 트럭들을 가리켜 **‘자동차’**라고 하며,길거리에 자라고 있는 다양한 종류의 가로수들을 일컬어 ‘나무’라고 할 수 있다. 개별 자동차와 나무는 완전히 동일하지 않지만 유사한 특성을 바탕으로 각각 ‘자동차’와 ‘나무’로 분류할 수 있다. 이처럼 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다. 자동차 - 바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단 (이라는 특징) 나무 - 푸른 잎과 갈색의 줄기를 가진 다년생 식물 (이라는 특징) 세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다. 분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다. 이때 ‘수많은 개별적인 현상들’을 객체라고 하고, ‘하나의 개념’을 타입이라고 한다. 분류는 객체를 타입과 연관시키는 것이다. 객체지향의 세계에서 타입은 개념과 동의어이며 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어를 의미한다. 객체는 자동으로 타입의 인스턴스라고 한다. 타입객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다. 타입은 세 가지 관점에서의 정의가 필요하다. 심볼: 타입을 가리키는 간략한 이름이나 명칭 내연: 타입의 완전한 정의 외연: 타입에 속하는 모든 객체들의 집합 ex) 자동차 심볼 - 자동차 내연 - 원동기를 동력원으로 해서 주행하는 사람이나 화물을 운반하는 기계 외연 - 모든 자동차들의 집합 → 도메인을 분석하는 동안 이름(심볼)과 의미(내연), 객체들의 집합(외연)을 이용해 개념을 정의할 수 있다. 외연과 집합타입의 외연은 타입에 속하는 객체들의 집합이다. 하나의 객체가 두 개 이상의 집합에 동시에 포함되는 경우에는 어떨까? 단일 분류 - 한 객체가 한 시점에 하나의 타입에만 속하는 것 다중 분류 - 한 객체가 한 시점에 여러 타입에 속하는 것 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다. 한 객체는 오로지 한 클래스의 인스턴스여야만 한다. 만약 객체가 타입을 변경할 수 있다면? 동적 분류 - 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 정적 분류 - 객체가 자신의 타입을 변경할 수 없는 경우 대부분의 언어에서는 동적 분류를 구현할 수 있는 방법을 제공하지 않는다. 다중 분류와 동적 분류 관점에서 도메인 모델의 초안을 만든 후 실제 구현에 적합하도록 단일 분류와 정적 분류 방식으로 객체들의 범주를 재조정하는 편이 분석과 구현 간의 차이를 메울 수 있는 가장 현실적인 방법이다. 클래스객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다. 아리스토텔레스 철학에서 비롯된 현재의 객체지향 패러다임에서는 만약 객체들이 동일한 특성을 가진다면 그것들은 동일한 카테고리에 속한다. 객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의된다. 객체의 특성을 사물의 가장 핵심적이고 필수불가결한 ‘본질’과 그렇지 않은 ‘우연’적인 속성으로 나눌 수도 있다. 객체지향 언어에서 클래스는 객체가 공유하는 본질적인 속성을 정의한다. 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한다. 자바스크립트와 같은 프로토타입 기반의 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다. 일반화와 특수화범주의 계층중세 유럽의 카를로스 린네의 생물 분류법은 ‘계’라는 최상위 단계가 있는 중첩된 계층 구조였다. ex) 계-문-강-목-과-속-종의 분류에서 고양이종 범주는 포유류강 범주의 하위 범주에 속한다. 얼룩고양이를 실제로 알지 못하더라도 얼룩고양이에게 (포유류처럼) 척추가 있고 새끼를 낳아 기르며 젖을 먹여 새끼를 기를 것이라는 사실을 쉽게 추론할 수 있다. 린네의 분류 체계는 범주 간의 계층적인 구조를 가진다. 린네의 계층 구조에서 계층의 상위에 위치한 범주를 계층의 하위 범주의 일반화 라고 하고, 계층의 하위에 위치한 범주는 계층의 상위 범주의 특수화 라고 한다. 서브타입어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입(supertype) 이라고 하며, 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype) 이라고 한다. 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다. 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다. 아리스토텔레스의 분류법에서는 기존의 범주가 가진 속성을 새로운 범주가 포함할 경우 새로운 범주는 기존의 범주를 확장해 정의할 수 있다. 이것은 객체지향의 세계에서도 동일하게 적용된다. 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가진다. 서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들은 슈퍼타입의 속성을 공유한다. 외연의 관점에서 서브타입은 슈퍼타입의 부분집합으로 표현된다. (종 &lt; 속 &lt; 과 &lt; 목 &lt; 강 &lt; 문 &lt; 계) (린네의 분류체계에서는 ‘계’로 갈수록 슈퍼타입, ‘종’으로 갈수록 서브타입) ex) 모든 고양이는 육식동물의 집합에 포함되며, 모든 육식동물은 포유류의 집합에 포함된다. 따라서 고양이의 집합은 육식동물의 부분집합이며, 육식동물의 집합은 포유류의 부분집합이다. 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 ‘100% 규칙’ 과 ‘is-a 규칙’ 을 준수해야 한다. 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 흔히 일반화 관계를 is-a 관계라고 한다. ex) “고양이는 육식동물이다 (O)”와 “육식동물은 고양이다 (X)” → 두 가지 범주 간의 일반화 관계를 표현한다. 모든 고양이 인스턴스들은 육식동물에 해당한다. 상속일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간 상속을 사용하는 것이지만, 모든 상속 관계가 일반화 관계인 것은 아니다. 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(conformance) 해야 한다는 것이다. 이는 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다. 구조적인 순응 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다는 것이다. ex) Person이 name이라는 속성을 가진다면 Person의 서브타입인 Employee 역시 name이라는 속성을 가질 것이라고 기대할 수 있다. Employee는 Person을 대체할 수 있다. 행위적인 순응 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다. 이를 흔히 **리스코프 치환 원칙(Liskov Substitution Principle, LSP)**이라고 한다. ex) Person이 getAge()라는 메시지에 대한 응답으로 나이를 반환한다면 서브타입인 Employee 역시 getAge()라는 메시지에 대한 응답으로 나이를 반환해야 한다. 상속은 서브타이핑(subtyping) 과 서브클래싱(subclassing) 의 두 가지 용도로 사용될 수 있다. 서브타이핑 - 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 (타입을 상속) 서브클래싱 - 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있는 경우 (클래스를 상속) 123456789101112131415161718192021222324252627// 서브타이핑interface MyClass { String Name();}class A: MyClass { public String Name() { return &quot;Class name is A&quot;; }}class B: MyClass { public String Name() { return &quot;Class name is B&quot;; }}public static void PrintName(MyClass obj) { Console.WriteLine(obj.Name());}static void Main(string[] args) { MyClass objA = new A(); MyClass objB = new B(); PrintName(objA); // Class name is A PrintName(objB); // Class name is B } 123456789101112131415161718192021222324252627282930313233// 서브클래싱class A { public String Name() { return &quot;Class name is A&quot;; }}class B: A { public String Name() { return &quot;Class name is B&quot;; }}public static void PrintName(A obj) { Console.WriteLine(obj.Name());}static void Main(string[] args) { A objA = new A(); A objB = new B(); PrintName(objA); // Class name is A PrintName(objB); // Class name is A }// 클래스 상속은 부모 클래스의 코드를 재사용하기 때문에 위와 같이 슈퍼클래스의 객체를 하위클래스의 객체로 대체하더라도 하위 클래스의 행동으로 대체되어 동작하지 않는다// 메소드 재정의(method overriding)를 통해 부모 클래스의 메소드를 대체해야 한다.class B: A { public override String Name() { return &quot;Class name is B&quot;; }} 객체지향 상속의 종류: 서브클래싱과 서브타이핑 (Subclassing &amp; Subtyping) 흔히 서브타이핑을 인터페이스 상속이라고 하고, 서브클래싱을 구현 상속이라고 한다. 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation) 을 사용하는 것이다. 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로, 그리고 또 부모 클래스로 위임한다. 프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이뤄지며, 메시지 역시 위임 메커니즘에 의해 처리된다. 자식 객체와 부모 객체 사이 상속과 위임을 통해 관계를 연결한다. 집합과 분해계층적인 복잡성 복잡성은 ‘계층’의 형태를 띤다. 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 ‘안정적인 형태’의 수와 분포에 의존한다. ex) 시계는 수많은 부품이 유기적으로 결합되어 부품들 간의 계층적인 형태를 취한다. 시계를 짧은 시간 안에 효율적으로 조립하는 방법은 작은 부품으로 구성된 안정적인 형태의 중간 부품을 이용해서 조립하는 것이다. 시계는 전체적인 연쇄 계층 구조로 구성된다. 집합 - 안정적인 형태의 부분으로부터 전체를 구축하는 행위 분해 - 전체를 부분으로 분할하는 행위 집합은 전체의 내부로 불필요한 세부사항을 감춰주는 추상화 메커니즘이자 캡슐화 메커니즘이다. 집합과 분해는 한 번에 다뤄야 하는 요소의 수를 감소시킴으로써 인지 과부하를 방지한다. 인간은 은유를 통해 쉽게 추상적인 경계를 찾으며, 인위적인 집합을 창조할 수 있다. 합성 관계객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 합성 관계를 사용한다. ex) 주문 항목은 반드시 어떤 한 주문의 일부로 생성되는 전체-부분 관계이다. 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다. 이 모델을 다루는 사람은 주문 항목과 관련된 세부 사항을 무시하고 주문과 상품이 존재하는 것처럼 모델을 다룰 수 있으며, 필요하다면 주문 내부로 들어가 주문 항목과 관련된 세부 사항을 확인할 수도 있다. ex) 상품은 주문 항목의 일부가 아니다. 주문 항목과 상품 간에는 단순한 물리적 통로만 존재한다. 이를 연관 관계라고 한다. 합성 관계는 연관 관계보다 더 강하게 객체들을 결합한다. 일반적으로 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다.ex) 주문이 제거되면 주문 항목도 함께 제거된다. 반면 연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다.ex) 주문과 주문 항목이 제거되더라도 상품은 계속 판매된다. 패키지소프트웨어의 구조를 단순화하기 위해서는 서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합해야 한다. 이렇게 묶는 구성 요소를 패키지(package) 또는 **모듈(module)**이라고 한다. 패키지를 이용하면 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있으며, 함께 협력하는 응집도 높은 클래스 집합을 하나로 모아 패키지 경계 안에서 작업을 할 수 있다. 패키지는 내부의 클래스들을 추상화한다.","link":"/2022/03/26/oop-true-and-false-appendix/"},{"title":"리팩터링 1장 - 2","text":"리팩터링: 첫 번째 예시 1.6 계산 단계와 포맷팅 단계 분리하기앞서 작성한 코드를 두 단계로 나눌 것이다. statement()에 필요한 데이터를 처리하기 앞서 처리한 결과를 텍스트나 HTML로 표현하기 그 다음 함수를 추출한다. 이때 계산 관련 코드는 전부 statement() 함수로 모으고 renderPlainText()는 data 매개변수로 전달된 데이터만 처리하게 만든다. 12345678910111213141516171819function statement(invoice, plays) { const statementData = {}; // 고객 데이터, 공연 정보를 중간 데이터로 옮김 statementData.customer = invoice.customer; statementData.performances = invoice.performances; // 필요 없어진 인수 삭제 return renderPlainText(statementData, plays);}function renderPlainText(data, plays) { // ... function totalAmount() { ... } function totalVolumeCredits() { ... } function usd(aNumber) { ... } function volumeCreditsFor(aPerformance) { ... } function playFor(aPerformance) { ... } function amountFor(aPerformance) { ... }} 연극 제목도 중간 데이터 구조에서 가져온다. 123456789101112function statement(invoice, plays) { const statementData = {}; statementData.customer = invoice.customer; statementData.performances = invoice.performances.map(enrichPerformances); return renderPlainText(statementData, plays); function enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); return result; }} 이제 playFor() 함수와 amountFor() 함수를 statement()로 옮겨준다. 12345678910111213141516171819function statement(invoice, plays) { // ... function enrichPerformance(aPerformance) { const result = Object.assign({}, aPerformance); // 중간 데이터에 연극 정보를 저장 result.play = playFor(result); result.amount = amountFor(result); return result; } // renderPlainText()의 중첩 함수였던 playFor()를 statement()로 옮김 function playFor(aPerformance) { return plays[aPerformance.playID]; } function amountFor(aPerformance) { ... }} renderPlainText() 안에서 playFor()와 amountFor()를 호출하던 부분을 중간 데이터를 사용하도록 바꿔주고, 같은 방식으로 다른 중첩 함수들도 옮겨주었다. 다음으로는 반복문을 파이프라인으로 바꾼다. 123456789function totalAmount(data) { // for 반복문을 파이프라인으로 바꿈 return data.performances.reduce((total, p) =&gt; total + p.amount, 0); }function totalVolumeCredits(data) { // for 반복문을 파이프라인으로 바꿈 return data.performances.reduce((total, p) =&gt; total + p.volumeCredits, 0);} 이제 statement()에 필요한 데이터 처리에 해당하는 코드를 모두 별도 함수로 빼낸다. 123456789101112131415161718192021function statement(invoice, plays) { return renderPlainText(createStatementData(invoice, plays));}// 중간 데이터 생성을 전담function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result; function enrichPerformance(aPerformance) { ... } function playFor(aPerformance) { ... } function amountFor(aPerformance) { ... } function volumeCreditsFor(aPerformance) { ... } function totalAmount() { ... } function totalVolumeCredits() { ... }} 마지막으로, 단계별로 분리한 코드를 별도 파일에 저장한 후 HTML 버전을 작성해준다. 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨 statement.js123456789101112131415161718192021import createStatmentData from './createStatementData.js';function statement(invoice, plays) { return renderPlainText(createStatementData(invoice, plays));}function renderPlainText(data, plays) { // ...}function htmlStatement(invoice, plays) { return renderHtml(createStatementData(invoice, plays));}function renderHtml(data) { // ... }function usd(aNumber) { // ...} createStatementData.js12345678910111213141516export default function createStatementData(invoice, plays) { const result = {}; result.customer = invoice.customer; result.performances = invoice.performances.map(enrichPerformance); result.totalAmount = totalAmount(result); result.totalVolumeCredits = totalVolumeCredits(result); return result; function enrichPerformance(aPerformance) { ... } function playFor(aPerformance) { ... } function amountFor(aPerformance) { ... } function volumeCreditsFor(aPerformance) { ... } function totalAmount() { ... } function totalVolumeCredits() { ... }} 함수를 추출하면서 코드량은 많이 늘었지만, 모듈화를 통해 전체 로직을 구성하는 요소 각각이 더 뚜렷해지고 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다. 1.8 다형성을 활용해 계산 코드 재구성하기조건부 로직을 다형성으로 바꿀 수 있다. 여기서는 공연료 계산기를 만들 것이다. 공연 관련 데이터를 계산하는 함수들로 구성된 클래스를 만들어 상속 계층을 정의한다. 123456789101112function enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance); const result = Object.assign({}, aPerformance); result.play = playFor(result); // ... }class PerformanceCalculator { constructor(aPerformance) { this.performance = aPerformance }} 그리고 계산기 클래스의 생성자에 함수 선언 바꾸기를 적용하여 연극의 레코드를 계산기로 전달한다. 123456class PerformanceCalculator { constructor(aPerformance, aPlay) { this.performance = aPerformance this.play = aPlay; }} 이제 함수들을 계산기로 옮겨준다. 12345678910111213141516171819202122232425262728function enrichPerformance(aPerformance) { const calculator = new PerformanceCalculator(aPerformance, playFor(aPerformance)); const result = Object.assign({}, aPerformance); result.play = playFor(result); // amountFor() 대신 계산기의 함수 이용 result.amount = calculator.amount; // volumeCreditsFor() 대신 계산기의 함수 이용 result.volumeCredits = calculator.volumeCredits; // ... }class PerformanceCalculator { // amountFor() 함수의 코드를 계산기 클래스로 복사 get amount() { let result = 0; switch (this.play.type) { case &quot;tragedy&quot;: // ... } return result; } // volumeCreditsFor() 함수의 코드를 계산기 클래스로 복사 get volumeCredits() { ... } } 상속 받은 서브클래스들을 활용하여 공연료 계산기를 다형성 버전으로 만들어준다. 타입 코드를 서브클래스로 바꾸고, 생성자를 팩터리 함수로 바꾼다. 123456789101112131415161718function enrichPerformance(aPerformance) { // 생성자 대신 팩터리 함수 이용 const calculator = createPerformanceCalculator(aPerformance, playFor(aPerformance)); // ... }function createPerformanceCalculator(aPerformance, aPlay) { switch(aPlay.type) { case &quot;tragedy&quot;: return new TragedyCalculator(aPerformance, aPlay); case &quot;comedy&quot;: return new ComedyCalculator(aPerformance, aPlay); default: throw new Error('...'); }}class TragedyCalculator extends PerformanceCalculator { ... }class ComedyCalculator extends PerformanceCalculator { ... } 그러면 조건부 로직을 다형성으로 바꿔줄 수 있다. 123456789101112131415161718class TragedyCalculator { get amount() { // ... }}class PerformanceCalculator { get amount() { let result = 0; switch (this.play.type) { case &quot;tragedy&quot;: throw '오류 발생'; // 비극 공연료는 TragedyCalculator를 이용하도록 유도 case &quot;comedy&quot;: // ... } return result; }} 장르를 통틀어서 공통되는 부분은 일반적인 경우를 기본으로 삼아 슈퍼클래스에 남겨두고, 장르마다 달라지는 부분은 필요할 때 오버라이드하게 만들어주었다. 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기두 개의 함수 amountFor()와 volumeCreditsFor()의 조건부 로직을 생성 함수 하나로 옮겨 같은 타입의 다형성을 기반으로 실행되는 함수를 모듈화했다. 계산기가 중간 데이터 구조를 채우게 한 지금의 코드와 달리 createStatementData()가 계산기 자체를 반환하게 구현해도 되지만, 여기서는 다형성 계산기를 사용한다는 사실을 숨기기보다는 중간 데이터 구조를 이용하는 방법을 보여주는 방식으로 작성했다. 1.10 마치며이번 장에서 살펴본 리팩터링 기법들은 다음과 같다 함수 추출하기 변수 인라인하기 함수 옮기기 조건부 로직을 다형성으로 바꾸기 이번 장의 예제에서는 리팩터링을 크게 세 단계로 진행했다. 원본 함수를 중첩 함수 여러 개로 나누기 단계 쪼개기 - 계산 코드와 출력 코드를 분리했다. 계산 로직을 다형성으로 표현했다. 💡 좋은 코드를 가늠하는 확실한 방법은 ‘얼마나 수정하기 쉬운가’다. 리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.","link":"/2022/02/03/refactoring-1-2/"},{"title":"리팩터링 1장 - 1","text":"리팩터링: 첫 번째 예시 1.1 자, 시작해보자!1.2 예시 프로그램을 본 소감프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다. 1.3 리팩터링의 첫 단계 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드 마련하기 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다. 1.4 statement() 함수 쪼개기 테스트 간단한 수정도 리팩터링 후에는 항상 테스트하는 습관을 들이자 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다. 함수 추출하기 💡 자바스크립트에서는 중첩 함수를 사용하면 바깥 함수의 변수를 새로 추출한 함수에 매개변수로 전달할 필요가 없다. 추출된 함수 코드에서 보다 명확하게 표현할 수 있는 것들을 찾는다. (ex. 변수 이름) 추출된 함수의 반환 값은 result 등의 네이밍으로 통일해줄 수 있다. 임시 변수 제거하기123456789101112// 😵 badconst play = plays[perf.playID];// 😗 sosofunction playFor(aPerformance) { return plays[aPerformance.playID];}const play = playFor(perf);// 😄 good (변수 인라인하기)let thisAmount = amountFor(perf, playFor(perf)); 지역 변수를 제거하면 유효범위를 신경 썽 할 대상이 줄어들어 추출 작업이 쉬워진다 적립 포인트 계산 코드 추출하기 format 변수 제거하기 함수 선언 바꾸기 - 함수의 핵심 기능을 살려주는 네이밍으로 바꿔준다 volumeCredits 변수 제거하기 반복문 쪼개기 로직에 따라 별도의 for문으로 분리한다 반복문을 쪼개서 발생하는 중복은 성능에 미치는 영향이 미미하다 💡 리팩터링으로 인한 성능 문제는 “특별한 경우가 아니라면 일단 무시하자” 문장 슬라이드하기 volumeCredits 값 갱신과 관련한 문장들을 한데 모은다 임시 변수를 질의 함수로 바꾸기가 수월해진다 1.5 중간 점검: 난무하는 중첩 함수","link":"/2022/01/29/refactoring-1-1/"},{"title":"리팩터링 10장 - 2","text":"조건부 로직 간소화 - 2 10.5 특이 케이스 추가하기코드베이스에서 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이라면 그 반응들을 한 데로 모으는 게 효율적이다. 이때 특수한 경우의 공통 동작을 요소 하나에 모아서 사용하는 특이 케이스 패턴을 사용한다. 절차리팩터링의 대상이 될 속성을 담은 데이터 구조(혹은 클래스)를 컨테이너라고 한자. 컨테이너에 특이 케이스인지를 검사하는 속성을 추가하고, false를 반환하게 한다. 특이 케이스 객체를 만든다. 이 객체는 특이 케이스인지를 검사하는 속성만 포함하며, 이 속성은 true를 반환하게 한다. 클라이언트에서 특이 케이스인지를 검사하는 코드를 함수로 추출한다. 모든 클라이언트가 값을 직접 비교하는 대신 방금 추출한 함수를 사용하도록 고친다. 코드에 새로운 특이 케이스 대상을 추가한다. 함수의 반환 값으로 받거나 변환 함수를 적용하면 된다. 특이 케이스를 검사하는 함수 본문을 수정하여 특이 케이스 객체의 속성을 사용하도록 한다. 테스트한다. 여러 함수를 클래스로 묶기나 여러 함수를 변환 함수로 묶기를 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다. 아직도 특이 케이스 검사 함수를 이용하는 곳이 남아 있다면 검사 함수를 인라인한다. 예시: 클래스12345678910class Site { get customer() { return this._customer; }}class Customer { get name() { ... } get billingPlan() { ... } set billingPlan(arg) { ... } get paymentHistory() { ... }} 1234567891011121314151617181920212223// 클라이언트 1const aCustomer = site.customer;let customerName;if (aCustomer === &quot;미확인 고객&quot;) { customerName = &quot;거주자&quot;;} else { customerName = aCustomer.name;}// 클라이언트 2const plan = (aCustomer === &quot;미확인 고객&quot;) ? registry.billingPlans.basic : aCustomer.billingPlans;// 클라이언트 3if (aCustomer !== &quot;미확인 고객&quot;) { aCustomer.billingPlan = newPlan;}// 클라이언트 4const weekDelinquent = (aCustomer === &quot;미확인 고객&quot;) ? 0 : aCustomer.paymentHistory.weeksDelinquentInLastYear; 클라이언트들은 알려지지 않은 “미확인 고객” 필드를 처리해야 한다. 123456789101112131415161718192021222324252627282930313233343536373839404142class Site { get customer() { return (this._customer === &quot;미확인 고객&quot;) ? new UnknownCustomer() : this._customer; }}class Customer { get isUnknown() { return false; }}class UnknownCustomer { get isUnknown() { return true; } get name() { return &quot;거주자&quot; } get billingPlan() { return registry.billingPlans.basic; } set billingPlan(arg) { // ... }}function isUnknown(arg) { if (!(arg instanceof Customer || arg instanceof UnknownCustomer)) { throw new Error(`잘못된 값과 비교: &lt;${arg}&gt;`); } return arg.isUnknown;}// 클라이언트 (읽는 경우)const plan = aCustomer.billingPlan;// 클라이언트 (쓰는 경우)aCustomer.billingPlan = newPlan; 12345678class NullPaymentHistory { get weeksDelinquentInLastYear() { return 0; }}// 클라이언트 4const weekDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear; 예시: 객체 리터럴123456789101112131415161718192021222324252627282930313233343536373839class Site { get customer() { return (this._customer === &quot;미확인 고객&quot;) ? createUnknownCustomer() : this._customer; }}class Customer { get name() { ... } get billingPlan() { ... } set billingPlan(arg) { ... } get paymentHistory() { ... } get isUnknown() { return false; }}function createUnknownCustomer() { return { isUnknown: true, name: &quot;거주자&quot;, billingPlan: registry.billingPlans.basic, paymentHistory: { weeksDelinquentInLastYear: 0, } }} function isUnknown(arg) { return arg.isUnknown;}// 클라이언트 1customerName = aCustomer.name;// 클라이언트 2const plan = aCustomer.billingPlans;// 클라이언트 3const weekDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear; 예시: 변환 함수(생략) 10.6 어서션 추가하기특정 조건이 참일 때만 제대로 동작하는 코드 영역이 있을 수 있다. 어서션을 이용하면, 코드 자체에 필요한 가정을 항상 명시적으로 기술할 수 있다. 어서션은 항상 참이라고 가정하는 조건부 문장으로, 어서션이 실패했다는 건 프로그래머가 잘못했다는 뜻이다. 어서션은 오류 찾기에 활용될 뿐 아니라, 프로그램이 어떤 상태임을 가정한 채 실행되는지를 다른 개발자에게 알려주는 훌륭한 소통 도구다. 절차 참이라고 가정하는 조건이 보이면 그 조건을 명시하는 어서션을 추가한다. 예시1234567class Customer { applyDiscount(aNumber) { return (this.discountRate) ? aNumber - (this.discountRate * aNumber) : aNumber; }} 이 코드에는 할인율이 항상 양수라는 가정이 깔려 있다. 1234567891011121314class Customer { applyDiscount(aNumber) { if (!this.discountRate) return aNumber; else { assert(this.discountRate &gt;= 0); return aNumber - (this.discountRate * aNumber); } } set discountRate(aNumber) { assert(null === aNumber || aNumber &gt;= 0); this._discountRate = aNumber; }} 이런 어서션은 오류의 출처를 특정하기 어려울 때 특히 제값을 한다. 10.7 제어 플래그를 탈출문으로 바꾸기제어 플래그란 코드의 동작을 변경하는 데 사용되는 변수를 말하며, 어딘가에서 값을 계산해 제어 플래그에 설정한 후 다른 어딘가의 조건문에서 검사하는 형태로 쓰인다. 제어 플래그는 리팩터링으로 충분히 간소화할 수 있다. 제어 플래그의 주 서식지는 반복문 안으로, 주로 return, break, continue와 함께 사용된다. 절차 제어 플래그를 사용하는 코드를 함수로 추출할지 고려한다. 제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 바꾼다. 하나 바꿀 때마다 테스트한다. 모두 수정했다면 제어 플래그를 제거한다. 예시1234567891011121314// beforelet found = false;for (const p of people) { if (!found) { if (p === &quot;조커&quot;) { sendAlert(); found = true; } if (p === &quot;사루만&quot;) { sendAlert(); found = true; } }} 123456789101112131415// after checkForMiscreants(people);function checkForMiscreants(people) { for (const p of people) { if (p === &quot;조커&quot;) { sendAlert(); return; } if (p === &quot;사루만&quot;) { sendAlert(); return; } }}","link":"/2022/05/06/refactoring-10-2/"},{"title":"리팩터링 10장 - 1","text":"조건부 로직 간소화 - 1 10.1 조건문 분해하기복잡한 조건부 로직은 프로그램을 복잡하게 만든다. 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수 호출로 바꿔주면 전체적인 의도가 더 확실히 드러난다. 절차 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출한다. 예시123456// beforeif (!aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd)) { charge = quantity * plan.summerRate;} else { charge = quantity * plan.regularRate + plan.regularServiceCharge;} 123456789101112131415161718// after if (summer()) { charge = summerCharge();} else { charge = quantity * plan.regularRate + plan.regularServiceCharge;}function summer() { return !aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd);}function summerCharge() { return quantity * plan.summerRate;}function regularcharge() { return quantity * plan.regularRate + plan.regularServiceCharge;} 10.2 조건식 통합하기비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 있다면 조건 검사도 하나로 통합하는 것이 좋다. ‘and’ 연산자와 ‘or’ 연산자를 사용하면 여러 개의 비교 로직을 하나로 합칠 수 있다. 조건부 코드를 통합하는 것이 중요한 이유는 두 가지다. 여러 조각으로 나뉜 조건들을 하나로 통합함으로써 내가 하려는 일이 더 명확해진다. 복잡한 조건식을 함수로 추출하면 코드의 의도가 훨씬 분명하게 드러난다. 절차 해당 조건식들 모두에 부수효과가 없는지 확인한다. 조건문 두 개를 선택하여 두 조건문의 조건식들을 논리 연산자로 결합한다. 테스트한다. 조건이 하나만 남을 때까지 2~3 과정을 반복한다. 하나로 합쳐진 조건식을 함수로 추출할지 고려해본다. 예시: or 사용하기123456// beforefunction disabilityAmount(anEmployee) { if (anEmployee.seniority &lt; 2) return 0; if (anEmployee.monthDisabled &gt; 12) return 0; if (anEmployee.isPartTime) return 0;} 12345678910// after function disabilityAmount(anEmployee) { if (isNotEligibleForDisability()) return 0;}function isNotEligibleForDisability() { return ((anEmployee.seniority &lt; 2) || (anEmployee.monthDisabled &gt; 12) || (anEmployee.isPartTime));} 10.3 중첩 조건문을 보호 구문으로 바꾸기조건문은 주로 두 가지 형태로 쓰인다. 참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태와, 한쪽만 정상인 형태다. 두 경로 모두 정상 동작이라면 if와 else 절을 사용한다. 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나온다. 두 번째 검사 형태를 흔히 보호 구문(guard clause) 이라고 한다. 중첩 조건문을 보호 구문으로 바꾸는 리팩터링의 핵심은 의도 부각에 있다. if-then-else 구조를 사용할 때는 if와 else절에 똑같은 무게를 두어, 코드를 읽는 이에게 양 갈래가 똑같이 중요하다는 뜻을 전달한다. 반면, 보호 구문은 이 일이 일어나면 무언가 조치를 취한 후 함수에서 빠져나온다는 것을 알 수 있어야 한다. 절차 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꾼다. 테스트한다. 1~2 과정을 필요한 만큼 반복한다. 모든 보호 구문이 같은 결과를 반환한다면 보호 구문들의 조건식을 통합한다. 예시123456789101112131415161718// beforefunction payAmount(employee) { let result; if (employee.isSeparated) { // 퇴사한 직원인가? result = { amount: 0, reasonCode: &quot;SEP&quot; }; } else { if (employee.isRetired) { // 은퇴한 직원인가? result = { amount: 0, reasonCode: &quot;RET&quot; }; } else { // 급여 계산 로직 lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).edit(); sed.do.eusmod = tempor.incididunt.ut(labore) &amp;&amp; dolore(magna.aliqua); ut.enim.ad(minim.veniam); result = someFinalComputation(); } }} 1234567891011// afterfunction payAmount(employee) { if (employee.isSeparated) return { amount: 0, reasonCode: &quot;SEP&quot; }; if (employee.isRetired) return { amount: 0, reasonCode: &quot;RET&quot; }; // 급여 계산 로직 lorem.ipsum(dolor.sitAmet); consectetur(adipiscing).edit(); sed.do.eusmod = tempor.incididunt.ut(labore) &amp;&amp; dolore(magna.aliqua); ut.enim.ad(minim.veniam); return someFinalComputation(); } 10.4 조건부 로직을 다형성으로 바꾸기복잡한 조건부 로직을 클래스와 다형성을 이용하여 분리할 수 있다. 타입을 여러 개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 처리하도록 구성하는 방법이 있다. 또는 기본 동작을 위한 case문과 그 변형 동작으로 구성된 로직을 떠올릴 수 있다. 기본 동작 로직을 슈퍼클래스로 넣고, 변형 동작을 뜻하는 case들을 각각의 서브클래스로 만든다. 절차 다형적 동작을 표현하는 클래스들이 아직 없다면 만들어준다. 팩터리 함수도 함께 만들면 좋다. 호출하는 코드에서 팩터리 함수를 사용하게 한다. 조건부 로직 함수를 슈퍼클래스로 옮긴다. 서브클래스 중 하나를 선택하여, 슈퍼클래스의 조건부 로직 메서드를 오버라이드한다. 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다. 슈퍼클래스 메서드에는 기본 동작 부분만 남긴다. 예시123456789101112131415161718192021222324252627282930// beforefunction plumages(birds) { return new Map(birds.map(b =&gt; [b.name, plumage(b)]));}function speeds(birds) { return new Map(birds.map(b =&gt; [b.name, airSpeedVelocity(b)]));}function plumage(bird) { switch (bird.type) { case '유럽 제비': return &quot;보통이다&quot;; case '아프리카 제비': return (bird.numberOfCoconuts &gt; 2) ? &quot;지쳤다&quot; : &quot;보통이다&quot;; default: return &quot;알 수 없다&quot;; }}function airSpeedVelocity(bird) { switch (bird.type) { case '유럽 제비': return 35; case '아프리카 제비': return 40 - 2 * bird.numberOfCoconuts; default: return null; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// afterfunction plumages(birds) { return new Map(birds .map(b =&gt; createBird(b)) .map(bird =&gt; [bird.name, bird.plumage]));}function speeds(birds) { return new Map(birds .map(b =&gt; createBird(b)) .map(bird =&gt; [bird.name, bird.airSpeedVelocity])); }class Bird { constructor(birdObject) { Object.assign(this, birdObject); } get plumage() { return &quot;알 수 없다&quot;; } get airSpeedVelocity() { return null; }}class EuropeanSwallow extends Bird { get plumage() { return &quot;보통이다&quot;; } get airSpeedVelocity() { return 35; }}class AfricanSwallow extends Bird { get plumage() { return (this.numberOfCoconuts &gt; 2) ? &quot;지쳤다&quot; : &quot;보통이다&quot;; } get airSpeedVelocity() { return 40 - 2 * this.numberOfCoconuts; }}function createBird(bird) { switch (this.type) { case '유럽 제비': return new EuropeanSwallow(bird); case '아프리카 제비': return new AfricanSwallow(bird); default: return new Bird(bird); }}","link":"/2022/04/26/refactoring-10-1/"},{"title":"리팩터링 11장 - 1","text":"API 리팩터링 - 1 11.1 질의 함수와 변경 함수 분리하기겉보기 부수효과가 있는 함수와 없는 함수는 명확히 구분하는 것이 좋다. 질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다. 이를 ‘명령-질의 분리’라고도 한다. 절차 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다. 새 질의 함수에서 부수효과를 모두 제거한다. 정적 검사를 수행한다. 원래 함수(변경 함수)를 호출하는 곳을 모두 찾아낸다. 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가한다. 하나 수정할 때마다 테스트한다. 원래 함수에서 질의 관련 코드를 제거한다. 테스트한다. 예시1234567891011121314// beforefunction alertForMiscreant(people) { for (const p of people) { if (p === &quot;조커&quot;) { setOffAlarms(); // 변경 함수 return &quot;조커&quot;; // 질의 함수 } if (p === &quot;사루만&quot;) { setOffAlarms(); return &quot;사루만&quot;; } } return &quot;&quot;;} 1234567891011121314151617181920212223242526272829// afterfunction findMiscreant(people) { for (const p of people) { if (p === &quot;조커&quot;) { return &quot;조커&quot;; } if (p === &quot;사루만&quot;) { return &quot;사루만&quot;; } } return &quot;&quot;;}const found = findMiscreant(people);alertForMiscreant(people);function alertForMiscreant(people) { for (const p of people) { if (p === &quot;조커&quot;) { setOffAlarms(); return; } if (p === &quot;사루만&quot;) { setOffAlarms(); return; } } return;} 11.2 함수 매개변수화하기두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다. 절차 비슷한 함수 중 하나를 선택한다. 함수 선언 바꾸기로 리터럴들을 매개변수로 추가한다. 이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한다. 테스트한다. 매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다. 하나 수정할 때마다 테스트한다. 예시123456789101112131415161718192021// beforefunction baseCharge(usage) { if (usage &lt; 0) return usd(0); const amount = bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07; return usd(amount);}function bottomBand(usage) { return Math.min(usage, 100);}function middleBand(usage) { return usage &gt; 100 ? Math.min(usage, 200) - 100 : 0;}function topBand(usage) { return usage &gt; 200 ? usage - 200 : 0;} 12345678910111213// afterfunction withinBand(usage, bottom, top) { return usage &gt; bottom ? Math.min(usage, top) - bottom : 0;}function baseCharge(usage) { if (usage &lt; 0) return usd(0); const amount = withinBand(usage, 0, 100) * 0.03 + withinBand(usage, 100, 200) * 0.05 + withinBand(usage, 200, Infinity) * 0.07; return usd(amount);} 11.3 플래그 인수 제거하기플래그 인수란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다. 123456789function bookConcert(aCustomer, isPremium) { if (isPremium) { // 프리미엄 예약용 로직 } else { // 일반 예약용 로직 }}bookConcert(aCustomer, true); 플래그 인수를 사용하면, 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기 어려워진다. 플래그 인수가 있으면 함수들의 기능 차이가 잘 드러나지 않는다. 플래그 인수를 제거하면 코드가 깔끔해짐은 물론 프로그래밍 도구에도 도움을 준다. 코드 분석 도구는 프리미엄 로직 호출과 일반 로직 호출의 차이를 더 쉽게 파악할 수 있게 된다. 절차 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성한다. 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다. 예시1234567891011// beforeaShipment.deliveryDate = deliveryDate(anOrder, true);aShipment.deliveryDate = deliveryDate(anOrder, false);function deliveryDate(anOrder, isRush) { if (isRush) { // rush일 때 호출할 로직 } else { // rush가 아닐 때 호출할 로직 }} 1234567891011// afterfunction rushDeliveryDate(anOrder) { // rush일 때 호출할 로직}function regularDeliveryRate(anOrder) { // rush가 아닐 때 호출할 로직}aShipment.deliveryDate = rushDeliveryDate(anOrder);aShipment.deliveryDate = regularDeliveryRate(anOrder); 11.4 객체 통째로 넘기기레코드를 통째로 넘기면 변화에 대응하기 쉽다. 함수가 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다. 그리고 매개변수 목록이 짧아져서 일반적으로는 함수 사용법을 이해하기 쉬워진다. 하지만 함수가 레코드 자체에 의존하기를 원치 않을 때, 특히 레코드와 함수가 서로 다른 모듈에 속한 상황이라면 이 리팩터링을 수행하지 않는다. 한편, 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출할 수도 있다. 절차 매개변수들을 원하는 형태로 받는 빈 함수를 만든다. 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다. 정적 검사를 수행한다. 모든 호출자가 새 함수를 사용하게 수정한다. 하나씩 수정하며 테스트하자. 호출자를 모두 수정했다면 원래 함수를 인라인한다. 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영한다. 예시일일 최저/최고 기온이 난방 계획에서 정한 범위를 벗어나는지 확인하는 실내온도 모니터링 시스템을 생각해보자. 1234567891011const low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;if (!aPlan.withinRange(low, high)) { alerts.push(&quot;방 온도가 지정 범위를 벗어났습니다.&quot;);}// HeatingPlan 클래스withinRange(bottom, top) { return (bottom &gt;= this._temperatureRange.low) &amp;&amp; (top &lt;= this._temperatureRange.high);} 최저/최고 기온을 뽑아내어 인수로 건내는 대신 범위 객체를 통째로 건넬 수도 있다. 123456789// HeatingPlan 클래스withinRange(aNumberRange) { return (aNumberRange.low &gt;= this._temperatureRange.low) &amp;&amp; (aNumberRange.high &lt;= this._temperatureRange.high);}if (!aPlan.withinRange(aRoom.daysTempRange)) { alerts.push(&quot;방 온도가 지정 범위를 벗어났습니다.&quot;);} 11.5 매개변수를 질의 함수로 바꾸기매개변수 목록은 함수의 동작에 변화를 줄 수 있는 일차적인 수단이다. 매개변수 목록은 중복은 피하는 게 좋으며 짧을수록 이해하기 쉽다. 피호출 함수가 스스로 ‘쉽게’ 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다. 호출하는 쪽은 간소하게 만드는 것이 좋다. 즉, 책임 소재를 피호출 함수로 옮긴다. 매개변수 제거 시 피호출 함수에 원치 않는 의존성이 생긴다면 매개변수를 질의 함수로 바꾸지 말아야 한다. 제거하려는 매개변수의 값을 다른 매개변수에 질의해서 얻을 수 있다면 안심하고 질의 함수로 바꿀 수 있다. 이때 대상 함수가 참조 투명해야 한다. 즉, 함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작해야 한다. 절차 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출해놓는다. 함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현식을 참조하도록 바꾼다. 하나 수정할 때마다 테스트한다. 함수 선언 바꾸기로 대상 매개변수를 없앤다. 예시1234567891011121314151617// beforeclass Order { get finalPrice() { const basePrice = this.quantity * this.itemPrice; let discountLevel; if (this.quantity &gt; 100) discountLevel = 2; else discountLevel = 1; return this.discountedPrice(basePrice, discountLevel); } discountedPrice(basePrice, discountLevel) { switch (discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }} 123456789101112131415161718// afterclass Order { get finalPrice() { const basePrice = this.quantity * this.itemPrice; return this.discountedPrice(basePrice); } get discountLevel() { return (this.quantity &gt; 100) ? 2 : 1; } discountedPrice(basePrice) { switch (this.discountLevel) { case 1: return basePrice * 0.95; case 2: return basePrice * 0.9; } }} 11.6 질의 함수를 매개변수로 바꾸기함수 안에서 전역 변수를 참조한다거나, 제거하길 원하는 원소를 참조하는 경우가 있다. 이때는 해당 참조를 매개변수로 바꿔 해결할 수 있다. 참조를 풀어내는 책임을 호출자로 옮기는 것이다. 이런 상황 대부분은 코드의 의존 관계를 바꾸려 할 때, 예컨대 대상 함수가 더 이상 (매개변수화하려는) 특정 원소에 의존하길 원치 않을 때 일어난다. 이 리팩터링의 단점은, 호출자가 복잡해진다는 것이다. 이 문제는 결국 책임 소재를 프로그램의 어디에 배정하느냐의 문제로 귀결되는 것으로, 항상 정답이 있는 것은 아니다. 절차 변수 추출하기로 질의 코드를 함수 본문의 나머지 코드와 분리한다. 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도 함수로 추출한다. 방금 만든 변수를 인라인하여 제거한다. 원래 함수도 인라인한다. 새 함수의 이름을 원래 함수의 이름으로 고쳐준다. 예시1234567891011// HeatingPlan 클래스get targetTemperature() { if (thermostat.selectedTemperature &gt; this._max) return this._max; else if (thermostat.selectedTemperature &lt; this._min) return this._min; else return thermostat.selectedTemperature;}// 호출자if (thePlan.targetTemperature &gt; thermostat.currentTemperature) setToHeat();else if (thePlan.targetTemperature &lt; thermostat.currentTemperature) setToCool();else setOff(); targetTemperature() 메서드와 전역 객체인 thermostat사이의 의존성을 끊어보자. 1234567891011// HeatingPlan 클래스targetTemperature(selectedTemperature) { if (selectedTemperature &gt; this._max) return this._max; else if (selectedTemperature &lt; this._min) return this._min; else return selectedTemperature;}// 호출자if (thePlan.targetTemperature(thermostat.selectedTemperature) &gt; thermostat.currentTemperature) setToHeat();else if (thePlan.targetTemperature(thermostat.selectedTemperature) &lt; thermostat.currentTemperature) setToCool();else setOff(); targetTemperature() 메서드와 전역 객체인 thermostat사이의 결합을 제거했을 뿐 아니라, HeatingPlan 클래스를 불변으로 만들었다. 모든 필드가 생성자에서 설정되며, 필드를 변경할 수 있는 메서드는 없다.","link":"/2022/05/14/refactoring-11-1/"},{"title":"리팩터링 11장 - 2","text":"API 리팩터링 - 2 11.7 세터 제거하기세터 메서드가 있다는 것은 필드가 수정될 수 있다는 뜻이다. 객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않았을 것이다. 세터 제거하기 리팩터링이 필요한 상황은 주로 두 가지다. 첫째, 사람들이 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때다. 두 번째는 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때다. 절차 설정해야 할 값을 생성자에서 받지 않는다면 그 값을 받을 매개변수를 생성자에 추가한다. 그런 다음 생성자 안에서 적절한 세터를 호출한다. 생성자 밖에서 세터를 호출하는 곳을 찾아 제거하고, 대신 새로운 생성자를 사용하도록 한다. 세터 메서드를 인라인한다. 가능하다면 해당 필드를 불변으로 만든다. 예시123456789101112// beforeclass Person { // ... get name() { return this._name; } set name(arg) { this._name = arg; } get id() { return this._id; } set id(arg) { this._id = arg; }}const martin = new Person();martin.name = &quot;마틴&quot;;margin.id = &quot;1234&quot;; id 필드는 객체를 생성한 뒤에 변경되면 안 된다. 생성자를 통해 id 를 설정하게끔 수정한다. 12345678910// afterclass Person { constructor(id) { this.id = id; } // ... }const martin = new Person(&quot;1234&quot;);martin.name = &quot;마틴&quot;; 11.8 생성자를 팩터리 함수로 바꾸기생성자에는 이상한 제약이 따라붙기도 한다. 자바 생성자는 반드시 생성자를 정의한 클래스의 인스턴스를 반환해야 한다. 생성자의 이름도 고정되며, 생성자를 호출하려면 특별한 연산자(new)를 사용해야 한다. 팩터리 함수에는 이런 제약이 없다. 절차 팩터리 함수를 만든다. 팩터리 함수의 본문에서는 원래의 생성자를 호출한다. 생성자를 호출하던 코드를 팩터리 함수 호출로 바꾼다. 하나씩 수정할 때마다 테스트한다. 생성자의 가시 범위가 최소가 되도록 제한한다. 예시1234567891011121314151617// beforeclass Employee { constructor(name, typeCode) { this._name = name; this._typeCode = typeCode; } get name() { return this._name; } get type() { return Employee.legalTypeCodes[this._typeCode]; } static get legalTypeCodes() { return { &quot;E&quot;: &quot;Engineer&quot;, &quot;M&quot;: &quot;Manager&quot;, &quot;S&quot;: &quot;Salesperson&quot; }; }}const leedEngineer = new Employee(document.leadEngineer, 'E'); 123456// afterfunction createEmployee(name) { return new Employee(name, 'E');}const leedEngineer = createEmployee(document.leadEngineer); 11.9 함수를 명령으로 바꾸기함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 ‘명령 객체’ 혹은 단순히 ‘명령’이라 한다. 명령 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다. 명령은 평범한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다. 그러나 명령을 사용해 유연성을 얻더라도 복잡성이 커질 수 있다. 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요할 때만 명령을 선택한다. 절차 대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스 이름은 함수 이름에 기초해 짓는다. 방금 생성한 빈 클래스로 함수를 옮긴다. 함수의 인수들 각각은 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다. 예시1234567891011121314151617181920// before function score(candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; let highMedicalRiskFlag = false; if (medicalExam.isSmoker) { healthLevel += 10; highMedicalRiskFlag = true; } let certificationGrade = &quot;regular&quot;; if (scoringGuide.stateWithLowCertification(candidate.originState)) { certificationGrade = &quot;low&quot;; result -= 5; } // ... result -= Math.max(healthLevel - 5, 0); return result;} 123456789101112131415161718192021222324252627282930313233343536// afterfunction score(candidate, medicalExam, scoringGuide) { return new Scorer(candidate, medicalExam, scoringGuide).execute();}class Scorer { constructor(candidate, medicalExam, scoringGuide) { this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; } execute(medicalExam, scoringGuide) { this._result = 0; this._healthLevel = 0; this._highMedicalRiskFlag = false; this.scoreSmoking(); this._certificationGrade = &quot;regular&quot;; if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) { this._certificationGrade = &quot;low&quot;; this._result -= 5; } // ... result -= Math.max(this._healthLevel - 5, 0); return result; } scoreSmoking() { if (this._medicalExam.isSmoker) { this._healthLevel += 10; this._highMedicalRiskFlag = true; } }} 11.10 명령을 함수로 바꾸기명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공하지만, 로직이 크게 복잡하지 않다면 명령 객체는 평범한 함수로 바꿔주는 게 낫다. 절차 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 함수로 추출한다. 명령의 실행 함수가 호출하는 보조 메서드 각각을 인라인한다. 함수 선언 바꾸기를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다. 명령의 실행 메서드에서 참조하는 필드들 대신 대응하는 매개변수를 사용하게끔 바꾼다. 생성자 호출과 명령의 실행 메서드 호출을 호출자(대체 함수) 안으로 인라인한다. 죽은 코드 제거하기로 명령 클래스를 없앤다. 예시123456789101112131415161718// beforeclass ChargeCalculator { constructor(customer, usgae, provider) { this._customer = customer; this._usage = usage; this._provider = provide; } get baseCharge() { return this._customer.baseRate * this._usage; } get charge() { return this.baseCharge + this._provider.connectionCharge; }}const monthCharge = new ChargeCalculator(customer, usage, provider).charge; 1234567// afterfunction charge(customer, usage, provider) { const baseCharge = customer.baseRate * usgae; return baseCharge + provider.connectionCharge;}const monthCharge = charge(customer, usage, provider); 11.11 수정된 값 반환하기데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다. 데이터가 수정됨을 알려주는 방법 중 하나는, 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다. 절차 함수가 수정된 값을 반환하게 하여 호출자가 그 값을 자신의 변수에 저장하게 한다. 피호출 함수 안에 반환할 값을 가리키는 새로운 변수를 선언한다. 계산이 선언과 동시에 이뤄지도록 통합한다. (즉, 선언 시점에 계산 로직을 바로 실행해 대입한다.) 피호출 함수의 변수 이름을 새 역할에 어울리도록 바꿔준다. 12345678910// beforelet totalAscent = 0;calculateAscent();function calculateAscent() { for (let i = 1; i &lt; points.length; i++) { const verticalChagne = points[i].elevation - points[i - 1].elevation; totalAscent += (verticalChange &gt; 0) ? verticalChange : 0; }} calculateAscent() 안에서 totalAscent 가 갱신된다는 사실이 드러나지 않는다. 1234567891011// afterconst totalAscent = calculateAscent();function calculateAscent() { let result = 0; for (let i = 1; i &lt; points.length; i++) { const verticalChagne = points[i].elevation - points[i - 1].elevation; result += (verticalChange &gt; 0) ? verticalChange : 0; } return result;} 11.12 오류 코드를 예외로 바꾸기예외는 프로그래밍 언어에서 제공하는 독립적인 오류 처리 메커니즘으로, 예외가 던져지면 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다. 예외는 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다. 예외를 던지는 코드를 프로그램 종료 코드로 바꿔도 프로그램은 여전히 정상 동작 해야한다. 정상 동작하지 않을 것 같다면, 예외 대신 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리해야 한다. 절차 콜스택 상위에 해당 예외를 처리할 예외 핸들러를 작서한다. 해당 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾는다. 정적 검사를 수행한다. catch절을 수정하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던진다. 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정한다. 모두 수정했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거한다. 예시123456// beforefunction localShippingRules(country) { const data = countryData.shippingRules[country]; if (data) return new ShippingRules(data); else return -23;} 이 코드는 국가 정보(country)가 유효한지를 이 함수 호출 전에 다 검증했다고 가정한다. 이 함수에서 오류가 난다면 무언가 잘못됐음을 뜻한다. 123456789// beforefunction calculateShippingCosts(anOrder) { // ... const shippingRules = localShippingRules(anOrder.country); if (shippingRules &lt; 0) return shippingRules; // 오류 전파}const status = calculateShippingCosts(orderData);if (status &lt; 0) errorList.push({ order: orderData, errorCode: status }); 1234567891011121314151617181920212223242526272829// afterfunction localShippingRules(country) { const data = countryData.shippingRules[country]; if (data) return new ShippingRules(data); else throw new OrderProcessingError(-23);}function calculateShippingCosts(anOrder) { // ... const shippingRules = localShippingRules(anOrder.country);}try { calculateShippingCosts(orderData);} catch (e) { if (e instanceof OrderProcessingError) { errorList.push({ order: orderData, errorCode: e.code }); } else { throw e; }}class OrderProcessingError extends Error { constructor(errorCode) { super(`주문 처리 오류: ${errorCode}`); this.code = errorCode; } get name() { return &quot;OrderProcessingError&quot; };} 11.13 예외를 사전확인으로 바꾸기함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다. 절차 예외를 유발하는 상황을 검사할 수 있는 조건문을 추가한다. catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고, 남은 try 블록의 코드를 다른 조건절로 옮긴다. catch 블록에 어서션을 추가하고 테스트한다. try문과 catch 블록을 제거한다. 예시(자바)123456789101112131415// ResourcePool 클래스...public Resource get() { Resource result; try { result = available.pop(); allocated.add(result); } catch (NoSuchElementException e) { result = Resource.create(); allocated.add(result); } return result;}private Deque&lt;Resource&gt; available;private List&lt;Resource&gt; allocated; 풀에서 자원이 고갈되는 건 예상치 못한 조건이 아니다. 사용하기 전에 allocated 컬렉션의 상태를 쉽게 확인할 수 있다. 12345678910111213// ResourcePool 클래스...public Resource get() { Resource result; if (available.isEmpty()) { result = Resource.create(); allocated.add(result); } else { result = available.pop(); allocated.add(result); } return result;}","link":"/2022/05/19/refactoring-11-2/"},{"title":"리팩터링 2장","text":"리팩터링 원칙 2.1 리팩터링 정의리팩터링의 사전적 정의는 다음과 같다. 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 리팩터링은 “재구성” 의 특수한 한 형태다. 단계를 작게 나눔으로써 구성을 체계화할 수 있고, 디버깅 시간을 단축할 수 있다. 리팩터링을 하더라도 사용자 관점에서는 달라지는 점이 없어야 한다. 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다. 리팩터링은 성능 최적화와 비슷하다. 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 2.2 두 개의 모자켄트 백은 소프트웨어 개발의 목적을 ‘기능 추가’ 또는 ‘리팩터링’ 으로 나누고, 이를 두 개의 모자라고 명명한다. ‘기능 추가’ 시에는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 반면 ‘리팩터링’ 시에는 기능 추가는 절대 하지 말아야 한다. (테스트도 새로 만들지 않는다) 2.3 리팩터링하는 이유 리팩터링하면 소프트웨어 설계가 좋아진다리팩터링하지 않으면 코드 구조가 무너지고, 설계를 유지하기 어려워지고, 더욱 빨리 부패한다. 중복 코드를 제거하여 코드량을 줄인다고 시스템이 빨라지는 것은 않지만, 수정하는 데 드는 노력과 이해해야할 코드량이 크게 줄어든다. 리팩터링하면 소프트웨어를 이해하기 쉬워진다다른 사람이 내 코드를 이해할 수 있도록 작성해야 한다. 리팩터링은 코드가 더 잘 읽히게 도와준다. 코드의 목적이 더 잘 드러나게, 내 의도를 더 명확하게 전달하도록 개선할 수 있다. 뿐만 아니라, 추후에 나 자신이 코드를 다시 봤을 때 이해하기도 쉬워진다. 리팩터링하면 프로그래밍 속도를 높일 수 있다내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.저자는 이를 ‘지구력 가설’ 이라고 부른다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다. 2.4 언제 리팩터링해야 하까?✔️ 3의 법칙 (1) 처음에는 그냥 한다. (2) 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다. (3) 비슷한 일을 세 번째 하게 되면 리팩터링한다. ✔️ 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다. 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다. 버그를 잡을 때도 마찬가지다. 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄여준다. ✔️ 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 창아본다. ✔️ 쓰레기 줍기 리팩터링 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다. ✔️ 코드 리뷰에 리팩터링 활용하기 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋으며, 다른 사람의 아이디어를 얻을 수 있다. 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 된다. 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다. 내가 떠올린 아이디어를 실제로 적용했을 때의 모습을 더 명확하게 볼 수 있다. cf) 짝 프로그래밍 ✔️ 관리자에게는 뭐라고 말해야 할까? “리팩터링한다고 말하지 말라”. 구체적인 방법은 개발자가 판단해야 한다. 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. ✔️ 리팩터링하지 말아야 할 때 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다. 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다. 이 결정에는 뛰어난 판단력과 경험이 뒷받침되어야 한다. 2.5 리팩터링 시 고려할 문제✔️ 새 기능 개발 속도 저하 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다. 균형점을 잡아야 한다. 준비를 위한 리팩터링이라면 주저하지 않고 시작한다. 반면 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는다. 코드베이스를 건강하게 만드는 것에 대해 팀원들에게 공감대를 형성해야 한다. 그러나 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 것이 아니며, 오로지 경제적인 이유다. 리팩터링은 개발 기간을 단축하고자 하는 것이다. ✔️ 코드 소유권 리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다. 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 하지만 제약이 따르더라도 리팩터링을 해야 한다. 저자가 선호하는 방식은 코드의 소유권을 팀에 두는 것이다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다. ✔️ 브랜치 브랜치-마스터를 사용하는 방식은 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다는 단점이 있다. 기능별 브랜치의 통합 주기는 짧게 관리해야 한다. 이 방식을 지속적 통합(CI; Continuous Integratin), 또는 트렁크 기반 개발(TBD; Trunk-Based Development)이라 한다. CI는 코드 전반에 거쳐 자잘하게 수정해야 하는 경우가 많을 때 도움이 된다. ✔️ 테스팅 리팩터링을 하면서 프로그램의 겉보기 동작은 똑같이 유지해야 한다. 실수하여 동작이 깨지더라도 오류를 재빨리 해결할 수 있어야 한다. 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다. 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 또한 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다. 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. ✔️ 레거시 코드 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 대규모 레거시 시스템에는 테스트를 보강해야 한다. 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다. 이러한 틈새를 만들 때 리팩터링이 활용된다. 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이 좋다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력하며, 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. ✔️ 데이터베이스 데이터베이스의 변경도 다른 리팩터링과 마찬가지로 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다. 그러나 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 2.6 리팩터링, 아키텍쳐, 애그니(YAGNI)리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다. 리팩터링은 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해 준다. 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어둘 수 있다. 함수 정의 시 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가하는 것이 그 예다. 유연성 메커니즘을 구현하는 데 추가적으로 치러야 할 비용들이 있지만, 리팩터링을 활용하면 다르게 접근할 수 있다. 미래에 필요해질 유연성과 그 변화에 가장 잘 대응할 수 있는 추측 대신, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 진행하면서 아키텍처도 그에 맞게 리팩터링해서 바꾼다. 이런 식의 설계 방식을 ‘간결한 설계’, ‘점진적 설계’, ‘YAGNI(you aren’t going to need it’) 등으로 부른다. 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 나을 수도 있다. 2.7 리팩터링과 소프트웨어 개발 프로세스리팩터링과 함께 퍼지기 시작한 XP(익스트림 프로그래밍)의 특징은 지속적 통합, 자가 테스트 코드 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다. XP는 수 년에 걸쳐 애자일의 부흥을 이끌었다. 애자일을 제대로 적용하기 위해서는 리팩터링이 필수적이다. 자가 테스트 코드, 지속적 통합, 리팩터링의 세 기법은 서로 강력한 상승효과를 발휘한다. 지속적 배포는 소프트웨어를 언제든 릴리스할 수 있는 상태로 유지해준다. 게다가 위험요소도 줄이고, 비즈니스 요구에 맞춰 릴리스 일정을 계획할 수 있다. 이처럼 견고한 기술적 토대를 바탕으로 프로덕션 코드 반영까지의 시간을 단축하고 버그를 줄여줘 소프트웨어의 신뢰성도 높일 수 있다. 2.8 리팩터링과 성능리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이지만, 그와 동시에 성능을 튜닝하기는 더 쉬워진다. 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다. 빠른 소프트웨어를 작성하는 방법 세 가지 ✔️ 시간 예산 분배 방식 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다. 컴포넌트는 할당된 자원 예산을 초과할 수 없다. 시간 예산 분배 방식은 멍격한 시간 엄수를 강조한다. ✔️ 끊임없이 관심을 기울이는 것 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다. ✔️ 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는 데 집중한다. 먼저 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아내고, 그 부분들을 개선한다. 최적화를 위한 수정도 작은 단계로 나눠서 진행하며, 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다. 프로그램을 잘 리팩터링해 두면 성능에 투입할 시간을 벌 수 있으며, 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있지만, 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다. 2.9 리팩터링의 유래 2.10 리팩터링 자동화","link":"/2022/02/09/refactoring-2/"},{"title":"리팩터링 3장","text":"코드에서 나는 악취 3.1 기이한 이름코드는 단순하고 명료하게 작성해야 한다. 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각의 역할을 알 수 있도록 이름 지어야 한다. 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 일 중 하나다. 3.2 중복 코드똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합할 수 있다. 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 → 함수 추출하기 코드가 비슷하긴 한데 완전히 똑같지는 않다면 → 문장 슬라이드하기 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있다면 → 메서드 올리기 3.3 긴 함수짧은 함수들은 간접 호출의 효과를 낼 수 있다. 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점이 있다. 짧은 함수로 구성된 코드를 이해하기 쉽게 만들기 위해서는 함수 이름을 잘 지어두어야 한다. 적극적으로 함수를 쪼개고, 함수 이름은 동작 방식이 아닌 ‘의도’가 드러나게 짓는다. 함수 추출하기 임시 변수를 질의 함수로 바꾸기 매개변수 객체 만들기 객체 통째로 넘기기 함수를 명령으로 바꾸기 조건문 분해하기 case문마다 함수 추출하기 조건부 로직을 다형성으로 바꾸기 반복문 쪼개기 3.4 긴 매개변수 목록 매개변수를 질의 함수로 바꾸기 객체 통째로 넘기기 매개변수 객체 만들기 플래그 인수 제거하기 여러 함수를 클래스로 묶기 3.5 전역 데이터전역 변수를 제거할 수 있는 대표적인 방법은 변수 캡슐화다. 데이터를 함수로 감싸 데이터를 수정하는 부분을 쉽게 찾을 수 있도록 만들고, 접근을 통제할 수 있게 된다. 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다. 3.6 가변 데이터 변수 캡슐화하기 - 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다 변수 쪼개기 - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우 문장 슬라이드하기 &amp; 함수 추출하기 - 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리 질의 함수와 변경 함수 분리하기 - 부작용이 있는 코드를 호출할 수 없게 만든다 세터 제거하기 - 변수의 유효범위를 줄일 수 있다 이 밖에도 파생 변수를 질의 함수로 바꾸기, 여러 함수를 클래스 또는 변환 함수로 묶기, 참조를 값으로 바꾸기 등을 적용할 수 있다. 3.7 뒤엉킨 변경뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때, 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 일을 순차적으로 진행하는 ‘단계 쪼개기’와 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모으는 ‘함수 옮기기’를 적용할 수 있다. 여러 맥락의 일에 관여하는 함수는 옮기기 전에 ‘함수 추출하기’를 수행하고, 모듈이 클래스라면 ‘클래스 추출하기’를 사용할 수 있다. 3.8 산탄총 수술코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우다. 이럴 때는 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다. 여러 함수를 클래스나 변환 함수로 묶을 수 있고, 단계 쪼개기를 적용할 수 있다. 어설프게 분리된 로직을 인라인 함수나 인라인 클래스와 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 방법이다. 3.9 기능 편애기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 발생하는 문제다. 이럴 때는 함수 추출하기와 함수 옮기기를 통해 함수를 데이터와 가까운 곳으로 옮겨준다. 함수가 사용하는 모듈이 다양하다면, 가장 많은 데이터를 포함한 모듈로 옮기거나, 함수 추출하기로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮길 수 있다. 전략 패턴과 방문자 패턴을 적용하여 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮겨준다면, 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정이 쉬워진다. 3.10 데이터 뭉치데이터 여러 개가 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되는 경우가 있다. 이럴 때는 가장 먼저 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다. 다음 매개변수 객체 만들기나 객체 통째로 넘기기를 적용해 매개변수 수를 줄여본다. 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시킬 수 있다. 3.11 기본형 집착프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초 타입을 직접 정의하기를 몹시 꺼리는 사람이 많다. 기본형을 객체로 바꾸면 데이터의 타입을 의미 있는 자료형으로 바꿀 수 있다. 기본형으로 표현된 코드가 조건부 동작을 제어한다면, 타입 코드를 서브클래스로 바꾸거나 조건부 로직을 다형성으로 바꿀 수 있다. 자주 함께 몰려다니는 기본형 그룹은 클래스 추출과 매개변수 객체화를 이용할 수 있다. 3.12 반복되는 switch문switch문은 조건부 로직을 다형성으로 바꿔 대체할 수 있다. 3.13 반복문반복문을 파이프라인으로 바꿔 제거할 수 있다. (ex. filter, map 등) 3.14 성의 없는 요소필요 없는 프로그램 요소라면 인라인 함수나 클래스, 또는 계층 합치기(상속의 경우)를 적용하여 제거한다. 💡 프로그램 요소프로그래밍 언어가 제공하는 함수(메서드), 클래스, 인터페이스 등 코드 구조를 잡는 데 활용되는 요소 3.15 추측성 일반화‘나중에 필요할 거야’라는 생각으로 당장은 필요없는 모든 종류의 후킹(hooking) 포인트와 특이 케이스 처리 로직을 작성해둔 경우다. 계층 합치기, 인라인 함수 및 클래스, 함수 선언 바꾸기로 불필요한 코드를 제거한다. 테스트 코드에만 사용되는 함수나 클래스는 테스트 케이스부터 삭제한 뒤 죽은 코드를 제거한다. 3.16 임시 필드특정 상황에서만 값이 설정되는 필드를 가진 클래스의 경우, 쓰이지 않는 것처럼 보이는 필드를 이해하기 어렵다. 클래스 추출하기와 함수 옮기기로 임시 필드들을 정리해준다. 또 특이 케이스를 추가하여 필드의 유효성 검사를 위한 대안 클래스를 분리해줄 수도 있다. 3.17 메시지 체인메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 이는 클라이언트가 객체 내비게이션 구조에 종속된 상황으로, 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다. 이는 위임 숨기기로 해결한다. 최종 결과 객체가 어떻게 쓰이는지부터 살펴보고, 함수 추출하기와 함수 옮기기로 체인을 숨긴다. 3.18 중개자객체는 캡슐화를 통해 외부로부터 세부사항을 숨겨줄 수 있다. 캡슐화의 과정에는 위임이 자주 활용된다. 하지만 캡슐화를 남용하는 경우 (ex. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임한다면) 중개자를 제거하여 실제로 일을 하는 객체와 직접 소통하게 만든다. 3.19 내부자 거래모듈 사이의 데이터 거래가 많아 결합도가 높아지는 문제가 있다면, 함수 옮기기와 필드 옮기기로 떼어놓는다. 여러 모듈이 같은 관심사를 공유한다면 제3의 모듈을 만들거나 위임 숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다. 상속 구조에서 부모 자식 간에 결탁이 생긴다면, 서브 클래스를 위임으로 바꾸거나 슈퍼클래스를 위임으로 바꿀 수 있다. 3.20 거대한 클래스클래스 추출하기로 필드 일부를 따로 묶는다. 분리할 컴포넌트를 원래 클래스와 상속 관계로 만든다면 슈퍼클래스 추출이나 타입 코드를 서브클래스로 바꾸는 방법을 적용한다. 코드량이 너무 많은 클래스에 대한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다. 클라이언트가 거대 클래스를 이용하는 패턴을 파악하여 클래스 추출, 슈퍼클래스 추출, 타입 코드를 서브클래스로 바꾸기 등을 활용하여 여러 클래스로 분리한다 3.21 서로 다른 인터페이스의 대안 클래스들클래스를 다른 클래스로 교체할 때는 인터페이스가 같아야 한다. 함수 선언 바꾸기로 메서드 시그니처를 일치시키거나, 함수 옮기기로 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어넣는다. 대안 클래스들 사이에 중복이 생기면 슈퍼클래스를 추출하는 방법을 고려한다. 3.22 데이터 클래스데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 이런 클래스에 public 필드가 있다면 레코드 캡슐화로 숨기고, 변경하면 안 되는 필드는 세터 제거로 접근을 원천 봉쇄한다. 다른 클래스에서 데이터 클래스의 게터/세터를 사용하는 메서드를 찾아서 그 메서드를 데이터 클래스로 옮기거나, 옮길 수 있는 부분만 별도 메서드로 뽑아낸다. 단계 쪼개기의 결과로 나온 중간 데이터 구조의 경우 캡슐화할 필요가 없으므로 필드 자체를 공개해도 된다. 3.23 상속 포기서브클래스가 부모의 메서드나 데이터를 받고 싶지 않을 수도 있다. 같은 계층에 서브클래스를 하나 새로 만들고, 메서드 내리기와 필드 내리기를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다. 상속 포기 문제는 서브클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 경우 발생한다. 이때는 서브클래스나 슈퍼클래스를 위임으로 바꿔 상속 메커니즘에서 벗어나보자. 3.24 주석특정 코드 블록이 하는 일에 주석을 남기고 싶다면 함수를 추출한다. 이미 추출된 함수임에도 여전히 설명이 필요하다면 함수 이름을 바꿔본다. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 어서션을 추가한다.","link":"/2022/02/17/refactoring-3/"},{"title":"리팩터링 4-5장","text":"테스트 구축하기 | 리팩토링 카탈로그 보는 법 리팩터링을 제대로 하기 위해서는 실수를 잡아주는 견고한 테스트가 뒷받침돼야 한다. 4.1 자가 테스트 코드의 가치 모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자 컴파일할 때마다 테스트도 함께 하면 생산성을 높일 수 있ㅏ. 자가 테스트 코드 자체뿐 아니라 테스트를 자주 수행하는 습관도 버그를 찾는 강력한 도구가 된다. 테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 기능을 추가해야 할 때 테스트부터 작성한다. 이로부터 켄트 벡의 ‘테스트 주도 개발(TDD)’ 기법이 탄생했다. TDD에서는 테스트를 작성하고, 이 테스트를 통과하게끔 코드를 작성하고, 결과 코드를 최대한 깔끔하게 리팩터링하는 과정을 짧은 주기로 반복한다. 4.2 테스트할 샘플 코드비즈니스 로직 코드를 UI와 분리하여 코드를 파악하고 테스트하기 편하게 만들어줄 수 있다. 4.3 첫 번째 테스트테스트를 두 단계로 진행한다. 123456describe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); // 1. 픽스처 설정 assert.equal(asia.shortfall, 5); // 2. 검증 });}); 테스트에 필요한 데이터와 객체를 뜻하는 픽스처를 설정한다 이 픽스처의 속성들을 검증한다. 실패해야 할 상황에서는 반드시 실패하게 만들자 일시적으로 코드에 오류를 주입하여 각 테스트가 실패하는 모습을 한 번씩 보는 것도 좋은 방법이다. 자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자 차이(chai) 라이브러리의 assert문 또는 expect문을 이용해 코드를 검증할 수 있다. 12345describe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); assert.equal(asia.shortfall, 5); }); 12345describe('province', function() { it('shortfall', function() { const asia = new Province(sampleProvinceData()); expect(asia.shortfall).equal(5); }); 실패한 테스트가 하나라도 있으면 리팩터링하면 안 된다! 4.4 테스트 추가하기테스트는 위험 요인을 중심으로 작성해야 한다. 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는 데 있다. 따라서 단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요가 없다. 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다 아래처럼 똑같은 픽스처가 중복되는 부분이 있다면, 픽스처를 여러 테스트문에서 접근할 수 있는 장소로 옮겨 중복을 제거할 수 있지만, 123456789describe('province', function() { const asia = new Province(sampleProvinceData()); it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); });}); ‘테스트끼리 상호작용하게 하는 공유 픽스처’를 생성하는 원인이 되어 테스트를 실행하는 순서에 따라 결과가 달라질 수 있기 때문에 문제가 된다. 이때는 beforeEach 를 사용할 수 있다. 123456789101112describe('province', function() { let asia; beforeEach(function() { asia = new Province(sampleProvinceData()); }) it('shortfall', function() { expect(asia.shortfall).equal(5); }); it('profit', function() { expect(asia.profit).equal(230); });}); 개별 테스트를 실행할 때마다 픽스처를 새로 만들면 모든 테스트를 독립적으로 구성할 수 있다. 4.5 픽스처 수정하기12345678describe('province', function() { // ... it('change production', function() { asia.producers[0].production = 20; expect(asia.shortfall).equal(-6); expect(asia.profit).equal(292); });}); 위 예제에서는 beforeEach에서 ‘설정’한 표준 픽스처를 취해서, 테스트를 ‘수행’하고, 이 픽스처가 일을 기대한 대로 처리했는지를 ‘검증’한다. 이 테스트는 it 구문 하나에서 두 가지 속성을 검증하고 있지만, 일반적으로 it 구문 하나당 검증도 하나씩만 하는 게 좋다. 4.6 경계 조건 검사하기의도나 예측 범위를 벗어나는 경계 지점에서 문제가 생길 경우 확인하는 테스트도 함께 작성하면 좋다. 컬렉션 타입의 값이 비었을 때나, 숫자형이 0 또는 음수인 경우를 검사해본다. 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자 테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩터링할 수 있는 보호막은 되어준다. 그리고 리팩터링을 하면서 프로그램을 더욱 깊이 이해하게 되어 더 많은 버그를 찾게 된다. 4.7 끝나지 않은 여정테스트는 반복적으로 진행해야 한다. 기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다. 버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하자","link":"/2022/02/24/refactoring-4-5/"},{"title":"리팩터링 6장 - 1","text":"기본적인 리팩터링 - 1 6.1 함수 추출하기코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙이자. 코드를 독립된 함수로 묶는 기준은 ‘목적과 구현을 분리’하는 것이다. 코드를 보고 무슨 일을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 ‘무슨 일’에 걸맞는 이름을 짓는다. 함수는 짧게 작성한다. 함수가 짧으면 캐싱하기도 쉽기 때문에 컴파일러가 최적화하는 데 유리할 때가 많다. 짧은 함수는 이름 짓기에 특별히 신경 써야 한다. 별도의 문서 없이 코드 자체만으로 내용을 충분히 설명되게 만들어야 한다. 절차 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다 (’어떻게’가 아닌 ‘무엇을’ 하는지가 드러나야 한다) 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다. 변수를 다 처리했다면 컴파일한다. 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다 (즉, 추출한 함수로 일을 위임한다) 테스트한다. 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다(인라인 코드를 함수 호출로 바꾸기) 💡 함수를 중첩시키면, 추출한 함수에서 원본 함수에 정의된 모든 변수에 접근할 수 있지만, 중첩 함수를 지원하지 않는 언어에서는 불가능한 방법이다. 따라서 원본 함수에서만 접근할 수 있는 변수들에 특별히 신경 써야 한다. 예시 코드 1234567891011121314151617181920// beforefunction printOwing(invoice) { let outstanding = 0; console.log(&quot;***************&quot;); console.log(&quot;**** 고객 채무 ****&quot;); console.log(&quot;***************&quot;); for (const o of invoice.orders) { outstanding += o.amount; } const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30); console.log(`고객명: ${invoice.customer}`); console.log(`채무액: ${customer}`); console.log(`마감일: ${invoice.dueDate.toLocaleDateString}`);} 1234567891011121314151617181920212223242526// afterfunction printOwing(invoice) { printBanner(); const outstanding = calculateOutstanding(invoice); recordDueDate(invoice); printDetails(invoice, outstanding);}function calculateOutstanding(invoice) { let result = 0; for (const o of invoice.orders) { result += o.amount; } return result;}function recordDueDate(invoice) { const today = Clock.today; invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);}function printDetails(invoice, outstanding) { console.log(`고객명: ${invoice.customer}`); console.log(`채무액: ${customer}`); console.log(`마감일: ${invoice.dueDate.toLocaleDateString}`);} 6.2 함수 인라인하기함수 본문이 이름만큼 명확하거나, 리팩터링 과정에서 잘못 추출된 함수들은 인라인한다. 간접 호출을 너무 과하게 쓰는 코드도 흔한 인라인 대상이다. 절차 다형 메서드인지 확인한다 (서브클래스에서 오버라이드하는 메서드는 인라인하면 안 된다.) 인라인할 함수를 호출하는 곳을 모두 찾는다. 각 호출문을 함수 본문으로 교체한다. 하나씩 교체할 때마다 테스트한다. 함수 정의(원래 함수)를 삭제한다. 예시 코드 1234567891011// beforefunction reportLines(aCustomer) { const lines = []; gatherCustomerData(lines, aCustomer); return lines;}function gatherCustomerData(out, aCustomer) { out.push([&quot;name&quot;, aCustomer.name]); out.push([&quot;location&quot;, aCustomer.location]);} 1234567// afterfunction reportLines(aCustomer) { const lines = []; lines.push([&quot;name&quot;, aCustomer.name]); lines.push([&quot;location&quot;, aCustomer.location]); return lines;} 핵심은 항상 단계를 잘게 나눠서 처리하는 것이다! 6.3 변수 추출하기지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들고, 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어서 코드의 목적을 훨씬 명확하게 드러낼 수 있다. 또 디버깅에도 도움이 된다. 변수 추출, 즉 표현식에 이름을 붙이기로 했다면 그 이름이 들어갈 문맥도 살펴야 한다. 함수를 벗어난 넓은 문맥에서까지 의미가 된다면 변수가 아닌 함수로 추출해야 한다. 절차 추출하려는 표현식에 부작용은 없는지 확인한다. 불변 변수를 하나 선언하고 이름을 붙인 표현식의 복제본을 대입한다. 원본 표현식을 새로 만든 변수로 교체한다. 테스트한다. 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다. 예시 코드 1234567// beforefunction price(order) { // 가격(price) = 기본 가격 - 수량 할인 + 배송비 return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100);} 1234567// afterfunction price(order) { const basePrice = order.quantity * order.itemPrice const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 const shipping = Math.min(order.quantity * order.itemPrice * 0.1, 100); return basePrice - quantityDiscount + shipping;} 같은 코드를 클래스 문맥 안에서는 변수가 아닌 메서드로 추출할 수 있다. 1234567891011121314151617181920212223242526272829class Order { constructor(aRecord) { this._data = aRecord; } get quantity() { return this._data.quantity; } get itemPrice() { return this._data.itemPrice; } get price() { return this.basePrice - this.quantityDiscount + this.shipping; } get basePrice() { return this.quantity * this.itemPrice; } get quantityDiscount() { return Math.max(0, this.quantity - 500) * this.itemPrice * 0.05; } get shipping() { return Math.min(this.basePrice * 0.1, 100); }} 6.4 변수 인라인하기절차 대입문의 우변(표현식)에서 부작용이 생기지는 않는지 확인한다. 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다. 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다. 테스트한다. 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다. 변수 선언문과 대입문을 지운다. 테스트한다. 예시 코드 123// beforelet basePrice = anOrder.basePrice;return (basePrice &gt; 1000); 12// afterreturn anOrder.basePrice &gt; 1000; 6.5 함수 선언 바꾸기함수는 프로그램을 작은 부분으로 나누는 주된 수단이다. 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다. 이러한 연결부에서 가장 중요한 것은 함수의 이름이다. 함수 구현 코드를 살펴볼 필요 없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있어야 한다. 함수의 매개변수 역시 중요하다. 매개변수는 함수를 사용하는 문맥을 설정한다. 매개변수를 적절히 사용하여 함수의 활용 범위를 넓힐 수 있으며, 다른 모듈과의 결합을 제거할 수도 있다. 간단한 절차 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다. 메서드 선언을 원하는 형태로 바꾼다. 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다. 테스트한다. 마이그레이션 절차 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다. 함수 본문을 새로운 함수로 추출한다. 추출한 함수에 매개변수를 추가해야 한다면 ‘간단한 절차’를 따라 추가한다. 테스트한다. 기존 함수를 인라인한다. 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다. 테스트한다. 예시 코드 123456// beforefunction inNewEngland(aCustomer) { return [&quot;MA&quot;, &quot;CT&quot;, &quot;ME&quot;, &quot;VT&quot;, &quot;NH&quot;, &quot;RI&quot;].includes(aCustomer.address.state);}const newEnglanders = someCustomers.filter(c =&gt; inNewEngland(c)); 123456// afterfunction inNewEngland(stateCode) { return [&quot;MA&quot;, &quot;CT&quot;, &quot;ME&quot;, &quot;VT&quot;, &quot;NH&quot;, &quot;RI&quot;].includes(stateCode);}const newEnglanders = someCustomers.filter(c =&gt; inNewEngland(c.address.satate)); 6.6 변수 선언하기데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동하기 때문에 함수보다 다루기가 까다롭다. 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하려는 함수를 만드는 식으로 캡슐화하는 것이 좋다. 데이터 캡슐화는 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워넣을 수 있다는 장점도 있다. 데이터의 캡슐화를 위해 객체 지향에서 객체의 데이터는 항상 private으로 유지해야 한다. 절차 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다. 정적 검사를 수행한다. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다. 변수의 접근 범위를 제한한다. 테스트한다. 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다. 예시 코드 1234567// before// 전역 변수에 중요한 데이터가 담겨 있는 경우let defaultOwner = { firstName: '마틴', lastName: '파울러' };// 데이터를 참조하는 코드spaceship.owner = defaultOwner;// 데이터를 갱신하는 코드defaultOwner = { firstName: '레베카', lastName: '파슨스' }; 123456789// after// defaultOnwer.jslet defaultOwner = { firstName: '마틴', lastName: '파울러' };export function getDefaultOwner() { return defaultOwner; }export function setDefaultOwner(arg) { defaultOwner = arg; }; 값 캡슐화하기 변수뿐 아니라 변수에 담긴 내용을 변경하는 행위까지 제어할 수 있게 캡슐화해보자. 게터가 데이터의 복제본을 반환하도록 수정한다. 123export function getDefaultOwner() { return Object.assign({}, defaultOwner); } 레코드 캡슐화를 통해 아예 변경할 수 없게 만드는 방법도 있다.","link":"/2022/03/10/refactoring-6-1/"},{"title":"리팩터링 7장","text":"캡슐화 모듈을 분리할 때는 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 잘 숨겨야 한다. 이때 레코드 캡슐화, 컬렉션 캡슐화, 기본형을 객체로 바꿔 캡슐화하는 방법 등이 많이 쓰인다. 클래스를 이용하면 내부 정보를 숨길 수 있을 뿐 아니라 위임 숨기기를 통해 클래스 사이의 연결 관계를 숨길 수도 있다. 알고리즘을 함수로 추출하여 구현을 캡슐화하는 방법도 있다. 7.1 레코드 캡슐화하기가변 데이터를 저장할 때는 레코드보다 객체를 선호한다. 객체를 사용하면 어떻게 저장했는지를 숨긴 채 각각의 값을 서로 다른 메서드로 제공할 수 있다. 레코드 구조는 필드 이름을 노출하는 형태와 필드를 외부로부터 숨겨서 원하는 이름을 쓸 수 있는 형태 두 가지로 구분할 수 있다. 후자는 주로 라이브러리에서 해시(hash), 맵(map), 해시맵(hashmap), 딕셔너리(dictionary), 연관 배열(associative array) 등의 이름으로 제공한다. 절차 레코드를 담은 변수를 캡슐화한다. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다. 테스트한다. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다. 테스트한다. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다. 예시: 간단한 레코드 캡슐화하기12345// beforeconst organization = { name: &quot;에크미 구스베리&quot;, country: &quot;GB&quot; };result += `&lt;h1&gt;${organization.name}&lt;/h1&gt;` // 읽기 예organization.name = newName; // 쓰기 예 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위함이므로, 레코드를 클래스로 바꾼다. 12345678910111213141516171819202122class Organization { constructor(data) { this._name = data.name; this._country = data.country; } set name(aString) { this._data.name = aString; } get name() { return this._data.name; }}const organization = new Organization({ name: &quot;에크미 구스베리&quot;, country: &quot;GB&quot; });function getOrganization() { return organization; }getOrganization().name = newName;result += `&lt;h1&gt;${getOrganization().name}&lt;/h1&gt;`; 예시: 중첩된 레코드 캡슐화하기 7.2 컬렉션 캡슐화하기컬렉션 변수로의 접근을 캡슐화하면서 게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이 바뀌어버릴 수 있다. 컬렉션 게터가 원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는 것이 좋다. 내부 컬렉션을 직접 수정하지 못하게 막는 방법 중 하나로, 절대로 컬렉션 값을 반환하지 않게 할 수 있다. 컬렉션에 접근하려면 컬렉션이 소속된 클래스의 적절한 메서드를 반드시 거치게 하는 것이다. 또 다른 방법은 컬렉션을 읽기전용으로 제공할 수 있다. 프락시가 내부 컬렉션을 읽는 연산은 그대로 전달하고, 쓰기는 모두 막는 것이다. 가장 흔히 사용하는 방식은 아마도 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다. 복제본을 수정해도 캡슐화된 원본 컬렉션에는 아무런 영향을 주지 않는다. 여기서 중요한 점은 코드베이스에 일관성을 주는 것이다. 컬렉션 접근 함수의 동작 방식을 통일해야 한다. 절차 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기부터 한다. 컬렉션에 원소를 추가/제거하는 함수를 추가한다. 정적 검사를 수행한다. 컬렉션을 참조하는 부분을 모두 찾는다. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기전용 프락시나 복제본을 반환하게 한다. 테스트한다. 예시123456789101112131415161718192021// beforeclass Person { constructor(name) { this._name = name; this._courses = []; } get name() { return this._name; } get courses() { return this._courses; } set courses(aList) { this._courses = aList; }}class Course { constructor(name, isAdvanced) { this._name = name; this._isAdvanced = isAdvanced; } get name() { return this._name; } get isAdvanced() { return this._isAdvanced; }} 모든 필드가 접근자 메서드로 보호받고 있으나, 세터를 이용해 수업 컬렉션을 통째로 설정한 클라이언트는 누구든 이 컬렉션을 마음대로 수정할 수 있다. 캡슐화가 깨지는 것이다. 12345678910111213141516// afterclass Person { // setter 제거 get courses() { return this._courses.slice(); } addCourse(aCourse) { this._courses.push(aCourse); } removeCourse(aCourse, fnIfAbsent = () =&gt; { throw new RangeError(); }) { const index = this._courses.indexOf(aCourse); if (index === -1) fnIfAbsent(); else this._courses.splice(index, 1); }} 7.3 기본형을 객체로 바꾸기단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의한다. 절차 아직 변수를 캡슐화하지 않았다면 캡슐화한다. 단순한 값 클래스를 만든다. 생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 게터를 추가한다. 정적 검사를 수행한다. 값 클래스의 인스턴스를 새로 만들어서 필드에 저장하도록 세터를 수정한다. 이미 있다면 필드의 타입을 적절히 변경한다. 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 게터를 수정한다. 테스트한다. 함수 이름을 바꾸면 원본 접근자의 동작을 더 잘 드러낼 수 있는지 검토한다. 예시12345678910// beforeclass Order { constructor(data) { this.priority = data.priority; // ... }}// 클라이언트const highPriorityCount = orders.filter(o =&gt; &quot;high&quot; === o.priority || &quot;rush&quot; === o.priority).length; 123456789101112131415161718192021// after class Order { get priority() { return this._priority; } set priority(aString) { this._priority = new Priority(aString); } // ...}class Priority { constructor(value) { this._value = value; } toString() { return this._value; }}const highPriorityCount = orders.filter(o =&gt; &quot;high&quot; === o.priority.toString() || &quot;rush&quot; === o.priority.toString()).length; 이렇게 하면 Priority 클래스를 새로운 동작을 담는 장소로 활용할 수 있게 된다 7.4 임시 변수를 질의 함수로 바꾸기임시 변수를 사용하면 코드의 반복을 줄이고 값의 의미를 설명할 수도 있어 유용하다. 여기서 한 걸음 더 나아가 아예 함수로 만들어 사용하는 편이 나을 때가 많다. 변수 대신 함수로 만들어두면 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어든다. 특히 추출할 메서드들에 공유 컨텍스트를 제공하는 클래스 안에서 적용할 때 효과가 가장 크다. 절차 변수가 사용되기 전에 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다. 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만든다. 테스트한다. 변수 대입문을 함수로 추출한다. 테스트한다. 변수 인라인하기로 임시 변수를 제거한다. 예시1234567891011121314// beforeclass Order { constructor(quantity, item) { this._quantity = quantity; this._item = item; } get price() { var basePrice = this._quantity * this._item.price; var discountFactor = 0.98; if (basePrice &gt; 1000) discountFactor -= 0.03; return basePrice * discountFactor;} 123456789101112131415161718192021// after class Order { constructor(quantity, item) { this._quantity = quantity; this._item = item; } get price() { return this.basePrice * this.discountFactor; } get basePrice() { return this._quantity * this._item.price; } get discountFactor() { var discountFactor = 0.98; if (basePrice &gt; 1000) discountFactor -= 0.03; return discountFactor; } 7.5 클래스 추출하기메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다. 함께 변경되는 일이 많거나 서로 의존하는 테이블들도 분리한다. 절차 클래스의 역할을 분리할 방법을 정한다. 분리될 역할을 담당할 클래스를 새로 만든다. 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다. 분리될 역할에 필요한 필드들을 새 클래스로 옮긴다. 메서드들도 새 클래스로 옮긴다. 이때 저수준 메서드, 즉 다른 메서드를 호출하기보다는 호출을 당하는 일이 많은 메서드부터 옮긴다. 양쪽 클래스의 인터페이스를 살펴보면서 불필요한 메서드를 제거하고, 이름도 새로운 환경에 맞게 바꾼다. 새 클래스를 외부로 노출할지 정한다. 노출하려거든 새 클래스에 참조를 값으로 바꾸기를 적용할지 고민해본다. 예시12345678910// beforeclass Person { get name() { return this._name; } set name(arg) { this._name = arg; } get telephoneNumber() { return `(${this.officeAreaCode}) ${this.officeNumber}`; } get officeAreaCode() { return this._officeAreaCode; } set officeAreaCode(arg) { this._officeAreaCode = arg; } get officeNumber() { return this._officeNumber; } set officeNumber(arg) { this._officeNumber = arg; }} 12345678910111213141516171819202122// afterclass Person { constructor() { this._telephoneNumber = new TelephoneNumber(); } get name() { return this._name; } set name(arg) { this._name = arg; } get telephoneNumber() { return this._telephoneNumber.toString(); } get areaCode() { return this._telephoneNumber.areaCode; } set areaCode(arg) { this._telephoneNumber.areaCode = arg; } get officeNumber() { return this._telephoneNumber.number; } set officeNumber(arg) { this._telephoneNumber.number = arg; }}class TelephoneNumber { get areaCode() { return this._areaCode; } set areaCode(arg) { this._areaCode = arg; } get number() { return this._number; } set number(arg) { this._number = arg; } toString() { return `(${this.areaCode}) ${this.number}`; }} 7.6 클래스 인라인하기클래스 인라인하기는 클래스 추출하기를 거꾸로 돌리는 리팩터링이다. 더 이상 제 역할을 못 해서 그대로 두면 안 되는 클래스는 인라인한다. 두 클래스의 기능을 지금과 다르게 배분하고 싶을 때도 클래스를 인라인한다. 절차 소스 클래스의 각 public 메서드에 대응하는 메서드들을 타깃 클래스에 생성한다. 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾼다. 소스 클래스의 메서드와 필드를 모두 타깃 클래스로 옮긴다. 소스 클래스를 삭제하고 조의를 표한다. 예시12345678910111213141516171819202122// beforeclass TrackingInformation { // ... get shippingCompany() { return this._shippingCompany; } set shippingCompany(arg) { this._shippingCompany = arg; } get trackingNumber() { return this._trackingNumber; } set trackingNumber(arg) { this._trackingNumber = arg; } get display() { return `${this.shippingCompany}: ${this.trackingNumber}`; }}class Shipment { // ... get trackingInfo() { return this._trackingInformation.display; } get trackingInformation() { return this._trackingInformation; } set trackingInformation(aTrackingInformation) { this._trackingInformation = aTrackingInformation; }} TrackingInformation이 현재는 제 역할을 못 하고 있으니 Shipment 클래스로 인라인한다. 123456789class Shipment { get trackingInfo() { return `${this.shippingCompany}: ${this.trackingNumber}`; } get shippingCompany() { return this._shippingCompany; } set shippingCompany(arg) { this._shippingCompany = arg; } get trackingNumber() { return this._trackingNumber; } set trackingNumber(arg) { this._trackingNumber = arg; } } TrackingInformation 클래스는 삭제한다. 7.7 위임 숨기기모듈화 설계를 제대로 하는 핵심은 캡슐화다. 캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다. 절차 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성한다. 클라이언트가 위임 객체 대신 서버를 호출하도록 수정한다. 모두 수정했다면, 서버로부터 위임 객체를 얻는 접근자를 제거한다. 테스트한다. 예시12345678910111213141516171819// beforeclass Person { constructor(name) { this._name = name; } get name() { return this._name; } get department() { return this._department; } set department() { this._department = arg; }}class Department { get chargeCode() { return this._chargeCode; } set chargeCode() { this._chargeCode = arg; } get manager() { return this._manager; } set manager() { this._manager = arg; }}// 클라이언트const manager = aPerson.department.manager; 클라이언트가 Department 클래스를 몰라도 되도록, Person 클래스에 간단한 위임 메서드를 만들어 의존성을 줄일 수 있다. 12345678// afterclass Person { // ... get manager() { return this._department.manager; }}// 클라이언트const manager = aPerson.manager; 7.8 중개자 제거하기위임 메서드를 매번 추가하다 보면 서버 클래스는 그저 중개자 역할로 전락하여, 차라리 클라이언트가 위임 객체를 직접 호출하는 게 나을 수 있다. 절차 위임 객체를 얻는 게터를 만든다. 위임 메서드를 호출하는 클라이언트가 모두 이 게터를 거치도록 수정한다. 모두 수정했다면 위임 메서드를 삭제한다. 예시123456789101112// beforeconst manager = aPerson.manager;class Person { // ... get manager() { return this._department.manager; }}class Department { // ... get manager() { return this._manager; }} 12345678910// afterclass Person { // ... get department() { return this._department; } // 삭제 // get manager() { return this._department.manager; }}// 클라이언트const manager = aPerson.department.manager; 7.9 알고리즘 교체하기메서드를 잘게 나누어 알고리즘을 간소화하자. 절차 교체할 코드를 함수 하나에 모은다. 이 함수만을 이용해 동작을 검증하는 테스트를 마련한다. 대체할 알고리즘을 준비한다. 정적 검사를 수행한다. 기존 알고리즘과 새 알고리즘의 결과를 비교하는 테스트를 수행한다.","link":"/2022/03/24/refactoring-7/"},{"title":"리팩터링 6장 - 2","text":"기본적인 리팩터링 - 2 6.7 변수 이름 바꾸기명확한 프로그래밍의 핵심은 이름짓기다. 간단한 변수의 경우 대체로 파악이 쉽지만, 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드라면 신중하게 이름을 지어야 한다. 절차 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다. 테스트한다. 예시1234567// beforelet tpHd = &quot;untitled&quot;;// 변수를 읽기만 하는 경우result += `&lt;h1&gt;${tpHd}&lt;/h1&gt;`;// 값을 수정하는 경우tpHd = obj['articleTitle']; 1234567891011121314// after: getter와 setter를 통해 변수 캡슐화하기result += `&lt;h1&gt;${title()}&lt;/h1&gt;`;setTitle(obj['articleTitle']);let _title = &quot;untitled&quot;;function title() { return _title;}function setTitle(arg) { _title = arg;} 6.8 매개변수 객체 만들기데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다. 나아가 함수가 이 데이터 구조를 받게 하면 매개변수 수가 줄어든다 절차 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다. 테스트한다. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다. 테스트한다. 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다. 다 바꿨다면 기존 매개변수를 제거하고 테스트한다. 예시1234567891011121314151617181920// before// 데이터 const station = { name: 'ZB1', readings: [ { temp: 47, time: &quot;2016-11-19 09:10&quot; }, { temp: 53, time: &quot;2016-11-19 09:20&quot; }, { temp: 58, time: &quot;2016-11-19 09:30&quot; }, { temp: 53, time: &quot;2016-11-19 09:40&quot; }, { temp: 51, time: &quot;2016-11-19 09:50&quot; }, ]};// 함수function readingsOutsideRange(station, min, max) { return station.readings.filter(r =&gt; r.temp &lt; min || r.temp &gt; max);}// 호출문alerts = readingsOutsideRange(station, operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling); 1234567891011121314151617// afterclass NumberRange { constructor(min, max) { this._data = { min: min, max: max }; } get min() { return this._data.min; } get max() { return this._data.max; }}function readingsOutsideRange(station, range) { return station.readings.filter(r =&gt; r.temp &lt; range.min || r.temp &gt; range.max);}const range = new NumberRange(operatingPlan.temperatureFloor, operatingPlan.temperatureCeiling);alerts = readingsOutsideRange(station, range); 6.9 여러 함수를 클래스로 묶기클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다. 공통 데이터를 중심으로 긴밀하게 엮여 작동하는 함수 무리는 클래스 하나로 묶을 수 있다. 여러 함수를 클래스로 묶으면 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다. 절차 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다. 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다. 예시12345678// before// 클라이언트 1const aReading = acquireReading();const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;// 클라이언트 2const aReading = acquireReading();const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;const taxableCharge = Math.max(0, base - taxThreshold(aReading.year)); 12345678910111213141516171819202122232425262728// afterclass Reading { constructor(data) { this._customer = data.customer; this._quantity = data.quantity; this._month = data.month; this._year = data.year; } get customer() { return this._customer; } get quantity() { return this._quantity; } get month() { return this._month; } get year() { return this._year; } get baseCharge() { return baseRate(this.month, this.year) * this.quantity; } get taxableCharge() { return Math.max(0, this.baseCharge - taxThreshold(this.year)); }}// 클라이언트 3const rawReading = acquireReading();const aReading = new Reading(rawReading);const basicChargeAmount = aReading.baseCharge;const taxableCharge = aReading.taxableCharge; 6.10 여러 함수를 변환 함수로 묶기데이터를 입력받아서 여러 가지 정보를 도출하는 작업들을 한데로 모아두면 검색과 갱신을 일관된 장소에서 할 수 있고 로직 중복도 막을 수 있다. 변환 함수를 사용하면 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다. 💡 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 것이 좋다. 절차 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다. 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다. 테스트한다. 나머지 관련 함수도 위 과정에 따라 처리한다. 예시123456789101112131415// before// 클라이언트 1const aReading = acquireReading();const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;// 클라이언트 2const aReading = acquireReading();const base = baseRate(aReading.month, aReading.year) * aReading.quantity;const taxableCharge = Math.max(0, base - taxThreshold(aReading.year));// 클라이언트 3const aReading = acquireReading();const basicChargeAmount = calculateBaseCharge(aReading);function calculateBaseCharge(aReading) { return baseRate(aReading.month, aReading.year) * aReading.quantity;} 1234567891011121314151617// after// 클라이언트 1, 3const rawReading = acquireReading(); // 미가공 측정값 const aReading = enrichReading(rawReading);const basicChargeAmount = aReading.baseCharge;// 클라이언트 2const rawReading = acquireReading(); // 미가공 측정값 const aReading = enrichReading(rawReading);const taxableCharge = aReading.taxableCharge;function enrichReading(original) { const result = _.cloneDeep(original); result.baseCharge = calculateBaseCharge(aReading); result.taxableCharge = Math.max(0, result.baseCharge - taxThreshold(result.year)); return result;} 👩‍🏫 주의할 점enrichReading() 처럼 정보를 추가해 반환할 때 원본 측정값 레코드는 변경하지 않아야 한다. 6.11 단계 쪼개기서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나눌 수 있다. 이렇게 분리하는 가장 간편한 방법 하나는 동작을 연이은 두 단계로 쪼개는 것이다. 가장 대표적인 예는 컴파일러다. 컴파일 작업은 여러 단계가 순차적으로 연결된 형태로 분리되어 있다. 각 단계는 자신만의 문제에 집중하기 때문에 나머지 단계에 관해서는 자세히 몰라도 이해할 수 있다. 절차 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다. 테스트한다. 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다. 테스트한다. 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다. 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다. 예시1234567891011// beforefunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice * product.discountRate; const shippingPerCase = (basePrice &gt; shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice - discount + shippingCost; return price;} 1234567891011121314151617// afterfunction priceOrder(product, quantity, shippingMethod) { const priceData = calculatePricingData(product, quantity); return applyShipping(priceData, shippingMethod);}function calculatePricingData(product, quantity) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice * product.discountRate; return { basePrice, quantity, discount };}function applyShipping(priceData, shippingMethod) { const shippingPerCase = (priceData.basePrice &gt; shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase; return priceData.basePrice - priceData.discount + shippingCost;} 👩‍🏫 험블 객체 패턴(Humble Object Pattern)명령줄 호출과 표준 출력에 쓰는 느리고 불편한 작업과 자주 테스트해야 할 복잡한 동작을 분리함으로써 테스트를 더 쉽게 수행하게 만든다","link":"/2022/03/18/refactoring-6-2/"},{"title":"리팩터링 8장 - 1","text":"기능 이동 - 1 8.1 함수 옮기기모듈성이란 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력이다. 모듈성을 높이려면 서로 연관된 요소들을 함게 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 한다. 모든 함수는 어떤 컨텍스트 안에 존재하며, 대부분은 특정 모듈에 속한다. 캡슐화를 위해 함수를 함수가 참조하는 곳이 많은 모듈로 옮겨주는 것이 좋다. 또한 호출자들의 현재 위치나 다음 업데이트 때 바뀌리라 예상되는 위치에 따라서도 함수를 옮겨야 할 수 있다. 함수를 옮기기 전에는 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보고 대상 함수를 호출하는 함수, 대상 함수가 호출하는 함수, 대상 함수가 사용하는 데이터를 살펴봐야 한다. 절차 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다. 이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다. 선택한 함수가 다형 메서드인지 확인한다. 선택한 함수를 타겟 컨텍스트로 복사한다. 타겟 함수가 새로운 터전에 잘 자리 잡도록 다듬는다. 정적 분석을 수행한다. 소스 컨텍스트에서 타겟 함수를 참조할 방법을 찾아 반영한다. 소스 함수를 타겟 함수의 위임 함수가 되도록 수정한다. 테스트한다. 소스 함수를 인라인할지 고민해본다. 예시: 중첩 함수를 최상위로 옮기기1234567891011121314151617181920212223// beforefunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance; return { time: totalTime, distance: totalDistance, pace: pace }; function calculateDistance() { let result = 0; for (let i = 1; i &lt; points.length; i++) { result += distance(points[i-1], points[i]); } return result; } function distance(p1, p2) { ... } function radians(degrees) { ... } function calculateTime() { ... }} 중첩 함수인 calculateDistance()를 최상위로 옮겨서 추적 거리를 다른 정보와는 독립적으로 계산하고 싶다. 12345678910111213141516171819202122// afterfunction trackSummary(points) { const totalTime = calculateTime(); const pace = totalTime / 60 / totalDistance(points); return { time: totalTime, distance: totalDistance(points), pace: pace };}function totalDistance(points) { let result = 0; for (let i = 1; i &lt; points.length; i++) { result += distance(points[i-1], points[i]); } return result;} function distance(p1, p2) { ... }function radians(degrees) { ... }function calculateTime() { ... } 예시: 다른 클래스로 옮기기12345678910111213141516171819202122// beforeclass Account { // ... get bankCharge() { let result = 4.5; if (this._daysOverdrawn &gt; 0) result += this.overdraftCharge; return result; } get overdraftCharge() { if (this.type.isPremium) { const baseCharge = 10; if (this.daysOverdrawn &lt;= 7) { return baseCharge; } else { return baseCharge + (this.daysOverdrawn - 7) * 0.05; } } else { return this.daysOverdrawn * 1.75; } }} 계좌 종류에 따라 이자 책정 알고리즘이 달라지도록 고쳐보자. overdraftCharge()를 계좌 종류 클래스인 AccountType으로 옮긴다. 1234567891011121314151617181920212223242526// afterclass Account { // ... get bankCharge() { let result = 4.5; if (this._daysOverdrawn &gt; 0) { result += this.type.overdraftCharge(this.daysOverdrawn); } return result; } }class AccountType { overdraftCharge(daysOverdrawn) { if (this.isPremium) { const baseCharge = 10; if (daysOverdrawn &lt;= 7) { return baseCharge; } else { return baseCharge + (daysOverdrawn - 7) * 0.85; } } else { return this.daysOverdrawn * 1.75; } }} 8.2 필드 옮기기프로그램의 진짜 힘은 데이터 구조에서 나온다. 주어진 문제에 적합한 데이터 구조를 선택해야 한다. 현재 데이터 구조가 적절하지 않다면 곧바로 수정해야 한다. 예를 들어, 함수에 항상 함께 건네지는 데이터 조각들은 상호 관계가 명확하게 드러나도록 한 레코드에 담는 게 좋다. 구조체 여러 개에 정의된 똑같은 필드들을 갱신해야 한다면 한 번만 갱신해도 되는 다른 위치로 옮겨야 한다. 레코드 뿐 아니라 클래스나 객체가 와도 마찬가지다. 클래스의 데이터들은 접근자 메서드들 뒤에 감줘져 있으므로 클래스에 곁들여진 함수들은 데이터를 이리저리 옮기는 작업을 쉽게 해준다. 절차 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다. 테스트한다. 타겟 객체에 필드(와 접근자 메서드들)를 생성한다. 정적 검사를 수행한다. 소스 객체에서 타겟 객체를 참조할 수 있는지 확인한다. 접근자들이 타겟 필드를 사용하도록 수정한다. 테스트한다. 소스 필드를 제거한다. 테스트한다. 예시123456789101112131415161718192021222324252627// beforeclass Customer { constructor(name, discountRate) { this._name = name; this._discountRate = discountRate; this._contract = new CustomerContract(dateToday()); } get discountRate() { return this._discountRate; } becomePreferred() { this._discountRate += 0.03; // ... } applyDiscount(amount) { return amount.subtract(amount.multiply(this._discountRate)); }}class CustomerContract { constructor(startDate) { this._startDate = startDate; }} discountRate 필드를 Customer에서 CustomerContract로 옮기자 12345678910111213141516171819202122232425262728293031323334353637383940// afterclass Customer { constructor(name, discountRate) { this._name = name; this._contract = new CustomerContract(dateToday()); this._setDiscountRate(discountRate); } get discountRate() { return this._contract._discountRate; } _setDiscountRate(aNumber) { this._contract._discountRate = aNumber; } becomePreferred() { this._setDiscountRate(this.discountRate + 0.03); // ... } applyDiscount(amount) { return amount.subtract(amount.multiply(this.discountRate)); }}class CustomerContract { constructor(startDate, discountRate) { this._startDate = startDate; this._discountRate = discountRate; } get discountRate() { return this._discountRate; } set discountRate(arg) { this._discountRate = arg; }} 8.3 문장을 함수로 옮기기중복 제거는 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나다. 코드가 반복되면 피호출 함수로 합친다. 이때 문장들을 함수로 옮기려면 그 문장들이 피호출 함수의 일부라는 확신이 있어야 한다. 절차 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다. 타겟 함수를 호출하는 곳이 한 곳뿐이면, 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다. 호출자가 둘 이상이면 호출자 중 하나에서 ‘타겟 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께’ 다른 함수로 추출한다. 추출한 함수에 기억하기 쉬운 임시 이름을 지어준다. 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다. 하나씩 수정할 때마다 테스트한다. 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인한 후 원래 함수를 제거한다. 새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다. 예시12345678910111213141516171819202122232425262728// beforefunction renderPerson(outStream, person) { const result = []; result.push(`&lt;p&gt;${person.name}&lt;/p&gt;`); result.push(renderPhoto(person.photo)); result.push(`&lt;p&gt;제목: ${person.photo.title}&lt;/p&gt;`); result.push(emitPhotoData(person.photo)); return result.join(&quot;\\n&quot;);}function photoDiv(p) { return [ &quot;&lt;div&gt;&quot;, `&lt;p&gt;제목: ${p.title}&lt;/p&gt;`, emitPhotoData(p), &quot;&lt;/div&gt;&quot;, ].join(&quot;\\n&quot;);}function emitPhotoData(aPhoto) { const result = []; result.push(`&lt;p&gt;위치: ${aPhoto.location}&lt;/p&gt;`); result.push(`&lt;p&gt;날짜: ${aPhoto.date.toDateString()}&lt;/p&gt;`); return result.join(&quot;\\n&quot;);} 12345678910111213141516171819202122232425// afterfunction renderPerson(outStream, person) { const result = []; result.push(`&lt;p&gt;${person.name}&lt;/p&gt;`); result.push(renderPhoto(person.photo)); result.push(emitPhotoData(person.photo)); return result.join(&quot;\\n&quot;);}function photoDiv(aPhoto) { return [ &quot;&lt;div&gt;&quot;, emitPhotoData(aPhoto), &quot;&lt;/div&gt;&quot;, ].join(&quot;\\n&quot;);}function emitPhotoData(aPhoto) { return [ `&lt;p&gt;제목: ${aPhoto.title}&lt;/p&gt;`, `&lt;p&gt;위치: ${aPhoto.location}&lt;/p&gt;`, `&lt;p&gt;날짜: ${aPhoto.date.toDateString()}&lt;/p&gt;` ].join(&quot;\\n&quot;);} 8.4 문장을 호출한 곳으로 옮기기코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직인다. 여러 곳에서 사용하던 기능이 일부 호출자에서는 다르게 동작하도록 바뀌어야 한다면, 함수가 여러 가지 일을 수행하게 될 수도 있다. 이럴 때는 우선 문장 슬라이드하기를 적용해 달라지는 호출자로 옮긴다. 절차 호출자가 한두 개뿐이고 피호출 함수도 간단한 단순한 상황이면, 피호출 함수의 처음(혹은 마지막) 줄(들)을 잘라내어 호출자(들)로 복사해 넣는다. 테스트만 통과하면 이번 리팩터링은 여기서 끝이다. 더 복잡한 상황에서는, 이동하지 ‘않길’ 원하는 모든 문장을 함수로 추출한 다음 검색하기 쉬운 임시 이름을 지어준다. 원래 함수를 인라인한다. 추출된 함수의 이름을 원래 함수의 이름으로 변경한다. 예시호출자가 둘뿐인 단순한 상황 12345678910111213141516171819202122// before function renderPerson(outStream, person) { outstream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\\n`); renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); // ✅}function listRecentPhotos(outStream, photos) { photos .filter(p =&gt; p.date &gt; recentdateCutoff()) .forEach(p =&gt; { outStream.write(&quot;&lt;div&gt;\\n&quot;); emitPhotoData(outStream, p); // ✅ outStream.write(&quot;&lt;/div&gt;\\n&quot;); });}function emitPhotoData(outStream, photo) { outStream.write(`&lt;p&gt;제목: ${photo.title}&lt;/p&gt;\\n`); outStream.write(`&lt;p&gt;날짜: ${photo.date.toDateString()}&lt;/p&gt;\\n`); outStream.write(`&lt;p&gt;위치: ${photo.location}&lt;/p&gt;\\n`);} renderPerson()은 그대로 둔 채 listRecentPhotos()가 위치 정보(location)을 다르게 렌더링하도록 만들어 보자. 1234567891011121314151617181920212223// afterfunction renderPerson(outStream, person) { outstream.write(`&lt;p&gt;${person.name}&lt;/p&gt;\\n`); renderPhoto(outStream, person.photo); emitPhotoData(outStream, person.photo); outStream.write(`&lt;p&gt;위치: ${photo.location}&lt;/p&gt;\\n`); }function listRecentPhotos(outStream, photos) { photos .filter(p =&gt; p.date &gt; recentdateCutoff()) .forEach(p =&gt; { outStream.write(&quot;&lt;div&gt;\\n&quot;); emitPhotoData(outStream, p); outStream.write(`&lt;p&gt;위치: ${p.location}&lt;/p&gt;\\n`); outStream.write(&quot;&lt;/div&gt;\\n&quot;); });}function emitPhotoData(outStream, photo) { outStream.write(`&lt;p&gt;제목: ${photo.title}&lt;/p&gt;\\n`); outStream.write(`&lt;p&gt;날짜: ${photo.date.toDateString()}&lt;/p&gt;\\n`);}","link":"/2022/04/01/refactoring-8-1/"},{"title":"리팩터링 8장 - 2","text":"기능 이동 - 2 8.5 인라인 코드를 함수 호출로 바꾸기함수는 동작의 목적을 말해주기 때문에 코드를 이해하기 쉽게 해주고, 중복을 없애준다. 이미 존재하는 함수와 똑같은 일을 하는 인라인 코드를 발견하면 해당 코드를 함수 호출로 대체할 수 있다. 특히 라이브러리가 제공하는 함수로 대체할 수 있다면 훨씬 좋다. 절차 인라인 코드를 함수 호출로 대체한다. 테스트한다. 예시12345// beforelet appliesToMass = false;for (const s of states) { if (s === &quot;MA&quot;) appliesToMass = true;} 12// afterappliesToMass = states.includes(&quot;MA&quot;); 8.6 문장 슬라이드하기하나의 데이터 구조를 이용하는 문장들은 한데 모여 있어야 좋다. 문장 슬라이드하기 리팩터링으로 이런 코드들을 한데 모아둘 수 있다. 관련 있는 코드들은 명확히 구분되는 함수로 추출하는 것이 좋다. 절차 코드 조각(문장들)을 이동할 목표 위치를 찾는다. 코드 조각의 원래 위치와 목표 위치 사이의 코드들을 훑어보면서, 조각을 모으고 나면 동작이 달라지는 코드가 있는지 살핀다. 코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여 넣는다. 테스트한다. 예시코드 조각을 슬라이드할 때는 1) 무엇을 슬라이드할지와 2) 슬라이드할 수 있는지 여부를 확인해야 한다. 1234567891011121314// beforeconst pricingPlan = retrievePricingPlan();const order = retreiveOrder();const baseCharge = pricingPlan.base;let charge;const chargePerUnit = pricingPlan.unit;const units = order.units;let discount;charge = baseCharge + units * chargePerUnit;let discountableUnits = Math.max(units - pricingPlan.discountThreshold, 0);discount = discountableUnits * pricingPlan.discountFactor;if (order.isRepeat) discount += 20;charge = charge - discount;chargeOrder(charge); 슬라이드가 안전한 지를 판단하려면 관련된 연산이 무엇이고 어떻게 구성되는지를 완벽히 이해해야 한다. 부수효과가 있는 코드를 슬라이드하거나 부수효과가 있는 코드를 건너뛰어야 한다면 훨씬 신중해야 한다. 또 상태 갱신에 특히나 신경 써야 하기 때문에 상태를 갱신하는 코드 자체를 최대한 제거하는 게 좋다. 슬라이드 후 테스트가 실패했을 때 가장 좋은 대처는 더 작게 슬라이드해보는 것이다. 더 읽을거리문장 교환하기라는 이름의 거의 똑같은 리팩터링 방법은 인접한 코드 조각을 이동하지만, 문장 하나짜리 조각만 취급한다. 따라서 이동한 조각과 건너뛸 조각 모두 단일 문장으로 구성된 문장 슬라이드로 생각해도 된다. 8.7 반복문 쪼개기종종 반복문 하나에서 두 가지 일을 수행하는 모습을 보게 된다. 하지만 이렇게 하면 반복문을 수정할 때마다 두 가지 일 모두를 잘 이해하고 진행해야 한다. 반복문을 분리하면 사용하기가 쉬워진다. 한 가지 값만 계산하는 반복문이라면 그 값만 곧바로 반환할 수 있다. 절차 반복문을 복제해 두 개로 만든다. 반복문이 중복되어 생기는 부수효과를 파악해서 제거한다. 테스트한다. 완료됐으면, 각 반복문을 함수로 추출할지 고민해본다. 예시123456789// beforelet youngest = people[0] ? people[0].age : Infinity;let totalSalary = 0;for (const p of people) { if (p.age &lt; youngest) youngest = p.age; totalSalary += p.salary;}return `최연소: ${youngest}, 총 급여: ${totalSalary}`; 123456789101112// afterlet youngest = people[0] ? people[0].age : Infinity;let totalSalary = 0;for (const p of people) { totalSalary += p.salary;}for (const p of people) { if (p.age &lt; youngest) youngest = p.age;}return `최연소: ${youngest}, 총 급여: ${totalSalary}`; 더 가다듬기각 반복문을 각각의 함수로 추출하고, 반복문을 파이프라인으로 바꿀 수 있다 1234567function totalSalary() { return people.reduce((total, p) =&gt; total + p.salary, 0);}function youngestAge() { return Math.min(...people.map(p =&gt; p.age));} 8.8 반복문을 파이프라인으로 바꾸기컬렉션 파이프라인을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다. 절차 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다. 반복문의 첫 줄부터 시작해서, 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 이때 컬렉션 파이프라인 연산은 1에서 만든 반복문 컬렉션 변수에서 시작하여, 이전 연산의 결과를 기초로 연쇄적으로 수행된다. 하나를 대체할 때마다 테스트한다. 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다. 예시","link":"/2022/04/07/refactoring-8-2/"},{"title":"리팩터링 9장","text":"데이터 조직화 9.1 변수 쪼개기역할이 둘 이상인 변수가 있다면 쪼개야 한다. 역할 하나당 변수 하나다. 절차 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다. 가능하면 이때 불변으로 선언한다. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조(이 변수가 쓰인 곳)를 새로운 변수 이름으로 바꾼다 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다. 테스트한다. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다. 예시12345678910111213function distanceTravelled(scenario, time) { let result; let acc = scenario.primaryForce / scenario.mass; // ⬅️ let primaryTime = Math.min(time, scenario.delay); result = 0.5 * acc * primaryTime * primaryTime; let secondaryTime = time - scenario.delay; if (secondaryTime &gt; 0) { let primaryVelocity = acc * scenario.delay; acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; // ⬅️ result += primaryVelocity * secondaryTime + 0.5 * acc * secondaryTime * secondaryTime; } return result;} acc 변수에 값이 두 번 대입되는 부분을 쪼개보자 12345678910111213function distanceTravelled(scenario, time) { let result; const primaryAcceleration = scenario.primaryForce / scenario.mass; // ✅ let primaryTime = Math.min(time, scenario.delay); result = 0.5 * primaryAcceleration * primaryTime * primaryTime; // ✅ let secondaryTime = time - scenario.delay; if (secondaryTime &gt; 0) { let primaryVelocity = primaryAcceleration * scenario.delay; // ✅ const secondaryAcceleration = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass; // ✅ result += primaryVelocity * secondaryTime + 0.5 * secondaryAcceleration * secondaryTime * secondaryTime; // ✅ } return result;} 9.2 필드 이름 바꾸기데이터 구조는 프로그램을 이해하는 데 큰 역할을 한다. 클래스에서 게터와 세터 메서드의 이름은 레코드 구조체의 필드 이름만큼 중요하다. 절차 레코드의 유효 범위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요 없다. 레코드가 캡슐화되지 않았다면 우선 레코드를 캡슐화한다. 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다. 테스트한다. 생성자의 매개변수 중 필드와 이름이 겹치는 게 있다면 함수 선언 바꾸기로 변경한다. 접근자들의 이름도 바꿔준다. 예시1const organiztaion = { name: &quot;애크미 구스베리&quot;, country: &quot;GB&quot; }; name을 title로 바꿔보자. organization 레코드를 클래스로 캡슐화한 뒤, 입력 데이터 구조를 내부 데이터 구조와 분리하자. 123456789101112131415161718192021222324class Organization { constructor(data) { this._title = data.title; this._country = data.country; } get title() { return this._title; } set title(aString) { this._title = aString; } get country() { return this._country; } set country(aCountryCode) { this._country = aCountryCode; }}const organization = new Organization({ title: &quot;애크미 구스베리&quot;, country: &quot;GB&quot; }) 9.3 파생 변수를 질의 함수로 바꾸기가변 데이터의 유효 범위는 가능한 한 좁혀야 한다. 그 방법 중 하나로, 값을 쉽게 계산해낼 수 있는 변수들을 모두 제거한다. 다만 예외가 있는데, 새로운 데이터 구조를 생성하는 변형 연산이라면 그대로 두는 것도 좋다. 데이터 구조를 감싸며 그 데이터에 기초하여 계산한 결과를 속성으로 제공하는 객체 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수 절차 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다. 해당 변수의 값을 계산해주는 함수를 만든다. 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다. 테스트한다. 변수를 읽는 코드를 모두 함수 호출로 대체한다. 테스트한다. 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다. 예시1234567891011class ProductionPlan { // ... get production() { return this._production; } applyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); this._production += anAdjustment.amount; }} 조정 값 adjustment를 적용하는 과정에서 직접 관련이 없는 누적 값 production까지 갱신하고 있다. (데이터 중복) 누적 값을 매번 갱신하지 않고 계산해보자. 12345678910class ProductionPlan { // ... get production() { return this._adjustments.reduce((sum, a) =&gt; sum + a.amount, 0); } applyAdjustment(anAdjustment) { this._adjustments.push(anAdjustment); }} 9.4 참조를 값으로 바꾸기객체(데이터 구조)를 다른 객체(데이터 구조)에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다. 참조로 다루는 경우에는 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신하며, 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다. 필드를 값으로 다룬다면 내부 객체의 클래스를 수정하여 값 객체(Value Object)로 만들 수 있다. 값 객체는 불변이기 때문에 대체로 자유롭게 활용하기 좋다. 하지만 특정 객체를 여러 객체에서 공유하고자 한다면, 그래서 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 다뤄야 한다. 절차 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다. 각각의 세터를 하나씩 제거한다. 이 값 객체의 필드들을 사용하는 동치성 비교 메서드를 만든다. 예시생성 시점에는 전화번호가 올바로 설정되지 못한 사람(Person) 객체가 있다. 123456789101112131415161718192021222324252627282930313233343536373839class Person { constructor() { this._telephoneNumber = new TelephoneNumber(); } get officeAreaCode() { return this._telephoneNumber.areaCode; } set officeAreaCode(arg) { this._telephoneNumber.areaCode = arg; } get officeNumber() { return this._telephoneNumber.number; } set officeNumber(arg) { this._telephoneNumber.number = arg; }}class TelephoneNumber { get areaCode() { return this._areaCode; } set areaCode(arg) { this._areaCode = arg; } get number() { return this._number; } set number(arg) { this._number = arg; }} 전화번호를 불변으로 만들고, 필드들의 세터만 제거한다. 전화번호를 ‘값’ 객체로 인정받기 위해 동치성 메서드를 만든다. 1234567891011121314151617181920212223242526272829303132333435class Person { constructor() { this._telephoneNumber = new TelephoneNumber(); } get officeAreaCode() { return this._telephoneNumber.areaCode; } set officeAreaCode(arg) { this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber); } get officeNumber() { return this._telephoneNumber.number; } set officeNumber(arg) { this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg); }}class TelephoneNumber { constructor(areaCode, number) { this._areaCode = areaCode; this._number = number; } // getter와 setter들... equals(other) { if (!(other instanceof TelephoneNumber)) return false; return this.areaCode === other.areaCode &amp;&amp; this.number === other.number; }} 9.5 값을 참조로 바꾸기하나의 데이터 구조 안에 논리적으로 똑같은 제3의 데이터 구조를 참조하는 레코드가 여러 개 있을 때가 있다. 논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 그 데이터를 갱신해야 할 때다. 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다. 값을 참조로 바꾸면 엔티티 하나당 객체도 단 하나만 존재하게 되는데, 그러면 보통 이런 객체들을 한데 모아놓고 클라이언트들의 접근을 관리해주는 일종의 저장소가 필요하다. 절차 같은 부류에 속하는 객체들을 보관할 저장소를 만든다. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 때마다 테스트한다. 예시1234567891011121314151617181920class Order { constructor(data) { this._number = data.number; this._customer = new Customer(data.customer); } get customer() { return this._customer; }}class Customer { constructor(id) { this._id = id; } get id() { return this._id; }} 이런 방식으로 생성한 고객 객체는 값이기 때문에, 고객 ID가 123인 주문을 다섯 개 생성한다면 독립된 고객 객체가 다섯 개 만들어진다. 이 중 하나를 수정하더라도 나머지 네 개에는 반영되지 않는다. 저장소 객체를 만들고, 고객 객체를 값으로 변경해보자. 12345678910111213141516171819202122232425262728let _repositoryData;export function initialize() { _repositoryData = {}; _repositoryData.customers = new Map();}export function registerCustomer(id) { if (!_repositoryData.customers.has(id)) { _repositoryData.customers.set(id, new Customer(id))'' } return findCustomer(id);}export function findCustomer(id) { return _repositoryData.customers.get(id);}class Order { constructor(data) { this._number = data.number; this._customer = registerCustomer(data.customer); } get customer() { return this._customer; }} 이 예에서는 특정 고객 객체를 참조하는 첫 번째 주문에서 해당 고객 객체를 생성했다. 또 다른 방법으로, 고객 목록을 미리 다 만들어서 저장소에 저장해놓고 주문 정보를 읽을 때 연결해줄 수도 있다. 9.6 매직 리터럴 바꾸기매직 리터럴(magic literal)이란 소스 코드에 (보통은 여러 곳에) 등장하는 일반적인 리터럴 값을 말한다. 매직 리터럴보다는, 코드 자체가 뜻을 분명하게 드러내는 게 좋다. 상수를 정의하고 숫자 대신 상수를 사용하면 된다. 상수가 특별한 비교 로직에 주로 쓰이는 경우에는 상수값 그대로를 사용하기보다는 함수 호출로 바꿀 수도 있다. 방법 상수를 선언하고 매직 리터럴을 대입한다. 해당 리터럴이 사용되는 곳을 모두 찾는다. 찾은 곳 각각에서 리터럴이 새 상수와 똑같은 의미로 쓰였는지 확인하여, 같은 의미라면 상수로 대체한 후 테스트한다.","link":"/2022/04/14/refactoring-9/"},{"title":"타입스크립트 이펙티브 1장","text":"타입스크립트 알아보기 아이템 1: 타입스크립트와 자바스크립트의 관계 이해하기“타입스크립트는 자바스크립트의 상위집합(superset)이다” 그렇기 때문에 자바스크립트 코드는 이미 타입스크립트다. 기존 자바스크립트 코드를 타입스크립트로 마이그레이션하는 데 엄청난 이점! 타입 구문을 사용하는 순간부터 자바스크립트는 타입스크립트 영역으로 들어가게 된다 타입 시스템에서는 런타임에 오류를 발생시킬 코드를 미리 찾아낸다123456789const states = [ { name: 'Alabama', capital: 'Montogmery' }, { name: 'Alaska', capital: 'Juneau' }, { name: 'Arizona', capital: 'Phoenix' }, // ...];for (const state of states) { console.log(state.capitol); // JS에서는 undefined, TS에서는 에러} 타입을 명시적으로 선언하여 의도를 분명하게 하면 오류를 구체적으로 알 수 있다.123456789101112131415interface State { name: string; capital: string;}const states: State[] = [ { name: 'Alabama', capitol: 'Montogery' }, { name: 'Alaska', capitol: 'Juneau' }, { name: 'Arizona', capitol: 'Phoenix' },];// 🚨 Error// 'State' 형식에 'capitol'이 없습니다.// 'capital'을(를) 쓰려고 했습니까? for (const state of states) { console.log(state.capital);} 타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 ‘모델링’한다 런타임에서 정상 동작하는 코드에 타입스크립트가 오류를 표시하는 경우123const a = null + 7;// ✅ JS에서는 a의 값이 7이 된다.// 🚨 TS Error: '+' 연산자를 ... 형식에 적용할 수 없습니다. 아이템 2: 타입스크립트 설정 이해하기 tsconfig.json으로 타입스크립트 설정 작성하기12345{ &quot;compilerOptions&quot;: { // ... }} noImplicitAny 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어123function add(a, b) { return a + b;} add 부분에 hover 시 타입스크립트가 추론한 함수의 타입 확인 가능1function add(a: any, b: any): any → 이를 암시적 any라고 부른다 noImplicitAny가 설정되었다면 오류 발생 strictNullChecks null과 undefined가 모든 타입에서 허용되는지 확인한다 12345// strictNullChecks 해제 시const x: number = null; // 정상// strictNullChecks 설정 시const x: number = null; // 🚨 에러: 'null' 형식은 'number' 형식에 할당할 수 없습니다. null을 사용하지 않으려면 null을 체크하는 코드나 단언문을 추가해야 한다 1234567const el = document.getElementById('status');el.textContent = 'Ready'; // 🚨 에러if (el) { el.textContent = 'Ready'; // 정상, null을 제외}el!.textContent = 'Ready'; // 정상, el이 null이 아님을 단언 타입스크립트에서 엄격한 체크를 하고 싶다면 strict 설정을 고려 아이템 3: 코드 생성과 타입이 관계없음을 이해하기 타입스크립트 컴파일러는 두 가지 역할을 수행한다. 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다. 코드의 타입 오류를 체크한다. 타입 오류가 있는 코드도 컴파일이 가능하다. 컴파일은 타입 체크와 독립적으로 동작하기 때문이다. 작성한 타입스크립트가 유효한 자바스크립트라면 타입스크립트 컴파일러는 컴파일을 해 낸다. 런타임에는 타입 체크가 불가능하다. 타입스크립트의 타입은 ‘제거 가능’하다. 즉 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버린다 런타임에 타입 정보를 유지하는 방법 특정 속성이 존재하는지 체크 ‘태그’ 기법 - 런타임에 접근 가능한 타입 정보를 명시적으로 저장 1234567891011121314151617181920interface Squrre { kind: 'square'; width: number;}interface Rectangle { kind: 'rectangle'; height: number; width: number;}type Shape = Square | Rectangle; // '태그된 유니온(tagged union)'function calculateArea(shape: Shape) { if (shape.kind === 'rectangle') { shape; // 타입이 Rectangle return shape.width * shape.height; } else { shape; // 타입이 Square return shape.width * shape.width; }} 타입(런타임 접근 불가)과 값(런타임 접근 가능)을 둘 다 사용하는 기법 타입을 클래스로 만들기 → 타입과 값으로 모두 사용할 수 있다 타입 연산은 런타임에 영향을 주지 않는다 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 자바스크립트 연산을 통해 변환을 수행해야 한다 런타임 타입은 선언된 타입과 다를 수 있다. switch~case 구문의 default 구문 API 요청의 반환값을 사용하는 경우 타입스크립트 타입으로는 함수를 오버로드할 수 없다.12function add(a: number, b: number) { return a + b; } // 🚨 에러: 중복된 함수 구현입니다.function add(a: string, b: string) { return a + b; } // 🚨 에러: 중복된 함수 구현입니다. 타입스크립트의 함수 오버로딩은 타입 수준에서만 가능하다 (구현체는 불가)12function add(a: number, b: number): number;function add(a: string, b: string): string; 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문이다 ‘런타임’ 오베허드가 없는 대신, 타입스크립트 컴파일러는 ‘빌드타임’ 오버헤드가 있다 타입스크립트가 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안할지, 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택할지의 문제에 맞닥뜨릴 수도 있다. 아이템 4: 구조적 타이핑에 익숙해지기 자바스크립트는 본질적으로 덕 타이핑(duck typing) 기반 🐤 덕 타이핑객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식 타입스크립트는 이 동작을 그대로 모델링한다. 예제 1234567891011121314interface Vector2D { x: number; y: number;}function calcaulateLength(v: Vector2D) { return Math.sqrt(v.x * v.x + v.y * v.y);}interface NamedVector { name: string; x: number; y: number;} NamedVector의 구조가 Vector2D와 호환되기 때문에 calcaulateLength 함수 호출 가능 🚨 문제 123456789101112131415161718interface Vector3D { name: string; x: number; y: number;}function normalize(v: Vector3D) { const length = calculateLength(v); return { x: v.x / length, y: v.y / length, z: v.z / length, };}normalize({ x: 3, y: 4, z: 5 })// { x: 0.6, y: 0.8, z: 1 } Vector3D 는 calculateLength 함수 호출 시 Vector2D와 호환된다 이때 z가 정규화에서 무시되기 때문에 잘못된 결과를 출력한다 구조적 타이핑과 클래스 할당문 123456789class C { foo: string; constructor(foo: string) { this.foo = foo; }}const c = new C('instanceof C');const d: C = { foo: 'object literal' }; // 정상 d는 string 타입의 foo 속성을 가지고, Object.prototype으로부터 비롯된 생성자를 가진다 구조적 타이핑을 사용하면 유닛 테스트를 쉽게 할 수 있다 1234567interface DB { runQuery: (sql: string) =&gt; any[];}function getAuthors(database: DB): Author[] { const authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`); return authorRows.map(row =&gt; ({ first: row[0], last: row[1] }));} 타입스크립트는 테스트 DB가 특정 인터페이스를 충족하는지 확인한다 추상화(DB)를 함으로써, 로직과 테스트를 특정한 구현으로부터 분리한다 아이템 5: any 타입 지양하기 any 타입에는 타입 안정성이 없다 123let age: number;age = '12' as any; // 정상age += 1; // 런타임에 정상, 🚨 age는 '121' any는 함수 시그니처를 무시해 버린다 12345function calculateAge(birthDate: Date): number { // ...}let birthDate: any = '1997-09-12';calculateAge(birthDate); // 정상 (🚨 추후 에러 발생 가능) any 타입에는 언어 서비스가 적용되지 않는다 IDE의 자동완성 기능과 적절한 도움말 제공 불가 any 타입은 코드 리팩터링 때 버그를 감춘다 any가 아닌 구체적인 타입을 사용하여 타입 체커가 오류를 발견하도록 해야 한다 any는 타입 설계를 감춰버린다 애플리케이션 상태 등의 객체 설계 시 any 사용을 지양해야 한다 any는 타입시스템의 신뢰도를 떨어뜨린다 사람은 항상 실수를 한다 any 타입을 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높일 수 있다 Ref 이펙티브 타입스크립트 1장: 타입스크립트 알아보기","link":"/2021/12/02/ts-effective-1/"},{"title":"타입스크립트 이펙티브 2장 - 1","text":"타입스크립트의 타입 시스템 아이템 6: 편집기를 사용하여 타입 시스템 탐색하기 타입스크립트에서 실행할 수 있는 프로그램 타입스크립트 컴파일러(tsc) 단독 실행 가능한 타입스크립트 서버(tsserver) 타입스크립트 서버에서 제공하는 언어 서비스를 사용하자 많은 편집기에서 타입스크립트가 그 타입을 어떻게 판단하는지 확인 가능 편집기상의 타입 오류를 살펴보는 것도 타입 시스템을 파악하는 데 좋은 방법 라이브러리와 라이브러리의 타입 선언 Go to Definition 옵션으로 d.ts에서 타입 정의 확인 가능 아이템 7: 타입이 값들의 집합이라고 생각하기 런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다 그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 타입을 가지고 있으며,이는 할당 가능한 값들의 집합이다. 집합의 종류 never - 아무것도 포함하지 않는 공집합. 아무 값도 할당 불가1const x: never = 12; // 🚨 '12' 형식은 'never' 형식에 할당할 수 없습니다. 리터럴(유닛) 타입 - 한 가지 값만 포함하는 타입 1type A = 'A'; 유니온 타입 - 두 개 혹은 세 개, 값 집합들의 합집합 1type AB = 'A' | 'B'; ‘할당 가능’하다는 뜻 - ‘부분 집합’1const a: AB = 'A'; // 'A'는 집합 {'A', 'B'}의 원소 실제 다루게 되는 타입은 대부분 범위가 무한대1type Int = 1 | 2 | 3 | 4 | 5 // | ... 원소를 서술하는 방법123interface Identified { id: string;} 타입 = 값의 집합 &amp; 연산자는 두 타입의 인터섹션(교집합)을 계산 | 연산자는 두 인터페이스의 유니온, 교집합이 없는 두 개 이상의 타입에서 사용 시 주의 12345678910interface Person { name: string;}interface Lifespan { birth: Date; death?: Date;}type PersonSpan = Person &amp; Lifespan;type K = keyof (Person | Lifespan); // 타입이 never extends : ~에 할당 가능한, ~의 부분집합 서브타입: 어떤 집합이 다른 집합의 부분집합123interface Vector1D { x: number; }interface Vector2D extends Vector1D { y: number; }interface Vector3D extends Vector2D { z: number; } Vector3D는 Vector2D의 서브타입, Vector2D는 Vector1D의 서브타입 제네릭에서의 extends123function getKey&lt;K extends string&gt;(val: any, key: K) { // ...} 집합의 관점에서 string을 상속 string 리터럴 타입, string 리터럴 타입의 유니온, string 자신을 포함 타입이 집합이라는 관점에서 배열과 튜플의 관계 살펴보기123const list = [1, 2]; // 타입은 number[]const tuple: [number, number] = list;// 🚨 'number[]' 타입은 '[number, number]' 타입의 0, 1 속성에 없습니다 트리플123const triple: [number, number, number] = [1, 2, 3];const doulbe: [number, number] = triple;// 🚨 숫자의 length값이 맞지 않기 때문에 할당문에 오류 발생 타입이 값의 집합이라는 뜻은, 동일한 값의 집합을 가지는 두 타입은 같다는 의미 아이템 8: 타입 공간과 값 공간의 심벌 구분하기 타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재123456interface Cylinder { radius: number; height: number;}const Cylinder = (radius: number, height: number) =&gt; ({ radius, height }); interface Cylinder에서 Cylinder는 타입, const Cyliner와 무관 일반적으로 type이나 interface 다음에 나오는 심벌은 타입,const나 let 선언에 쓰이는 값은 값 컴파일 타입에서 타입 정보는 제거된다 class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능123456789101112// 타입으로 쓰인 Cylinder 클래스class Cylinder { radius = 1; height = 1;}function calculateVolume(shape: unknown) { if (shape instanceof Cylinder) { shape // 정상, 타입은 Cylinder shape.radius // 정상, 타입은 number }} 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면,값으로 쓰일 때는 생성자가 사용된다 typeof - 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 한다.12345type T1 = typeof p; // 타입은 Persontype T2 = typeof email; // 타입은 (p: Person, subject: string, body: string) =&gt; Responseconst v1 = typeof p; // 값은 'object'const v2 = typeof email; // 값은 'function' 타입의 관점에서 typeof 은 값을 읽어서 타입스크립트 타입을 반환 값의 관점에서 typeof 은 자바스크립트 런타임의 typeof 연산자를 반환 (심벌의 런타임 타입을 가리킴) 클래스1234type T = typeof Cylinder; // 타입이 typeof Cylinderdeclare let fn: T;const c = new fn(); // 타입이 Cylinder InstanceType 제너릭을 사용해 생성자 타입과 인스턴스 타입 전환 가능1type C = InstanceType&lt;typeof Cylinder&gt;; // 타입이 Cylinder 속성 접근자 [] obj['field']와 obj.field는 값이 동일하더라도 타입은 다를 수 있으므로, 타입의 속성을 얻을 때는 obj['field']를 사용한다 👩‍🏫 타입스크립트에서 타입 공간과 값 공간을 혼동해서 잘못 작성하는 경우 주의 아이템 9: 타입 단언보다는 타입 선언을 사용하기 타입 단언은 오류를 발견하지 못한다1234interface Person { name: string };const alice: Person = {}; // 🚨 'Person' 유형에 필요한 'name' 속성이 '{}' 유형에 없습니다.const bob = {} as Person; // 오류 없음 속성을 추가할 때도 마찬가지 타입 선언문에서는 잉여 속성 체크가 동작하지만, 단언문에서는 적용되지 않는다 화살표 함수의 타입 선언12const people = ['alice', 'bob', 'jan'].map(name =&gt; ({name}));// Person[]을 원했지만 결과는 { name: string; }[]... 단언문 대신 화살표 함수의 반환 타입을 선언123const people = ['alice', 'bob', 'jan'].map( (name): Person =&gt; ({ name })); // 타입은 Person[] 그러나 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작에서부터 명명된 타입을 가져야 오류가 정확하게 표시된다 타입 단언이 꼭 필요한 경우 타입 체커가 추론한 타입보다 개발자가 판단하는 타입이 더 정확할 때12345document.querySelector('#myButton').addEventListener('click', e =&gt; { e.currentTarget // 타입은 EventTarget const button = e.currentTarget as HTMLButtonElement; button // 타입은 HTMLButtonElement}); ! 문법을 사용해서 null이 아님을 단언하는 경우12const elNull = document.getElementById('foo'); // 타입은 HTMLElement | nullconst el = document.getElementById('foo')!; // 타입은 HTMLElement 타입 단언문으로 임의의 타입 간에 변환 A가 B의 부분집합(서브타입)인 경우 사용 아이템 10: 객체 래퍼 타입 피하기 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환 가능 (래퍼 객체) string 기본형과 String 래퍼 객체가 항상 동일하게 동작하는 것은 아니다 String 객체는 오직 자기 자신하고만 동일하다12'hello' === new String('hello'); // falsenew String('hello') === new String('hello'); // flase 타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다1234567function isGreeting(phrase: String) { return [ 'hello', 'good day', ].includes(phrase); // 🚨 'String' 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다. } string은 String에 할당할 수 있지만 String은 string에 할당할 수 없다 타입스크립트가 제공하는 타입 선언은 전부 기본형 타입이다 아이템 11: 잉여 속성 체크의 한계 인지하기 타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 ‘그 외의 속성은 없는지’ 확인한다.123456789101112interface Room { numDoors: number; ceilingHeightFt: number;}const obj = { numDoors: 1, ceilingHeightFt: 10, elephant: 'present',};const r: Room = obj; // 정상 obj 타입은 Room 타입의 부분 집합을 포함하므로, Room에 할당 가능하며 타입 체커도 통과한다 잉여 속성 체크는 할당 가능 검사와는 별도의 과정이다 타입스크립트는 런타임 오류 뿐 아니라 의도와 다르게 작성된 코드까지 찾는다 1234567891011121314interface Options { title: string; darkMode?: boolean;}function createWindow(options: Options) { if (options.darkMode) { setDarkMode(); } // ...}createWindow({ title: 'Spider Solitaire', darkmode: true // 🚨 에러 }); 런타임에 에러가 발생하지 않지만, 타입스크립트에서 에러가 발생한다 Options는 넓은 타입으로 해석된다12const o1: Options = document; // 정상const o2: Options = new HTLMAnchorElement; // 정상 document와 HTLMAnchorElement의 인스턴스 모두 string 타입인 title 속성을 갖고 있기 때문에 할당문은 정상 잉여 속성 체크는 객체 리터럴만 체크한다1234567const o: Options = { darkmode: true, title: 'Ski Free' }; // 🚨 에러 const intermediate = { darkmode: true, title: 'Ski Free' };const o: Options = intermediate; // 정상// 타입 단언문을 사용할 때도 적용되지 않는다 const o: Options = { darkmode: true, title: 'Ski Free' } as Options // 정상 아이템 12: 함수 표현식에 타입 적용하기 타입스크립트에서는 함수 선언문이 아닌 함수 표현식을 권장 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다12type DiceRollFn = (sides: number) =&gt; number;const rollDice: DiceRollFn = sides =&gt; { /* ... */ }; 반복되는 함수 시그니처를 하나의 함수로 통합하여 불필요한 코드의 반복을 줄일 수 있다 라이브러리는 공통 함수 시그니처를 타입으로 제공하기도 한다 ex) 리액트의 MouseEventHandler 시그니처가 일치하는 다른 함수가 있을 때도 함수 표현식에 타입 적용 가능 ex) fetch 함수 1const responseP = fetch('/quote?by=Mark+Twain'); // 타입이 Promise&lt;Response&gt; 응답의 데이터를 추출123456async function getQuote() { const response = await fetch('/quote?by=Mark+Twain'); const quote = await response.json(); return quote;} 이때 /quote가 존재하지 않는 API거나 fetch가 실패하는 경우 버그가 발생한다→ 상태 체크를 수행해 줄 checkedFetch 함수 작성 함수 선언문을 함수 표현식으로 바꾸고, 함수 전체에 타입을 적용 1234// lib.dom.d.tsdeclare function fetch( input: RequestInfo, init?: RequestInit): Promise&lt;Response&gt;; 1234567const checkedFetch: typeof fetch = async (input, init) =&gt; { const response = await fetch(input, init); if (!reponse.ok) { throw new Error('Request failed: ' + response.status); } return response;}","link":"/2021/12/11/ts-effective-2-1/"},{"title":"타입스크립트 이펙티브 2장 - 2","text":"타입스크립트의 타입 시스템 아이템 13: 타입과 인터페이스의 차이점 알기 인터페이스와 타입 모두 사용 가능한 것 인덱스 시그니처 함수 타입 제너릭12345678type TPair&lt;T&gt; = { first: T; second: T;}interface IPair&lt;T&gt; = { first: T; second: T;} 인터페이스는 타입을 확장할 수 잇으며, 타입은 인터페이스를 확장할 수 있다 하지만 인터페이스는 유니온 타입 같은 복잡한 타입을 확장하지는 못한다 클래스 구현 시 타입과 인터페이스 둘 다 사용 가능하다 12345678class StateT implements TState { name: string = ''; capital: string = '';}class StateT implements IState { name: string = ''; capital: string = '';} 인터페이스와 타입의 차이점 유니온 타입은 있지만 유니온 인터페이스는 없다1type AorB = 'a' | 'b'; 유니온 타입 확장이 필요한 경우12345type Input = { /* ... */ };type Output = { /* ... */ };interface VariableMap { [name: string]: Input | Output;} 유니온 타입에 추가 속성을 붙인 타입 만들기1type NamedVariable = (Input | Output) &amp; { name: string }; → 인터페이스로 표현 불가! 튜플과 배열 타입123type Pair = [number, number];type StringList = string[];type NamedNums = [string, ...number[]]; 인터페이스로 튜플과 비슷하게 구현하기 (제한적, 튜플 메서드 사용 불가)123456interface Tuple { 0: number; 1: number; length: 2;}const t: Tuple = [10, 20]; // 정상 타입에는 없는 인터페이스의 보강 기능 (선언 병합)123456789101112interface IState { name: string; capital: string;};interface IState { population: number;}const wyoming: IState = { name: 'Wyoming', capital: 'Cheyenne', population: 500_000}; // 정상 타입스크립트는 여러 버전의 자바스크립트 표준 라이브러리에서 타입을 모아 병합한다 타입은 기존 타입에 추가적인 보강이 없는 경우에만 사용해야 한다 복잡한 타입이라면 타입 별칭을, 간단한 객체 타입이라면 인터페이스를 사용하자 👩‍🏫 하지만 무엇보다 일관성이 가장 중요! 아이템 14: 타입 연산과 제너릭 사용으로 반복 줄이기 타입에 이름 붙이기 타입이 반복적으로 등장하는 함수123function distance(a: {x: number, y: number}, b: {x: number, y: number}) { return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));} 타입에 이름을 붙여 개선하기12345interface Point2D { x: number; y: number;}function distance(a: Point2D, b: Point2D) { /* ... */ } 함수의 타입 시그니처 개선하기 몇몇 함수가 같은 타입 시그니처를 공유하는 경우12function get(url: string, opts: Options): Promise&lt;Response&gt; { /* ... */ }function post(url: string, opts: Options): Promise&lt;Response&gt; { /* ... */ } 해당 시그니처를 명명된 타입으로 분리하기123type HTTPFunction = (url: string, opts: Options) =&gt; Promise&lt;Response&gt;;function get: HTTPFunction = (url, opts) =&gt; { /* ... */ }function post: HTTPFunction = (url, opts) =&gt; { /* ... */ } 인터페이스를 확장하여 반복 제거하기12345678interface Person { firstName: string; lastName: string;}interface PersonWithBirthDate extends Person { birth: Date;} 이미 존재하는 타입을 확장하는 경우 인터섹션 연산자(&amp;) 사용하기1type PersonWithBirthDate = Person &amp; { birth: Date }; 전체 애플리케이션의 상태를 표현하는 State 타입과 부분만 표현하는 TopNavState 합치기1234567891011interface State { userId: string; pageTitle: string; recentFiles: string[]; pageContents: string;}interface TopNavState { userId: string; pageTitle: string; recentFiles: string[];} ‘매핑된 타입’ 사용하기123type TopNavState = { [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]}; 유틸 타입 Pick 사용하기1type TopNavState = Pick&lt;State, 'userId' | 'pageTitle' | 'recentFiles'&gt;; 태그된 유니온에서 인덱싱하기12345678910interface SaveAction { type: 'save'; // ...}interface LoadAction { type: 'load'; // ...}type Action = SaveAction | LoadAction;type ActionType = Action['type']; // 타입은 'save' | 'load' 타입을 선택적 필드를 포함하는 타입으로 변환하기123456789101112interface Options { width: number; height: number; color: string; label: string;}interface OptionsUpdate { width?: number; height?: number; color?: string; label?: string;} 매핑된 타입과 keyof 사용하기1type OptionsUpdate = {[k in keyof Options]?: Options[k]}; 유틸 타입 Partial 사용하기1type OptionsUpdate = Partial&lt;Options&gt;; 값의 형태에 해당하는 타입을 정의하고 싶은 경우12345678const INIT_OPTIONS = { width: 640, height: 480, color: '#00FF00', label: 'VGA',}type Options = typeof INIT_OPTIONS; 함수나 메서드의 반환 값에 명명된 타입 만들기12345function getUserInfo(userId: string) { // ... return { userId, name, age, height, weight, favoriteColor };}// 추론된 반환 타입은 { userId: string; name: string; age: number, ... }; ReturnType 제네릭 사용하기1type UserInfo = ReturnType&lt;typeof getUserInfo&gt;; 제너릭 타입에서 매개변수 제한하기12345678910interface Name { first: string; last: string;}type DancingDuo&lt;T extends Name&gt; = [T, T];const couple1: DancingDuo&lt;{ first: string }&gt; = [ { first: 'Sonny' }, { first: 'Cher' },]; // 🚨 에러 extends를 사용하여 Pick의 정의 완성하기123456type Pick&lt;T, K extends keyof T&gt; = { [k in K]: T[k];}; type FirstLast = Pick&lt;Name, 'first' | 'last'&gt;; // 정상type FirstMiddle = Pick&lt;Name, 'first' | 'middle'&gt;; // 🚨 에러 아이템 15: 동적 데이터에 인덱스 시그니처 사용하기 타입스크립트에서는 타입에 ‘인덱스 시그니처’를 명시하여 유연하게 매핑을 표현 123456type Rocket = {[property: string]: string};const rocket: Rocket = { name: 'Falcon 9', variant: 'v1.0', thrust: '4,940 kN',}; // 정상 {[property: string]: string} 키의 이름(키의 위치만 표시하는 용도)/ 키의 타입/ 값의 타입→ 🚨 자동완성, 정의로 이동, 이름 바꾸기 등에서 문제 발생 인덱스 시그니처는 부정확하므로 인터페이스 사용12345interface Rocket { name: string; variant: string; thrust_kN: number;} 인덱스 시그니처는 동적 데이터를 표현할 때 사용한다 CSV 파일의 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶은 경우, 열 이름이 무엇인지 미리 알 방법이 없을 때123456789101112function parseCSV(input: string): {[columnName: string]: string}[] { const lines = input.split('\\n'); const [header, ...rows] = lines; const headerColumns = header.split(','); return rows.map(rowStr =&gt; { const row: {[columnName: string]: string} = {}; rowStr.split(',').forEach((cell, i) =&gt; { row[headerColumns[i]] = cell; }); return row; });} 👩‍🏫연관 배열의 경우, 객체에 인덱스 시그니처를 사용하는 대신 Map 타입을 사용하는 것을 고려 어떤 타입에 가능한 필드가 제한되어 있는 경우라면 인덱스 시그니처로 모델링하지 말아야 한다 1234567interface Row1 { [column: string]: number } // 너무 광범위interface Row2 { a: number; b?: number; c?: number; d?: number } // 최선type Row3 = | { a: number; } | { a: number; b: number; } | { a: number; b: number; c: number; } | { a: number; b: number; c: number; d: number }; // 가장 정확하지만 사용하기 번거로움 Record 사용하기1type Vec3D = Record&lt;'x' | 'y' | 'z', number&gt;; 매핑된 타입 사용하기12type Vec3D = {[k in 'x' | 'y' | 'z']: number};type ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number}; → 키마다 별도의 타입 사용 가능 아이템 16: number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기 자바스크립트 객체의 키는 문자열만 가능 숫자는 키로 사용 불가 배열의 인덱스도 사실은 문자열 타입스크립트는 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식 Array의 타입 선언(lib.es5.d.ts)1234interface Array&lt;T&gt; { // ... [n: number]: T;} 인덱스 시그니처가 number로 표현되어 있다면 입력한 값이 number여야 한다는 것을 의미하지만, 실제 런타임에 사용되는 키는 string 타입이다 만약 숫자로 인덱싱을 한다면 Array 또는 튜플 타입을 사용하는 것을 권장 🤔 그러나 Array의 메서드를 사용하고자 하는 게 아니라면?→ ArrayLike 타입을 사용123456789 function checkedAccess&lt;T&gt;(xs: ArrayLike&lt;T&gt;, i: number): T { if (i &lt; xs.length) { return xs[i]; } throw new Error('...'); }``` ```jsx(마크다운 오류 방지 라인) ArrayLike는 길이와 인덱스 시그니처만 있다 ArrayLike도 키는 여전히 문자열 아이템 17: 변경 관련된 오류 방지를 위해 readonly 사용하기 함수 파라미터로 넘어가는 배열의 변경을 방지 readonly 배열의 요소를 읽을 수 있지만, 쓸 수는 없다 length를 읽을 수 있지만, 바꿀 수는 없다 배열을 변경하는 pop을 비롯한 다른 메서드를 호출할 수 없다 number[] 는 readonly number[] 의 서브타입 매개변수를 readonly 로 선언하면? 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크한다 호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받게 된다 호출하는 쪽에서 함수에 readonly 배열을 매개변수로 넣을 수도 있다 자바스크립트에서는 기본적으로 함수가 매개변수를 변경하지 않는다고 가정하지만, 이러한 암묵적인 방법은 타입 체크에 문제를 일으킬 수 있다 어떤 함수를 readonly 로 만들면, 그 함수를 호출하는 다른 함수들도 모두 readonly로 만들어야 한다→ 타입의 안전성을 높인다 readonly 배열을 조작하는 방법 arr.length = 0 대신 arr = [] arr.push('abc') 대신 arr = arr.concat(['abc']) readonly는 얕게(shallow) 동작한다 객체로 구성된 readonly 배열이 있다면, 그 객체 자체는 readonly가 아니다 객체에 사용할 때는 Readonly 제네릭을 사용123456789interface Outer { inner: { x: number; }}const o: ReadOnly&lt;Outer&gt; = { inner: { x: 0 }};o.inner = { x : 1 }; // 🚨 에러o.inner.x = 1; // 정상 cf) ts-essentials의 DeepReadonly 제네릭 인덱스 시그니처에 readonly를 사용하면 객체 속성 변경 방지 가능 아이템 18: 매핑된 타입을 사용하여 값을 동기화하기 여러번 반복되는 타이핑 줄이기123456789101112131415161718192021222324252627282930interface ScatterProps { xs: number[]; ys: number[]; xRange: [number, number]; yRange: [number, number]; color: string, onClick: (x: number, y: number, index: number) =&gt; void,}const REQUIRES_UPDATE: {[k in keyof ScatterProps]: boolean} = { xs: true, ys: true, xRange: true, yRange: true, color: true, onClick: false,};function shouldUpdate( oldProps: ScatterProps, newProps: ScatterProps) { let k: keyof ScatterProps; for (k in oldProps) { if (oldProps[k] !== newProps[k] &amp;&amp; REQUIRES_UPDATE[k]) { return true; } } return false;} 매핑된 타입을 사용해서 관련된 값과 타입을 동기화할 수 있다 인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려하자!","link":"/2021/12/11/ts-effective-2-2/"},{"title":"타입스크립트 이펙티브 3장","text":"타입 추론 아이템 19: 추론 가능한 타입을 사용해 장황한 코드 방지하기 코드의 모든 변수에 타입을 선언하는 것은 비생산적이며 형편없는 스타일이다. 객체는 비구조화 할당문을 활용하자 모든 지역 변수의 타입이 추론되도록 한다1234 function logProduct(product: Product) {const { id, name, price } = product;console.log(id, name, price); } 타입 구문을 생략하는 경우 함수 내에서 생성된 지역 변수 함수 파라미터에 기본값이 있는 경우 타입을 명시하면 좋은 경우 객체 리터럴을 정의할 때, 잉여 속성 체크가 동작한다 함수의 반환 타입 함수의 입출력 타입에 대해 더욱 명확하게 알 수 있다 명명된 타입을 사용할 수 있다 1234interface Vector2D { x: number; y: number; }function add(a: Vector2D, b: Vector2D) { return { x: a.x + b.x, y: a.y + b.y };} → 이 함수의 반환타입은 Vector2D와 호환되지 않는다! cf) eslint 규칙 중 no-inferrable-types 사용 가능 작성된 모든 타입 구문이 정말로 필요한지 확인 아이템 20: 다른 타입에는 다른 변수 사용하기 변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않는다 타입 확장하기 - 유니온 타입 1let id: string | number = &quot;12-34-56&quot;; → 더 많은 문제가 발생할 위험이 있다 차라리 별도의 변수를 도입하자12const id = &quot;12-34-56&quot;;const serial = 123456; → 이렇게 하면 let이 아닌 const로 사용도 가능하다! 아이템 21: 타입 넓히기 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에, 변수는 ‘가능한’ 값들의 집합인 타입을 가진다 타입스크립트의 ‘넓히기’ 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추하는 것 1let x = 'x'; → 변수 x는 할당 시점에 넓히기가 동작해서 string으로 추론된다 넓히기를 제어하는 것이 좋다 넓히기를 제어하는 방법 const로 변수 선언하기 객체에서 타입스크립트의 넓히기 알고리즘은 각 요소를 let으로 할당된 것처럼 다룬다 123456const v = { x: 1 };v.x = 3; // 정상v.x = '3'; // 🚨 '3' 형식은 'number' 형식에 할당할 수 없습니다.v.y = 4; // 🚨 '{ x: number; }' 형식에 'y' 속성이 없습니다.v.name = 'Pythagoras'; // 🚨 '{ x: number; }' 형식에 'name' 속성이 없습니다 타입스크립트의 기본 동작 재정의하기 명시적 타입 구문 제공 123const v: { x: 1|3|5 } = { x: 1,}; // 타입이 { x: 1|3|5; } 타입 체커에 추가적인 문맥 제공 ex) 함수의 매개변수로 값을 전달 const 단언문 사용하기 (as const) 1234567891011121314const v1 = { x: 1, y: 2,} // 타입은 { x: number, y: number; }const v2 = { x: 1 as const; y: 2,}; // 타입은 { x: 1, y: number; }const v3 = { x: 1, y: 2,} as const; // 타입은 { readonly x: 1; readonly y: 2; } 아이템 22: 타입 좁히기 분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입 좁히기 instanceof 으로 타입 좁히기 속성 체크로 타입 좁히기 12345678910interface A { a: number }interface B { b: number }function pickAB(ab: A | B) { if ('a' in ab) { ab // 타입이 A } else { ab // 타입이 B } ab // 타입이 a | B} Array.isArray 등의 내장 함수로 타입 좁히기 🚨주의! null 체크 시 typeof null === 'object'가 된다 명시적 ‘태그’ 붙이기 (tagged union)12345678910function handleEvent(e: AppEvent) { switch (e.type) { case 'download': e; break; case 'upload': e; break; }} 타입스크립트를 돕기 위해 커스텀 함수 도입 (사용자 정의 타입 가드)123function isInputElement(el: HTMLElement): el is HTMLInputElement { return 'value' in el;} 배열에서 undefined 걸러내기123456function isDefined&lt;T&gt;(x: T | undefined): x is T { return x !== undefined;}const members = ['Janet', 'Michael'].map( who =&gt; jackson5.find(n =&gt; n === who)).filter(isDefined) // 타입이 string[] 아이템 23: 한꺼번에 객체 생성하기 타입스크립트의 타입은 일반적으로 변경되지 않는다. 따라서 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다. 객체를 제각각 나눠야 한다면, 타입 단언문(as) 을 사용한다12345interface Point { x: number; y: number; }const pt = {} as Point;pt.x = 3;pt.y = 4; // 정상 객체 전개 연산자(...) 사용 선택적 필드 방식으로 표현하기123456789101112function addOptional&lt;T extends object, U extends object&gt;( a: T, b: U | null): T &amp; Partial&lt;U&gt; { return { ...a, ...b };}const nameTitle = { name: 'Khufu', title: 'Pharaoh' };const pharaoh = addOptional( nameTitle, hasDates ? { start: -2589, end: -2566 } : null); 아이템 24: 일관성 있는 별칭 사용하기 별칭을 남발하면 제어 흐름을 분석하기 어렵다 객체의 속성을 별칭에 할당하면 strictNullChecks에서 걸릴 위험이 있다123456789101112131415interface Polygon { exterior: Coordinate[]; holes: Coordinate[][]; bbox?: BoundingBox;}function isPointInPolygon(polygon: Polygon, pt: Coordinate) { polygon.bbox // 타입이 BoundingBox | undefined const box = polygon.bbox; box // 타입이 BoundingBox | undefined if (polygon.bbox) { polygon.bbox // 타입이 BoundingBox box // 타입이 BoundingBox | undefined }} 속성 체크는 polygon.bbox의 타입을 정제했지만 box는 그렇지 않다→ 객체 비구조화 할당 이용하기 1234567function isPointInPolygon(polygon: Polygon, pt: Coordinate) { const { bbox } = polygon; if (bbox) { const { x, y } = bbpx; // ... }} 객체 비구조화 이용 시 주의사항 전체 bbox 속성이 아니라 x와 y가 선택적 속성일 경우 속성 체크가 더 필요하다 bbox에는 선택적 속성이 적합했지만 holes에는 그렇지 않다 런타임에도 혼동을 야기할 가능성 속성보다 지역 변수 사용하기 (교재 p.134 참조) 아이템 25: 비동기 코드에는 콜백 대신 async 함수 사용하기 과거 자바스크립트의 비동기 콜백 지옥 ES2015는 Promise 개념을 도입 ES2017에서는 async와 await 도입 타입스크립트에서는 런타임에 관계없이 async/await 사용 가능! 타입스크립트의 프로미스 반환 타입은 Promise&lt;Response&gt; 일반적으로 프로미스보다는 async/await 을 권장 더 간결하고 직관적 async 함수는 항상 프로미스를 반환하도록 강제된다 1234// function getNumber(): Promise&lt;number&gt;async function getNumber() { return 42;} 콜백이나 프로미스를 사용하면 실수로 반(half)동기 코드를 작성할 수 있지만, async를 사용하면 항상 비동기 코드를 작성할 수 있다.1234567891011121314151617const _cache: {[url: string]: string} = {};async function fetchWithCache(url: string) { if (url in _cache) { return _cache[url]; } const response = await fetch(url); const text = await response.text(); _cache[url] = text; return text;}let requestStatus: 'loading' | 'success' | 'error';async function getUsre(userId: string) { requestStatus = 'loading'; const profile = await fetchWithCache(`/user/${userId}`); requestStatus = 'success';} async 함수에서 프로미스를 반환하면 반환 타입은 Promise&lt;Promise&lt;T&gt;&gt;가 아닌 Promise&lt;T&gt;가 된다123456// function getJSON(url: string): Promise&lt;any&gt;async function getJSON(url: string) { const response = await fetch(url); const jsonPromise = response.json(); // 타입이 Promise&lt;any&gt; return jsonPromise;} 아이템 26: 타입 추론에 문맥이 어떻게 사용되는지 이해하기 문자열 타입을 문자열 리터럴 타입의 유니온으로 사용하는 경우1234567type Language = 'JavaScript' | 'TypeScript' | 'Python';function setLanguage(language: Language) { /* ... */ }setLanguage('JavaScript'); // 정상let language = 'JavaScript';setLanguage(language); // 🚨 에러 해결 방법 타입 선언에서 language의 가능한 값을 제한 12let language: Language = 'JavaScript';setLanguage(language); // 정상 language를 상수로 만들기12const language = 'JavaScript';setLanguage(language); // 정상 → const를 사용하여 타입 체커에게 변경할 수 없다고 알려주기 튜플 사용 시 주의점 위와 마찬가지로 값을 분리 당함1234567function panTo(where: [number, number]) { /* ... */ }panTo([10, 20]); // 정상const loc = [10, 20]; panTo(loc);// 🚨 'number[]' 형식의 인수는 '[number, number]' 형식의 매개변수에 할당될 수 없습니다 해결 방법 타입 선언 제공12const loc: [number, number] = [10, 20];panTo(loc); // 정상 상수 문맥 제공 123const loc = [10, 20] as const;panTo(loc);// 🚨 에러: 'readonly [10, 20]' 형식은 '[number, number]'에 할당할 수 없습니다. 최선의 해결책1234function panTo(where: readonly [number, number]) { /* ... */ }const loc = [10, 20] as const;panTo(loc); // 정상 객체 사용 시 주의점 문자열 리터럴이나 튜플을 포함하는 큰 객체에서 상수를 뽑아낼 때, 프로퍼티 타입이 string으로 추론되는 경우 타입 단언이나 상수 단언을 사용할 수 있다. 콜백 사용 시 주의점 콜백을 다른 함수로 전달할 때, 타입스크립트는 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용한다. 이 경우 넘겨주는 함수의 매개변수에 타입 구문을 추가해서 해결할 수 있다. 아이템 27: 함수형 기법과 라이브러리로 타입 흐름 유지하기 함수형 프로그래밍을 지원하는 최근의 라이브러리 ex) map, flatMap, filter, reduce 등 타입 정보가 그대로 유지되면서 타입 흐름(flow)이 계속 전달된다 lodash의 Dictionary 타입 123const rows = rawRows.slice(1) .map(rowStr =&gt; _.zipObject(headers, rowStr.split(','))); // 타입이 _.Dictionary&lt;string&gt;[] Dictionary&lt;string&gt;은 {[key: string]: string} 또는 Record&lt;string, string&gt; 과 동일하다 flat 메서드 T[][] =&gt; T[]1234declare const rosters: {[team: string]: BasketBallPlayer[]};const allPlayers = Object.values(rosters).flat();// 타입이 BasketBallPlayer[] 기타 내장된 함수형 기법들 타입스크립트의 많은 부분이 자바스크립트 라이브러리의 동작을 정확히 모델링하기 위해서 개발되었으므로, 라이브러리 사용 시 타입 정보가 잘 유지되는 점을 활용하자","link":"/2021/12/18/ts-effective-3/"},{"title":"타입스크립트 이펙티브 4장","text":"타입 설계 아이템 28: 유효한 상태만 표현하는 타입을 지향하기 애플리케이션의 상태 표현하기12345678910111213141516171819interface RequestPending { state: 'pending';}interface RequestError { state: 'error'; error: string;}interface RequestSuccess { state: 'ok'; pageText: string;}type RequestState = RequestPending | RequestError | RequestSuccess;interface State { currentPage: string; requests: {[page: string]: RequestState};} 모든 상황 고려하기 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하기 생각하기 아이템 29: 사용할 때는 너그럽게, 생성할 때는 엄격하게 TCP 구현체의 견고성 원칙 또는 포스텔의 법칙→ 함수의 시그니처에도 적용 함수의 매개변수는 타입의 범위가 넓어도 되지만,결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다 👎 bad case1234567891011121314declare function setCamera(camera: CameraOptions): void;declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;interface CameraOptions { center?: LngLat; zoom?: number; bearing?: number; pitch?: number;}type LngLat = { lng: number; lat: number; } | { lon: number; lat: number; } | [number, number]; 👍 good case12345678910111213141516171819interface LngLat { lng: number; lat: number; };type LngLatLike = LngLat | { lon: number; lat: number; } | [number, number];interface Camera { center: LngLat; zoom: number; bearing: number; pitch: number;}interface CameraOptions extends Omit&lt;Partial&lt;Camera&gt;, 'center'&gt; { center?: LngLatLike;}type LngLatBounds = { northeast: LngLatLike, southwest: LngLatLike } | [LngLatLike, LngLatLike] | [number, number, number, number];declare function setCamera(camera: CameraOptions): void;declare function viewportForBounds(bounds: LngLatBounds): Camera; → 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하자 아이템 30: 문서에 타입 정보를 쓰지 않기 타입 구문은 타입스크립트 타입 체커가 타입 정보를 동기화하도록 강제한다 함수의 입력과 출력의 타입을 코드로 표현하는 것이 주석보다 더 낫다 값을 변경하지 않는다고 설명하는 주석 대신 readonly 로 선언하기 변수명에 타입 정보 넣지 않기 (단위가 있는 숫자들은 제외) 아이템 31: 타입 주변에 null 값 배치하기 결함이 있는 예제12345678910111213function extent(nums: number[]) { let min, max; for (const num of nums) { if (!min) { min = num; max = num; } else { min = Math.min(min, num); max = Math.max(max, num); } } return [min, max];} 🚨 최솟값이나 최댓값이 0인 경우 🚨 nums 배열이 비어있는 경우 min과 max를 한 객체 안에 넣고 null이거나 null이 아니게 하기1234567891011function extent(nums: number[]) { let result: [number, number] | null = null; for (const num of nums) { if (!result) { result = [num, num]; } else { result = [Math.min(num, result[0]), Math.max(num, result[1])]; } } return [min, max];} null과 null이 아닌 값을 섞어서 클래스 만들기123456789101112131415161718192021class userPosts { user: UserInfo; posts: Post[]; constructor(user: UserInfo, posts: Post[]) { this.user = user; this.posts = posts; } static async init(userId: string): Promise&lt;UserPosts&gt; { const [user, posts] = await Promise.all([ fetchUser(userId), fetchPostsForUser(userId) ]); return new UserPosts(user, posts); } getUserName() { return this.user.name; }} 한 값의 null 여부가 다른 null 여부에 암시적으로 관련되도록 설계하면 안 된다 API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 한다 클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다 아이템 32: 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기 👎 잘못된 예시 1234interface Layer { layout: FillLayout | LineLayout | PointLayout; paint: FillPaint | LinePaint | PointPaint;} → 각각 타입의 계층을 분리된 인터페이스로 나누기 12345678910111213141516interface FillLayer { type: 'fill'; layout: FillLayout; paint: FillPaint;}interface LineLayer { type: 'line' layout: LineLayout; paint: LinePaint;}interface PointLayer { type: 'point'; layout: PointLayout; paint: PointPaint;}type Layer = FillLayer | LineLayer | PointLayer; 태그드 유니온 - 타입스크립트는 태그를 참고하여 범위를 좁힐 수 있다 123456function drawLayer(layer: Layer) { if (layer.type === 'fill') { const { paint } = layer; // 타입이 FillPaint const { layout } = layer; // 타입이 FillLayout } else // ... ``` 여러 개의 선택적 필드가 동시에 값이 있거나 동시에 undefined인 경우, 두 개의 속성을 하나의 객체로 모으기 12345678interface Person { name: string; // birthPlace와 birthDate를 하나로 모음 birth?: { place: string; date: Date; }} 아이템 33: string 타입보다 더 구체적인 타입 사용하기 “stringly typed”는 좋지 못한 패턴123456interface Album { artist: string; title: string; releaseDate: string; recordingType: string;} 타입을 제한하거나, 유니온 타입을 사용하기12345678type RecordingType = 'studio' | 'live';interface Album { artist: string; title: string; releaseDate: Date; recordingType: RecordingType;} 함수의 매개변수에 string을 잘못 사용하지 않도록 주의1234function pluck(records: any[], key: string): any[] { return records.map(r =&gt; r[key]);}// 🚨 '{}' 형식에 인덱스 시그니처가 없으므로 요소에 암시적으로 'any' 형식이 있습니다 제네릭과 keyof을 사용하여 고쳐보기12345type K = keyof Album;function pluck&lt;T&gt;(records: T[], key: keyof T) { return records.map(r =&gt; r[key]);} → 이때 타입스크립트는 반환 타입을 추론한다 keyof T로 범위 더 좁히기123function pluck&lt;T, K extends keyof T&gt;(records: T[], key: K): T[K][] { return records.map(r =&gt; r[key]);} 결과123pluck(albums, 'releaseDate'); // 타입이 Date[]pluck(albums, 'artist'); // 타입이 string[]pluck(albums, 'recordingType'); // 타입이 RecordingType[] 아이템 34: 부정확한 타입보다는 미완성 타입을 사용하기 코드를 더 정밀하게 만들려던 시도가 너무 과했고 그로 인해 코드가 오히려 더 부정확해지는 문제12345678910111213141516interface Point { type: 'Point'; coordinates: number[];}interface LineString { type: 'LineString'; coordinates: number[][];}interface Polygon { type: 'Polygon'; coordinates: number[][];}type Geometry = Point | LineString | Polygon; // 다른 것들도 추가될 수 있다 아래와 같이 구체화하는 경우 GeoJSON의 위치정보에는 추가 정보가 들어갈 수 없게 된다12345type GeoPosition = [number, number];interface Point { type: 'Point'; coordinates: GeoPosition;} 부정확함을 바로잡는 방법을 쓰는 대신, 테스트 세트를 추가하여 놓친 부분이 없는지 확인하기1234567891011121314151617181920212223242526type Expression = number | string | CallExpression;type CallExpression = MathCall | CaseCall | RGBCall;interface MathCall { 0: '+' | '-' | '/' | '*' | '&gt;' | '&lt;'; 1: Expression; 2: Expression; length: 3;}interface CaseCall { 0: 'case'; 1: Expression; 2: Expression; 3: Expression; length: 4 | 6 | 8 | 10 | 12 | 14 | 16 // 등등}interface RGBCall { 0: 'rgb'; 1: Expression; 2: Expression; 3: Expression; length: 4;} → 잘못 사용된 코드에서 오류가 발생하기는 하지만 오류 메시지가 더 난해해진다 타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다 개발 경험을 생각하기 아이템 35: 데이터가 아닌, API와 명세를 보고 타입 만들기 직접 타입 선언을 작성하는 것이 아닌 명세를 기반으로 타입을 작성한다면 사용 가능한 모든 값에 대해서 코드가 작동한다는 확신을 가질 수 있다. 아이템 36: 해당 분야의 용어로 타입 이름 짓기 동일한 의미를 나타낼 때는 같은 용어를 사용하기 data, info, thing, item, object, entity같은 모호하고 의미없는 이름은 피하기 이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지를 고려하기 아이템 37: 공식 명칭에는 상표를 붙이기 공식 명칭 (nominal typing) 타입이 아니라 값의 관점에서 말하기1234567891011121314interface Vector2D { _brand: '2d'; x: number; y: number;}function vec2D(x: number, y: number): Vector2D { return { x, y, _brand: '2d' };}function calculateNorm(p: Vector2D) { return Math.sqrt(p.x * p.x + p.y * p.y);}calculateNorm(vec2D(3, 4)); // 정상const vec3D = {x: 3, y: 4, z: 1};calculateNorm(vec3D); // 🚨 '_brand' 속성이 ... 형식에 없습니다 상표 시스템은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다 타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 구분하기 위해 공식 명칭이 필요할 경우 상표를 붙일 수 있다.","link":"/2021/12/22/ts-effective-4/"},{"title":"타입스크립트 이펙티브 5장","text":"any 다루기 아이템 38: any 타입은 가능한 한 좁은 범위에서만 사용하기 두 가지 any 작성 방식123456789function f1() { const x: any = expressionReturningFoo(); // 이렇게 하지 말자 processBar(x);}function f2() { const x = expressionReturningFoo(); // 이게 낫다 processBar(x as any);} any 타입이 processBar 함수의 매개변수에만 사용된 표현식이므로 다른 코드에는 영향을 미치지 않기 때문이다 타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 함수의 반환 타입을 명시하는 것이 좋다 강제로 타입 오류 제거 시 any 대신 @ts-ignore 사용하기123456function f1() { const x = expressionReturningFoo(); // @ts-ignore processBar(x); return x;} → 근본적인 문제 해결은 아니다 객체와 관련한 any의 사용법 1234567const config: Config = { a: 1, b: 2, c: { key: value }} as any; // 이렇게 하지 말자 → 모든 속성이 타입 체크가 되지 않는 부작용 발생 1234567const config: Config = { a: 1, b: 2, // 이 속성은 여전히 체크된다 c: { key: value as any }}; 아이템 39: any를 구체적으로 변형해서 사용하기 일반적인 상황에서는 any보다 더 구체적으로 표현할 수 있는 타입이 존재할 가능성이 높다1234567function getLengthBad(array: any) { // 이렇게 하지 말자 return array.length;}function getLength(array: any[]) { return array.length;} 함수의 매개변수로 객체 사용 시 타입 구체화하기12345678function hasTwelveLetterKey(o: {[key: string]: any}) { for (const key in o) { if (key.length === 12) { return true; } } return false;} 함수의 타입 구체화하기123type Fn0 = () =&gt; any; // 매개변수 없이 호출 가능한 모든 함수type Fn1 = (arg: any) =&gt; any; // 매개변수 1개type FnN = (...args: any[]) =&gt; any; // 모든 개수의 매개변수 (&quot;Funtion&quot; 타입과 동일) 아이템 40: 함수 안으로 타입 단언문 감추기 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 것이 좋다 어떤 함수든 캐싱할 수 있는 래퍼 함수 cacheLast12345678910111213141516declare function cacheLast&lt;T extends Function&gt;(fn: T): T;declare function shallowEqual(a: any, b: any): boolean;function cacheLast&lt;T extends Function&gt;(fn: T): T { let lastArgs: any[]|null = null; let lastResult: any; return function(...args: any[]) { // 🚨 '(...args: any[]) =&gt; any' 형식은 'T' 형식에 할당할 수 없습니다 if (!lastArgs || !shallowEqual(lastArgs, args)) { lastResult = fn(...args); lastArgs = args; } return lastResult; };} → 타입스크립트는 반환문에 있는 함수와 원본 함수 T 타입이 어떤 관련이 있는지 알지 못하기 때문에 오류 발생 단언문을 추가해서 오류를 제거123456789101112function cacheLast&lt;T extends Function&gt;(fn: T): T { let lastArgs: any[]|null = null; let lastResult: any; return function(...args: any[]) { if (!lastArgs || !shallowEqual(lastArgs, args)) { lastResult = fn(...args); lastArgs = args; } return lastResult; } as unknown as T;} 객체를 매개변수로 하는 shallowObjectEqual1234567891011declare function shallowObjectEqual&lt;T extends object&gt;(a: T, b: T): boolean;function shallowObjectEqual&lt;T extends object&gt;(a: T, b: T): boolean { for (conts [k, aVal] of Object.entries(a)) { if (!(k in b) || aVal !== (b as any)[k]) { // b[k] 구문에 타입 단언 필요 return false; } } return Object.keys(a).length === Object.keys(b).length; } 아이템 41: any의 진화를 이해하기 예제1234567function range(start: number, limit: number) { const out = []; // 타입이 any[] for (let i = start; i &lt; limit; i++) { out.push(i); // out의 타입이 any[] } return out; // 타입이 number[] } out의 타입은 any[]로 선언되었지만 number 타입의 값을 넣는 순간부터 타입은 number[]로 진화한다 타입의 진화 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다12345const result = []; // 타입이 any[]result.push('a');result // 타입이 string[]result.push(1); result // 타입이 (string | number)[] 기타 조건문에서는 분기에 따라 타입이 변화한다 변수의 초깃값이 null인 경우도 any의 진화가 발생한다 any 타입의 진화는 noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 발생한며, 명시적 any 선언 시 타입이 그대로 유지된다 any 타입의 진화는 암시적 any 타입에 어떤 값을 할당할 때만 발생하며, 암시적 any 타입은 함수 호출을 거쳐도 진화하지 않는다. 타입을 안전하게 지키기 위해서는 암시적 any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 좋다 아이템 42: 모르는 타입의 값에는 any 대신 unknown을 사용하기 함수의 반환값에 unknown 사용하기123456789101112131415function parseYAML(yaml: string): any { // ... }function safeParseYAML(yaml: string): unknown { return parseYAML(yaml);}const book = safeParseYAML(` name: Villette author: Charlotte Bronte`) as Book; alert(book.title); // 🚨 'Book' 형식에 'title' 속성이 없습니다book('read'); // 🚨 이 식은 호출할 수 없습니다 any가 강력하면서도 위험한 이유 어떠한 타입이든 any 타입에 할당 가능하다 어떠한 타입이든 unknown 타입에 할당 가능하다 어떠한 타입도 never에 할당할 수 없다 any 타입은 어떠한 타입으로도 할당 가능하다 unknown은 오직 unknown과 any에만 할당 가능하다 never 타입은 어떠한 타입으로도 할당 가능하다 → 타입 시스템과 상충된다 instanceof 체크 후 unknown에서 원하는 타입으로 변환하기12345function processValue(val: unknown) { if (val instanceof Date) { val // 타입이 Date }} 사용자 정의 타입 가드로 unknown에서 원하는 타입으로 변환하기123456789101112function isBook(val: unknown): val is Book { return ( typeof(val) === 'object' &amp;&amp; val !== null &amp;&amp; 'name' in val &amp;&amp; 'author' in val );}function processValue(val: unknown) { if (isBook(val)) { val // 타입이 Book }} unknown 대신 제네릭 매개변수 사용하기123function safeParseYAML&lt;T&gt;(yaml: string): T { return parseYAML(yaml);} → 타입 단언문과 똑같다!→ 제네릭보다는 unknown을 반환하고 사용자가 직접 단언문을 사용하거나 원하는 대로 타입을 좁히도록 강제하는 것이 좋다 단언문123declare const foo: Foo;let barAny = foo as any as Bar;let barUnk = foo as unknown as Bar; unknown의 경우 분리되는 즉시 오류를 발생하므로 any보다 안전하다(에러가 전파되지 않는다) 정말 null과 undefined가 불가능하다면 unknown 대신 {} 사용하기 아이템 43: 몽키 패치보다는 안전한 타입을 사용하기 자바스크립트에서는 객체나 클래스에 임의의 속성을 추가할 수 있다12window.monkey = 'Tamarin';document.monkey = 'Howler'; 일반적으로 좋은 설계는 아니다 (전역 변수 사이드 이펙트의 문제) 타입스크립트에서는 에러 12document.monkey = 'Tamarin';// 'Document' 유형에 'monkey' 속성이 없습니다 해결 방법 1(document as any).monkey = 'Tamarin'; // 정상 → 👎 타입 안정성을 해치는 안 좋은 코드 차선책 1. interface의 보강(augmentation)12345interface Document { monkey: string;}document.monkey = 'Tamarin'; // 정상 모듈의 관점에서라면 global 선언 추가12345678export {};declare global { interface Document { monkey: string; }} document.monkey = 'Tamarin'; // 정상 보강은 전역적으로 적용되기 때문에, 코드의 다른 부분이나 라이브러리로부터 분리할 수 없다 차선책 2. 더 구체적인 타입 단언문 사용12345interface MonkeyDocument extends Document { monkey: string;}(document as MonkeyDocument).monkey = 'Macaque'; // 정상 아이템 44: 타입 커버리지를 추적하여 타입 안전성 유지하기 any 타입이 여전히 프로그램 내에 존재할 수 있는 두 가지 경우 명시적 any 타입 ex) any[], {[key: string]: any} 서드파티 타입 선언 @types 선언 파일로부터 any 타입이 전파되는 경우 가장 극단적인 예 - 전체 모듈에 any 타입을 부여하는 경우1declare module 'my-module'; → my-module 에서 어떤 것이든 오류 없이 임포트할 수 있다 타입에 버그가 있는 경우 선언된 타입과 실제 반환된 타입이 맞지 않는 경우 npm의 type-coverage 패키지 활용하여 any 추적하기","link":"/2021/12/29/ts-effective-5/"},{"title":"타입스크립트 이펙티브 6장","text":"타입 선언과 @types 아이템 45: devDependencies에 typescript와 @types 추가하기 npm의 의존성 구분 dependencies - 현재 프로젝트 실행 시 필수적인 라이브러리 devDependencies - 런타임에는 필요없는 라이브러리 peerDependencies - 런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리 타입스크립트는 개발 도구일 뿐이고 타입 정보는 런타임에 존재하지 않기 때문에, 타입스크립트와 관련된 라이브러리는 일반적으로 devDependencies에 속한다 타입스크립트 프로젝트에서 고려해야 할 의존성 타입스크립트 자체 의존성 타입스크립트를 시스템 레벨로 설치하기보다는 devDependencies에 넣는 것을 권장한다→ npm install 시 팀원들 모두 항상 정확한 버전의 타입스크립트 설치 가능 대부분의 타입스크립트 IDE와 빌드 도구는 devDependencies를 통해 설치된 타입스크립트의 버전을 인식할 수 있다 타입 의존성(@types)을 고려 DefinitelyTyped에서 라이브러리에 대한 타입 정보를 얻을 수 있다 @types 라이브러리는 타입 정보만 포함하고 있으며 구현체는 포함하지 않는다 원본 라이브러리 자체가 dependencies에 있더라도 @types 의존성은 devDependencies에 있어야 한다 아이템 46: 타입 선언과 관련된 세 가지 버전 이해하기 타입스크립트 사용 시 고려해야 할 사항 라이브러리의 버전 타입 선언(@types)의 버전 타입스크립트의 버전 타입스크립트에서 의존성을 사용하는 방식 특정 라이브러리는 dependencies로, 타입 정보는 devDependencies로 설치 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식의 문제점 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않은 경우 타입 선언도 업데이트하여 라이브러리와 버전을 맞춘다 보강 기법 또는 타입 선언의 업데이트를 직접 작성한다 라이브러리보다 타입 선언의 버전이 최신인 경우 라이브러리 버전을 올리거나 타입 선언의 버전을 내리기 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우 타입스크립트의 최신 버전을 사용한다 라이브러리 타입 선언의 버전을 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애 버린다 @types 의존성이 중복되는 경우 ex) @types/bar 가 현재 호환되지 않는 버전의 @types/foo 에 의존하는 경우 전역 네임스페이스에 있는 타입 선언 모듈인 경우 중복 문제가 발생한다.→ 서로 버전이 호환되도록 업데이트한다 일부 라이브러리는 자체적으로 타입 선언을 포함(번들링)한다. package.json 의 types 필드가 .d.ts 파일을 가리키도록 되어 있다 버전 불일치 문제를 해결할 수 있지만, 네 가지 부수적인 문제점이 있다 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만 타입스크립트 버전이 올라가면서 오류가 발생하는 경우 - 번들된 타입에서는 @types의 버전 선택 불가능 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존하는 경우 - devDependencies에 들어간 의존성을 다른 사용자는 설치할 수 없기 때문→ DefinitelyTyped에 타입 선언을 공개하여 타입 선언을 @types로 분리한다 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우→ 과거 버전으로 돌아가서 패치 업데이트를 한다 타입 선언의 패치 업데이트를 자주 하기 어렵다는 문제 잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법에 도움이 되며 생산성을 크게 향상시킨다 라이브러리 공개 시, 타입 선언을 자체적으로 포함하는 것과 타입 정보만 분리하여 DefinitelyTyped에 공개하는 것의 장단점을 비교해 보자 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함하는 것을 권장한다 아이템 47: 공개 API에 등장하는 모든 타입을 익스포트하기 라이브러리 제작자는 프로젝트 초기에 타입 익스포트부터 작성해야 한다 타입을 익스포트하지 않았을 경우12345678910111213interface SecretName { first: string; last: string;}interface SecretSanta { name: SecretName; gift: string;}export function getGift(name: SecretName, gift: string): SecretSanta { // ... } 해당 라이브러리 사용자는 SecretName 또는 SecretSanta 를 직접 임포트할 수 없고, getGift만 임포트할 수 있다 Parameters와 ReturnType을 이용해 추출하기12type MySanta = ReturnType&lt;typeof getGift&gt;; // SecretSantatype MyName = Parameters&lt;typeof getGift&gt;[0]; // SecretName → 사용자가 추출하기 전에 공개 메서드에 사용된 타입은 익스포트하자! 아이템 48: API 주석에 TSDoc 사용하기 함수 주석에 // ... 대신 JSDoc 스타일의 /** ... **/ 을 사용하면 대부분의 편집기는 함수 사용부에서 주석을 툴팁으로 표시해 준다 타입스크립트 관점의 TSDoc123456789/** * Generate a greeting * @param name Name of the person to greet * @param title ... * returns ... */function greetFullTSDoc(name: string, title: string) { return `Hello ${title} ${name}`;} 타입 정의에 TSDoc 사용하기123456789/** 특정 시간과 장소에서 수행된 측정 */interface Measurement { /** 어디에서 측정되었나? */ position: Vector3D; /** 언제 측정되었나? */ time: number; /** 측정된 운동량 */ momentum: Vector3D; } → Measurement 객체의 각 필드에 마우스를 올려 보면 필드별로 설명을 볼 수 있다 😮 주의! 타입스크립트에서는 타입 정보가 코드에 있기 때문에 TSDoc에서는 타입 정보를 명시하면 안 된다 아이템 49: 콜백에서 this에 대한 타입 제공하기 자바스크립트에서 this는 다이나믹 스코프 ‘정의된’ 방식이 아니라 ‘호출된’ 방식에 따라 달라진다 타입스크립트는 자바스크립트의 this 바인딩을 그대로 모델링한다 this를 사용하는 콜백 함수에서 this 바인딩 문제 해결하기 콜백 함수의 매개변수에 this를 추가하고, 콜백 함수를 call로 호출하는 방법12345678function addKeyListener( el: HTMLElement, fn: (this: HTMLElement, e: KeyboardEvent) =&gt; void) { el.addEventListener('keydown', e =&gt; { fn.call(el, e); });} 👩‍🏫 이때 반드시 call 을 사용해야 한다 만약 라이브러리 사용자가 콜백을 화살표 함수로 작성하고 this를 참조하려고 하면 타입스크립트가 문제를 잡아낸다1234567class Foo { registerHandler(el: HTMLElement) { addKeyListener(el, e =&gt; { this.innerHTML; // 🚨 'Foo' 유형에 'innerHTML' 속성이 없습니다 }); }} 콜백 함수에서 this 값을 사용해야 한다면 this는 API의 일부가 되는 것이기 때문에반드시 타입 선언에 포함해야 한다 아이템 50: 오버로딩 타입보다는 조건부 타입을 사용하기 두 가지 타입의 매개변수를 받는 함수12345function double(x: number | string): number | string;function double(x: any) { return x + x };const num = double(12); // string | numberconst str = double('x'); // string | number 선언문에는 number 타입을 매개변수로 넣고 string 타입을 반환하는 경우도 포함되어 있다 → 제네릭을 사용하여 동작을 모델링할 수 있다 12345function double&lt;T extends number|string&gt;(x: T): T;function double(x: any) { return x + x };const num = double(12); // 타입이 12const str = double('x'); // 타입이 'x' (😮 string을 원하고 있다.) → 타입이 너무 과하게 구체적인 문제 조건부 타입 타입 공간의 if 구문1234function double&lt;T extends number | string&gt;( x: T): T extends string ? string : number;function double(x: any) { return x + x }; 개별 타입의 유니온으로 일반화하기 때문에 타입이 더 정확해진다 각각이 독립적으로 처리되는 타입 오버로딩과 달리, 조건부 타입은 타입 체커가 단일 표현식으로 받아들이기 때문에 유니온 문제를 해결할 수 있다 아이템 51: 의존성 분리를 위해 미러 타입 사용하기 CSV 파일을 파싱하는 라이브러리 작성 시 NodeJS 사용자를 위해 매개변수에 Buffer 타입을 허용하는 경우 Buffer 타입 정의를 위해 @types/node 패키지 필요 그러나 다른 라이브러리 사용자들은 해당 패키지가 불필요하다 각자가 필요한 모듈만 사용할 수 있도록 구조적 타이핑 적용하기 123456interface CsvBuffer { toString(encoding: string): string;}function parseCSV(contents: string | CsvBuffer): {[column: string]: string}[] { // ... } CsvBuffer 가 Buffer 타입과 호환되기 때문에 NodeJS 프로젝트에서도 사용 가능1parseCSV(new Buffer(&quot;column1, column2\\nval2,val2&quot;, &quot;utf-8&quot;)); 미러링: 작성 중인 라이브러리가 의존하는 라이브러리의 구현과 무관하게 타입에만 의존한다면, 필요한 선언부만 추출하여 작성 중인 라이브러리에 넣는 것 다른 라이브러리의 타입이 아닌 구현에 의존하는 경우에도 동일한 기법을 적용할 수 있고 타입 의존성을 피할 수 있다 → 유닛 테스트와 상용 시스템 간의 의존성을 분리하는 데도 유용하다 아이템 52: 테스팅 타입의 함정에 주의하기 타입 선언 테스트하기 유틸리티 라이브러리에서 제공하는 map 함수의 타입 작성하기1declare function map&lt;U, V&gt;(array: U[], fn: (u: U) =&gt; V): V[]; 단순히 함수를 호출하는 테스트만으로는 반환값에 대한 체크가 누락될 수 있다 (’실행’에서의 오류만 검사한다) 반환값을 특정 타입의 변수에 할당하여 간단히 반환 타입을 체크할 수 있는 방법1const lengths: number[] = map(['john', 'paul'], name =&gt; name.length); number[] 타입 선언은 map 함수의 반환 타입이 number[] 임을 보장한다 그러나 테스팅을 위해 할당을 사용하는 방법에는 두 가지 문제가 있다 불필요한 변수를 만들어야 한다 일반적인 해결책은 변수 도입 대신 헬퍼 함수를 정의하는 것이다12function assertType&lt;T&gt;(x: T) {}assertType&lt;number[]&gt;(map(['john', 'paul'], name =&gt; name.length)); 두 타입이 동일한지 체크하는 것이 아니라 할당 가능성을 체크한다 객체의 타입을 체크하는 경우123456const beatles = ['john', 'paul', 'george', 'ringo'];assertType&lt;{ name: string }[]&gt;( map(beatles, name =&gt; ({ name, inYellowSubmarine: name === 'ringo' }))); // 정상 반환된 배열은 {name: string}[] 에 할당 가능하지만, inYellowSubmarine 속성에 대한 부분이 체크되지 않았다 타입스크립트의 함수는 매개변수가 더 적은 함수 타입에 할당 가능하다는 문제12const double = (x: number) =&gt; 2 * x;assertType&lt;(a: number, b: number) =&gt; number&gt;(double); // 정상?! Parameters와 ReturnType 제네릭 타입을 이용해 함수의 매개변수 타입과 반환 타입만 분리하여 테스트할 수 있다12345678910111213 const double = (x: number) =&gt; 2 * x; let p: Parameters&lt;typeof double&gt; = null; assertType&lt;[number, number]&gt;(p); // 🚨 '[number]' 형식의 인수는 '[number, number]' 형식의 매개변수에 할당될 수 없습니다 let r: ReturnType&lt;typeof double&gt; = null; assertType&lt;number&gt;(r); // 정상 ``` - `map`의 콜백 함수에서 사용하게 되는 this 값에 대한 타입 선언 테스트 ```jsx declare function map&lt;U, V&gt;( array: U[], fn: (this: U[], u: U, i: number, array: U[]) =&gt; V ): V[]; 타입 시스템 내에서 암시적 any 타입을 발견하기 위해 DefinitelyTyped의 타입 선언을 위한 도구 dtslint 사용하기123456789const beatles = ['john', 'paul', 'george', 'ringo'];map(beatles, function( name, // $ExpectType string i, // $ExpectType number array // $ExpectType string[]) { this // $ExpectType string[] return name.length; // $ExpectType number[]}); dtslint는 할당 가능성을 체크하는 대신 각 심벌의 타입을 추출하여 글자 자체가 같은지 비교한다","link":"/2022/01/06/ts-effective-6/"},{"title":"타입스크립트 이펙티브 7장","text":"코드를 작성하고 실행하기 아이템 53: 타입스크립트 기능보다는 ECMAScript 기능을 사용하기 자바스크립트에 새로 추가된 기능은 타입스크립트의 초기 기능과 호환성 문제를 발생시켰다 자바스크립트의 신규 기능을 그대로 채택하고 타입스크립트 초기 버전과 호환성을 포기해ㅆ다 그러나 이미 사용되고 있던 몇 가지 기능(호환성 문제로 지양하는 방식)이 있다. 열거형(enum) 몇몇 값의 모음을 나타내는 방식 😵 문제점 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험하다 상수 열거형(const enum)은 런타임에 완전히 제거되어, 문자열 열거형에서 문제를 일으킨다 preserveConstEnums 플래그를 설정한 상수 열거형은 런타임 코드에 정보를 유지한다 문자열 열거형은 구조적 타이핑이 아닌 명목적 타이핑을 사용한다 문자열 열거형의 명목적 타이핑은 자바스크립트와 동작이 다르다는 문제가 있다 12345678enum Flavor { VANILLA = 'vanilla', CHOCOLATE = 'chocolate', STRAWBERRY = 'strawberry',}let flavor = Flavor.CHOCOLATE; // 타입이 Flavor flavor = 'strawberry'; // 🚨 'strawberry' 형식은 'Flavor' 형식에 할당할 수 없습니다 → 열거형 대신 리터럴 타입의 유니온 사용을 권장한다 1type Flavor = 'vanilla' | 'chocolate' | 'strawberry'; 매개변수 속성 생성자의 매개변수를 사용하여 클래스 초기화 시 타입스크립트에는 간결한 문법을 제공한다123class Person { constructor(public name: string) {} } 😵 문제점 실제로는 코드가 늘어난다 매개변수 속성은 런타임에는 실제로 사용되지만, 타입스크립트에서는 사용되지 않는 것처럼 보인다 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워진다 네임스페이스와 트리플 슬래시 임포트 123456namespace foo { function bar() {}}/// &lt;reference path=&quot;other.ts&quot; /&gt;foo.bar(); → ES2015 스타일의 모듈(import와 export) 사용을 권장한다 데코레이터 클래스, 메서드, 속성에 annotation을 붙이거나 기능을 추가하는 것 😵 문제점 표준화가 완료되지 않았기 때문에 비표준으로 바뀌거나 호환성이 깨질 가능성이 있다 아이템 54: 객체를 순회하는 노하우 편집기에서 오류가 발생하는 경우12345678910const obj = { one: 'uno', two: 'dos', three: 'tres',};for (const k in obj) { const v = obj[k]; // 🚨 obj에 인덱스 시그니처가 없기 때문에 엘리먼트는 암시적으로 'any' 타입입니다 } → k가 string으로 인식되기 때문이다 k의 타입을 더욱 구체적으로 명시해서 해결한다1234let k: keyof typeof obj;for (k in obj) { const v = obj[k]; // 정상} 🤔 k가 string으로 추론된 이유1234567891011interface ABC { a: string; b: string; c: number;}function foo(abc: ABC) { for (const k in abc) { const v = abc[k]; // 🚨 }} a, b, c 외에 다른 속성이 존재하는 객체도 foo 함수의 매개변수 abc에 할당 가능하기 때문이다 keyof을 사용하는 것의 문제 v도 string | number로 한정되어 범위가 너무 좁아진다 단지 객체의 키와 값을 순회하고 싶다면 Object.entries를 사용한다123456function foo(abc: ABC) { for (const [k, v] of Object.entries(abc)) { k // string 타입 v // any 타입 }} 아이템 55: DOM 계층 구조 이해하기 DOM 엘리먼트를 사용할 때 타입스크립트의 에러 타입 예시 EventTarget window, XMLTHttpRequest Node document, Text, Comment Element HTMLElement, SVGElement 포함 HTMLElement &lt;i&gt;, &lt;b&gt; HTMLButtonElement &lt;button&gt; EventTarget DOM 타입 중 가장 추상화된 타입으로, 이벤트리스너의 추가/제거, 이벤트 보내기만 가능 123456function handleDrag(eDown: Event) { const targetEl = eDown.currentTarget; targetEl.classList.add('dragging'); // 🚨 개체가 null인 것 같습니다. // 🚨 'EventTarget' 형식에 'classList' 속성이 없습니다 ``` Event의 currentTarget 속성의 타입은 EventTarget | null Node Element가 아닌 Node 텍스트 조각과 주석 Element와 HTMLElement HTML이 아닌 엘리먼트 SVGSvgElement HTMLxxxElement HTMLxxxElement 형태의 특정 엘리먼트들은 자신만의 고유한 속성을 가지고 있다 ex) HTMLImageElement - src, HTMLInputElement - value 항상 정확한 타입을 얻을 수 있는 것은 아니다12345// 정확한 타입document.createElement('button'); // HTMLButtonElement// 정확한 타입이 아닌 경우document.getElementById('my-div'); // HTMLElement 타입 단언문 사용 1document.getElementById('my-div') as HTMLDivElement; strictNullChecks 설정 시 엘리먼트가 null인 경우를 체크한다 Event 는 가장 추상화된 이벤트로, 별도의 계층구조를 가진다 ex) UIEvent, MouseEvent, TouchEvent, WheelEvent, KeyboardEvent 더 많은 문맥 정보를 제공하여 DOM에 대한 타입 추론을 가능하게 해야 한다 아이템 56: 정보를 감추는 목적으로 private 사용하지 않기 public, protected, private 같은 접근 제어자 타입스크립트 키워드기 때문에 컴파일 후에 제거된다 심지어 단언문을 사용하면 타입스크립트 상태에서도 private 속성에 접근 가능하다123456class Diary { private secret = 'cheated on my English test';}const diary = new Diary();(diary as any).secret; // 정상 → 정보를 감추기 위해 private을 사용하면 안 된다 정보를 감추기 위해 클로저 사용하기12345678910111213declare function hash(text: string): number;class PasswordChecker { checkPassword: (password: string) =&gt; boolean; constructor(passwordHash: number) { this.checkPassword = (password: string) =&gt; { return hash(password) === passwordHash; } }}const checker = new PasswordChecker(hash('s3cret'));checker.checkPassword('s3cret'); // true PasswordChecker의 생성자 외부에서 passwordHash 변수에 접근할 수 없기 때문에 정보가 숨겨진다 이때 passwordHash에 접근하는 메서드 역시 생성자 내부에 정의되어야 한다 메서드 정의가 생성자 내부에 있으면, 인스턴스 메서드로 생성된다는 점을 기억하자 (메모리 낭비) 비공개 필드(현재 표준화 진행중) 사용하기 접두사 # 타입 체크와 런타임 모두에서 비공개 클래스 외부에서는 접근할 수 없지만, 클래스 메서드나 동일 클래스의 개별 인스턴스끼리는 접근이 가능하다. 아이템 57: 소스맵을 사용하여 타입스크립트 디버깅하기 디버거는 런타임에 동작하며, 현재 동작하는 코드가 어떤 과정을 거쳤는지 모른다 디버깅 문제를 해결하기 위해 브라우저는 소스맵(source map) 기능을 제공한다 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다 타입스크립트의 소스맵 활성화123456// tsconfig.json{ &quot;compilerOptions&quot;: { &quot;sourceMap&quot;: true }} → 각 .ts 파일에 대해서 .js와 .js.map 두 개의 파일을 생성한다 소스맵에 대해 알아야 할 사항들 타입스크립트와 함께 번들러나 압축기를 사용하고 있다면, 번들러나 압축기가 각자의 소스맵을 생성한다. 이상적인 디버깅을 위해서는 생성된 자바스크립트가 아닌 원본 타입스크립트 소스로 매핑되도록 해야 한다. 상용 환경에 소스맵이 유출되고 있는지 확인해야 한다. 소스맵에 원본 코드의 인라인 복사본이 포함되어 있다면 공개해서는 안될 내용이 들어있을 수 있다.","link":"/2022/01/15/ts-effective-7/"},{"title":"타입스크립트 이펙티브 8장","text":"타입스크립트로 마이그레이션하기 아이템 58: 모던 자바스크립트로 작성하기 타입스크립트의 컴파일러를 자바스크립트의 ‘트랜스파일러’로 사용 타입스크립트는 자바스크립트의 상위집합이므로 타입스크립트를 자바스크립트로 컴파일할 수 있다 ECMAScript 모듈 사용하기 ES2015에 등장한 import와 export 를 사용하는 모듈이 표준이 되었다 프로토타입 대신 클래스 사용하기12345678910111213141516class Person { first: string; last: string; constructor(first: string, last: string) { this.first = first; this.last = last; } getName() { return this.first + ' ' + this.last; }}const marie = new Person('Marie', 'Curie');const personName = marie.getName(); var 대신 let/const 사용하기 스코프 문제 피하기 함수 선언문 대신 함수 표현식을 사용하여 호이스팅 문제 피하기 for(;;) 대신 for-of 또는 배열 메서드 사용하기 for-of 루프는 코드가 짧고 인덱스 변수를 사용하지 않아 실수를 줄일 수 있다 인덱스 변수가 필요한 경우엔 forEach 메서드 사용 권장 함수 표현식보다 화살표 함수 사용하기 상위 스코프의 this를 유지할 수 있다 코드를 더 직관적이고 간결하게 작성할 수 있다 단축 객체 표현과 구조 분해 할당 사용하기 변수와 객체 속성의 이름이 같은 경우12const x = 1, y = 2, z = 3;const pt = { x, y, z }; 객체 속성 중 함수를 축약해서 표현하는 방법12345678const obj = { onClickLong: function(e) { // ... }, onClickCompact(e) { // ... }, }; 객체 구조 분해1const { props: { a, b } } = obj; 함수 매개변수 기본값 사용하기 기본값을 기반으로 타입 추론이 가능하기 때문에, 타입스크립트로 마이그레이션 시 매개변수에 타입 구문을 쓰지 않아도 된다 저수준 프로미스나 콜백 대신 async/await 사용하기 버그나 실수를 방지할 수 있고, 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다 연관 배열에 객체 대신 Map과 Set 사용하기 인덱스 시그니처 사용 시 constructor 등의 특정 문자열이 주어지는 경우 예약어로 인식하는 문제 Map 사용하기1234567function countWordsMap(text: string) { const counts = new Map&lt;string, number&gt;(); for (const word of text.split(/[\\s,.]+/)) { counts.set(word, 1 + (counts.get(word) || 0)); } return counts;} 타입스크립트에 use strict 넣지 않기 타입스크립트는 기본적으로 'use strict'를 사용 alwaysStrict 또는 strict 컴파일러 옵션 설정 권장 TC39나 타입스크립트 릴리즈 노트를 통해 최신 기능 확인 가능 아이템 59: 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기 @ts-check 지시자를 사용하여 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시할 수 있다 매우 느슨한 수준으로 타입 체크를 수행한다 타입 불일치나 함수의 매개변수 개수 불일치 등 선언되지 않은 전역 변수 숨어 있는 변수라면 변수를 제대로 인식할 수 있게 별도로 타입 선언 파일을 만들기12// @ts-checkconsole.log(user.firstName); 1234567// types.d.tsinterface UserData { firstName: string; lastName: string;}declare let user: UserData; 선언 파일을 찾지 못하는 경우 ‘트리플 슬래시’ 참조를 사용하여 명시적으로 임포트123// @ts-check/// &lt;reference path=&quot;./types.d.ts&quot; /&gt;console.log(user.firstName); // 정상 알 수 없는 라이브러리 서드파티 라이브러리의 타입 정보 @types/xxx 설치하기 DOM 문제123// @ts-checkconst ageEl = /** @type {HTMLInputElement} */(document.getElementById('age'));ageEl.value = '12'; // 정상 부정확한 JSDoc 타입스크립트 언어 서비스는 타입을 추론해서 JSDoc을 자동으로 생성해 준다 1234567// @ts-check/** * @param {number} val */function double(val) { return 2 * val;} 아이템 60: allowJS로 타입스크립트와 자바스크립트 같이 사용하기 allowJS 옵션 타입 체크와 관련이 없지만, 기존 빌드 과정에 타입스크립트 컴파일러를 추가하기 위함 모듈 단위로 타입스크립트로 전환하는 과정에서 테스트를 수행하기 위함 프레임워크 없이 빌드 체인 직접 구성하기 outDir 옵션 사용하기 아이템 61: 의존성 관계에 따라 모듈 단위로 전환하기 의존성 관련 오류 없이 작업하려면, 다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해서 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 한다 서드파티 라이브러리 타입 정보를 가장 먼저 해결 (@types/) 외부 API의 타입 정보 추가 리팩터링은 타입스크립트 전환 작업이 완료된 후에 해야 한다 선언되지 않은 클래스 멤버→ ‘누락된 모든 멤버 추가’ 빠른 수정 1234567891011class Greeting { greeting: string; name: any; // 직접 수정 필요 constructor(name) { this.greeting = 'Hello'; this.name = name; } greet() { return this.greeting + ' ' + this.name; } } 타입이 바뀌는 값12345const state = {};state.name = 'New York';// 🚨 '{}' 유형에 'name' 속성이 없습니다state.capital = 'Albany';// 🚨 '{}' 유형에 'capital' 속성이 없습니다 → 한번에 객체 생성 또는 타입 단언문 사용하기 자바스크립트에서 JSDoc과 @ts-check를 사용해 타입 정보를 추가한 상태라면, 타입스크립트로 전환하는 순간 타입 정보가 ‘무효화’된다는 점에 주의 마지막으로 테스트 코드를 타입스크립트로 전환 아이템 62: 마이그레이션의 완성을 위해 noImplicitAny 설정하기 noImplicitAny 설정을 통해 타입 선언과 관련된 실제 오류를 드러낼 수 있다 최종적으로 가장 강력한 설정은 &quot;srict: true&quot;","link":"/2022/01/20/ts-effective-8/"},{"title":"우아한 타입스크립트 1부","text":"타입시스템 올바르게 사용하는 법 지난 8월 우아한테크세미나 발표 주제였던 우아한 타입스크립트 영상을 보고 정리한 내용이다. 1. 작성자와 사용자타입스크립트의 타입 시스템은 컴파일러에게 타입을 명시적으로 지정하거나, 컴파일러가 자동으로 타입 추론하게끔 할 수 있다. 형태를 정해둔 함수의 경우 구현자와 사용자가 모두 이해할 수 있는 타입 구문을 작성해야 한다. 타입이란 해당 변수가 할 수 있는 일을 결정한다. 매개변수의 타입이 없는 자바스크립트는 함수 사용법에 대한 오해를 야기할 수 있다. 타입스크립트의 추론에 의지하는 경우, 함수의 매개변수 타입을 지정하지 않고 타입스크립트 컴파일러가 리턴타입을 추론하게끔 한다. noImplicitAny 옵션 타입을 명시적으로 지정하지 않은 경우, 타입스크립트가 추론 중 any라고 판단하게 되면 컴파일 에러를 발생시킨다.1234// 🚨 Parameter 'a' implicity has an 'any' typefunction f(a) { return a * 25;} 함수의 리턴타입을 명시하지 않은 경우123456789// 함수의 리턴타입은 number로 추론된다 function f(a: number) { if (a &gt; 0) { return a * 25; }}console.log(f(5)); // 125console.log(f(-5) + 5); // NaN 🚨 런타임과 컴파일타임의 타입이 다름 strictNullChecks 옵션 모든 타입에 자동으로 포함되어 있는 null과 undefined를 제거해준다.12345678// 명시적으로 지정하지 않은 함수의 리턴타입은 number | undefined로 추론된다 function f(a: number) { if (a &gt; 0) { return a * 25; }}console.log(f(-5) + 5); // 🚨 Object is possibly undefined 👩‍🏫 작성자의 입장에서 바디의 추론을 정확하게 할 수 있도록 명시적으로 리턴타입을 지정해야 한다. noImplicitReturns 옵션 함수 내에서 모든 코드가 값을 리턴하지 않으면, 컴파일 에러를 발생시킨다 ex) 조건문 등에 걸려서 return 하지 않는 경우 매개변수에 object가 들어오는 경우123456function f(a) { return // ...}f({ name: 'Zig', age: 25 }); f({ name: 'Zig' }); // 🚨 object literal type 또는 interface, type을 이용하여 커스텀한 타입을 만들 수 있다.1234interface PersonInterface { name: string; age: number;} 2. interface와 type alias structural type system - 구조가 같으면 같은 타입 nominal type system - 구조가 같아도 이름이 다르면 다른 타입 타입스크립트에서 이름 기반의 nominal type system을 사용하는 방법1234567891011type PersonID = string &amp; { readonly brand: unique symbol };function PersonID(id: string): PersonID { return id as PersonID;}function getPersonById(id: PersonID) {}getPersonById(PersonID('id-aaaaaa'));getPersonById('id-aaaaaa'); // 🚨 Argument of type 'string' is not assignable to parameter of type 'PersonID' 3. 서브타입과 슈퍼타입 예제1 1234// sub1 타입은 sup1 타입의 서브타입 let sub1: 1 = 1;let sup1: number = sub1;sub1 = sup1; // 🚨 Type 'number' is not assignable to type '1'; 1234// sub2 타입은 sup2 타입의 서브 타입let sub2: number[] = [1];let sup2: object = sub2;sub2 = sup2; // 🚨 Type '{}' is missing the following properties from type 'number[]'; 1234// sub3 타입은 sup3 타입의 서브 타입let sub3: [number, number] = [1, 2]; // 튜플, 2개만 들어갈 수 있음let sup3: number[] = sub3;sub3 = sup3; // 🚨 Type 'number[]' is not assignable to type '[number, number]'. 예제2 1234// sub4 타입은 sup4 타입의 서브 타입 let sub4: number = 1;let sup4: any = sub4;sub4 = sup4; 1234// sub5 타입은 sup5 타입의 서브 타입 let sub5: never = 0 as never;let sup5: number = sub5; sub5 = sup5; // 🚨 Type 'number' is not assignable to type 'never'; → never 는 모든 타입이 서브타입으로 가지고 있는 타입 123456789class SubAnimal {}class SubDog extends SubAnimal { eat() {} }// sub6 타입은 sup6 타입의 서브 타입 let sub6: SubDog = new SubDog();let sup6: SubAnimal = sub6;sub6 = sup6; 같거나 서브타입인 경우 할당이 가능하다 → 공변1234567891011// primitive typelet sub7: string = '';let sup7: string | number = sub7;// object - 각각의 프로퍼티가 대응하는 프로퍼티와 같거나 서브타입이어야 한다let sub8: { a: string; b: number } = { a: '', b: 1 };let sup8: { a: string | number; b: number } = sub8;// array - object와 마찬가지let sub9: Array&lt;{ a: string; b: number }&gt; = [{ a: '', b: 1 }];let sup9: Array&lt;{ a: string | number; b: number }&gt; = sub9; 함수의 매개변수 타입만 같거나 슈퍼타입인 경우, 할당이 가능하다 → 반변123456789101112131415161718192021222324class Person {}class Developer extends Person { coding() {}}class StartupDeveloper extends Developer { burning() {}}function tellme(f: (d: Developer) =&gt; Developer) {}// 정상 tellme(function dToD(d: Developer): Developer) { return new Developer(); }// 정상 - 매개변수에 슈퍼타입을 할당하는 경우tellme(function pToD(d: Person): Developer) { return new Developer();}// 🚨 에러 - 매개변수에 서브타입을 할당하는 경우tellme(function sToD(d: StartupDeveloper): Developer) { return new Developer();} → strictFunctionTypes 옵션으로 에러 확인 가능 any 대신 unknown 사용하기123456789function fany(a: unknown): number | string | void { a.toString(); // 🚨 a: unknown일 때만 에러 발생 (any에서는 허용) if (typeof a === 'number') { return a * 25; } else if (typeof a === 'string') { return `Hello ${a}`; }} 4. 타입 추론 이해하기 let과 const의 타입 추론12let a = 'Zig'; // stringconst b = 'Zig'; // 'Zig', literal type as const12const arr = ['Zig', 'Sun', 'Haru'] as const;// readonly ['Zig', 'Sun', 'Haru'] Best commen type12let a = [0, 1, null]; // (number | null)[]const a = [0, 1, null]; // (number | null)[] 1234567891011class Animal {}class Rhino extends Animal {}class Elephant extends Animal {}class Snake extends Animal {}const a = [new Rhino(), new Elephant(), new Snake()];// (Rhino | Elephant | Snake)[]const b = [new Animal(), new Rhino(), new Elephant(), new Snake()]; // Animal[]const b: Animal[] = [new Rhino(), new Elephant(), new Snake()];// Animal[] Contextual Typing - 위치에 따라 추론이 다름1234567const click = (e) =&gt; { e; // any};document.addEventListener('click', (e) =&gt; { e; // MouseEvent}); 5. Type Guard로 안전함을 파악하기 typeof Type Guard보통 primitive 타입일 경우1234567891011function getNumber(value: number | string): number { value; // number | string if (typeof value === 'number') { value; // number return value; } value; // string return -1;} instanceof Type GuardError 객체 구분에 많이 쓰임1234567891011121314151617class NegativeNumberError extends Error {}function getNumber(value: number): number | NegativeNumberError { if (value &lt; 0) return new NegativeNumberError(); return value;}function main() { const num = getNumber(-10); if (num instanceof NegativeNumberRror) { return; } num; // number} in operator Type Guard - object의 프로퍼티 유무로 처리하는 경우1234567function redirect(user: Admin | User) { if ('role' in user) { // ... } else { // ... }} literal Type Guard - object의 프로퍼티가 같고, 타입이 다른 경우tagged type을 사용한다1234567function getWheelOrMotor(machine: Car | Boat): number { if (machine.type === 'CAR') { return machine.wheel; } else { return machine.motor; }} custom Type Guard1234567891011121314151617function getWheelOrMotor(machine: Car | Boat): number { if (isCar(machine)) { return machine.wheel; } else if (isBoat(machine)) { return machine.motor; } else { return -1; }}function isCar(arg: any): arg is Car { return arg.type === 'CAR';}function isBoat(arg: any): arg is Boat { return arg.type === 'BOAT';} → lodash 등의 라이브러리에서도 많이 사용하는 방식 6. Class를 안전하게 만들기 Class Property의 타입을 명시적으로 지정해야 한다12345// v3.9.7class Square1 { area; // 🚨 implicit any sideLength; // 🚨 implicit any} 123456789// v3.9.7class Square2 { area: number; sideLength: number;}const square2 = new Square2(); console.log(square2.area); // 컴파일타임에는 number, 런타임에는 undefinedconsole.log(square2.sideLength); // 컴파일타임에는 number, 런타임에는 undefined → strictPropertyInitialization 옵션 Class의 Property가 생성자 혹은 선언에서 값이 지정되지 않으면 컴파일 에러가 발생한다12345// v3.9.7class Square2 { area: number = 0; sideLength: number = 0; } v4~부터의 Class Property 타입 추론12345678910// v4.0.2class Square3 { area; // 생성자에 의해 추론 sideLength; // 생성자에 의해 추론 constructor(sideLength: number) { this.sideLength = sideLength; this.area = sideLength ** 2; }} 여전히 생성자를 벗어나면 추론되지 않는다12345678910111213141516// v4.0.2class Square4 { sideLength!: number; // !로 의도를 표현 constructor(sideLength: number) { this.initialize(sideLength); } initialize(sideLength: number) { this.sideLength = sideLength; } get area() { return this.sideLength ** 2; // 🚨 }} 정리서브타입과 수퍼타입에 대해 애매하게 알고 있었던 것 같다. 이펙티브 타입스크립트에서는 서브타입의 범위가 수퍼타입보다 넓은 것으로 설명하고 있었던 것 같은데, 수학적 개념의 집합과 타입스크립트의 ‘값의 범위’로서의 타입은 서로 다른 개념이라는 것을 제대로 알고 있어야겠다. 공변과 반변에 대해서도 언젠가 들어본 내용을 확실하게 짚고 넘어갈 수 있었다. 일반적인 객체 형태의 타입이 아니라 함수 매개변수로 쓰인 타입의 경우 타입 필드의 사용 여부에 따라서 할당 가능 여부를 판단할 수 있어야 할 것이다. 타입 가드를 하는 방법도, arg is T 방법만 쓰는 것이 아니라 여러 실용적인 방법들을 앞으로도 많이 활용해봐야겠다! Ref https://sorto.me/posts/2021-03-16+variance","link":"/2021/12/19/woowa-typescript-01/"},{"title":"우테코 1주차 기록","text":"우아한테크코스 1주차 우테코 OT 정신 없이 어떻게 흘러가는지도 몰랐던 첫 주! 백 52명, 프론트 26명이 선발됐다. 경쟁률은… 아무튼 깃헙 블로그도 공개 공간이니 공개하면 안될 것 같다. 엄청 쎘다. 그저 감개무량 데일리 미팅 게더타운 꿀귀다! 조금 버벅이는 게 없잖아 있지만, 짧게짧게 쓸만 한 것 같다. 월요일 오전 잠시 들어와 본 나밖에 없는 미팅룸... 둘째 날 게더타운으로 이동할 때, 코치인 포코가 늦어 일찍 모인 크루들에게 포코의 휴식 공간으로 이동하자고 제안했다. 모두 호응하며 따라와줘 기뻤다 🙃 ㅋㅋㅋ 나중에 들어온 포코 당황잼 cypress jest, enzyme 등 기존에 조금씩 사용해보던 테스트 툴들과 비슷하다. 그런데 훨씬 더 편리한 느낌?! 예제도 잘 제공되어 있다. mocha, chai 등 여러 라이브러리에서 기능을 가져왔다고 한다. 예제도 많이 제공해 주고, 문서도 잘 되어 있어서 편리하다. 빨간 불이 사라지고 하나씩 초록 불이 뜰 때의 쾌감 😯 기능이 원하는 대로 구현되는 것만큼이나 기쁘다. 간단한 계산기 미션을 하는 데도 상당한 테스트가 떨궈졌다. 생각지도 못했던 경우들이 나타났다. 여태까지 테스트 없이 진행한 프로젝트들에서의 코드가 얼마나 허술했는지 깨달았다. 첫 주부터 TDD를 강조 또 강조했던 것만큼, 앞으로의 개발에서는 정말 테스트를 많이 적용해봐야겠다! 페어프로그래밍 사소하지만 몰랐던 문법, 기능들을 페어를 통해 배울 수 있었다. 공동으로 브랜치를 파서 하는 만큼 나 혼자가 아닌 상대방과 함께 하는 책임감을 가지게 된다. 학교 수업 등에서 팀플을 하면 친구들끼리 얼레벌레 코드 공유하게 되는데, 협업할 수 있는 live share라는 좋은 툴을 알게 되었다. 재밌고 편리한 툴인 것 같다! 혼자 코딩하면 침묵 속에 (가끔 욕 정도 하면서..) 작성하는데, 페어와 말하면서 하다보니 코로나로 인해 사람 만나지 못하는 동안 얼마나 대화 실력이 떨어졌는지 새삼 느겼다. 😓 내가 작성한 코드를 설명하고 함께 토론하는 시간의 중요성도 느끼고, 말하면서 실수하는 부분을 스스로 캐치하거나 페어가 짚어주면서 빠르게 깨닫게 되는 경험이었다. 보이는 라디오 20대 중반이 되어도, 대학을 졸업해도 이런 것을 해야 한다니… 😭 정말 싫지만 또 씩씩하게 해 본다. 팀원들이 다들 서글서글 좋은 분이신 것 같다. 내 아이디어도 많이 반영해 주셨다. 😝 유튜브에 박제되는 건 아니겠지… 📚 배우기eval is evil호출 방식에 따라서 동작하는 범위가 달라지고, js 인터프리터를 사용하여 계산이 무거워진다고 한다.여태까지도 뭔가 옳은 방식의 코드는 아닌 것 같아 쓰지 않았는데, 이번 기회에 간단하게 eval을 사용하면 안 되는 이유를 알고 더욱 주의해야겠다 😮 Ref https://velog.io/@modolee/javascript-eval-is-evil/@modolee/javascript-eval-is-evil javascript destructinges6에 새로 등장한 문법이다. 우리말로는 ‘구조 해체 할당’이라고 한다. destructuring은 array의 값이나 object의 프로퍼티들을 프로그램 안에서 쓸 수 있는 변수로 만들어 준다. destructing은 언제 필요할까? 🤔 123456789101112131415161718192021const developer = { name: 'Zig Song', level: 'Junior', stacks: { html: 9, css: 8.5, javascript: 7 }}; const displayDetail = data =&gt; { const name = data.name; const level = data.level; const htmlRating = data.stacks.html; const cssRating = data.stacks.css; const javascriptRating = data.stacks.javascript; console.log(name, level, htmlRating, cssRating, javascriptRating); }; displayDetail(developer); 누가 봐도 displayDetail 함수 안에서 data가 쓸데없이 많이 중복되고 있는 것을 알 수 있다. 이를 아래처럼 destructing으로 바꿔쓰면 더욱 직관적이다. 1const { name, level, stacks: { html, css, javascript } } = developer; array destructing은 아래와 같은 방식으로 작성한다. 12345678910const profile = ['zig song', 'student', '25'];const displayProfile = data =&gt; { const name = data[0]; const job = data[1]; const age = data[2]; console.log(`Hello my name is ${name} and I'm ${age} years old. I'm a ${job}.`);};displayProfile(profile); 12345const [name, job, age] = profile;console.log(name); // zig songconsole.log(job); // studentconsole.log(age); // 25 destructing 구문 안에서 변수의 이름을 특정한 이름으로 지정해주거나,rest operator를 사용하여 사용하지 않는 변수들을 일괄 처리하는 팁들도 있다 😉 Ref https://medium.com/better-programming/demystifying-modern-destructuring-in-javascript-918295756b1f package-lockpackage-lock에는 프로젝트의 의존성 모듈들에 대한 버전 정보가 들어있다. 그래서 lock 즉 외부로부터 영향 받지 않기 위해 잠금 처리를 한다. lock을 통해 여러 개발자가 코드를 올리고 내려 받는 프로젝트에서, 설치 시점에 상관없이 항상 동일한 버전의 패키지가 설치되는 것을 보장받을 수 있다.yarn을 사용한다면 yarn.lock이라는 이름으로 생성된다. Ref https://www.daleseo.com/js-package-locks/ javascript event loop웹 브라우저에서 javascript를 동작하게 해주는 javascript 엔진(ex. v8)은 memory allocation이 발생하는 heap과 execution contexts가 담긴 stack으로 구분된다. javascript는 single call stack을 갖고 있는 single thread language다. 1234567891011121314function multiply9(a, b) { return a + b;}function square() { return multiply(n, n);}function printSquare(n) { var sqaured = square(n); console.log(squared);}printSquare(4); 위 코드에서 stack에는 main() → printSquare() → square() → multiply() 순서대로 함수가 stack에 쌓이고 LIFO(Last-In-First-Out) 방식으로 호출된다. 이때 비동기 request가 각각 호출되면, 첫 번째 호출이 완료되는 동안 다른 어떤 동작도 할 수 없다. 이를 blocking이라고 한다. 이 문제를 해결하기 위해 asynchronous callback이 사용된다. javascript 콜 스택은 한 번에 한 가지 일밖에 할 수 없다. 그래서 setTimeOut() 등의 비동기 request가 호출되면 해당 함수는 stack에 쌓이고, callback으로 처리된다. 이때 web API는 해당 비동기 callback이 실행되기까지 기다리고, stack에서 해당 호출은 빠지고 다음으로 실행할 요청들을 담는다. (이때 callback 함수를 task queue에 등록하는 처리는 자바스크립트 엔진이 아니라 브라우저가 실행한다!) web API에서 callback의 호출이 마무리되면 task queue에 해당 task가 담기고, stack이 빌 때까지 기다렸다가 event loop를 통해 stack에 다시 담겨 실행된다. 즉 비동기 실행 함수는 stack → web API → task queue → stack 순으로 이동한다. Refhttps://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;feature=youtu.behttps://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop 🤔 생각해보기질문 잘 하는 법질문 잘 하는 법 쓸데 없는 질문은 없다. 내가 궁금해 하는 건 분명 다른 사람도 궁금해 한다. 올려 놓은 질문 잊지 말기! 답변이 달렸는지 계속 확인하고 토론을 이어가자. 질문을 잘 하는 개발자 질문을 받는 사람과 Context 맞추기 질문을 올리고 반드시 tracking 페어 프로그래밍짝 프로그래밍이란 단축되는 개발 시간 두렵거나 지겹거나 한 일을 페어로! 😬 생각하는 과정, 나의 전문성 기르기 패키지 매니저 관련VS코드에서 패키지 매니저 확인하는 기준젯브레인에서 패키지 매니저 확인하는 기준VS 코드 개발팀이 실제로 패키지 매니저를 자동으로 감지하고자 추가했던 코드 TDD, BDDTDD 묻고 BDD로 가! 코드 작성 전 테스트 코드 먼저! BDD: Given(주어진 환경) - When(행위) - Then(기대결과) TDD: add(1, 1)이 2인지 확인 vs BDD: 사용자가 “=”를 눌렀을 때, 1+1의 값 2가 화면에 표시되는지 확인 BDD로 시나리오 검증, 해당 시나리오에서 사용되는 각 모듈들은 TDD test case로 검증 개발자 커뮤니티슬기로운 개발자 생활 - OKKY 빨리 가려면 혼자 가고, 멀리 가려면 같이 가라! javascript 코딩 스타일클린 코드 자바스크립트 standard라는 npm 패키지를 사용한다. 네이밍 치트시트 Actions 부분을 읽어보면 좋을 것 같다. 👻 아래는 읽어보기!자바스크립트 스탠다드 스타일Airbnb JavaScript 스타일 가이드클린 코드 타입스크립트 네이버 fe newsnaver fe-news cypress cheat sheetcypress cheat sheet etc 백엔드에서 한 명 탈주했다. 😢 다른 문제가 있는 건 아니고, 본인이 진정으로 하고 싶은 개발을 찾아 떠나시는 것 같았다. 모두 꿈을 찾아 성공하길! 누군가의 말대로, 일주일의 루틴이 생기는 건 아주 피곤하지만 즐거운 일이다. 밤에 잠이 잘 오는 것은 덤 🛌 슬랙에 정말 많은 자료가 올라온다. MVC 패턴에 대한 노래라든지, 헝가리 댄스로 알아보는 bubble sort라든지.. 정말 충격적인 것들이 많았음 😑 찐들의 향기를 많이 묻혀가야겠다. 😎 마무리 하루빨리 대면으로 만나서 많은 사람들과 친해지고 싶다. 우울한 삶에 조금이나마 활력이 생겨서 좋다 배민 1만원 쿠폰을 받았다! 치킨 시켜먹었다. 개이득","link":"/2021/02/06/woowa-week-01/"},{"title":"우테코 2주차 기록","text":"우아한테크코스 2주차 목, 금요일을 설연휴로 보내는 덕분에(?) 이번주 우테코는 3일만! 보이는 라디오 리허설 때부터 나름 흥했다. 예상치 못하게 ‘반박시 요기요~’가 터져버려서, 많은 호응과 함께 실제 발표 포스터에도 담기게 되었다 😱 시간을 아주 많이 쏟고 싶진 않았고, 적당히 잘 한 것 같다. 실제 발표 날에는 더 만반의 준비를 해온 팀들도 있었다. 모두 엄청 재미있게 잘 봤다 😆 팀 회고까지 진행하고 드뎌 아이스브레이킹용 팀플이 끝났다! 거리두기가 완화되면 같이 밥이라도 먹고 싶다. 계산기 미션 공통 피드백 주석 잘 달기! JSDoc이라는 툴을 알게 되었다. 👩‍🏫 typescript를 쓰면 주석의 기능을 할 수도 있다. 함수의 가장 이상적인\u001c파라미터 개수는 0개지만, 일반적인 경우 2개 이하가 좋다고 한다. 함수 파라미터에 객체를 통째로 파라미터로 넘기는 방법, arguments 사용하기 - javascript의 유연함을 이용한 방식 ☠️ 함수 매개변수에는 null을 쓰지 마세요 테스트 코드에서의 랜덤값 고민해 보기 README 잘 쓰기! ✅ parseInt()는 몇 진수인지 밝혀줘야 한다. Refhttps://boycoding.tistory.com/21https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments 페어 프로그래밍 자동차 경주 미션 1단계를 진행했다. 페어에게 UI 로직을 따로 분리하는 방법을 배웠다. 페어를 통해 내가 헷갈렸던 javscript 함수들을 똑바로 익힐 수 있었고, 생각지 못했던 예외 케이스들을 고려해볼 수 있었다. 나는 우리 작업에서 사소하게 놓쳤던 부분들을 짚어주며 서로에게 도움이 되었던 것 같다. 🙃 세심한 PR 리뷰 배민 내부 개발자이신 리뷰어님께 좋은 피드백을 받았다. 한밤 중에도 설연휴에도 쉬지 않고 열심히 코멘트와 질문에 대한 답변을 달아주신다. 넘 감동 😭 아직 2단계 피드백을 기다리고 있다. 신경 쓰다보니 PR 올리기 전 코딩을 하며 클린 코드에 더욱 신경 쓰게 되는 것 같다. 📚 배우기리팩토링(Refactoring) 반복문보다는 파이프를 사용하자 12345678const completedTodos = [];for (const todo of todos) { if (todo.completed) { completedTodos.push(todo); }}const completedTodos = todos.filter(todo =&gt; todo.completed); 함수를 리턴하는 함수를 pipe 함수라고 한다. 함수들을 인자로 받아서, 이 함수들을 연속적으로 실행해주는 함수를 리턴하는 것이다. 12345678let pipe = () =&gt; () =&gt; {}; // 함수를 리턴하는 함수const p = pipe( a =&gt; a + 1, a =&gt; a * 10);console.log(p(0)); switch 대신 object literal을 사용하자. 12345678910111213141516171819202122function wannaEat(food) { switch(food) { case 'pizza': console.log('피자 먹고 싶다') break case 'chicken': console.log('치킨 먹고 싶다') break case 'ramen': console.log('라면 먹고 싶다') break }}function wannaEat(food) { const foodList = { pizza: '피자 먹고 싶다', chicken: '치킨 먹고 싶다', ramen: '라면 먹고 싶다' }; console.log(foodList[food])} 사실 object도 많이 사용했던 방식이긴 한데, 내부에서 간단한 기능을 수행하는 switch~case 문을 이렇게 바꾸는 건 생각하지 못했다. 배열이나 객체는 forEach보다는 map을 이용해 불변 객체처럼 다루기 - Debugging with Browser - 크롬 개발자 도구Source 탭 Event Listener Breakpoints 활용하기 snippet → lodash 등을 사용 가능 Network 탭 페이지 새로고침 → 해당 페이지 로드에 어떤 데이터와 파일들이 로드되는지 확인 가능 톱니바퀴 옵션 → Capture Screenshots 체크 후 새로 고침 → 해당 페이지에 접속하고 난 후 화면이 렌더링되는 순서를 보여 줌 Performance 탭 javascript 동작이 느리거나, 성능을 비교하고 싶을 때 사용(테스트: https://googlechrome.github.io/devtools-samples/jank/) Screenshots, Memory cmd + shift + P → show performance monitor - 실시간으로 사용되는 CPU 분석 결과 Memory 탭 메모리 사용에 대한 자세한 분석 Allocation Sampling → Start - 메모리 사용에 대한 기록 Stop → 메모리를 많이 잡아먹는 순서대로 정렬 가능 Application 탭 쿠키, 스토리지 등 확인 Security 탭 현재 페이지에서 이용하는 보안 이슈, 증명서 등 Lighthouse 웹 어플리케이션의 품질 보증 PWA 관련 모바일 아이콘 실제 모바일 사이즈에서 확인 - 시간을 다루는 방법 호출 스케줄링(scheduling a call) - 일정 시간이 지난 후에 원하는 함수를 예약 실행(호출)할 수 있게 하는 것 setTimeout setInterval requestAnimationFrame - 화면에 repaint가 일어날 때 호출 CSS Layout 재미있음! 🐸 근데 마지막 단계 못 깼다 😬 열받는다. flex-flow, align-self, align-content 등을 새로 알아간다.https://flexboxfroggy.com/#ko - 웹 어셈블리(WASM)뭔가 하다가 코치 포코가 잠깐 언급했다. 와즘! 이라고 하셔서 처음 들어본 김에 기록기록 ✍️ 웹 어셈블리는 웹 브라우저에서 실행할 수 있는 새로운 유형의 코드이다. 네이티브에 가까운 성능으로 동작하며, 컴파일 타겟으로 C/C++, Rust 등의 언어로 작성된 프로그램을 웹에서 사용할 수 있게 해준다. 웹에서 사용할 수 있는 효율적인 저수준 바이트 코드로서, 자바스크립트 이외의 언어(예: C, C++, Rust 등)를 사용하여 프로그램을 작성한 다음 런타임 이전에 웹어셈블리로 컴파일할 수 있다. 결과적으로 로드 및 실행이 매우 빠른 웹 앱을 얻을 수 있게 되는 것이다! 😮 웹 어셈블리는 JavaScript와 함께 실행되도록 설계되었다. WebAssembly JavaScript API를 사용하여 WebAssembly 모듈을 JavaScript 앱에 불러와 둘 사이의 기능을 공유할 수 있다. V8에서 자바스크립트 소스를 로드, 파싱하고 기계 코드로 변환, 트리를 만드는 과정들은 복잡하다. V8은 최적화된 컴파일을 위해 터보팬이라는 기능을 사용한다. 그러나 터보팬은 CPU를 사용함으로써 배터리 소모량을 증가시킨다. 반면 웹 어셈블리는 컴파일 단계에서 최적화를 거치고, 파싱도 필요하지 않다. 모든 최적화가 프론트엔드 컴파일러에서 처리되는 것이다. + WebAssembly에서 알파벳을 따와 WASM이라고 하는 것이었다! 별 다른 뜻이 있는 게 아니었다. 🤷‍♀️+ 웹 어셈블리에 대한 자세한 사용법은 나중에 필요하면 공부해 보자 😅 Refhttps://developer.mozilla.org/en-US/docs/WebAssemblyhttps://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-웹어셈블리와의-비교-언제-웹어셈블리를-사용하는-게-좋은가-cf48a576ca3https://d2.naver.com/helloworld/8257914 🤔 생각해보기github 레포 디렉토리 구조 보기https://github.com/woowacourse/javascript-calculator요기에 ‘1s’만 붙여주면 된다고 한다.https://github1s.com/woowacourse/javascript-calculator 아니면https://chrome.google.com/webstore/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc?hl=ko요런 크롬 익스텐션도 있다. etc 갑자기 핫해진 클럽하우스 요즘은 javascript 라인의 끝에 세미콜론(;)을 붙이지 않는 세력(?)도 있다고 한다. 넘 어색하고 충격적이다… 아직 2주밖에 안 지났는데, (그것도 풀 2주도 아니고!) 아카이브나 우테코 도서관 등 먼저 나서서 총대를 메고 일을 시작하시는 분들이 계신다.20대 초반이라면 빠이팅 넘쳐서 했을텐데… 20대 중반이 지나가면서 그런 거 하는 사람 없을 거라고 생각했는데… 다들 넘 열정적이시고 대단하신 것 같다. 존경함 👍 😎 마무리3일 뿐이었지만 설연휴까지 포함해서 미션하느라 정신없이 지나간 한 주였다.라섹한지 2주된 내 눈은… 안녕~하루하루 할 일이 쌓여서 설레고 기쁘다 ^^ 기타 Refhttps://junhobaik.github.io/functional-go-pipe/https://sjyoung.tistory.com/42","link":"/2021/02/13/woowa-week-02/"},{"title":"우테코 9주차 기록","text":"우아한테크코스 9주차 페어 프로그래밍 정말 짜잘한 JavaScript와 CSS들을 알아간다. setAttribute와 removeAttribute와의 전쟁.. 🤯 form reset과의 전쟁 2차전 select input에도 required를 걸 수 있다니! 시야가 좁아질 땐, ‘삽질!’을 외치자 리팩토링 천재 마지막 등교날에도 과외 간 서니 😢 3주라는 가장 긴 시간 동안 함께 했는데, 동갑내기 친구로서 같이 제대로 못 논게 아쉽다! 정말 똑똑하고 꼼꼼하고, 항상 한 발 앞서서 생각하는 훌륭한 페어였다. 주변 크루들과 떠드는 데 정신 팔려 종종 산만했던 태도를 보인 게 미안하다. 공수타이번주는 방학식이 진행돼서 포수타/로수타가 없었다. 대신 새로 들어오신 프론트엔드 코치 공원의 공수타 ☘️동글동글 작고 귀여우신 분이었다. 나이도 어리고 아직 학생이시라는데 👀 N사☘️까지 거쳐서 이곳 우테코 코치로 오신 게 너무 대단하다.다시 등교가 시작되면 먼저 다가가서 같이 카페 가자고 해야겠다 🤓 테코톡주모의 SPA 테코톡! 사실 내가 하고 싶었던 주제여서 기대가 됐다. 군더더기 없이 깔끔했던 발표였다. MPA (Multi-Page Application) 2개 이상의 페이지로 구성 앱이 새로고침되는 전통적인 방식 SSR (Server Side Rendering) 모든 것들을 서버로부터 계속 다시 받아옴 사용자 동작에 따라 앱이 다시 실행된다. 화면 깜박이게 된다. 장점 - SEO에 유리하다. 초기 로딩 속도가 빠르다. 단점 - 매번 새로 고침이 발생하여 사용자 경험을 해칠 수 있다. 페이지를 요청할 때마다 서버에서 페이지를 구성하는 모든 리소스를 구성에서 응답하므로 서버의 부하가 증가한다. SPA (Single-Page Application) 말 그대로, 1개의 페이지로 구성되어 앱의 새로고침 없이 필요한 화면을 전환시킨다. CSR 사용자의 요청에 따라 필요한 부분만 렌더링한다. 모든 JS 파일을 다운 받아야 해서 초기 로딩 시간은 오래 걸린다. 화면이 깜박이지 않고 바로 수정된 데이터를 표시한다. 속도가 빠르며, 서버의 부하가 감소한다. 사용자 친화적이다. (페이지 내에서 클릭하여 다음 단계로 넘어가는 과정에서 깜박임 없이 부드러운 화면 전환이 이루어진다.) SEO에 불리하다. 웹 크롤러가 페이지를 색인화하면 SPA를 빈 페이지로 인식하기 때문이다. 초기에 모든 JS를 받아와야 하기 때문에 초기 로딩 속도가 느리다. SPA에서 SSR 사용하기?전부를 SSR로 하기는 불가하다. 모든 것을 SSR로 하면 MPA나 다름 없다. ⇒ 👩‍🏫 Content 중심의 개발하기!단순 렌더링은 SSR로, 클라이언트 반응이 필요한 경우 CSR을 활용할 수 있다! 👨‍🏫 강의유튜브 미션 셀프 코드 리뷰내가 생각했을 때 바보 같지만 나눠보고 싶은 질문 util성 함수는 어디까지 분리해야 할까요? 2개 이상의 모듈에서 사용하면 util로 분리하는 게 맞을까요? 모듈(많은 경우 class)의 메소드에서 그냥 직접 써야 할지 고민 🤔ex) lazyLoading, throttle을 일단은 util 파일로 구분하였는데, 사실상 둘 모두 한 군데서만 사용 중. util로 빼는 게 옳은 방식일까? (한 달 전에는 리뷰어님이 분리하라고 하셔서 그렇게 했던 기억) 그때는 몰랐지만 지금은 알게된 것 object destructuring을 유용하게 잘 쓰고 있다 아래와 같은 방식으로, object의 key값에 대괄호 붙여 변수명을 사용하기1this.store.update({ [STORE_KEYS.LIKED_VIDEO_IDS]: videoId }); 그때도 몰랐고 아직도 잘 모르겠는 것 throttle 파일에서 사용하고 있는 .apply() 메소드. 연습하자. 반복하고 있는 실수 및 습관이 있다면? 예외처리를 조금 그때그때 필요에 따라 아무데서나 사용하는 느낌이 있다. id, class 선택자를 기준 없이 혼용해서 사용하고 있는 점 😵 기존에 작성하던 방식에서 코드를 단순히 가져와서 사용한 경우는 없는지 ‘본 영상’, ‘볼 영상’, ‘좋아요 누른 영상’ 갈수록 점점 탭이 많아졌지만 기존의 코드 틀을 벗어나지 못하고 그대로 가져다 쓴 부분이 많았다. 중복을 줄여보려고 애썼지만 모두 줄여지지 않았고, 처음부터 확장성을 고려하지 못하고 문제해결에 급급하여 navigation tab들 간에 이동하는 코드가 지저분해졌다. 확실하게 말할 수 있는 발전한 1가지 아직도 완벽하진 않지만, store에 앱의 데이터를 저장하고 유저의 동작에 따라 update시킨 후 controller에 notify하는 법에 익숙해졌다. CustomEvent의 등록과 dispatch를 기존의 코드를 따라하지 않고, 원래의 목적에 맞게 스스로 생각해서 작성하는 법 다시 유튜브 강의실 미션 코드를 작성한다면 어떻게 작성할 것인가? nav tab들 간의 이동에서 router를 시도하다가 실패하긴 했지만, 지하철 노선도 미션을 수행하며 history에 대한 이해도가 조금 는 만큼 router를 시도해보고 싶다. 예외처리를 조금 더 일관성 있게 하자! 나의 과거 기록을 보며 사색하며 떠오르는 생각은? 미션 시작 초반에는 새로운 것을 많이 시도해보고자 애썼다. 하지만 시간이 지날수록 기력도 딸리고(?) 미션을 끝내기에 급급해서, 기존에 설계된 코드들에서 크게 벗어나지 않고 기능을 되는 대로 구현하기 바빴던 것 같다. 그래도 미션을 함께했던 페어와 그래도 시시때때로 토론하고, 코치의 도움을 받아가가면서 몸으로 체화한 코드들이 많아서 뿌듯한 느낌이다. ☺️ 아직도 많이 부족하지만 점차 나아져보자. 기타Netlify로 Webpack server 배포하기Ref https://hshine1226.medium.com/netlify를-통해서-static-react-app-배포해보기-bd0a574c8c08 debuggerRef https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/debugger 배민 신입 개발자 이력서Ref https://www.youtube.com/watch?v=Yc56NpYW1DM 😎 마무리이번주는 코치와의 면담도 하고, 카페에서 죽치고 코딩하는 백엔드 크루들과도 몇몇 알게 됐다.살면서 제일 재밌었던 방학식도 하고, 두 달 전 보이는 라디오에서 함께 했던 백엔드 크루들을 보니 또 반갑고 즐거웠다! 모든 크루들이 두 달이라는 짧은 시간,그것도 실제로 본 건 한 달 밖에 안되는 시간 동안에도 정말 많이 친해지고 끈끈해진 것 같다.다시한번 우리 프론트 크루들과 술파티도 하고, (4인끼리…) 포코조 랜선 회식도 하고 정말 다른 의미로 정신없었던 Lv1의 마지막 주 😵 잘 쉬고, 가득 충전하고 이제 본격적으로 리액트를 배울 Lv2를 또 씩씩하게 준비해보자! 😎놀러가자 놀러가자 오예","link":"/2021/04/03/woowa-week-09/"},{"title":"우테코 12주차 이야기","text":"우아한테크코스 12주차 Storybook으로 컴포넌트 UI 테스트 | prop drilling | propTypes 페어 프로그래밍콜린버스 타고 페어 프로그래밍 중…항상 많이 맞춰주고, 배려해주고, 의견을 조심스럽게 말해주는 고마운 페어다!아직 부족한 점이 많아서 함께 공부해 나가고 있다. 공부하기prop drillingthreading이라고도 불리는 prop drilling은, 리액트 컴포넌트 트리에서 데이터가 전달되는 과정을 가리킨다. 12345678910111213141516171819202122function Toggle() { const [on, setOn] = React.useState(false) const toggle = () =&gt; setOn(o =&gt; !o) return &lt;Switch on={on} onToggle={toggle} /&gt;}function Switch({on, onToggle}) { return ( &lt;div&gt; &lt;SwitchMessage on={on} /&gt; &lt;SwitchButton onToggle={onToggle} /&gt; &lt;/div&gt; )}function SwitchMessage({on}) { return &lt;div&gt;The button is {on ? 'on' : 'off'}&lt;/div&gt;}function SwitchButton({onToggle}) { return &lt;button onClick={onToggle}&gt;Toggle&lt;/button&gt;} 위의 예제에서, on이라는 상태와 toggle이라는 이벤트 핸들러가 각각 SwitchMessage와 SwitchButton 컴포넌트에 알맞게 들어가게 하기 위해서는 Switch 컴포넌트를 거쳐야 한다. Switch 컴포넌트는 그 자체로 on과 toggle이 필요하지 않지만, 그 자식 컴포넌트들에서 데이터가 필요하기 때문에 이 데이터들을 props로 넘겨준다. 이를 prop drilling이라고 한다. prop drilling은 데이터의 흐름을 추적하기 쉽고 해당 값들이 어디서 사용되는지 파악하는 데 유리하다. 그러나 앱의 규모가 커짐에 따라 수많은 컴포넌트 레이어를 거쳐 prop drilling이 발생한다면 여러가지 문제가 발생할 수 있다. 일부 데이터의 자료형을 바꾸는 경우 필요보다 많은 props를 전달하다가 컴포넌트를 분리(또는 제거)하는 과정에서 필요없는 props가 남는 경우 필요보다 적은 props를 전달하면서 동시에 defaultProps를 남용하여 정말 필요한 props이 전달되지 못할 경우 props의 이름이 중간에 변경되어서 값을 추적하기가 힘들어지는 경우 render 메소드를 성급하게 여러 블록으로 분리시키는 것은 prop drilling의 문제를 더욱 악화시킨다. 가능한 하나의 render 메소드를 사용하고, 실제로 필요한 경우에만 render 내의 블록들을 분리하자. 기억하지도 못할 여러 컴포넌트들에 props를 떠돌아다니게 하지 말자 Fun fact, there’s nothing technically stopping you from writing your entire application as a single React Component 또 defaultProps의 사용을 지양하자. 정말 불필요한 prop에만 default 값을 부여하자.마지막으로, 관련 있는 state는 가능한 가장 가까운 곳에 위치하는 것이 좋다! 😉 참고: React Context API Refhttps://kentcdodds.com/blog/prop-drilling 유연한 컴포넌트를 작성하기 위한 4가지 원칙 by Dan abramov원칙 1: 데이터 흐름을 중단해서는 안 된다.렌더링 내에서 데이터 흐름을 중단하지 말자. prop을 state에 복사하는 것은, 이후의 모든 업데이트를 무시하게 된다. 변화에 따라 업데이트되길 원한다면 prop을 계산한 값을 render 메소드 안으로 옮기는 것이다. 12345678910111213class Button extends React.PureComponent { render() { const textColor = slowlyCalculateTextColor(this.props.color); return ( &lt;button className={ 'Button-' + this.props.color + ' Button-text-' + textColor // ✅ 언제나 최신 }&gt; {this.props.children} &lt;/button&gt; ); }} 또는 메모이제이션을 사용하여 특정 prop이 바뀔 때마다 고비용의 계산을 할 수 있다. 12345678function Button({ color, children }) { const textColor = useMemo( () =&gt; slowlyCalculateTextColor(color), [color] // ✅ `color`가 바뀌기 전에는 다시 계산하지 않습니다 ); return ( ... )} 또, 부수효과(ex. 데이터 가져오기) 내에서 데이터 흐름을 중단하지 말자데이터를 fetch해오는 url의 query가 바뀔 경우, 아래의 lifecycle 메소드를 이용하여 props의 변경을 제대로 반영할 수 있다. 12345componentDidUpdate(prevProps) { if (prevProps.query !== this.props.query) { // ✅ 변경시에 다시 가져오기 this.fetchResults(); }} hook은 이러한 일관성을 정적으로 분석할 수 있게끔 해준다. 123456789101112131415useEffect(() =&gt; { function fetchResults() { const url = getFetchUrl(); // 데이터 가져오기 실행... } function getFetchUrl() { return ( 'http://myapi/results?query' + query + '&amp;page=' + currentPage ); } fetchResults();}, [currentPage, query]); // ✅ 변경시에 다시 가져오기 currentPage, query는 부수효과의 ‘종속성’이 된다. 마지막으로, 최적화 내에서 데이터 흐름을 중단하지 말자. Ref https://overreacted.io/ko/writing-resilient-components/ 알아보기propTypesReact의 propTypes를 사용하면 TypeScript를 사용하지 않고도 컴포넌트가 받아야 할 props의 타입을 확인할 수 있다. 12345678910111213import PropTypes from 'prop-types';class Greeting extends React.Component { render() { return ( &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; ); }}Greeting.propTypes = { name: PropTypes.string}; isRequired 옵션으로 해당 prop에 대한 강제성을 부여할 수 있으며, defaultPropTypes로 기본값을 설정할 수 있다. 1234567Greeting.propTypes = { name: PropTypes.string.isRequried // 필수 prop};Greeting.defaultProps = { name: 'Stranger'}; propTypes는 성능상의 이유로 development mode에서만 확인이 가능하다. Ref https://ko.reactjs.org/docs/typechecking-with-proptypes.html manifest.jsonCRA 프로젝트 디렉토리를 정리하면서 public 폴더의 manifest.json 파일을 필요없겠지? 생각하여 지워버렸더니 에러 발생 😑 해당 파일은 앱에 대한 정보를 담고 있는 JSON 파일로, 배경색, 앱의 이름, 홈스크린 아이콘 등에 대한 정보를 담고 있다. short_name: 사용자 홈 화면에서 아이콘 이름으로 사용name: 웹앱 설치 배너에 사용icons: 홈 화면에 추가할때 사용할 이미지start_url: 웹앱 실행시 시작되는 URL 주소display: 디스플레이 유형(fullscreen, standalone, browser 중 설정)theme_color: 상단 툴바의 색상background_color: 스플래시 화면 배경 색상orientation: 특정 방향을 강제로 지정(landscape, portrait 중 설정) Ref https://altenull.github.io/2018/03/09/웹앱-매니페스트-서비스워커-Web-App-Manifest-Service-Worker/ css input, img 태그에는 before, after 등 pseudo element를 사용할 수 없다. letter-spacing 속성을 사용하여 자간을 조정할 수 있다. React의 refreact-lotto 학습로그 참조 Ref https://cereme.dev/frontend/react-hooks-useeffect-useref-feat-closure/ useState의 타입은?Router 없이 state로 pagination을 구현하겠다고, state에 React Component 자체를 넣어봤다. 그리고 state를 찍어보았다. 대략 이런 셈 12345const [currentPage, setCurrentPage] = useState(&lt;CardList cards={[]} /&gt;);useEffect(() =&gt; { console.log(currentPage);}); 과연 무엇이 찍혔을까? 123456{ $$typeof: Symbol(react.element), key: null, ...} 신기한 것이 찍혔다. $$typeof이 뭘까? React의 JSX에서 다음과 같이 리턴하면, 1&lt;CardList cards={['zig', 'woo', 'yang']}&gt; 실제로는 아래와 같이 컴파일된다. 12345React.createElement( /* type */ 'CardList', /* props */ { cards: ['zig', 'woo', 'yang'] }, // ...) 그리하여 해당 값이 콘솔에 아래와 같은 형태로 찍히는 것이다. 12345678{ $$typeof: Symbol(react.element), key: null, props: { cards: [...] } ...} 클라이언트 사이드 UI 라이브러리들이 보편화되기 전, HTML을 생성하고 DOM을 주입하기 위해서는 주로 아래와 같은 방법이 사용되었다. 12const messageEl = document.getElementById('message');messageEl.innerHTML = '&lt;p&gt;' + message.text + '&lt;/p&gt;'; 이 코드는 정상 작동하겠지만, message.text에 &lt;img src onerror=&quot;stealYourPassword()&quot;&gt;와 같은 값이 들어온다면 어떨까? 누군가가 작성한 코드가 앱의 렌더된 HTML에 inject되는 XSS 공격이 발생할 수 있는 것이다. 이 때문에 React에서는 문자열 텍스트에 대한 이스케이핑이 기본으로 지원되어, message.text에 &lt;img&gt; 등의 수상한 태그 문자열이 들어오면 이를 실제 DOM으로 변환시키지 않고 이스케이프한 뒤 DOM에 주입시킨다. &lt;img&gt; 태그가 마크업 코드 그대로 표시되는 것이다. (정말 임의로 HTML을 넣어야 하는 상황이라면, dangerouslySetInnerHTML을 사용할 수 있다.) 그러나 서버의 결함 등으로 인해 유저가 문자열 대신 임의의 JSON 객체를 입력하여 그 값이 서버에 저장될 수 있다면, React는 또다시 XSS 공격에 취약해진다. 그렇게 React 0.14부터는 모든 React element에 Symbol 태그를 달기로 했다. JSON에는 Symbol을 넣을 수 없기 때문에, 서버에 보안 구멍이 생겨 텍스트 대신 JSON을 반환한다 하더라도 그 JSON에는 Symbol.for('react.element')를 포함할 수 없다. React는 element.$$typeof를 체크하여, 해당 키가 없거나 무효하면 React element 생성을 거부한다. Ref https://overreacted.io/why-do-react-elements-have-typeof-property/ 질문하기ComponentQ. 컴포넌트를 어느정도까지 분리 해야할까요? 또 어떤 경우 컴포넌트를 그룹화해서 하나의 컴포넌트처럼 보이게 하는 것이 좋을까요?Refhttps://developer.mozilla.org/ko/docs/Web/Web_Componentshttps://overreacted.io/ko/the-elements-of-ui-engineering/https://overreacted.io/ko/writing-resilient-components/ Props 리액트에서 속성을 불변 객체로 다루는 이유는 무엇일까요? 또, 불변 객체로 다루지 않았을 때 발생할 수 있는 이슈는 무엇일까요? 하위 컴포넌트에서 상위 컴포넌트의 상태인 Props 를 직접 수정할 수 없는 이유는 무엇일까요? Prop Drilling을 해결할 수 있는 방법은 Context API 혹은 Redux 같은 State Container와 Store Management뿐일까요? Storybook 스토리북을 이용하면 특히 어떤 컴포넌트나 페이지를 테스트할 때 이점이 있을까요? Hooks API class 컴포넌트는 더이상 필요가 없을까요? class 기반으로 구현할 때 컴포넌트마다 반복되는 로직을 재사용할 수 있는 방법은 무엇이 있을까요? (꼭 리액트에서만이 아니라 좀 더 일반적인 방법들에 대해서도 고민해볼까요?) ‘함수’가 어떻게 ‘상태’를 가질 수 있는 걸까요? useEffect 에서는 보통 어떤 작업들을 하게 될까요? Hooks를 사용할 때 반드시 지켜야 하는 사용 규칙은 무엇인가요? Controlled &amp; Uncontrolled Components 제어 컴포넌트를 지향하라는 의견이 많은 이유는 무엇일까요? useImperativeHandle 이 언급되는 이유가 무엇일까요? 비제어 컴포넌트는 사용할 일이 없는건가요? 기타고통없는 UI 개발을 위한 StorybookUI 개발 환경이며 동시에 UI 컴포넌트 플레이그라운드라고 할 수 있는 storybooksRef https://jbee.io/tool/storybook-intro/ React에는 ‘함수형 컴포넌트’가 없다함수형 프로그래밍이란 보통 순수함수를 다루는 프로그래밍 기법을 가리킨다.React에서 hook과 함께 등장한 형태의 컴포넌트는 ‘함수 컴포넌트’로, useEffect 등 사이드 이펙트를 이용한다. Ref https://gyuwon.github.io/blog/2020/07/24/react-has-no-functional-components.html React 17 delegates events to root instead of document기존에 React는 이벤트들을 document에 위임했다. 아래의 input에 걸린 onChange 이벤트를 document 전체에 위임하여 등록한 것이다. 123456789const MyComponent = () =&gt; { const handleChangeInput = () =&gt; { ... }; return ( &lt;div id=&quot;container&quot;&gt; &lt;input onChange={handleChangeInput} /&gt; &lt;/div&gt; );} 여기서 id가 container인 요소에 change 이벤트를 걸고, 그 안에서 e.stopPropagation()을 호출하는 경우를 생각해보자. 1234document.querySelector('#container').addEventListener('change', (e) =&gt; { e.stopPropagation(); console.log('deter change event');}); e.stopPropagation()이 이벤트 버블링을 막고 있기 때문에, input에 걸린 handleChangeInput의 동작이 실행되지 않는 문제가 발생한다. 이를 해결하기 위해, React 17부터는 document가 아닌 root에 이벤트를 위임한다. Ref https://bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document React Best Practices Kent C. Dodds Dan Abramov Michel Weststrate Controlled Component vs Uncontrolled ComponentUncontrolled 컴포넌트DOM에 있는 값을 필요할 때 직접 가져와 사용하는 방식으로, 사용자가 입력한 값이 화면에 보이는 값이 된다. 사용자가 값을 입력한다 화면에 입력값이 표시된다. 이벤트 핸들러가 입력값을 컴포넌트에 전달한다 필요한 로직을 수행한다. Controlled 컴포넌트React의 State로 값을 관리하는 방식으로, 사용자가 입력한 값이 아닌 react의 state 렌더 결과가 화면에 보인다. 사용자가 값을 입력한다 이벤트 핸들러가 입력값을 컴포넌트에 전달한다. setState를 호출한다. 화면에 입력값(state)이 표시된다. Ref 하루(우테코 3기 FE 크루) Lottie에어비앤비에서 만든 애니메이션 라이브러리 마무리일이 밀리고 밀리기만 한다. 리액트도 리액트지만 CSS 너무 어렵다. 살면서 일이 이렇게 많을 수는 없을 거다.","link":"/2021/04/24/woowa-week-12/"},{"title":"우테코 13주차 이야기","text":"우아한테크코스 13주차 React Portal | Context API 페어 프로그래밍콜린이랑 마지막 페어 주간! 내가 주도적으로 개발한 것 같아서, 콜린의 의견이 어떻냐고 자주 물어봤다. 그래도 항상 다 괜찮다고 해주니까, 괜히 너무 걱정하지 말고 그 말을 믿어야겠다. 나는 사실 생각하지 않고 코드를 일단 짜는 스타일인데, 중간중간에 콜린이 사소한 실수들을 잘 잡아줘서 삽질할 뻔 한 시간들을 많이 줄일 수 있어서 좋았다. 전체적으로 무난하고 평화로운(?) 코딩이었다. 시간에 조금 쫓겨서 에러 처리를 완벽히 하지 못한 점이 아쉽다. 언제나 여유가 좀만 더 있었으면, 생각하게 된다. 테코톡 - 웹접근성 &amp; 웹표준(정리 중)요 미키쓰의 테코톡신기한 툴을 사용했다 공부하기class component에서의 this binding자식 컴포넌트에 props로 넘겨주는 부모 컴포넌트의 메소드 내부에서 this를 참조하지 않고 있다면 바인딩을 안 해줘도 될까? 하는 의문이 문득 들었다. 답은 일단 YES긴 한데, 왜냐면 참조해야할 값이 없으니까. 그렇지만 컴포넌트의 마운트/언마운트 시점을 예측 불가할 수도 있기 때문에 자식 컴포넌트에서 props로 받고 있는 메소드가 this 참조값을 잃어버릴 수도 있겠다는 생각은 든다. 일단 바인딩하자! React Portal부모 컴포넌트의 외부 DOM에 컴포넌트를 렌더링하는 기능이다. 마스킹된 숫자를 입력해야 하는 일부 자식 컴포넌트에서, 현재의 view 상위에서 가상 키보드를 보여줘야 할 상황에서 사용했다. 우선 index.html의 root와 같은 층위에, Portal 컴포넌트를 띄울 곳을 id attribute와 함께 지정해 준다. 123&lt;!-- public/index.html --&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;div id=&quot;keyboard&quot;&gt;&lt;/div&gt; hook을 사용하고 있기 때문에 React.createPortal을 사용했다. 첫 번째 인자로는 Portal을 통해 보여줄 컴포넌트, 두 번째 인자는 보여줄 DOM 노드를 전달해준다. 1234567891011// VirtualKeyboard.jsexport const KeyboardPortal = ({ children }) =&gt; { const el = document.getElementById('keyboard'); return createPortal(children, el);};const VirtualKeyboard = (props) =&gt; { return ( // ... );} 사실 root와 같은 층위에 새로운 DOM 요소를 삽입해주는 것이 부담스러워서(?), Keyboard를 사용하는 상위 React 컴포넌트에 해당 노드를 심어주고자 했으나 ‘Target DOM’을 찾을 수 없다는 에러가 계속 발생했다. 리뷰를 통해 에러의 원인을 확실히 할 수 있었다. document.getElementById로 셀렉팅 해올 수 있는 경우는 DOM 오브젝트가 생성된 이후입니다.리액트 컴포넌트의 렌더링 순서에 의존하는 코드를 작성하면 그 코드는 잘못 작성된 것 사용하는 곳에서는 Portal 컴포넌트로 실제 렌더링할 컴포넌트를 한번 감싸준다. 123456// CardPasswordInput.jsreturn ( &lt;KeyboardPortal&gt; &lt;VirtualKeyboard inputNumbers={cardPas sword} setInputNumbers={setCardPassword} /&gt; &lt;/KeyboardPortal&gt;) Refhttps://ko.reactjs.org/docs/portals.htmlhttps://velog.io/@velopert/react-portals 알아보기서로 떨어진 form과 button 연결하기React를 사용하다보면 컴포넌트의 요소들을 조립하기가 난감해지는 상황이 종종 발생한다. 이번에는 form과 button을 연결하고 싶은데, button이 컴포넌트 상으로 form과 같은 컴포넌트 내에 위치하기가 어려워졌다. 이럴 때!button의 form 속성을 활용하면 멀리 떨어진 form과 연결할 수 있다. React에서는 formId 속성을 사용한다. 12345&lt;form id=&quot;register&quot;&gt; &lt;input /&gt;&lt;/form&gt;&lt;button form=&quot;register&quot;&gt; PropTypes.shapeprop-types를 통해 vanilla JS를 사용하면서도 React 컴포넌트에 들어가야 할 props에 대해 타입 제한을 걸 수 있다. 123456PageHost.propTypes = { navigationTitle: PropTypes.string.isRequired, hasBackButton: PropTypes.bool.isRequired, children: PropTypes.node.isRequired, handleGoBack: PropTypes.func,}; 그런데 nesting된 object가 들어올 경우 타입을 뭐라고 명시해줘야 할까? PropTypes.shape()를 쓰면 된다! 1234567891011CardCompletion.propTypes = { cardData: PropTypes.shape({ bankId: PropTypes.string.isRequired, cardNumbers: PropTypes.object.isRequired, expirationDate: PropTypes.object.isRequired, ownerName: PropTypes.string.isRequired, }), handleConfirmPage: PropTypes.func.isRequired, isEditing: PropTypes.bool.isRequired, cardId: PropTypes.string,}; em vs rem재사용되는 컴포넌트의 크기를 페이지마다 다르게 하다보니, 사이즈의 정확한 픽셀값보다 상대적인 값을 사용하기로 했다. em은 실제 사용된 요소의 폰트 크기에 의해서 정해진다. 1234567html { font-size: 100%; /* 16px by default */}h1 { font-size: 2em; /* 16px * 2 = 32px */} rem은 루트의 em을 의미한다. 1rem은 브라우저에서 설정된 &lt;html&gt;의 font-size와 동일하다. Refhttps://jeongwooahn.medium.com/번역-rem-vs-em-5eac6122b8ea global attribute hiddenglobal attribute인 hidden attribute는 해당 element가 아직 관련이 없거나, 더 이상 관련이 없는지를 나타내는 boolean attribute이다. 예를 들어, 현재 상황과 관련없는 페이지의 elements를 숨기는데 사용될 수 있다. 브라우저는 hidden attribute가 설정된 elements를 설정하지 않는다. 1&lt;p hidden&gt;This node won't be rendered.&lt;/p&gt; hidden attribute는 단순히 어떤 요소를 표시하지 않기 위해 사용하면 안 된다. 만약 어떤 것이 hidden으로 설정되면, 스크린 리더기 등 모든 표현방식에서 사라지게 됩니다. 단순히 보이지 않게 하고 싶다면, css의 display: none을 사용하자. css의 display: none과 같이 html element의 스타일 속성을 명시적으로 지정한 경우에는, hidden 속성이 있더라도 이를 override한다. Refhttps://developer.mozilla.org/ko/docs/Web/HTML/Global_attributes/hiddenhttps://velog.io/@bigsaigon333/Level1-javascript-racingcar 질문하기Context API Context API를 쓰면 Redux를 사용할 필요가 없다는 말이 있던데 사실인가요? 레벨1에서 전역 변수를 지양해야한다는 피드백이 많았는데 React에서는 전역 상태를 사용해도 되는 될까요? 기타모의면접패턴에 막혀서 대부분의 시간을 당황해 하며 보냈다. 😭 역시 인생에 예측대로, 뜻대로 되는 건 없다! 지속 가능한 소프트웨어를 만들어가는 방법비즈니스 로직Service 단에 작성하는 코드비즈니스 흐름 기준으로 각 역할을 가진 협력 도구 클래스들을 중계해 주는 역할을 하며, 각 협력 도구 클래스들이 명시적으로 한 가지 일을 담당한다. 상세 구현 로직은 잘 모르더라도 비즈니스의 흐름은 이해 가능한 로직이어야 한다. 소프트웨어 레이어 Presentation Layer - 외부 영역에 대한 처리를 담당하는 코드나 요청이 이루어진다. 외부 변화에 민감한, 외부 의존성이 높은 영역이다. Business Layer - 비즈니스 로직을 투영하는 레이어 Implement Layer - 비즈니스 로직을 이루기 위해 도구로서 상세 구현 로직을 갖고 있는 클래스들을 가진다. 가장 많은 클래스들이 존재하고 있으면서 구현 로직을 담당하기 때문에 재사용성도 높은 핵심 레이어다. Data Access Layer는 - 상세 구현 로직이 다양한 자원에 접근할 수 있는 기능을 제공하는 레이어. 기술 의존성을 격리하여 구현 로직에게 순수한 인터페이스를 제공하며, 일반적으로 별도의 모듈로 구성된다. 모듈화새로운 기술 또는 기술의 전환이 필요할 때 비교적 쉽고 빠르게 기존 비즈니스에 가장 적은 영향을 끼치며 모듈 단위로 변경이 가능해지게끔 구성 👾 통제와 제어를 통해 소프트웨어를 예측 가능하게 만들자. 지속 성장하면서 운영 가능한 소프트웨어를 위해서! Ref https://geminikim.medium.com/지속-성장-가능한-소프트웨어를-만들어가는-방법-97844c5dab63 React 학습 문서 추천Refhttps://reactjs.org/docs/thinking-in-react.htmlhttps://reactjs.org/docs/jsx-in-depth.htmlhttps://kentcdodds.com/blog/https://overreacted.io/ 앱 접근성, 스크린리더 확인iOS - 손쉬운 사용크롬 익스텐션 - WAVE 마무리밀리고 밀린다..! 사람 살려!!","link":"/2021/05/01/woowa-week-13/"},{"title":"우테코 14주차 이야기","text":"우아한테크코스 14주차 git hook | React + TypeScript | Redux 페어 프로그래밍우여곡절 끝에 3인 페어가 되었다. 입아체 체프와, 투두 출신 개발자 유조! 둘 다 실력자라서 내가 잘할 수 있을지 긴장되었다. 그래도 꿀잼으로 잘 진행하고 있다. 온라인으로 할 때는 3명이라 오디오가 때때로 물려서 불편하긴 한데, 의사결정과 작업 속도가 더 빠른 느낌이다. 지난 3인 페어를 거쳐간 크루들이 말했듯 ‘짝’보다는 ‘팀’에 가까운 형태라, 뭔가 더 으쌰으쌰 힘도 난다. 첫 오프라인 페어 때는 거의 흥의 민족이 되어 신나게 코딩했다. 체프는 이것저것 정말 많이 잘 알고 있다. 나도 그런 편이지만, 이유는 모른 채 깨작깨작 어디선가 조금씩 코드 긁어다 붙여놓기만 했던 나와는 다르다. 진짜 생각을 하고 이유 있는 코드를 작성한다. 배울 만한 자세다. 어디선가 막히면, 혼자서라도 문제를 해결해와서 공유해 준다. 대단하다! 또 이것저것 많이 컨벤션을 준비해와서 일을 체계적으로 착착 진행할 수 있었다. 반장 재질… 유조는 redux와 thunk 모두 처음이라고 했는데, 충분히 금방 해낼 수 있을 것 같다. 따로 시간 내서 배우고 연습해보려는 열정이 대단하다. 그리고 정말 다른 사람들의 의견을 잘 받아준다. 수동적으로 받아들이기만 하는 것이 아니라, 충분한 고려 끝에 수용한다. 의견을 제시한 사람의 기분을 좋게 만들어 주기도 한다. 유조의 ‘좋아요’라는 어투가 너무 재미있다. 중독될 것 같다. 이번 미션부터는 typescript로 작업하고 싶었던 내 의견도 모두 긍정적으로 받아줘서 정말 고마웠다. 부끄럽지 않게 시간 내서 공부해야겠다. 일단 UI 작업은 끝냈다. 특히 체프가 정말 CSS의 고수여서 수월하게 작업할 수 있었던 것 같다. 나도 빨리 짬이 차서 CSS에 능숙해지면 좋겠다! 많이 연습해야지. 테코톡 - Virtual DOM(정리 중) 이번주 테코톡은 바로 나였다… 녹화 도중 구급차가 시끄럽게 지나가서 조금 웃긴 것 같았지만, 끝내서 후련하다! 공부하기React.FC, 사용해야 할까?TypeScript로 리액트 앱을 개발하면 React.FC (Function Component)를 사용할 수 있다. 123456789type TodoItemProps = { text: string;}const TodoItem: react.FC&lt;TodoItemProps&gt; = ({ name }) =&gt; { return ( // ... )} 세부적인 구조는 아래와 같이 생겼다. 12345678interface FunctionComponent&lt;P = {}&gt; { (props: PropsWithChildren&lt;P&gt;, context?: any) : ReactElement&lt;any, any&gt; | null; propTypes?: WeakValidationMap&lt;P&gt;; contextTypes?: ValidationMap&lt;any&gt;; defaultProps?: Partial&lt;P&gt;; displayName?: string;} React.FC를 사용하면 props에 기본적으로 children이 들어간다. 이는 장점이 될 수도, 단점이 될 수도 있다. children이 옵셔널 형태로 들어가기 때문에 props 타입이 명확해지지 않고, children이 필요하지 않거나 들어가면 안 되는 컴포넌트의 경우 사용이 곤란하다.또 React.FC를 사용하면 컴포넌트의 defaultProps, propTypes, contextTypes를 설정할 때 자동완성이 가능하다.그러나 이 경우 defaultProps가 제대로 작동하지 않는다. 123456789101112131415type TodoItemProps = { text: string;}const TodoItem: React.FC&lt;TodoItemProps&gt; = ({ name }) =&gt; { return ( &lt;div&gt;{name}&lt;/div&gt; )}TodoItem.defaultProps = { text: 'some todo',}export default TodoItem; 해당 컴포넌트를 사용하는 곳에서 prop을 넘겨주지 않는다면 에러가 발생한다. 123const App: React.FC = () =&gt; { return &lt;TodoItem /&gt;; // Property 'text' is missing} 장단점이 있겠지만, React.FC를 쓰지 않는 편이 나을 것 같다! Refhttps://velog.io/@velopert/create-typescript-react-componenthttps://fettblog.eu/typescript-react-why-i-dont-use-react-fc/ d.ts에 특정 모듈 기능 추가하기Ambient declaration은, 기존 JavaScript 모듈을 TypeScript에서 사용하기 위해 기존 JavaScript 모듈의 타입 정보를 별도의 파일로 선언한 것을 의미한다. npm install [module-name] 또는 npm install @types/[module-name]으로 사용했던 것들은 모두 이미 존재하는 모듈의 .d.ts를 가져다 쓰고 있는 것이다. style 모듈로 emotion을 사용하면서, default theme에 대한 정의가 필요했다. TypeScript를 사용하고 있기 때문에 해당 theme에 대한 타입 정의도 필요해졌다. 아래와 같이 작성했다. 12345678910111213// emotion.d.tsimport '@emotion/react';declare module '@emotion/react' { export interface Theme { bgColor: { primary: string; secondary: string; lightGrey: string; }; // ... }} export하고자 하는 내용을 interface 또는 type으로 작성할 수 있다.JavaScript에서 declare가 의미하는 바가 무엇인지는 정확히 알아내지 못했다. 🤔 Refhttps://www.slideshare.net/gloridea/dts-74589285https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html type vs interfaceTypeScript에서 타입 선언 시 사용되는 두 가지 방식이다. Type union, tuple 등에는 type만 사용이 가능하다. 기본타입, 배열과 튜플, 유니온타입에 새로운 이름을 붙일 수 있다. (Interface는 불가능)12345type Name = string;type myAction =| { type: &quot;INCREMENT&quot;; count: number }| { type: &quot;DECREMENT&quot;; count: number } 실제로는 새 타입을 생성하는 것이 아니기 때문에 타입과 관련된 에러 발생 시 실제 타입을 보여준다. 객체 타입으로 표시된다.123456type Alias = { num: number }interface Interface { num: number}declare function aliased(arg: Alias): Aliasdeclare function interfaced(arg: Interface): Interface interfaced에 hover하면 interface가 표시되지만,aliased에 hover하면 객체 타입으로 표시된다. Interface 같은 이름으로 여러 번 선언해도 컴파일 시점에 합쳐지기 때문에 확장성이 좋다. (Declaration Merging) extends, implements를 통해 확장할 수 있다. Refhttps://velog.io/@swimme/Typescript-type-vs-Interfacehttps://joonsungum.github.io/post/2019-02-25-typescript-interface-and-type-alias/ 알아보기git hooks &amp; huskygit hooksgit을 사용할 수 있도록 도와주는 기능이다. git에서 commit, push 등 특정 이벤트 발생 순간에 hook 즉 갈고리를 걸어서 특정 스크립트가 실행될 수 있게 해준다.모든 git repository에 기본적으로 설치되어 있으며, cd .git/hooks에 들어가면 모든 기본 hook들을 확인할 수 있다. husky는 프론트엔드 개발 환경에서 git hook을 손쉽게 제어하도록 도와주는 도구이다.husky pre-commit 명령어에 lint-staged를 작성하여 git에 staged된 파일에 대해서 lint 검사를 수행해 준다. 검사가 실패하면 commit을 할 수 없다. 12yarn add -D husky lint-stagednpx husky add .husky/pre-commit &quot;npx lint-staged&quot; Refhttps://woowabros.github.io/tools/2017/07/12/git_hook.htmlhttps://www.huskyhoochu.com/how-to-use-lint-staged/ json serverjson 문법으로 간단하게 데이터베이스를 만들 수 있다. 1234567891011121314151617// data.json{ &quot;todos&quot;: [ { &quot;id&quot;: &quot;1a&quot;, &quot;text&quot;: &quot;블로그 작성&quot; }, { &quot;id&quot;: &quot;2b&quot;, &quot;text&quot;: &quot;친구 약속&quot; }, { &quot;id&quot;: &quot;3c&quot;, &quot;text&quot;: &quot;코드리뷰&quot; }, ]} 아래와 같이 실행하여 로컬에 json server를 띄운다. 12yarn global add json-serverjson-server --watch data.json --port 3001 간단한 배포는 heroku로 가능하다고 한다.Ref https://react.vlpt.us/redux-middleware/08-json-server.html redux toolkit액션타입, 액션생성함수, 리듀서를 모두 준비해야 하는 redux의 불편함을 한결 덜어주는 도구다. 리덕스 개발팀에서 만들었다. 리듀서, 액션타입, 액션생성함수, 초기상태를 하나의 함수 slice로 편하게 선언할 수 있다. 1234567891011121314151617181920import { createSlice } from '@reduxjs/toolkit';const msgboxSlice = createSlice({ name: 'msgbox', initialState: { open: false, message: '', }, reducers: { open(state, action) { state.open = true; state.message = action.payload }, close(state) { state.open = false; } }});export default msgboxSlice; Ref https://velog.io/@velopert/using-redux-in-2021 react에서 svg를 컴포넌트처럼 사용하기1234567import logoSvg from '../assets/images/logo.svg';const Header = () =&gt; { return ( &lt;img src={logoSvg} alt=&quot;logo&quot; /&gt; )} 위와 같이 img 태그의 src에 넣어주는 것이 일반적이지만, svg를 바로 리액트 컴포넌트처럼 사용할 수도 있다. 1234567import { ReactComponent as Logo } from '../assets/images/logo.svg';const Header = () =&gt; { return ( &lt;Logo /&gt; )} Ref https://kyounghwan01.github.io/blog/React/handling-svg/ CSS justify-items input, button 등은 globalStyle이 안 먹힐 수 있기 때문에 font-family: inherit이 필요하다. display: grid에도 justify-content: center 적용이 가능하다. ~와 + 선택자의 차이 (인접 선택자) x + y: x 바로 뒤에 있는 하나의 y만 선택 x ~ y: x 다음의 모든 y 선택 user-select: none - 드래그를 막아준다. flexbox 활용하기 - 컨테이너에 display: flex를 하고 하나의 자식 요소에 width (또는 height)를 적용한 후 다른 자식 요소를 flex: 1로 준다면 첫 번째 요소가 차지하고 남은 영역만큼을 모두 차지할 수 있다. z-index에 음수값 넣기 Ref https://code.tutsplus.com/ko/tutorials/the-30-css-selectors-you-must-memorize--net-16048 react-app-rewiredcra 프로젝트에서 babel이나 webpack 설정을 변경해야할 때가 있다.이때 eject를 할 수도 있지만, 모든 모듈들이 풀어 헤쳐지기 때문에 복잡해진다는 문제가 있다.이럴 때 react-app-rewired를 사용한다. 해당 툴은 webpack 설정을 override해준다.사용 시 스크립트를 변경해줘야 한다. 123456789// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;, &quot;storybook&quot;: &quot;start-storybook -p 6006 -s public&quot;, &quot;build-storybook&quot;: &quot;build-storybook -s public&quot;}, enum 사용을 지양하는 이유 treeshaking의 문제 정수형 enum 사용 시 enum에 정수로 접근하고자 하는 경우(위험) TypeScript가 에러를 뱉지 않는다. Refhttps://blog.logrocket.com/why-typescript-enums-suck/https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/ storybook에 argTypes 넣기1234567891011// Button.stories.jsexport default { title: 'shared/Button', component: Button, argTypes: { size: { type: 'radio', options: ['REGULAR', 'LARGE'], }, },}; 특정 컴포넌트의 스토리북에서 바꿔보고 싶은 인자를 미리 설정해서 편리하게 사용할 수 있다. 질문하기Flux Architecture Flux는 MVC의 어떤 문제를 해결했을까? Flux 패턴의 다양한 구현 라이브러리가 있는 이유는 무엇일까? 이전 미션에서와 같이 React 자체에서 제공하는 방법으로만 상태를 관리하는 것에 비해 어떤 장점이 있을까요? Redux 3가지 원칙이 있는 이유는 무엇일까요? Flux와 다른 점이 무엇일까요? 불변성을 지키기위해 많은 노력이 들어가는데 꼭 지켜야할까요? Router 서버 사이드 라우팅으로 할 수 없는, 클라이언트 사이드 라우팅의 장점이 있을까요? 클라이언트 사이드에서 라우팅을 적용할 때, 대응해야 하는 케이스에는 어떤 것들이 있을까요? 기타React 꽃길만 걷기Styling CSS 대신 PostCSS 등 SASS 툴 사용하기 styled components 사용하기 UI library 사용 지양 함수 컴포넌트 사용하기 useEffect로 lifecycle API 흉내내기 다양한 내장 Hook, 반복되는 로직은 Custom hook으로 작성 상태관리 Context API + useReducer Redux, Mobx는?➡️ 미들웨어/ 리덕스 개발자도구/ 유틸함수 등 지원 스토어에 넣어야 하는 값: 이유가 있을 때만! 상태를 다른 컴포넌트와 공유해야 할 때 다른 컴포넌트에서 해당 값을 바꿔야 할 때 컴포넌트 엄청 깊숙한 곳에서 상태를 필요로 할 때 서버사이드 렌더링시에 데이터 재사용이 필요할 때 Container &amp; PresentationalContainer component에는 하나의 Presentational component만 있어도 된다. Reducer 똑똑하게 작성하기(객체화) 12345678910const counter = (state = initialState, action) =&gt; { switch (action.type) { case INCREMENT: return { ...state, count: state.count + 1 }; case DECREMENT: return { ...state, count: state.count - 1 }; default: return state; }} 대신redux-actions, redux-act, typesafe-actions 등 사용 가능 123456789101112const counter = createReducer( { // (payload는 여기서 사실 필요 없음 - 이해를 돕기 위한 코드) [INCREMENT]: (state, { payload: null }) =&gt; ({ ...state, count: state.count + 1 }), [DECREMENT]: (state, { payload: null }) =&gt; ({ ...state, count: state.count - 1 }), }, initialState,) 상태는 최대한 깊지 않게 관리만약에 깊어진다면 Immer.js 사용하기 Ducks 패턴액션타입, 액션생성함수, 리듀서를 한 파일에 선언 데이터 요청 상태 관리하기리덕스 미들웨어에서 받아오는 데이터 요청의 성공/실패 등 로딩 상태를 관리하는 리듀서 분리하기 SSR(서버사이드렌더링)SEO를 위해선 필수!Next.js를 사용할 수 있다. 타입스크립트와 테스트 자동화 도입하기 Ref https://drive.google.com/file/d/18MJDVzre8DYnEx9OITrYZOC_cVUeaSdV/view Redux 어떻게 써야 잘 썼다고 소문 날까?언제 리덕스가 필요할까? 리덕스를 사용한 개발 스타일이 너무 마음에 들 때 미들웨어 서버사이드 렌더링 더 쉬운 테스팅 컴포넌트가 아닌 곳에서 글로벌 상태를 사용하거나 업데이트를 해야할 때 그냥 많이 사용돼서 Ref https://velog.io/@velopert/using-redux-in-2021 프론트엔드 웹서비스에서 우아하게 비동기 처리하기Ref https://www.youtube.com/watch?v=FvRtoViujGg 마무리다른 크루들과 오랜만의 회고 시간을 가지면서, 다들 하루하루 너무나도 벅찬 이 감정 상태와 고민을 공유했다. 확실히 다들 지쳐가는 게 보이긴 한다. 티는 안 내려고 하는 것 같지만… 다들 고민이 많은 것 같다. 나는 그런 고민할 시간도 힘도 없어서 그냥 오늘 하루만 알차게 보내자는 마음으로 살고 있는데. 말도 안 되는 소리긴 하지만, 일부러라도 여유를 조금 가지고 사는 편이 나은 것 같다. 스스로에게 질식 당하는 일은 너무 무서운 일이니까.","link":"/2021/05/08/woowa-week-14/"},{"title":"우테코 16주차 기록","text":"우아한테크코스 16주차 useCallback과 useMemo | React의 Router | Redux Middlware 페어 프로그래밍목요일이나 되어서야 새 페어가 매칭되었다. 지난번에 매칭됐다가, 옮겨지느라 같이 하지 못한 엘라! 마지막으로 또 친구인 크루가 걸렸다. 아직 이것저것 많이 맞춰가는 단계고, 이번엔 디자인 시안도 구체적으로 주어지지 않아 시행착오가 많다. 하지만 항상 열정 넘치는 크루같아 보인다. 마감일까지 열심히 잘 달릴 수 있을 것 같다! 테코톡 - 프론트엔드의 비동기 (callback -&gt; promise -&gt; async/await)(정리 중)우테코 가수 카일의 FE 비동기가 주제였다.카일 발표 거의 철학자… 공부하기CRA 앱에서 babel 설정을 도와주는 친구들CRA로 React 앱을 만들면 babel 설정을 마음대로 하기가 어렵다. .babelrc 파일을 생성해도 적용이 되지 않는다.node_modules/react-scripts/config/webpack.config.js를 들어가 보면 다음과 같이 babelrc가 false로 되어 있기 때문이다. 12345{ // ... babelrc: false, // ... } 물론 eject를 통해 config들을 모두 꺼내볼 수 있지만, 한 번 eject를 하면 모든 설정들과 프로젝트의 dependency들이 밖으로 나오기 때문에 복잡하며, 다시 돌이킬 수도 없다는 문제가 있다. 이를 해결해주는 모듈이 몇 개 있다. 가장 대표적인 것은 react-app-rewired이다. 1yarn add react-app-rewired scripts를 수정해 준다. 1234567// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, ...}, config-overrides.js 파일을 만들어 설정을 바꿔준다.이때 customize-cra를 사용하면 편리하다. 1234// config-overrides.jsconst { override, useBabelRc } = require('customize-cra');module.exports = override(useBabelRc()); 이제 CRA에 설정된 값을 필요에 따라 override하여 사용할 수 있다. 비슷한 모듈로 craco가 있다. 1yarn add @craco/craco 마찬가지로 scripts를 수정해 준다. 123456// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, } Refhttps://www.npmtrends.com/@craco/craco-vs-customize-cra-vs-react-app-rewiredhttps://micalgenus.github.io/articles/2019-02/React-eject-없이-babelrc-적용 TypeScript any vs unknownanyScript는 지양해야 하지만, TypeScript로 개발을 하다보면 정말 넘어가고 싶은 부분들마저도 끈질기게 타이핑을 요구하는 부분들이 있다. 이때 잠시 any를 쓰려고 하면 eslint@typescript-eslint/no-explicit-any rule에 의해 eslint가 잔소리를 뿜어댄다. 그런데 여기서 unknown을 쓰면 다시 잠잠해진다. 알쏭달쏭한데, 각각 어떤 상황에서 쓰는 것일까? any는 우선 TypeScript 기본 타입에 등록되어 있다. 동적인 데이터를 받아오는 경우 등 타입 검사를 하지 않고, 그 값들이 컴파일 시간에 검사를 통과하길 원할 때 사용한다.또한, any 타입은 타입의 일부만 알고 전체는 알지 못할 때 유용하다. 예를 들어, 여러 다른 타입이 섞인 배열에 any를 사용할 수 있다. 1let list: any[] = [1, true, &quot;free&quot;]; any는 어떠한 타입이든(never 제외) 다른 타입에 할당할 수 있도록 만드는 ‘타입 와일드카드’와도 같다. unknown 타입은 any와 마찬가지로 모든 타입의 값이 할당될 수 있다. 123456let variable: unknownvariable = true // OK (boolean)variable = 1 // OK (number)variable = 'string' // OK (string)variable = {} // OK (object) 하지만 조금 다른 것은 unknown 타입으로 선언된 변수는 any를 제외한 다른 타입으로 선언된 변수에 할당될 수 없다는 것이다. 1234567891011let variable: unknownlet anyType: any = variablelet booleanType: boolean = variable// Error: Type 'unknown' is not assignable to type 'boolean'.(2322)let numberType: number = variable// Error: Type 'unknown' is not assignable to type 'number'.(2322)let stringType: string = variable// Error: Type 'unknown' is not assignable to type 'string'.(2322)let objectType: object = variable// Error: Type 'unknown' is not assignable to type 'object'.(2322) unknown 타입으로 선언된 변수는 프로퍼티에 접근할 수 없으며, 메소드를 호출할 수 없으며, 인스턴스를 생성할 수도 없다. 말 그대로 unknown이기 때문이다. 123let variable: unknownvariable.foo.bar // Error: Object is of type 'unknown'.(2571) unknown 값을 사용하기 위해서는 Type Guard가 필요하다. 123456let variable: unknowndeclare function isFunction(x: unknown): x is Functionif (isFunction(variable)) { variable() // OK} any가 사용될 곳이라면 unknown 타입으로 대체할 수 있다. unknown 타입으로 지정된 값은 타입을 먼저 확인 후에 무언가를 할 수 있기 때문에 안전하다. 👾 결론! any보다는 unknown을 사용하는것이 좀 더 안전한 방법이다. Refhttps://typescript-kr.github.io/pages/basic-types.html#anyhttps://jbee.io/typescript/TS-9-unknown/https://overcurried.netlify.app/안전한%20any%20타입%20만들기/ React hooks의 필요성Ref https://blog.bitsrc.io/6-reasons-to-use-react-hooks-instead-of-classes-7e3ee745fe04 - Redux Toolkit + TypeScript + ThunkRef https://www.newline.co/@bespoyasov/how-to-use-thunks-with-redux-toolkit-and-typescript--1e65fc64 알아보기CSS :focus-withinhtml의 &lt;label&gt;과 &lt;input&gt;은 뗄레야 뗄 수 없는 관계다.아래 두 가지 작성 방식이 있다. 123&lt;label&gt;Click me &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/label&gt; 12&lt;label for=&quot;username&quot;&gt;Click me&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; for 속성이 필요하지 않고 연결 관계가 명확한 첫 번째 방식을 쓸 때가 많다.이때 &lt;input&gt;에 focus가 되었을 시 &lt;input&gt;의 색상 뿐 아니라 &lt;label&gt;의 색상도 바꾸게 하고 싶었다. 하지만 CSS에는 부모 요소를 선택하는 방법이 없다. 두 번째 방식으로 형제 선택자를 사용하려 했으나, 형제 선택자는 ‘다음’ 요소만 선택이 가능하다고 한다. 이때 &lt;label&gt;에 :focus-within 선택자를 사용하면 된다. :focus-within 선택자를 부모 요소에 사용하면 내부 자식 요소에 포커스 된 경우까지 잡아준다. 아래는 styled-components로 작성한 예시 1234567const Label = styled.label` // ... &amp;:focus-within { color: ${PALETTE.DEFAULT_BLACK}; }`; TypeScript Record typeobject 형태의 데이터를 다룰 때 사용하는 타입이다. Partial, Pick 등과 마찬가지로 Uitility Type에 속한다.Record&lt;Keys,Type&gt;의 형태로 사용한다. 12345678910111213141516interface CatInfo { age: number; breed: string;}type CatName = &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;const cats: Record&lt;CatName, CatInfo&gt; = { miffy: { age: 10, breed: &quot;Persian&quot; }, boris: { age: 5, breed: &quot;Maine Coon&quot; }, mordred: { age: 16, breed: &quot;British Shorthair&quot; },};cats.boris; const cats: Record&lt;CatName, CatInfo&gt; Ref https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeystype AbortControllerMDN에 따르면, AbortController 인터페이스는 하나 이상의 웹 요청을 취소할 수 있게 해준다. 라고 적혀 있다.인터페이스? JavaScript에서 인터페이스라는 용어를 만난 건 처음인 것 같다. 비동기 요청을 보냈을 때 해당 요청을 취소할 수 있는 툴이 있는 것들과 유사하게,AbortController는 document.querySelector와 같은 DOM 요청을 취소해줄 수 있다. 물론 비동기 요청도 취소가 가능하다. 123456789const abortController = new AbortController(); const signal = abortController.signal;fetch('http://example.com', { signal }) .catch(({ message }) =&gt; { console.log(message); });abortController.abort(); Refhttps://developer.mozilla.org/ko/docs/Web/API/AbortControllerhttps://genie-youn.github.io/journal/자바스크립트에서_AbortController를_활용하여_비동기_작업_중단하기.html optional mapArray가 undefined일 수 있는 상황에 대비하여 Array 자체에 ?로 optional을 붙여줄 수도 있지만, 123let arr = [1,2,3];arr?.push(4); map 메소드를 사용하는 변수가 Array 객체인지 확인하기 위해 map 메소드에도 ?를 붙여줄 수 있다. 123let arr = [1,2,3];arr.map?.((item) =&gt; /* ... */); CSS flexboxdisplay: flex, justify-content: center만 주구장창 쓰지 말고 flexbox 제대로 이해하고 사용하자! Ref https://d2.naver.com/helloworld/8540176 질문하기테스트 코드에 대해 처음 배운 뒤로 시간이 꽤 흘렀습니다. 그동안 여러분 스스로 경험한, 테스트 코드를 작성해야 하는 이유가 있나요?무엇을 테스트해야 할까요? 기타PR을 꾸며주는 익스텐션Ref https://chrome.google.com/webstore/detail/github-writer/diilnnhpcdjhhkjcbdljaonhmhapadap 마무리개인적으로는 정말 울적한 나날들의 연속이다. 데일리 조와 한강 나들이도 너무 즐거웠고, 주말에 루터 등교를 째고(?) 만난 친구들과의 소란스러웠던 만남도 행복했다. 집에 오면 다시 그 시간 만큼의 울적함이 몰려오긴 하는데, 아마 크루들이 없었다면 정말 더 힘들었을 것 같다. 미션도 마지막을 향해 간다. 우테코도 절반이 지나간다.","link":"/2021/05/22/woowa-week-16/"},{"title":"우테코 17-18주차 기록","text":"우아한테크코스 17-18주차 React Testing Library | msw | custom hook 17주차가 상상을 초월할 만큼(?) 너무나 바쁘기도 했고, 18주차는 사실상 해탈하고 몸과 정신이 이미 방학해버렸기 때문에 하나의 포스팅으로 작성한다. 페어 프로그래밍또 열심히 페어를 해봤다. useFetch, useNotify 등의 custom hook도 만들고, redux toolkit도 TypeScript 붙여서 무사히 적용했다. SUBWAY 테마를 이용해서 귀엽게 페이지도 꾸몄다. 마지막 날까지 백엔드 크루들과 정신없이 타임어택 코딩했지만, QA처럼 들어오는 수정사항들에 즉각적으로 코드를 고쳐 재배포하는 것도 나름 굉장한 경험이었다. 3팀을 뽑아 시연하는 날 우리 팀이 뽑혔는데, 크게 오작동 없이 작동해서 다행이었다. 그런데 테스트는 정말 머리가 아프다! 결국 마지막 주말에 뇌절하고 말았다. 테코톡 - 프론트엔드에서 Component란 &amp; 프론트엔드에서의 테스트 종류브랜 &amp; 도비정리 중… 공부하기msw (Mock Server Worker)RTL을 사용하면서 mock server를 사용했다. 12345const server = setupServer( rest.get('/stations', (_, res, ctx) =&gt; { return res(ctx.status(200), ctx.json(stationsData)); }),) 실제 앱에서 보내는 데이터를 가로채서 localhost의 mock server로 보내주는 역할을 한다. 리액트의 대가 Kent C. Dodds 선생님께서도 msw를 권장하고 있다.물론 클라이언트에서 서버로 보내는 요청을 test 단에서 처리하기 위해 12// jest.mockjest.mock('../../utils/api-client') 위처럼 함수를 mocking하거나 123456789101112window.fetch.mockResolvedValueOnce({ ok: true, json: async () =&gt; ({success: true}),});expect(window.fetch).toHaveBeenCalledWith( '/checkout', expect.objectContaining({ method: 'POST', body: JSON.stringify(shoppingCart), }),) 이 같은 방식으로 window.fetch를 mocking할 수도 있다. 그러나 이는 클라이언트 테스트를 위해 매 요청마다 백엔드 서버 자체를 중복으로 건드려야 하는 문제가 있으며, 모든 테스트들을 작은 단위로 나눠서 각각 실행시키기 때문에 통합 테스트의 관점에서도 올바르지 못하다 (사실 정확히 무슨 말인지는 이해하지 못했다 😕) 이때 사용할 수 있는 것이 msw다. msw를 통해 실제 서버에서 돌리는 것처럼 클라이언트의 api 요청을 처리할 수 있다. Node.js의 nock도 비슷한 역할을 하는데, msw는 브라우저 환경에서도 실행 가능한 것이 장점이다. Refhttps://testing-library.com/docs/react-testing-library/example-intro/https://github.com/mswjs/mswhttps://kentcdodds.com/blog/stop-mocking-fetch (TypeScript) 객체타입에서의 두 가지 함수 표기법123456789type ObjType = { foo: () =&gt; void bar(): void}interface ObjInterface { foo: () =&gt; void bar(): void} 함수에 타입을 붙여주는 두 방식은 언뜻 보면 단지 스타일 차이같지만, strict mode를 활성화시키면 명확한 차이가 발생한다. 다음과 같이 Animal 타입과 이를 상속받는 Dog 타입이 존재한다. 123456interface Animal { id: number}interface Dog extends Animal { name: string} 이때 Viewer의 아래 타이핑 방식은 어떻게 동작할까? 123456789interface Viewer&lt;T&gt; { view: (v: T) =&gt; void}declare let animalViewer: Viewer&lt;Animal&gt;declare let dogViewer: Viewer&lt;Dog&gt;dogViewer = animalViewer // OK!animalViewer = dogViewer // Error! (v: T) =&gt; void는 반변한다. dogViewer에 animalViewer를 대입할 경우, Dog을 제공했을 때 모든 Dog은 id를 갖고 있으므로 정상동작한다. 반면 animalViewer에 dogViewer를 대입할 경우, Animal을 제공했을 때 Animal은 Dog이 갖고 있는 name을 갖고 있지 않을 수 있으므로 정상동작을 장담할 수 없다. 그러나 아래와 같은 타이핑은 어떻게 동작할까? 123456789interface Viewer&lt;T&gt; { view(v: T): void}declare let animalViewer: Viewer&lt;Animal&gt;declare let dogViewer: Viewer&lt;Dog&gt;dogViewer = animalViewer // OK!animalViewer = dogViewer // OK..? animalViewer = dogViewer는 성립하지 않아야 하지만 타입 시스템은 아무런 문제도 찾지 못한다. 속성 단축 표기법을 사용할 경우 실제 공변/반변성과는 달리 양변(bivariant) 타입이 된다. strict mode임에도 불구하고 타입 시스템의 안정성을 확보할 수 없는 부분이 생기는 것이다. 그러므로 정말로 양변하는 타입을 의도한 것이 아니라면 항상 화살표 표기법을 사용하는 것이 좋다! Refhttps://sorto.me/posts/2021-03-16+variance useFetch hook오만가지 시도 끝에… useFetch custom hook을 구현해 보았다. 123456789101112131415161718192021222324252627282930type HTTP_METHOD = 'GET' | 'POST' | 'PUT' | 'DELETE';const useFetch = (method: HTTP_METHOD = 'GET') =&gt; { const [loading, setLoading] = useState&lt;boolean&gt;(false); const BASE_URL = useAppSelector((state) =&gt; state.serverSlice.server); const fetchData = async (endpoint: string, data?: unknown) =&gt; { setLoading(true); try { const response = await axios({ method, url: `${BASE_URL}/${endpoint}`, data, }); return { status: API_STATUS.FULFILLED, data: response.data }; } catch (error) { console.error(error); return { status: API_STATUS.REJECTED, message: error.response?.data.message || ALERT_MESSAGE.SERVER_ERROR, }; } finally { setLoading(false); } }; return [fetchData, loading] as const;}; 대부분의 useFetch hook은 GET 요청일 때를 default로 구현이 되어 있다. 컴포넌트의 초기 마운트 시 데이터를 요청해오는 형태가 일반적이기 때문에 hook 메서드 내부에서 useEffect 호출을 통해 데이터를 fetch해 오는데, POST와 PUT, 그리고 DELETE까지 CRUD를 모두 다 쓰는 앱에서는 어쩔 수 없이 data를 fetch해오는 함수 (fetchData) 자체를 리턴해줘야 했다. 그리고 리턴타입을 객체가 아닌 배열로 하여 쓰고 싶은데, TypeScript 린트가 계속 해결할 수 없는 에러를 뱉어서 이런저런 시도 끝에 as const를 붙여줬다. 참조타입인 객체 또는 배열은 속성값이 언제든 변경될 수 있는 위험 때문에, 타입 추론의 범위를 좁혀주기 위해 const assertion을 사용해야 하는 것 같다. const assertion을 해준 객체의 프로퍼티 또는 배열의 원소들은 모두 readonly로 변경된다. (중첩된 경우에도 모두 readonly가 적용된다고 한다!) 리뷰어님께서 알려주신 use-http의 useFetch에는 상당히 많은 http 관련 hook들이 있다.cache와 interceptor, persist와 abort, suspense 등 http 요청의 부가적인 기능들까지 수행할 수 있는 나만의 custom hook을 만들어보는 것도 재밌을 것 같다! Refhttps://medium.com/@seungha_kim_IT/typescript-3-4-const-assertion-b50a749dd53bhttps://velog.io/@logqwerty/Enum-vs-as-const 알아보기NavLinknavigation bar를 구현할 때 사용했다. Route를 구현할 때, 현재 matching된 URL에 해당한 링크만 하이라이팅해줄 수 있다. 12345678910const NavBar = () =&gt; { return ( &lt;NavLink to={ROUTE.LOGIN} activeStyle={selectedNavStyle}&gt; &lt;Styled.NavItem&gt;로그인&lt;/Styled.NavItem&gt; &lt;/NavLink&gt; &lt;NavLink to={ROUTE.SIGNUP} activeStyle={selectedNavStyle}&gt; &lt;Styled.NavItem&gt;회원가입&lt;/Styled.NavItem&gt; &lt;/NavLink&gt; )} Ref https://reactrouter.com/web/api/NavLink 기타실용적인 프론트엔드 테스트 전략Refhttps://www.youtube.com/watch?v=q9d631Nl0_4&amp;t=1595s 프론트엔드에서 우아하게 비동기 처리하기Ref React Concurrent Mode useTransition useDeferredValuehttps://www.youtube.com/watch?v=FvRtoViujGg 웹 브라우저의 렌더링 프로세스와 웹 성능 최적화Ref https://cresumerjang.github.io/2019/06/24/critical-rendering-path/ 기타 테스트 도구들react-hook-test-libraryhttps://react-hooks-testing-library.com/ redux-saga-test-planhttps://www.npmjs.com/package/redux-saga-test-plan React Hooks: What’s going to happen to my tests?Ref https://kentcdodds.com/blog/react-hooks-whats-going-to-happen-to-my-tests 마무리일단 React Testing Library가 너무나도 어렵다… 🤯하다보면 정말 재미가 없고, 돌아가지도 않고, 개발을 포기하고 싶어지기까지 한다!그치만 뭐 별 수 있나 계속 해야지 😑 마냥 재밌기만 한 일은 없는 것 같다. 코치 공원과 면담을 했다. 사실상 면담이 아닌 만담이었지만.정말 내 주변엔 내가 기댈 수 있는 좋은 사람들이 많이 있다는 것을 알았다. 많이 고맙다.지칠 때도 있겠지만, 모두가 똑같을 것이다. 모두 누군가의 도움을 필요로 할 것이고, 서로 도와주면서 버텨내는 것이다. 나도 누군가에게 힘이 되어줄 수도 있을까? 리뷰어이자 배민 FE 개발자이신 Vallista님과도 식사를 했다.온통 모르는 이야기들이 많이 나와서 조금 어질어질했지만,단순한 비즈니스 관계가 아니라 정말 우리에게 많은 도움을 주시고자 신경 써주신다는 점을 느낄 수 있었다.그리고 개인적으로는 정말 대단하신 분이다. 누가 봐도 대단한 사람.나만의 엣지를 갖춘 개발자가 되자, 지그!","link":"/2021/06/05/woowa-week-17/"},{"title":"우테코 21주차 기록","text":"우아한테크코스 21주차 19, 20주차는 우테코의 가장 긴 방학이었다. 못 만났던 친구들도 많이 만나서 정말 원없이 알차게 놀고, 잦은 음주🍻 로 가득했던 2주였다. 그래도 학습로그도 작성하고, React 공식 문서와 TypeScript handbook, UX 강의 시청과 코어 자바스크립트 완독까지 마무리했다. 아마 React Query도 공부했을 걸? 방학의 끄트머리 여행까지 다녀온 후 기획안과 모의면접 준비까지 열심히 달렸다! 모의면접 - 헷갈렸어요런타임 vs 컴파일 vs 트랜스파일 런타임: 컴파일 과정을 마친 프로그램이 사용자에 의해 실행될때의 환경 또는 시간 JavaScript의 런타임: 브라우저, Node.js 컴파일: 한 언어로 작성된 소스코드를 다른 언어로 변환하는 것. 프로그램을 위한 소스코드를 작성하고 이를 컴파일 하여 기계어코드로 변환하는 일련의 과정 Java → bytecode C → assembly 트랜스파일: 한언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것 ES6 → ES6 C++ → C coffeescript → javascript 👾 TypeScript가 JavaScript로 변환되는 것은 비슷한 수준의 추상화라는 점에서 트랜스파일링이라고 하기도 하지만, 이 역시 컴파일로 통칭해서 사용하는 것이 일반적이다. Refhttps://ideveloper2.tistory.com/166https://zunoxi.github.io/programming/2021/03/10/dev-web-runtime/ JS 콜백 특정 조건일 때 해당 함수를 실행하라고 알려주는 것 콜백 함수를 다른 함수의 인자로 전달할 때 그 제어권도 함께 위임한다. JS callback &amp; Promise callback - 다른 함수의 실행이 끝나면 실행되는 함수 함수 실행 순서를 조정하기 위해 사용 너무 많은 흐름, callback hell이 탄생할 수 있음 Promise - 비동기 callback 실행 시 반환되는 객체 task가 성공적으로 수행된 이후 .then()에 callback을 붙일 수 있음 task가 실패했다면 .catch() → 둘 다 비동기를 만들어준다는 점에서는 동일하다! Refhttps://dev.to/neisha1618/callbacks-vs-promises-4mi1 JS promise vs generator Generator의 제어권을 Promise에게 넘긴다. yield를 호출해 멈춘 Generator을 Promise가 제어하도록 하는 것이다. generator는 비동기적 구현을 동기적 구현으로 추상화시킬 수 있다. 즉 동기적으로 작동하는 것처럼 코드를 작성할 수 있다. Refhttps://suhwan.dev/2018/04/18/JS-async-programming-with-promise-and-generator/ 리듀서는 왜 순수함수여야할까 state를 직접 변경하는 것은 순수하지 않은 동작이다. 순수함수는 같은 input에 대해 반환되는 값이 항상 일정하리라고 보장되는 함수를 의미한다.1const add = (a, b) =&gt; a + b //pure function 함수 내 변수 외에 외부의 값을 참조, 의존하거나 변경하지 않아야 한다. state의 불변성을 유지하라는 뜻으로 생각할 수 있다. state가 불변성을 유지해야 하는 이유는, redux는 참조값으로 상태 변화를 감지하기 때문이다. 참조값이 아닌, 원시값 자체를 비교하기 위한 deep copy는 연산 비용이 너무 크기 때문이다. Refhttps://www.freecodecamp.org/news/why-redux-needs-reducers-to-be-pure-functions-d438c58ae468/ 모의면접 - 피드백 면접관이 피면접자가 맘에 들어서 질문을 끌어내는 경우는 좋은 신호 장황하게 답변시 면접관이 끊으면 안 좋은 신호 면접관과 호흡 맞추기, 핑퐁이 되어야 한다. 흐름이 중요하다. 운이 좋으면 실력이 없어도 흐름 잘타서 면접이 잘 끝날수도 있다. 운이 안 좋아 꼬투리를 잡히면 안타깝다. 지그는 회피 스킬을 잘 쓰긴 하는데 너무 많이 회피하진 말자. 흐름을 빠르게 바꾸자! “잘 모르겠지만”으로 시작하지 말자. 도치법, 두괄식으로 답변하자. 그런데 장황한 사람들이 하면 큰일난다. 길을 잃어요! 면접관도 길을 잃어요. 블로그를 잘 쓰자. 뭘 쓰든 다 따라올 수밖에 없다 “~ 이렇게 알고 있다.”는 금물. 아는 게 아는 게 아니다. 내재화된 자신만의 해석을 얘기해주는 것이 좋다. Refhttps://www.youtube.com/watch?v=gXfEE6v5bSI 기타프론트엔드에서 TDD가 가능하다는 것 - FE CONF 2020Refhttps://www.youtube.com/watch?v=L1dtkLeIz-M 마무리Lv3 시작 일주차, 아직도 제대로 코딩을 시작한 건 없고 뭔가 흐름을 놓친 기분이다. 어디까지 워라밸을 챙겨야 하는 건지 모르겠다. Life가 Work를 압도할 지경이다. 나 자신을 챙기겠다는 건강한 마인드가 이제는 조금 핑계가 되어가는 것 같다. Lv3 시작과 동시에 다시 정신 차리겠다고 했는데, 지난 한 주도 애매하게 보냈다. 비교하지는 않으려고 하는데, 아무래도 십 수년의 습관이 남아있나 보다. 슬슬 불안감이 찾아온다. 불안감을 없애는 방법은 나 자신을 다시 단련하는 방법밖에 없을 것 같다. 충분히 잘 쉬고 놀았으니 다시 몰두하기! 이제 진짜 시작될 팀매칭도 기대된다. 주제들도 흥미롭고, 어떤 팀원과 함께하게 될지 궁금하다. 팀이 벌써 매칭되는 꿈까지 꿔버렸다. 역시나 이상한 내용들이 섞여 있는 어질어질한 꿈이었지만… 어떤 팀이 되든, 어떤 프로젝트가 걸리든 멋진 크루들과 함께 신나게 달려가 보고 싶다.","link":"/2021/06/26/woowa-week-21/"},{"title":"우테코 23주차 기록","text":"우아한테크코스 23주차Git, Github 활용하기 | React App에서 svg 다루기 | babelrc vs webpack 놀토 프로젝트API 설계백엔드 크루들과 API 명세를 함께 짰다. 스키마, api 등 각자 사용하는 명칭이 다르기도 했고, 세부적인 기능들의 request url을 query parameter(/recent?filter=progress)로 할 것인지 path variable(recent/progress)로 할 것인지에 대한 의견도 조금씩 갈렸다. 역시 같은 프로젝트를 한다고 해도 머릿속에 그리는 내용은 조금씩 다르다. 이래서 페어 프로그래밍, 협업의 과정이 정말 중요한 것 같다. 그래도 팀원들 모두 열정적이고 화기애애해서 합이 잘 맞아가는 것 같아 재미있다! 그밖에는 UI 틀을 어느 정도 잡고 프론트엔드 작업에 들어갔다.github의 신기한 기능들을 접하면서 개발을 하니 정말 일하는 기분도 들고 설렌다. Git Flow우아한 형제들 기술 블로그를 참조하여 우리 팀만의 Git Flow를 정했다. upstream/main - 완전한 프로덕트가 배포될 브랜치 upstream/develop - 실제 개발이 이루어지는 브랜치 upstream/release - release-1.0.0과 같은 버전들로 구분한다. 특정 시점에 정해진 기능들을 하나의 단위로 모아 배포하기 위한 목적으로 분리하였다. origin/feature/~~~end/XXX - frontend, backend로 구분한다. 팀원들이 각자 fork한 자신의 레포지토리(origin)에 브랜치를 따서 맡은 기능을 작업한다. 작업 후에는 develop으로 PR을 보낸다. origin/hotfix/~~~end/XXX - frontend, backend로 구분한다. 버그가 생겼을 때 빠르게 수정한 후 main과 develop 브랜치로 merge한다. Refhttps://techblog.woowahan.com/2553/ 프론트엔드 공부.babelrc와 webpack.config🍀 여기서 읽기 CRA 없이 svg를 React component로 사용하기🍀 여기서 읽기 공부하기PR, ISSUE 템플릿 등록하기PR과 ISSUE를 등록할 때 사용할 템플릿을 미리 만들어둘 수 있다.지금은 아래와 같이 3가지 템플릿으로 분리해 두었다. Refhttps://soft.plusblog.co.kr/66 CSS box-shadow vs filter: drop-shadowCSS의 box-shadow 속성은 요소의 테두리를 감싼 그림자 효과를 추가한다. 1234export const Card = styled.div` box-shadow: 4px 4px 8px 4px rgba(85, 85, 85, 0.2); // ...`; 아무래도 ‘그림자’인만큼 빛이 투과하는 방향 한쪽으로만 shadow가 생긴다.반대 대각선 방향으로도 shadow를 번지게 하고 싶다면 확산 정도를 나타내는 blur 옵션(4번째 인자)을 줄 수 있지만, 뭔가 불충분한 느낌이었다. 이때 우연히 filter: drop-shadow 속성을 발견했다! CSS filter 속성은 흐림 효과나 색상 변형 등 그래픽 효과를 요소에 적용한다. 1234const Root = styled.form` // ... filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.25));`; 위와 같이 요소의 모든 stroke에 흐림 효과를 줄 수 있다. Refhttps://developer.mozilla.org/ko/docs/Web/CSS/box-shadowhttps://developer.mozilla.org/ko/docs/Web/CSS/filter storybook에서 절대경로 importReact App에서 컴포넌트드를 import할 때, 점이 많이 생기는 게 싫어서 절대경로로 import하는 것을 선호한다. 절대경로 import를 위해 tsconfig.json에서 baseUrl을 아래와 같이 설정했다. 1234567// tsconfig.json{ &quot;compilerOptions&quot;: { // ... &quot;baseUrl&quot;: &quot;src&quot; },} 그런데 storybook에서는 절대경로 import가 먹히지 않는다! TypeScript 탓일까, storybook에서도 webpack 설정을 따로 해줘야 했다..storybook/webpack.config.js에 만들어줄 수도 있지만, .storybook/main.js의 webpackFinal에 config를 추가해주는 방법도 있다. 프로젝트에서 TypeScript를 사용할 때 alias(단축경로)를 쓰려면 tsconfig.json과 webpack.config.js 두 곳에 모두 설정을 추가해줘야 하는데, tsconfig-paths-webpack-plugin를 이용하여 간단히 해결할 수 있다. 1yarn add -D tsconfig-paths-webpack-plugin 123456789// .storybook/main.jsconst TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin')module.exports = { webpackFinal: async (config) =&gt; { config.resolve.plugins.push(new TsconfigPathsPlugin({})); return config; },}; Refhttps://bugtypekr.tistory.com/84 Context Provider는 실제 DOM element일까?React에서 Context로 감싼 요소는 실제 DOM element인지 궁금해졌다. (아닐 것 같지만) 123456789const ThemeContext = React.createContext('light');const App = () =&gt; { return ( &lt;ThemeContext.Provider value=&quot;dark&quot;&gt; &lt;div&gt;안녕하세요!&lt;/div&gt; &lt;/ThemeContext.Provider&gt; );}; 역시 실제 DOM에 렌더링되는 것은 아니었다. React devtools에서는 확인 가능하다. extends HTMLAttributesTypeScript를 이용하여 React App 개발 시, 컴포넌트에 들어갈 Props를 extends해서 사용할 수 있다. 특히 button과 같은 특정 목적을 가지는 컴포넌트의 경우 해당하는 html 태그의 기본 속성들을 확장해서 사용하면 유용하다. 12345interface Props extends ButtonHTMLAttributes&lt;HTMLButtonElement&gt; { buttonStyle: ButtonStyle; reverse?: boolean; children: React.ReactNode;} ButtonHTMLAttributes는 아래와 같은 interface로 정의되어 있다. &lt;button&gt; 태그가 가질 수 있는 속성들이 optional로 나열되어 있다. &lt;T&gt; 자리에 알맞은 제네릭을 넣어주면 된다. 12345678910111213interface ButtonHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt; { autoFocus?: boolean; disabled?: boolean; form?: string; formAction?: string; formEncType?: string; formMethod?: string; formNoValidate?: boolean; formTarget?: string; name?: string; type?: 'submit' | 'reset' | 'button'; value?: string | ReadonlyArray&lt;string&gt; | number; } storybook의 Controls와 Actionsstorybook의 Controls 패널에서는 GUI로 컴포넌트의 인자들을 변경할 수 있다. 기본적으로 컴포넌트의 props 값들이 Controls 패널에 표시된다. 12345const Toggle = ({ labelText = '', checked = false, onChange }: Props) =&gt; { return ( // ... );}; 위 컴포넌트에는 props로 내려받는 labelText, checked, onChange 3개의 값이 들어간다. Actions에서는 이벤트 핸들러 콜백이 실행될 때의 데이터를 보여준다. 12345export default { title: 'components/common/Toggle', component: Toggle, argTypes: { onClick: { action: 'toggled' } },}; 이렇게 해주거나, 아래처럼 on으로 시작하는 모든 action들을 감지하게끔 작성해 준다. 12345export default { title: 'components/common/Toggle', component: Toggle, parameters: { actions: { argTypesRegex: '^on.*' } },}; 또는 .storybook/preview.js에 미리 parameters를 등록해줄 수도 있다. 123456789export const parameters = { actions: { argTypesRegex: '^on[A-Z].*' }, controls: { matchers: { color: /(background|color)$/i, date: /Date$/, }, },}; Refhttps://storybook.js.org/docs/riot/essentials/controlshttps://storybook.js.org/docs/riot/essentials/actions etc모바일에서 localhost 환경 구성하기우테코 크루의 정리글 Refhttps://chinsun9.github.io/2021/07/01/remote-debug-android-chrome/ useMemo, useCallback은 언제 써야하는가?Refhttps://haragoo30.medium.com/usememo-usecallback을-언제-써야되나-6a5e6f30f759 마무리UI를 어느 정도 마무리 짓고 프론트엔드 개발에 들어갔다.우리 팀만의 git flow도 정하고 github도 이것저것 설정하고 나니 정말 일하는 기분이 든다.아직 시작 단계라 몰아치는 게(?) 많은데, 페이스를 잃지 않고 끝까지 무사히 완주했으면 좋겠다!","link":"/2021/07/11/woowa-week-23/"},{"title":"우테코 22주차 기록","text":"우아한테크코스 22주차 팀매칭1순위로 지원했던 아마찌의 &lt;모두의 토이 프로젝트&gt; 팀에 배정되었다. 프론트 크루는 미키와 함께하게 되었다. 같이 해본 적은 없지만 기대되는 크루다. 백엔드 크루들과도 재미있게 합이 잘 맞는 느낌이다. UI 디자인끝없는 figma 작업 중… 디자인 해본 적 없는데 괜히 해야할 것 같은 느낌에 이것저것 해보고 있다. 마무리이번주는 정말 코딩을 안했다. 텅 비어버린 깃허브 잔디…근데 코테 보고 너무 감을 많이 잃어서 급현타가 왔다. 그리고 이제 정말 바빠질 것 같다.이제 UI 그만하고 코딩해야지","link":"/2021/07/04/woowa-week-22/"},{"title":"우테코 24주차 기록","text":"우아한테크코스 24주차 놀토 프로젝트이미지 처리백엔드와 사진 데이터를 어떻게 보내고 받을 것인지 많은 논의가 있었다. 결국 JSON 형식 대신 form-data 형식으로 body를 전송하기로 했다. 잘 저장되고, 잘 받아지고 있다! 아무래도 백엔드 인원이 많고, API가 빨리빨리 처리되다 보니 프론트엔드 측에서 살짝씩 밀리고 있었어서 조금 부담감과 긴장감이 생겼다. recoil? react query? react query 완전 fancy하고 편리하다. 사용하자 (지그) 우리 앱은 서버와의 즉각적인 통신이 필요하지 않을 것 같으니 recoil로도 충분하다 (미키) react query 완전 편리한 것 같다. 상태관리할 데이터도 딱히 없을 것 같다. (미키) 포코가 상태관리 나중에 하면 힘들어질 거라고 했다. 다른 크루들도 사용할 때 recoil을 사용해보는 게 좋겠다. (지그) recoil 너무 복잡하다. 더군다나 cache된 데이터만 가져오고, 서버에서 신규 데이터를 가져오는 과정이 복잡하다. (미키) 결론: react-query 쓰자! 🙆‍♂️🙆‍♀️ 프론트엔드 공부&lt;input type=&quot;file&quot; /&gt; 다루는 법🍀 여기서 읽기 왜 forwardRef를 사용할까?🍀 여기서 읽기 TypeScript의 index signature🍀 여기서 읽기 ModalProvider 만들기🍀 여기서 읽기 공부하기historyApiFallbackreact-router-dom의 Link를 통해 페이지를 라우팅하면 문제없이 동작하지만, 직접 주소창에 /upload 등을 입력하여 접속하거나 새로고침을 하면 404 에러가 발생한다. 특정 주소로 바로 접속 시 서버 쪽 라우터에서 먼저 연결할 곳이 있는지 확인하는데, /upload와 같은 URL 엔드포인트는 서버쪽 라우터가 아닌 react-router로 동작하는 SPA 라우터기 때문이다. historyApiFallback 옵션을 켜서 문제를 해결할 수 있다. history API를 사용하는 SPA에서, historyApiFallback을 사용하면 404 에러 발생 시 index.html로 리다이렉트 해준다. 12345// webpack.config.jsdevServer: { // ... historyApiFallback: true,}, Refhttps://velog.io/@yhe228/주소창에-url-직접-입력시-라우팅-안되는-이슈https://velopert.com/1173https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback router 내부 페이지에서 reload 시 페이지가 날아가 버리는 경우webpack은 기본적으로 output에 설정해둔 경로(default는 /)에서 번들링된 파일(bundle.js)를 가져오려고 한다. 페이지 reload 시 기본적으로 서버에 해당 주소로 요청이 가는데, 상기했듯 SPA에서 서버는 주소에 해당하는 페이지를 가지고 있지 않다. 이러한 요청은 react-router가 클라이언트 단에서 처리하여, 어떤 JavaScript를 렌더링할지 결정한다. 따라서 서버가 특정 주소로의 접근을 이해할 수 있도록 만들어줘야 한다. 서버(devServer)와 클라이언트(output)의 route를 동일하게 맞춰줌으로써 문제를 해결할 수 있다. webpack 설정을 통해 번들링된 파일을 항상 같은 곳에서 가져올 수 있도록 수정한다. 123456789// webpack.config.jsoutput: { // ... publicPath: '/',},devServer: { // ... publicPath: '/',}, Refhttps://stackoverflow.com/questions/54786191/react-router-not-working-when-url-contains-multiple-pathshttps://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writing-manuallyhttps://webpack.js.org/configuration/dev-server/#devserverpublicpath- etc웹 접근성 참고자료 https://sungdoo.dev/programming/accessibility-is-not-about-supporting-blind-people/ https://sungdoo.dev/retrospective-or-psa/how-accessibility-nudges-you-to-be-better-developer/ https://onwah.tistory.com/m/24 Naver NULI 레진코믹스 WAI-ARIA 프론트엔드 엔지니어 vs 웹 퍼블리셔 https://hyeonseok.com/blog/396 https://hyeonseok.com/blog/657 클래스101의 디자인 시스템 크롬 개발자도구의 소소한 기능들 https://www.youtube.com/watch?v=toXJLUa7i0Y vscode에서 api를 테스트해주는 익스텐션 https://www.thunderclient.io/ github learning lab https://lab.github.com/ 마무리두 번째 코로나 검사 받았다 😷 아팠다. 리팩토링할 일들이 쌓여간다…평일 6시 퇴근이라는 유토피아를 살아가는 팀은 없었다. 다들 누가 더 오래 버티나 내기 중. 그래도 정말 갈수록 재미있어지는 것 같다.","link":"/2021/07/18/woowa-week-24/"},{"title":"우테코 25주차 기록","text":"우아한테크코스 25주차 놀토 프로젝트데모데이 2차 발표데모데이 2차 발표를 무사히(?) 마쳤다. 마지막에 프론트엔드의 어뷰징 크루 덕분에 웃긴 사진이 올라가서 웃음이 터져버렸지만… 😂 다른 모든 팀들도 각양각색의 매력을 뽐냈다. 다들 OAauth부터 구현을 많이 한 것 같았고, 모바일 기반으로 프로젝트를 만든 팀이 더 많았다. 그리고 개발자들끼리 모였다고 해도 UI적인 요소를 빼고 볼 수는 없는 것 같다. 그래도 아직 2주밖에 지나지 않아서 그런지 조금씩 미완성된 느낌을 주는 팀들도 있었다. 물론 우리 팀도! 서로 좋은 피드백을 주고받고, 우리도 다른 팀들에서 사용한 좋아보이는 기술이나 팀 문화들을 조금씩 적용해보기로 했다. UTUT는 Usability Test, 사용성 테스트를 의미한다. 제품을 사용자에게 테스트하여 평가하기 위해 사용자 중심 상호 작용 디자인에 사용되는 기술로, 서비스의 정식 런칭 전에 사용자들이 우리 서비스를 얼마나 잘 사용할 수 있는지 테스트해보기 위해 실행했다. 사실은 기능 구현하느라 정신없이 바쁜 와중에 UT를 해야 한다니! 부담도 크고 ‘굳이?’하는 생각도 들었지만, 가볍게 시작해보기로 했다. 한번 UT를 해본 프론트엔드 크루들이 진행하고 백엔드 크루들은 관찰기록을 해주었는데, UT 마무리 후에는 모두 아주 좋았다는 평가를 했다. 생각보다 훨씬 많은 것을 얻었기 때문이다! 구체적으로 깨달은 내용들은 다음과 같다. 사용자가 서비스를 잘 파악하기 위해서는 기존 더미 데이터의 양식(질)도 중요하다. 우리가 잘 알고 있다고 생각한 서비스의 컨셉과 용어들이 사용자에게는 낯설게 느껴질 수 있다. 입력 폼의 인풋 라벨만 가지고는 무엇을 작성해야 할지 알기 어렵다. 생각보다 더 친절하게 설명해줘야 한다. (툴팁 등을 활용해도 좋다.) UI로 콘텐츠의 영역을 명확히 구분하자. ‘마이페이지’가 있으면 좋겠다. 좋은 피드백들을 많이 받을 수 있었고, 이후에 서비스가 조금 더 갖춰지면 자체적으로 한번 더 UT를 진행하기로 했다. OAuth구글, 깃헙 2가지 방식으로 OAuth를 구현했다. OAuth를 제공하는 곳에 어플리케이션을 등록한다. 사용자가 로그인을 누르면, 등록한 어플리케이션의 client_id와 redirect_uri를 담아 OAuth 요청을 보낸다. code가 포함된 url로 이동하게 된다. 해당 code를 params에 담아 다시 요청을 보낸다. 응답에 accessToken이 담겨 오는데, 이를 사용하여 사용자의 로그인 정보를 저장하면 된다. 이때 client_id가 프론트 코드에 노출되어도 되는지에 대한 불안감과 처음에 시도했던 깃헙은 어플리케이션 당 redirect_uri를 1개밖에 설정할 수 없다는 문제 로 인해 대부분의 과정은 백엔드에서 대신 처리해주기로 했다.dev와 prod 모드로 어플리케이션 자체를 2개 등록해서, 프론트의 요청에 따라 redirect_uri를 놀토 프로젝트 서버에서 알아서 처리해준다. accessToken까지 놀토 서버에서 보내주고 있다. 다만 code를 포함한 url 페이지로 진입 시 code를 얻고 다시 프로젝트 페이지로 돌아가야 하는 상황이라, OAuth를 위한 페이지 컴포넌트를 따로 만들어준 점은 조금 아쉽다. 그래도 기존의 그냥 흰 화면이 아닌, 커스텀한 로딩 화면을 띄울 수 있다는 점은 좋을지도? 문제가 많았던 깃헙을 한번 겪고 나니, 구글은 바로 뚝딱 진행되었다! 프론트엔드 공부react query에서 debounce 사용하기🍀 여기서 읽기 Error Boundary와 Suspense🍀 여기서 읽기 공부하기&lt;p&gt; 대신 &lt;pre&gt; 태그&lt;p&gt; 태그를 사용하여 피드의 본문을 보여주니 입력한 문자열의 개행을 구분하지 않고 보여준다는 버그가 있었다. 이때 &lt;pre&gt; 태그를 사용하여 여러 줄의 문자열 개행을 구분할 수 있다.‘preformatted text’라는 뜻으로, 입력한 문자를 그대로 보여준다. copy-webpack-plugin특정 폴더에 있는 (혹은 그 폴더 자체를) 다른 폴더로 복사해준다.netlify 배포 시 redirect 설정을 위해 public 폴더 내에 _redirect 파일을 작성해주었는데, 번들링 결과물인 dist 폴더에는 적용되지 않는다는 문제가 있었다. 이때 redirect 해줄 파일을 public 폴더에서 dist 폴더로 그대로 복사해서 넣기 위해 copy-webpack-plugin을 사용했다. 123456789101112// webpack.config.jsconst CopyPlugin = require('copy-webpack-plugin');module.exports = { // ... plugins: [ // ... new CopyPlugin({ patterns: [path.resolve(__dirname, 'public', '_redirects')], }), ]} 원래는 아래와 같이 작성해주어야 하지만, 1234patterns: [ { from: &quot;source&quot;, to: &quot;dest&quot; }, { from: &quot;other&quot;, to: &quot;public&quot; },], 따로 path를 지정해주지 않는 경우 webpack의 output으로 지정한 (여기서는 dist) 곳으로 알아서 옮겨준다. Refhttps://webpack.js.org/plugins/copy-webpack-plugin/ Array의 신기한 점12Array(3); // [&lt;3 empty items&gt;][...Array(3)]; // [undefined, undefined, undefined] setState에 callback을 저장할 때 왜 호출이 될까?함수 컴포넌트의 useState에 콜백함수를 저장해주고 싶었는데, setState로 콜백함수 등록 시 해당 콜백함수가 저장되는 것이 아닌 바로 호출되어 버리는 문제가 있었다. 이는 setState의 인자로 함수를 넘기는 것으로 인지하기 때문이었다! 무슨 의미냐 하면, setState는 상태를 업데이트할 수 있는 방법이 2가지 있다. 12setState(nextState);setState((prevState) =&gt; { ...prevState, nextState }); 이런 상황에서 () =&gt; console.log('callback!')과 같은 함수를 callback이라는 변수에 담아 새로운 state로 등록하면, 12setState(callback); // 이렇게 작성하면setState(() =&gt; console.log('callback!')); // 이렇게 인지하여 바로 실행한다! 그렇기 때문에 1setState(() =&gt; callback); 위와 같이 작성해주어야 올바르게 상태로 저장이 가능하다. 깨닫기까지 상당히 오랜 시간이 걸렸다 😵 Refhttps://dev.to/sarioglu/how-to-store-a-function-using-react-usestate-4ffh useMemo로 Context Api Provider 최적화프로젝트에서 modal, snackbar, alert 등을 사용하기 위해 여기저기서 context api를 사용하고 있다.🍀 참고 - ModalProvider 만들기 각 provider가 생성하는 openModal 등의 메서드를 현재 컴포넌트가 리턴하는 jsx에 인라인으로 넣어주고 있어서 호출할 때마다 새로운 객체를 만들고 있다. context provider value의 참조값이 바뀌어 자식 컴포넌트들에서 매번 리렌더링되고 있었던 것이다! 😱 이때 provider 내부에서 메서드들을 useMemo로 감싸주어, 자식 컴포넌트에서 사용하는 provider 메서드를 매번 새로 만드는 것을 방지할 수 있다. (편안…) 1234567891011121314151617181920212223242526272829const ModalProvider = ({ children }: Props) =&gt; { const [modal, setModal] = useState&lt;ReactNode | null&gt;(null); const [isOpen, setIsOpen] = useState(false); const openModal = (modalComponent: ReactNode) =&gt; { // ... }; const closeModal = () =&gt; { // ... }; const modalElement: React.ReactNode = ( &lt;Styled.ModalContainer onMouseDown={handleClickDimmed}&gt; // ... &lt;/Styled.ModalContainer&gt; ); // useMemo로 최적화 const contextValue = useMemo(() =&gt; ({ openModal, closeModal }), []); return ( &lt;Context.Provider value={contextValue}&gt; {children} {isOpen &amp;&amp; ReactDOM.createPortal(modalElement, modalRoot)} &lt;/Context.Provider&gt; );}; etcvscode에서 api 테스트하기 https://www.thunderclient.io/ github lab https://lab.github.com/ webpack에서 path 리다이렉트가 안 된다면?path의 depth가 깊어질 때 (예: some/many/:id) 리다이렉트가 잘 안되는 문제가 있다면, HtmlWebpackPlugin에서 base를 설정하면 된다. PR 리뷰 시 checkout하기 귀찮다면?Github 공식 CLI를 사용하자! 이런저런 기능들이 많다. https://blog.outsider.ne.kr/1498 마무리팀원들은 예상했던 것보다 훨씬 꿈이 큰 걸지도 모른다는 생각이 들었다. 기존 서비스들에서 좋아보이는 여러 기능들을 벤치마킹해서 우리 프로젝트에 적용하고 싶어한다. 물론 다 좋지만, 시간 내에 구현하기는 절대 어려워 보인다. (특히 2명밖에 없는 프론트엔드에서는 더욱…) 내가 너무 현실적인 S형 사람이라 그런가? 보수적인 입장으로 아이디어를 많이 보류하자고 의견을 냈는데, 다들 어떻게 생각할지 궁금하다. Lv3 내에 어느 정도 완성된 기능을 보여주자는 생각을 하는 사람도 있을 것이고, Lv4까지 가져가더라도 하고싶은 것 다 해보는 게 우선이라고 생각하는 사람도 있을 것이다. 다 맞는 의견이다. 같은 프로젝트를 하더라도 같은 시간 안에서 목표를 어떻게 잡는지에 따라 상상하는 우리 프로젝트의 모습이 달라질 것이다. 그렇게 이번주는 회의가 많았고, 마지막 평일 밤 놀토 팀 (랜선) 회식을 했다! 소소한 이야기들도 하고, 꿀잼이었던 라이어 게임도 했다. 거리두기 4단계 2주 연장이라니… 언제쯤 팀원들을 볼 수 있을까? 같이 오프라인으로 만나서 이야기하며 더욱 가까워지고 싶은 마음이다. 그러면 더 코딩이 재밌어질 텐데! 코딩이 재미 없다는 건 아니다. 하루하루 이게 사람 사는 건가 싶을 정도로, 말 그대로 눈 뜨자마자 노트북 앞에 앉아서 잠들기 직전까지 코딩하고 있지만 아주 괜찮은 편이다. 내일은 또 어떤 기능을 구현할지, 어떤 새로운 챌린징한 이슈가 기다리고 있을지 설레기까지(!) 한다. 코다(코딩 다이어트)를 하고 있는 건지 살이 계속 빠지고 있지만, 운동도 꾸준히 하면서 체력을 유지해나가고 있다. 잠만 조금 더 일찍 자면 좋을 것 같다 🛌","link":"/2021/07/25/woowa-week-25/"},{"title":"우테코 26주차 기록","text":"우아한테크코스 26주차 놀토 프로젝트AWS 이전고마운 배겐 팀원들 덕에 무사히(!) 프론트 서버 AWS 이전에 성공했다. 젠킨스도 연동하고. 아직 알 수 없는 내용 투성이지만 어느 정도 개념은 잡혀간다. 더보기 시멘틱 버저닝3차 데모데이 이전 v2.0.1 배포 완료! 더보기 테스트미키와 열띤 논의 끝에 작은 단위에서부터 bottom-up 방식으로 유닛 테스트를 진행하기로 했다. react-query hook을 테스트해줄 react-hooks-testing-library와 지난 지하철 미션 나를 그토록 괴롭혔던 msw도 사용하게 되었다. 더보기 아직 컴포넌트 단위의 테스트는 시작하지 못했는데, 걱정이 조금 되기도 한다. 😩 프론트엔드 공부TypeScript type guard🍀 여기서 읽기 react hook test🍀 여기서 읽기 공부하기flex-basisflex-basis는 flex 아이템의 기본 크기를 설정한다. flex-basis에는 width, height에 들어갈 수 있는 단위들을 입력하거나 컨텐츠의 크기에 맞게 조절되는 값을 넣어줄 수 있다. 123456789101112.item { flex-basis: 10em; flex-basis: 3px; flex-basis: auto; /* 원본 크기 키워드 */ flex-basis: fill; flex-basis: max-content; flex-basis: min-content; flex-basis: fit-content;} flex-grow는 아이템이 flex-basis의 값보다 커질 수 있는지를 결정하는 속성이다. flex-grow의 값이 0보다 크다면 해당 아이템은 원래의 크기보다 커져 flex container의 나머지 빈 공간을 채우게 된다. (flex-basis가 0일 때, flex-grow는 flex 값과 같다.) flexbox 내 아이템의 width와 flex-grow 속성을 통해 flexbox에 꽉 차는 화면을 구성할 수 있다. flex-shrink는 아이템이 flex-basis의 값보다 작아질 수 있는지를 결정한다. flex-shrink의 값이 0보다 크다면 해당 아이템은 flex-basis보다 작아진다. flex-shrink의 값을 0으로 설정하면 아이템의 크기가 flex-basis보다 작아지지 않기 때문에 고정폭의 컬럼을 쉽게 만들 수 있다. (고정 크기는 width로 설정한다.) flexbox 내 아이템의 flex-shrink 속성을 통해 아이템의 컨텐츠를 변경하지 않고서도 고정된 너비를 유지할 수 있다. Refhttps://developer.mozilla.org/ko/docs/Web/CSS/flex-basishttps://studiomeal.com/archives/197 시멘틱 버저닝과 github tag시멘틱 버저닝은 소프트웨어의 버전 변경 규칙에 대한 제안으로, 줄여서 SemVer라고도 부른다. Major: 하위 버전과 호환성이 깨질 수 있는 API 변경사항. breaking change가 발생했을 때를 가리키기도 한다. Minor: 하위 호환성은 지키면서 새로운 기능이 추가된 상황 Patch: 기능 범위 내에서 버그가 수정된 상황 github의 tag 기능을 이용하여 서비스의 버전을 명시할 수 있으며, 원하는 tag에서 release를 작성할 수 있다.facebook의 react팀 release 노트를 참고해서 작성해 보았다. 아직 정식 배포를 하지 않은 초기 개발 단계기 때문에 `v0.1.0`으로 시작했고, 기능 추가와 버그 수정을 거쳐 `v0.2.1`을 배포했다. Refhttps://semver.org/lang/ko/https://github.com/facebook/react/releases AWS EC2로 배포하기🧩 EC2EC2(Elastic Compute Cloud)는 AWS에서 제공하는 클라우드 컴퓨팅 서비스로, 원격으로 가상의 컴퓨터를 사용할 수 있는 기능이다.각각의 컴퓨터는 ‘인스턴스’라고 부르며, 지역(region)을 선택할 수 있다. 온디맨드 방식으로 용량을 자유자재로 늘리거나 줄일 수 있으며, 사용한 만큼만 비용을 지불한다. 사용자가 인스턴스를 완전히 제어할 수 있으며, 보안 및 네트워크 구성, 스토리지 관리에 효과적이다. EC2 인스턴스를 생성하고 운영체제, CPU, 메모리, 스토리지, 네트워킹 용량 등을 선택한다. 이후 보안을 위해 키 페어(public key + private key)를 선택하고, 생성된 .pem 파일을 다운로드 받는다. 👾 이 키 페어를 잃어버리면 다시는 인스턴스에 접근할 수 없다! EC2 인스턴스를 원격으로 제어할 수 있는 shell을 웹을 통해서도 열 수 있지만, 로컬에서 제어하기 위해 SSH 클라이언트를 이용할 수도 있다. 로컬의 .pem 키가 저장된 곳에서 ssh 명령어로 인스턴스에 연결한다. 1ssh -i [프라이빗 키(.pem)경로] [AMI의 사용자 이름]@[인스턴스의 퍼블릭 DNS] sudo apt update를 통해 리눅스를 최신 버전으로 업데이트하고, apache 등의 웹서버를 설치한다. 이제 EC2 인스턴스의 웹 서버를 통해 접속할 수 있다. IPv4 또는 이에 해당하는 DNS를 통해 접속할 수 있다. 이때 방화벽 문제로 접속할 수가 없다면? 인바운드/아웃바운드 규칙을 설정한다. 인바운드 - 외부에서 EC2 인스턴스로 접속하는 것. 보안 상 최소한으로 설정되어야 한다. 아웃바운드 - EC2 인스턴스에서 외부로 접속하는 것. 모두 열려있어야 한다. 22번 포트는 SSH 통신을 위한 방식으로, 기본적으로 열려 있다. 웹을 사용하기 위해서는 80번 포트도 열어야 한다.\u001e 👾 인스턴스 중지 후 재시작 시 IP 주소가 바뀜에 주의 🧩 S3AWS S3(Simple Storage Service)는 인터넷 스토리리지 서비스로, 웹 규모의 컴퓨팅 작업을 보다 쉽게 할 수 있도록 설계되었다. 데이터 스토리지를 위한 기본 컨테이너인 S3 버킷을 만들고, 데이터를 저장하거나 다운로드한다. 이때 데이터를 업로드/다운로드하려는 사용자에게 권한을 부여하거나 제한할 수 있다. 사용한 스토리지만큼 요금이 청구된다는 장점이 있다. 단독 스토리지로도 사용할 수 있으며, EC2, EBS, Glacier와 같은 다른 AWS 서비스와도 함께 사용할 수 있어 클라우드 어플리케이션, 컨텐츠 배포, 백업 및 아카이빙 등의 사례에 알맞다. 🧩 CloudFrontAmazon CloudFront는 빠른 전송 속도로 데이터, 동영상, 애플리케이션 및 API를 사용자에게 안전하게 전송하는 CDN(Contents Delivery Network) 서비스다. html, css, js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원한다. CloudFront는 AWS 백본 네트워크를 통해 콘텐츠를 가장 효과적으로 서비스할 수 있는 엣지로 각 사용자 요청을 라우팅하여 콘텐츠 배포 속도를 높인다. 또한 파일(객체)의 사본이 전 세계 여러 엣지 로케이션에 유지(또는 캐시)되므로 안정성과 가용성이 향상된다. Amazon S3 버킷 또는 고유 HTTP 서버와 같은 오리진 서버를 지정하고, CloudFront는 이로부터 파일을 가져온 다음 전 세계 CloudFront 엣지 로케이션에 배포한다. 👾 캐싱 전략CloudFront를 사용하면 기본적으로 캐시 시간(TTL)이 24시간으로 설정된다. 따라서 사용자가 배포된 기준으로 항상 최신 버전을 보게끔 해야 한다면, CloudFront의 캐싱 전략을 적절히 선택해야 한다. 🧩 정리React로 개발하여 번들링한 프론트엔드 빌드 결과물인 index.html과 bundle.js를 S3 버킷에 저장 후, CloudFront를 이용하여 사용자에게 보여준다! Ref https://www.youtube.com/watch?v=Pv2yDJ2NKQA https://seoyeonhwng.medium.com/aws-ec2란-무엇인가-acf6b7041908 https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/Welcome.html https://usefultoknow.tistory.com/entry/Amazon-S3란-무엇일까 https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/Introduction.html https://aws.amazon.com/ko/premiumsupport/knowledge-center/cloudfront-serving-outdated-content-s3/ 젠킨스 연동하기젠킨스는 지속적 통합(CI; Continuous Integration)과 지속적 제공(CD; Continuous Delivery/Development) 통합 서비스를 제공하는 툴이다. git과 같은 버전관리 시스템과 연동하여 소스의 커밋을 감지하면 자동으로 테스트를 포함한 빌드가 실행되도록 설정할 수 있다. 젠킨스가 제공하는 대시보드를 통해 여러가지 배포 작업의 상황을 모니터링할 수 있다. AWS EC2에 젠킨스 서버를 띄워 사용할 수 있으며, 여러 젠킨스 플러그인을 설치할 수 있다. github의 webhook을 통해 자동으로 젠킨스 Job을 실행할 수 있다. (merge를 포함한) push 이벤특 발생하면, 자동으로 젠킨스 Job이 실행되도록 한다. 쉘 용어 정리 TTL: Time To Live의 약자로, 캐시가 살아 있는 시간을 의미한다. sync: aws s3와 싱크를 맞춘다. --delete: 로컬에서 삭제된 파일이 있는 경우, s3에서도 삭제한다. 최종적인 AWS + 젠킨스 실행 플로우는 아래와 같다. Ref https://www.jenkins.io/doc/ https://ict-nroo.tistory.com/31 https://taetaetae.github.io/2018/02/08/github-web-hook-jenkins-job-excute/ PrivateRoute로그인하지 않은 상태에서 진입하면, 바로 튕기게끔 해주기 위해 Private Route를 구현했다. 로그인이 된 상태(isLogin)라면 children으로 넘긴 컴포넌트를 바로 렌더하고, 그렇지 않다면 로그인을 위한 창을 띄운 후 디폴트 페이지로 리다이렉트 해준다. 123456789101112131415161718192021222324252627282930313233343536373839interface Props extends RouteProps { children: React.ReactNode;}const PrivateRoute = ({ children, ...props }: Props) =&gt; { const { isLogin } = useMember(); const modal = useModal(); const notification = useNotification(); const openLoginModal = () =&gt; { notification.confirm('로그인이 필요한 서비스입니다.', () =&gt; modal.openModal(&lt;LoginModal /&gt;)); }; return ( &lt;Route {...props} render={({ location }) =&gt; { if (isLogin) { return children; } else { openLoginModal(); return ( &lt;Redirect to={{ pathname: ROUTE.HOME, state: { from: location, }, }} /&gt; ); } }} /&gt; );};export default PrivateRoute; 전체 route를 관리하는 최상단 컴포넌트에서 간단하게 사용할 수 있다. 1234567891011121314151617const App = () =&gt; { return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path={ROUTE.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route exact path={ROUTE.ABOUT}&gt; &lt;About /&gt; &lt;/Route&gt; &lt;PrivateRoute path={ROUTE.UPLOAD}&gt; &lt;Upload /&gt; &lt;/PrivateRoute&gt; &lt;/Switch&gt; &lt;/Router&gt; )} 아래와 같이 동작한다. Ref https://www.youtube.com/watch?v=Y0-qdp-XBJg etcgithub의 새로운 보안 정책작업하던 중간에 github 연결이 한번 끊겼다! 정말 갑자기 remote 저장소에 푸쉬가 되지 않았다. github 작업을 위해 패스워드를 사용해왔었는데, 8월부터는 패스워드 인증 방식 대신 토큰 기반 인증을 사용한다고 한다. 기존에 토큰 또는 SSH 기반의 인증을 사용했던 사용자의 경우 문제가 없었지만, 패스워드를 사용했던 본인의 경우에는 갑자기 Brownouts이 발생했던 것이다. 처음 마주하는 에러에 한 시간 동안 아무 작업도 하지 못한 채 울상이었는데, 아래 링크 글을 참조하여 다시 연결에 성공했다! 귀찮긴 하지만 보안 측면에서 필요한 작업인 것 같다. Ref https://velog.io/@cookncoding/GitHub-암호-토큰-방식GitHub-Deprecation-Notice-메일-해결 npm 모듈 크기 확인하기성능 최적화를 고민하는 프론트엔드 개발자라면 사용하는 NPM 패키지들이 트리셰이킹을 지원하는지, ESM으로 되어있는지, 타입 정의가 있는지, 고민해볼 필요가 있다. 이곳에서 사용 중인 라이브러리를 검사할 수 있다! 👾 ESMES Modules로, JavaScript에서 스탠다드 모듈 시스템을 지원하는지 여부를 알려준다. ESM을 통해 아래와 같은 import 방식을 사용할 수 있다. 1import React from 'react'; ESM은 트리셰이킹을 지원하며, 번들러를 통해 불필요한 코드를 제거해준다. Ref https://bundlephobia.com/ https://irian.to/blogs/what-are-cjs-amd-umd-and-esm-in-javascript/ 마무리기능은 많이 못했지만 수많은 버그들을 잡고, CSS도 꼼꼼하게 정리했던 한 주였다. 글쓰기 과제도 하고, 인터뷰 스낵 스터디도 새로 시작했다. 주말까지 집에서 꼼짝도 못하고 정신없던 시간들.올해 정신없다는 말을 가장 많이 쓰는 것 같다. 그래도 머리를 싸매던 문제들이 조금씩 풀려가면서 팀원들과 안도의 웃음이 터지는 순간은 정말 뿌듯하고 알 수 없는 기쁨이 몰려온다. 페어 미키가 따끔한 조언을 해줬다. 나도 내 의견이 있었으면 좋겠다고. 지난 프로젝트에서, 회사에서, 또는 다른 크루들이 썼다고 무조건 옳은 코드는 아닌데 편하고 익숙한 방식으로 그저 가져다 쓰자고 주장했던 상황들이 종종 보였나 보다. 분명 인지하고 있었던 문제인데, 버그는 계속 터지고 요구사항은 넘쳐나는 와중에 신경쓰지 못한 것 같다. 나를 위해 솔직하게 말해준 미키에게 정말 고마웠다! 초심으로 돌아가 본질을 찾는 연습을 꾸준히 해야겠다. 너무 무리하거나 일에 쫓겨 살지 않도록 신경도 쓰고. 마지막은 내가 만든 팀원들의 미모티콘!","link":"/2021/08/01/woowa-week-26/"},{"title":"우테코 27주차 기록","text":"우아한테크코스 27주차 놀토 프로젝트마지막(?) 기능 회의3차 데모데이 다음 날, 마지막 기능인 댓글과 마이페이지 회의를 쭉 달렸다. vscode는 켜지도 않고 하루종일 회의만 했다. 그래도 이전까지 해온 경험이 있어서인지 나름대로 착착 진행되었다. 미키가 댓글을, 내가 마이페이지를 맡기로 했다. 마크업을 뚝딱뚝딱 하고 백엔드 api를 붙였다. 조금 더 완성도 있는 서비스가 되어가고 있다! 유닛 테스트컴포넌트 단위의 테스트를 진행하고 있다. 컴포넌트의 모든 비즈니스 로직을 추출하여 테스트에 용이하게끔 만들자는 의견이 있었는데, 뭔가 아직은 그럴 필요성까지는 느끼지 못하여 jest로 함수를 적당히 mocking해서 테스트하고 있다. 처음 틀을 잡을 때는 삽질을 굉장하게 했는데, 그 이후부터는 착착 초록불이 뜨는 것을 보니 코딩할 맛이 난다. 공부하기JIT 컴파일 타임인터뷰 스낵 스터디를 하던 중, 자바스크립트에서 런타임 이전에 이뤄진다는 ‘코드 평가 과정(스캐닝 과정)’은 정확히 어떤 시점에 발생하는지 궁금하여 스터디 페어와 함께 찾아보았다. 자바스크립트에서 이뤄지는 JIT 컴파일(just-in-time compilation) 이란 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다. 동적 번역(dynamic translation)이라고도 불린다. 이는 Java 등 컴파일이 필요한 언어와, 코드를 한 줄 한 줄 읽어내려가며 실행하는 JavaScript 등의 인터프리터 언어 두 가지 방식을 혼합한 방식이다. 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다. 즉 코드를 우선 인터프리터 방식으로 실행하고 필요할 때 컴파일하는 것이다. 이런 방식으로 JavaScript는 성능을 크게 개선시킬 수 있었다. 👾 크롬의 자바스크립트 엔진인 V8은 JIT 컴파일을 지원한다. 브라우저는 자바스크립트 엔진으로 자바스크립트 소스를 내부에서 이해할 수 있는 언어로 변환하고 실행하는데, 이를 컴파일이라고 부른다. 자바스크립트같은 인터프리터 언어는 항상 같은 코드를 반복해서 컴파일하고 생성한다. 브라우저에서 새로고침이나 페이지 이동이 발생하면 항상 같은 코드를 새로 컴파일하게 되는 것이다. 그래서 V8에서는 먼저 JavaScript 코드를 Interpreter 방식으로 컴파일하고 이를 ByteCode로 만들어 낸다. 컴파일 속도를 높이기 위해 이 ByteCode를 캐싱해두고, 자주 쓰이는 코드를 최적화하여 이후 컴파일 시 참조하여 속도를 높인다. 🤔 그래서 정확히, 실행컨텍스트를 만들고 변수 선언부를 등록하는 과정이 ‘런타임’인지 그 이전의 어떤 단계인지는 알지 못했다. 아무튼 런타임은 아닌 것으로! Refhttps://oowgnoj.dev/review/advanced-js-1https://pks2974.medium.com/v8-에서-javascript-코드를-실행하는-방법-정리해보기-25837f61f551 etc커스텀 React Hooks로 로직 공유하기컴포넌트의 비즈니스 로직을 hook으로 빼서, 해당 hook을 react-hooks-testing-library로 테스트할 수 있다. Refhttps://medium.com/jit-team/how-to-smoothly-manage-shared-logic-with-custom-react-hooks-558575c11bcf normalize-css모든 브라우저에서 동일한 결과물을 보기 위해 사용하는 툴이다. CSS reset 등을 사용하면 DOM 요소들에 기본적으로 적용되어 있는 margin 등의 스타일 기본값을 모두 초기화시켜줄 수 있지만, 이는 필요한 속성들까지도 전부 제거해버린다는 문제점이 있다. noramlize-css는 normalizing이 필요한 속성들만 초기화시켜준다는 점에서 유용하다. macOS와 window에서 화면이 서로 다르게 보이는 문제를 해결하고자 사용했는데, 결국 normalize-css로는 모든 문제가 해결되지는 않아 각 요소들을 하나하나 체크하면서 적당한 여백을 두게끔 조정하고 있다. 프론트엔드 개발의 귀찮음 스택 += 1 styled-components 등의 CSS-in-JS를 사용 중이라면 styled-normalize를 사용할 수 있다. 최신 CSS flexbox의 gap 속성은 지금도 유용하게 쓰고 있다. scroll-snap-type 속성은 놀토 서비스에 잠깐 적용했다가 사용되지 않아서 뺐다. 하지만 어디든 센스있게 사용 가능한 속성인 것 같다. aspect-ratio라는 속성이 기대된다! Refhttps://www.youtube.com/watch?v=lkTpOHv1Ros&amp;feature=youtu.be TDD 모르는 사람도 시작하는 법Refhttps://twitter.com/KentBeck/status/1421257650113634304 마무리아찔했던 3차 데모데이였다..🥲 그리고 도쿄올림픽 꽤나 재밌었다. 팀원들과 여자배구 4강전 같이 봤다.잔여백신도 착착 잘 잡는 우리 팀원들. 나는 언제 맞을까나? 이번주는 마지막 기능들을 빠르게 구현하느라 기술적인 어려움에 마주하는 경험이나 챌린징한 배움들은 조금 적은 편이었다. 하지만 서비스에 조금 더 어울리게끔 조금씩 개선해나가는 과정도 뿌듯한 것 같다 😆 이제 다음 주 최종발표만을 앞두고 있다. 이제서야 슬슬 지치는 기분도 들지만, 조금만 더 정신차리고 버텨서 유종의 미를 거둬보자!","link":"/2021/08/08/woowa-week-27/"},{"title":"우테코 28주차 기록","text":"우아한테크코스 28주차 놀토 프로젝트2번째 UT자체적으로 2번째 UT를 진행했다. 코치님도 2분 모셨는데, 개발자 도구까지 열어보시더니 http request도 확인해 보시고 피드 등록에 script 태그를 심거나 DB를 터뜨릴 수 있는 SQL injection까지 시도해보시는 등 말을 잇지 못할 QA를 보여주셨다. 🤦‍♀️ 그래도 덕분에 문제점들을 파악하고, 조금씩 고칠 수 있었다. 사용자의 요구대로 UI을 조금 바꾸거나 추후 논의해보기로 한 기능들도 생겼지만, 현 수준에서는 보류하거나 기타 이유들로 적용을 기각한 항목들도 있었다. 시간은 오래 걸리지만 UT는 꼭 필요한 작업인 것 같다! 배포는 꼼꼼하게!지난 v0.2.1 배포 후 main 브랜치를 develop 브랜치에 합치지 않아서, develop 브랜치에 지난 release 커밋이 들어와 있지 않아 한 차례 곤혹을 겪었다. 몇 시간의 삽질과 고민과 투표 끝에, 아쉽지만 지난 버전은 날리고 새롭게 태그를 달아 배포하기로 했다. 이제는 배포할 때마다 꼼꼼하게 브랜치 간 커밋 이력을 관리해야겠다는 큰 교훈을 남겼다. 아무튼 간에 드디어 v1.0.1 배포 완료!🧸 놀토 v1.0 구경가기 skeleton ui이미지 파일 때문에 피드 데이터를 로드해 오는데 꽤나 시간이 걸려서, 전체 파일이 로드될 때까지 사용자에게 보여줄 skeleton ui를 만들었다. 생각보다 어려운 건 없었고, 모양과 약간의 애니메이션만 CSS로 잘 잡아준 후 http request 응답이 loading 상태일 때 띄워주면 된다. 예쁘게 동작해서 다행이다. 반응형 ui드디어 반응형 ui를 ‘시작’은 해 보았다! 계속해서 UI가 바뀌는 만큼 신경 써줘야 할 부분들이 은근 많았다. 모바일의 경우 어쩔 수 없이 제외시켜야 하는 항목들도 생겼는데, 단순히 컨텐츠의 크기만 바꾸는 것이 아니라 요소들 간의 배치도 다시 해줘야 하는 경우들이 발생하여 앞으로 더욱 신경 쓸 부분이 될 것 같다. 프론트엔드성능 분석🍀 여기서 읽기 공부하기테스트 자동화기존에 젠킨스에서 프론트엔드 테스트를 돌리는 스크립트를 넣어주던 것을 빼고, github husky를 이용하여 로컬에서 github으로 푸쉬하기 전에 테스트를 돌려주기로 했다. husky는 프론트엔드 개발 환경에서 git hook을 손쉽게 제어하도록 도와주는 매니저로, git에서 특정 이벤트(commit, push 등)가 발생할 때 hook을 걸어 특정 스크립트가 실행되도록 도와준다. 프로젝트 루트 안에 frontend 디렉토리가 들어가 있어서, git 관련 액션(push)이 실행될 때 타겟 디렉토리인 frontend로 들어가도록 스크립트를 수정해주었다. 12345// package.json&quot;scripts&quot;: { // ... &quot;prepare&quot;: &quot;cd .. &amp;&amp; husky install frontend/.husky&quot;}, 그리고 .husky 디렉토리의 pre-push 폴더에 아래와 같이 작성해 준다. 123456#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;cd frontendyarn test Refhttps://github.com/typicode/huskyhttps://www.huskyhoochu.com/npm-husky-the-git-hook-manager/ etc리액트 앱 S3, CloudFront에 배포하기Ref https://react-etc.vlpt.us/08.deploy-s3.html Merge vs Squash and Merge vs Rebase and MergeRef https://meetup.toast.com/posts/122 마무리드디어 마지막 데모데이가 끝났다! 랜선 회식은 또 했지만, 코로나 때문에 팀원들을 아직까지도 만나지 못하고 있는 게 정말 속상하다. 오프라인으로 나가지 못하면서 더욱 정보의 공유가 같은 팀으로 제한되어 새로운 기술들이나 정확한 정보들에 대한 공유가 힘들었다. 그러면서 더욱 불안하거나 조급해지고, 뒤처진다는 생각이 불쑥불쑥 들었던 게 사실인 것 같다. 특히 이번 주는 기술적으로 챌린징한 깨우침들을 얻었다기보다는 이것저것 버그들을 수정하거나 UI들을 고친 것에 불과했기 때문에 더더욱. 그래도 후회없이 정말 잘 했다고 생각하자! 정말 20대 이후 최고로 열심히, 밤낮없이 일했으니까. 지그 짱 👍","link":"/2021/08/14/woowa-week-28/"},{"title":"우테코 29주차 기록","text":"우아한테크코스 29주차 모의면접오랜만에 보는 크루들과 함께 했던 순한 맛 모의면접 피드백 차분하게 잘 얘기한 것 같아서 좋았다. 기술 질문에 대해서는 술술 얘기했는데, 그에 비해 소프트 스킬에 대한 부분은 조금씩 막힘이 있는 것 같아서 보완해보면 좋지 않을까! 소프트 스킬 물어볼 때는 기술 질문 답할때에 비교해서 조금 논리가 덜하고 중복된 말이 많은 느낌 시선이 정면 유지를 잘 해서 좋았다. 문장이 긴 거 같긴 한데, 이해는 잘 되서 특별히 나쁘게 느끼진 않았다. 잘 정리된 문장으로 얘기해줘서 이해하기 좋았다. 몸을 계속 움직이는데 조금 줄이면 좋을 것 같다. 두괄식으로 답변을 잘 해준 것 같다. 평소 텐션과 다르게(!) 차분하게 잘해준 것 같다. 제스처를 적절하게 사용한다. 사용자 경험을 중요하게 생각한다는 부분을 경험(UT)을 곁들여서 얘기해줘서 진정성 있어 보였다. 질문 리스트 react-query를 사용한 이유? swr에 대해 들어봤는지? swr대신 리액트 쿼리를 사용한 이유? 성능 분석을 어떤 식으로 진행했는가? 성능 개선은 어떤 식으로 진행했는가? lazy loading을 어떻게 구현할 수 있을까? 이미지가 화면에 실제 보였을 때를 어떻게 알 수 있을까? react hook form을 사용한 이유? react hook form을 사용하면서 어려웠던 점? css in css대신 css in js를 선택한 이유? 하나의 프로덕트를 완성하는데 가장 중요하다고 생각되는 부분이 무엇인가? 최근에 진행한 프로젝트에서 협의점을 찾아가는 경험? 좋은 프론트엔드 개발자란 무엇이라고 생각하는지? 10년 후의 나의 모습→ 다른 사람들이 필요로 하는 개발자! 지식적인 부분이든, 팀 내 분위기를 띄워주는 역할으로든 😆 모두에게 주어졌던 피드백 중 하나는, 화상 면접에 대비한 시선처리 문제였다. 생각하느라고 잠시 옆이나 아래를 보게 되면 마치 어딘가를 보고 컨닝하는 것 같다. 그리고 커뮤니케이션 등 소프트 스킬에 대한 답변도 잘 준비가 되어있어야겠다. 기술 면접보다도 어려울 수 있다는 걸 처음 느꼈다. 프론트엔드 공부babel과 polyfill🍀 여기서 읽기 Web Server와 WAS🍀 여기서 읽기 성능 최적화 미션Lv4의 서문을 여는 성능 베이스캠프 미션! 파도 파도 끝이 없지만 많은 내용들을 알차게 배울 수 있었다. 🍀 여기서 읽기 공부하기Github ActionsGithub Actions란 Github 저장소를 기반으로 소프트웨어 개발 workflow를 자동화할 수 있는 도구이다. 성능 미션을 진행하며, github에 push 이벤트가 발생했을 때 빌드 파일들을 s3 버킷에 자동으로 업로드해주기 위해 사용했다. 사실 우테코 S3 버킷에 직접 접근할 수 있는 권한이 없어서, AWS의 ACL(Access-Control-List) 기능을 사용해 우회해서 들어가주었다. 이 부분은 크루 곤이의 글에서 확인할 수 있다. cloudfront distribution도 invalidate 해주는 커맨드를 추가하고자 했으나, 잘 되지 않아 우선 보류 😬 간단한 workflow는 아래와 같다. Checkout node 설정 npm 및 yarn 설치 dependency 설치 프로젝트 빌드 - 이때 환경변수에 필요한 API_KEY값을 넣어주었다. aws s3 파일 동기화 - 환경변수에 AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_DEFAULT_REGION이 필요하다. 완성된 최종 코드는 다음과 같다. main 브랜치에 push 이벤트가 발생하면 Github이 아래 과정들을 순차적으로 실행시켜준다. 1234567891011121314151617181920212223242526272829303132333435363738name: push_builderon: push: branches: mainjobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v1 with: node-version: '14' - run: npm install - name: Setup yarn run: npm install -g yarn - name: Install Dependencies run: yarn - name: Build run: yarn build env: GIPHY_API_KEY: ${{ secrets.GIPHY_API_KEY }} - name: S3 Deploy env: AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }} AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }} AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }} run: aws s3 sync ./dist s3://[s3-bucket-name]/ --acl bucket-owner-full-control Refhttps://yung-developer.tistory.com/111https://zzsza.github.io/development/2020/06/06/github-action/ React App S3 &amp; Cloudfront로 배포하기리액트로 만든 앱을 S3와 Cloudfront를 이용해 배포해보자! 🍀 여기서 읽기 etc얼렁뚱땅 도메인 붙이기 대작전백엔드 크루 웨지의 도메인 붙이기 대장정. 생각보다 설정해줘야 할 것들이 많다! Ref https://www.notion.so/2adc105ad25748d49d0e18f34d1150c8#76819d7a5c08402f875454bb45a3acad JavaScript 번들러로 본 조선시대 붕당의 이해JavaScript 모듈 시스템의 등장 배경부터 CommonJS → AMD → UMD → ES6 Module로 이어지는 역사까지 재미있게 다루고 있다. 그 외에도 태스크 러너와 이제는 없어서는 안 될 webpack 등의 모듈 번들러까지 설명하고 있다. Ref https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html react-iconsbabel + TypeScript하나의 앱에서 두 컴파일러(트랜스파일러)를 함께 쓴다면? Ref https://ui.toast.com/weekly-pick/ko_20181220 우아한형제들 채용 전문가 인터뷰Ref https://www.youtube.com/watch?v=XJBIz-Z-Xds 독개’s 프론트엔드 성능 최적화의 모든 것정말 대단한 크루 크리스 👍👍 Ref https://songwon2019.notion.site/Quick-Start-04fd057643ee4fb5b1439b5758e7814a 마무리바쁘고 자존감 떨어지고 개발자 해도되나 생각까지 들었던 일주일이다. 아침에 눈 뜨는 게 무섭기까지 할 정도로 겁을 먹었다. 벌써 Lv4라 더욱 그런 듯하다.","link":"/2021/08/28/woowa-week-29/"},{"title":"우테코 31주차 기록","text":"렌더링 성능 최적화 | webpack 설정 놀토 프로젝트Sentryproduction에서 발생하는 에러를 잡기 위해 Sentry라는 도구를 사용해주었다. 뭔가를 실수로 잘못 눌러 무료 14일 체험판이 신청되어, 슬랙과도 연동을 시켜 놓았다. 전체 에러에 대해서 Sentry 에러를 발생시키고, Http 에러가 아닌 개발자가 확인하지 못한 에러들에 대해서는 유저 리포트를 띄워 문제 발생 케이스를 참고할 수 있도록 했다. webpack 설정 재정비🍀 여기서 읽기 성능 최적화✅ 정적 이미지 파일 확장자 변경사용자가 업로드하는 이미지 파일이 gif아닌 서비스 자체에서 사용하는 정적 이미지들의 확장자를 webp로 변경했다. &lt;picture&gt;와 &lt;source&gt; 태그를 활용하여 webp 확장자를 지원하지 않는 브라우저에서도 png 확장자 파일로 받아와서 이미지가 문제없이 로딩될 수 있게끔 작성했다. 1234567return ( &lt;picture&gt; &lt;source srcSet={webpUrl} type=&quot;image/webp&quot; /&gt; &lt;source srcSet={pngUrl} type=&quot;image/png&quot; /&gt; &lt;img src={pngUrl} width=&quot;180px&quot; alt={name} /&gt; &lt;/picture&gt;) ✅ loadable을 이용한 코드 스플리팅각 라우터에 해당하는 페이지의 자바스크립트 소스코드를 각 페이지에 진입할 때마다 불러올 수 있게 하기 위해서 코드 스플리팅을 진행했다. React에서 기본 제공하는 lazy 대신, preload 옵션을 줄 수 있는 loadable components를 사용했다. 각 컴포넌트에 대하여 코드 스플리팅 이후 분리될 청크 파일의 이름을 아래와 같이 지정할 수 있다.(webpackChunkName 옵션) 123const Home = loadable(() =&gt; import(/* webpackChunkName: &quot;Home&quot; */ 'pages/Home/Home'));const About = loadable(() =&gt; import(/* webpackChunkName: &quot;About&quot; */ 'pages/About/About'));const Upload = loadable(() =&gt; import(/* webpackChunkName: &quot;Upload&quot; */ 'pages/Upload/Upload')); 특정 페이지로 진입하고자 할 때 클릭하는 버튼 등에 mouseOver 이벤트 리스너를 달아주어 필요한 컴포넌트의 로드 시점을 앞당겼다. 1234567return ( &lt;li onMouseOver={() =&gt; Page.RecentFeeds.preload()}&gt; &lt;NavLink to={ROUTE.RECENT} className=&quot;nav-link&quot; activeClassName=&quot;selected&quot;&gt; Toy Projects &lt;/NavLink&gt; &lt;/li&gt;) ✅ splitChunksoptimization.splitChunks 설정 시 webpack은 기본적으로 번들링 과정에서 청크를 분할한다. 구체적으로 webpack은 다음 조건에 따라 자동으로 청크를 분할한다. 새 청크를 공유할 수 있거나 모듈이 node_modules 폴더에 있는 경우 새 청크가 20kb보다 클 경우(minimize + gzip 이전에) 요청 시 청크를 로드할 때 최대 병렬 요청 수가 30개 이하일 경우 초기 페이지 로드 시 최대 병렬 요청 수가 30개 이하일 경우 splitChunks.chunks는 최적화를 위해 선택될 청크를 나타낸다. 값으로 all, async 및 initial을 넣을 수 있다. 여기서 async 즉 비동기 청크란 컴파일 단계에서 초기에 로드되는 청크가 아닌, 런타임에서 동적으로 로드되는 청크를 가리킨다. 캐시그룹(splitChunks.cacheGroups)을 사용하여 특정 조건으로 청크 파일을 생성할 수 있다. 디폴트 옵션에 나와있는 대로 node_modules를 별도의 청크로 분리하고, 이름은 vendor로 지정해주었다. 나머지 청크 파일들에 대해서는 prefix를 통해 filename만 따로 명시해주었다. 👾 비동기 모듈은 따로 파일을 분리해야 동적으로 불러올 수 있기 때문에 비동기로 import되는 모듈들은 따로 옵션을 주지 않아도 webpack이 알아서 별도의 파일로 분리해준다. 123456789101112131415161718// webpack.config.jsmodule.exports = { optimization: { splitChunks: { chunks: 'async', cacheGroups: { vendor: { chunks: 'all', name: 'vendor', test: /[\\\\/]node_modules[\\\\/]/, }, default: { filename: 'common-[name].js', }, }, }, },} Refhttps://webpack.js.org/plugins/split-chunks-plugin/#roothttps://simsimjae.medium.com/webpack4-splitchunksplugin-옵션-파헤치기-19f5de32425a 프론트엔드렌더링 성능 개선 강의✅ 브라우저 렌더링 개선브라우저의 메인 스레드 일이 넘치면 어떻게 될까? 당연히 유저 인터랙션이나 페이지 전환 시 화면이 버벅거리게 되며, 이 현상을 ‘쟁크’라고 부르기도 한다.. 문제를 방지하기 위해 일반적인 스크린의 주사율인 60FPS를 맞춰 화면 업데이트를 끊기지 않도록 하는 것이 좋다. 1초에 60프레임 = 1프레임 당 16.67ms (paint를 위한 시간을 고려하면 약 10ms) reflow, repaint를 줄이거나 memoization을 사용하여 똑같은 작업을 매번 새로하지 않도록 해주는 것도 좋은 생각이다. 특히 repaint 시 layer를 적절하게 사용한다면 repaint 작업을 브라우저의 메인 스레드가 아닌 GPU에서 수행하도록 도와주기 때문에 작업 비용을 줄일 수 있다. 페이지의 layer 확인은 크롬 개발자 도구의 점 세 개 → More Tools → Layers에서 확인할 수 있다. 한편 web worker를 사용하여 브라우저의 일을 나눠서 처리해줄 수도 있다. web worker는 스크립트 연산을 웹 어플리케이션의 주 실행 스레드와 분리된 별도의 백그라운드 스레드에서 실행할 수 있는 기술이다. 🚨 layout thrashing은 위험하다! layout thrashing이란, 동기적으로 레이아웃의 변경을 강제하는 동작으로, 아래와 같은 코드에 해당한다. 1234567const paragraphs = document.querySelector('p');const greenBlock = document.getElementById('block');for (let i = 0; i &lt; paragraphs.length; i++) { let blockWidth = greenBlock.offsetWidth; paragraphs[i].style.width = blockWidth + 'px';} 이처럼 자바스크립트로 스타일링 값을 읽고 강제로 할당하는 것만으로도 layout 단계에서 다시 JavaScript 파싱 단계로 돌아가게 되므로 연산이 낭비되는 문제가 있다. 🔮useLayoutEffectDOM이 모두 로드된 후 실행되는 useEffect와 달리, useLayoutEffect는 React에서 DOM을 업데이트하고 브라우저가 paint하기 전에 인자로 받은 콜백을 동기적으로 실행한다. useLayoutEffect에는 DOM이 실제로 화면에 그려지기 전에 미리 실행되어야 할 동작을 정의할 수 있다. Refhttps://developer.mozilla.org/ko/docs/Web/API/Web_Workers_APIhttps://www.youtube.com/watch?v=a9wbrTbg_RIhttps://www.youtube.com/watch?v=kU5Z4D5N3Kk ✅ 프레임워크/라이브러리가 (미리) 해주는 일 기본 수준의 최적화 (DOM 제어 &amp; lifecycle) React.memo를 활용하자 ✅ 사용자 경험을 위한 성능실제 성능 지표도 중요하지만, 사용자가 ‘체감하는’ 속도가 중요하다. 빈 페이지가 뜨는 시간을 최소화하고, 아직 컨텐츠가 로딩되지 않은 페이지에는 뭐라도 보여야 한다. 기본적인 로딩 UI를 활용하거나, 스켈레톤 UI를 활용하는 것도 좋은 방법이다. 모두 만족스럽지 않다면, SSR을 사용해보는 것은 어떨까? 😲 Web Server와 WAS🍀 여기서 읽기 공부하기styled-component, 왜 다르게 보일까?(dev와 prod에서)production에서 styled-component는 CSSOM API를 이용해서 스타일을 바로 집어넣는다! 그래서 styled-components에 대한 내용이 구구절절 나오는 dev에서와는 다르게 보인다. &lt;dev에서의 구구절절한 styled-components 태그&gt; &lt;prod에서 깔끔한 styled-components 태그&gt; 웹 폰트 사용하기여태까지 @import 구문만을 믿고 잘못 가져오고 있었다! 세상에 그래서 페어의 윈도우와 내 MacOS에서의 화면이 더욱 다르게 보였나보다. html &lt;link&gt; 태그의 preload 속성을 사용하여 웹 폰트의 링크를 “먼저” 불러온 후 사용할 수도 있다. 하지만 폰트 링크를 한번 불러오고, 실제 폰트 파일을 내려받는 2차례의 과정을 거치게 된다. 또한 vietnamese나 latin-ext와 같이 사용하지 않는 폰트의 형식까지 모조리 불러와 불러오는 font 파일이 매우 많아지게 되는 문제가 발생한다. 실제로 아래와 같이 작성했을 때 불러오는 전체 폰트 파일의 크기는 무려 469kB에 달했다. (총 3개의 폰트 사용) 12&lt;!-- index.html --&gt;&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&amp;display=swap&quot; rel=&quot;preload&quot; as=&quot;font&quot; onload=&quot;this.rel='stylesheet'&quot; crossorigin=&quot;anonymous&quot;&gt; 그래서 사용할 폰트를 preload를 사용하여 무엇보다 빠르게 불러오는 선택지보다, 우리가 실제 사용할 폰트만 선택적으로 불러와 전체 파일의 용량을 줄이는 방향을 선택했다. 폰트 파일의 확장자들 중 용량이 가장 낮은 woff2를 기본으로 선택하고, woff2 확장자를 지원하지 않는 브라우저에 대비하여 truetype을 추가로 넣어주었다. 12345678910111213&lt;!-- index.html --&gt;&lt;style&gt; @font-face { font-family: 'Open Sans'; font-style: normal; font-weight: 400; font-display: swap; src: url('./fonts/OpenSans-Regular.woff2') format('woff2'), url('./fonts/OpenSans-Regular.ttf') format('truetype'); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; } /* ... */&lt;/style&gt; 앱 전체에서 사용하는 Global Style에 styled-components를 이용하여 @font-face를 넣어줄까도 고민했었지만, 자바스크립트로 작성된 styled-components를 한번 파싱하고 CSS를 또 불러오는 것은 성능이 좋지 못하다고 판단하여 앱의 진입점인 index.html에 &lt;style&gt; 태그로 바로 넣어주었다. &lt;head&gt; 안에 있는 &lt;style&gt;이나 &lt;link&gt;에 포함된 리소스들은 &lt;body&gt; 태그 내부에서의 DOM 파싱과 병렬적으로 이루어지기 때문에 리소스를 보다 빠르게 로드할 수 있다. Ref https://www.youtube.com/watch?v=4YCBBoSg2fk 기타언제 나온 문법이지? 어느 브라우저 지원? 바벨이 컴파일해주나?Ref https://kangax.github.io/compat-table/es6/ 인상적인 랜딩 페이지Ref https://www.tossbank.com/?referral=5131843 마무리무난한 컨디션이 계속된다. 조급한 건 여전히 디폴트지만, 이번주는 그래도 여유롭게 지나갔다. 코딩은 많이 못해서 일에 사실 큰 재미는 느끼지 못한다. 파도 파도 끝없는 성능 최적화 때문에… 강의도 많고, 계속해서 뭔가 일정이 있었다. 팀원들과 감정회고도 진행했다. 우리 팀원들 정말 아기자기하고 귀엽다. 벌써 9월도 절반 가까이 지났는데, 루터 가서 빨리 만나고 싶다. 😆","link":"/2021/09/11/woowa-week-31/"},{"title":"우테코 32주차 기록","text":"Lv4 1차 데모데이 | 애플 클론코딩 놀토 프로젝트카카오 공유하기Kakao API를 이용해서 카카오 공유 기능을 만들었다! TypeScript 타이핑 때문에 조금 복잡했지만 쉽게 사용할 수 있었다. 마크다운 컴포넌트 작성react-markdown 라이브러리를 사용해서 피드 업로드 시 마크다운 문법을 사용할 수 있도록 해주었다. remove-markdown 라이브러리를 추가적으로 사용해서 피드 썸네일에서는 일반 텍스트로 나오게끔 작성해 주었는데, 왠지 하나의 기능에 라이브러리를 떡칠(…)한 것 같아서 어떻게 할지 고민이다. gif to mp4진입 페이지의 FCP(First Contentful Paint)와 LCP(Largest Contentful Paint)에 큰 영향을 주는 피드의 gif 확장자 파일들을 mp4 확장자로 변경하여 렌더링하기로 했다. 백엔드에서 FFmpeg 툴을 활용하여 변환해주었다. 뚝딱뚝딱 잘 만들어주는 우리팀 백엔드 팀원들에게 무한 감사를… 🙇‍♀️ 덕분에 페이지 진입 시 받아오는 리소스의 용량이 1/10 수준으로 줄어들었다! 페이지 전체의 focusout 이벤트 처리검색창의 옵션, 프로필 드롭다운 등 무언가 부수적인 렌더링 요소가 보였다가 다른 곳을 클릭하면 사라져야 하는 이슈가 아직 해결되지 않고 있었다. 이번 스프린트에 리팩토링을 진행하며 이슈를 해결해보았다. (천재 코더 페어 미키의 작품 👍) 드롭다운의 열고 닫힌 상태를 관리하는 상황이라고 가정해보자. 컴포넌트 단에서 useFocusOut hook을 실행한다. 드롭다운을 닫는 콜백함수를 전달하여 registeredCallbackInfos 배열에 담아준다. 현재 페이지를 가리키는 document에 mousedown 이벤트를 걸어준다. 그러면 페이지에서 발생하는 마우스 클릭 이벤트에 대해서 이벤트 핸들러가 trigger될 것이다. 이때 마우스를 클릭한 곳이 event.target 즉 ref가 가리키는 DOM 요소가 아니라면 (현재 열려 있는 드롭다운의 외부를 클릭했다면) 해당 드롭다운을 닫는 콜백함수를 실행한다. 마지막으로 드롭다운 컴포넌트 unmount 시 더 이상 해당 콜백 함수는 의미가 없어지므로 useEffect의 cleanup 함수를 통해서 해제해준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, { useEffect, useRef, useState } from 'react';import { genNewId } from 'utils/common';interface RegisteredCallbackInfo { id: number; callback: () =&gt; void; targetElementRef: React.MutableRefObject&lt;Element&gt;;}const idGenerator = genNewId();let registeredCallbackInfos: RegisteredCallbackInfo[] = [];// (3)document.addEventListener('mousedown', (event) =&gt; { registeredCallbackInfos.forEach((callbackInfo) =&gt; { if (!callbackInfo.targetElementRef.current) return; // (4) if (!callbackInfo.targetElementRef.current?.contains(event.target as Node)) { callbackInfo.callback(); } });});const useFocusOut = (callback: () =&gt; void) =&gt; { const [id, _] = useState(idGenerator.next().value); const targetElementRef = useRef(null); useEffect(() =&gt; { // (2) registeredCallbackInfos.push({ id, callback: callback, targetElementRef, }); // (5) return () =&gt; { registeredCallbackInfos = registeredCallbackInfos.filter( (callbackInfo) =&gt; callbackInfo.id !== id, ); }; }, []); return targetElementRef;};export default useFocusOut; 사용하는 측에선 간편하게 렌더링 요소를 보이지 않게끔 하는 콜백함수만 넘겨주면 된다. 123456789101112const SearchOption = ({ searchType, setSearchType }: Props) =&gt; { const [isOptionOpened, setIsOptionOpened] = useState(false); // (1) const ref = useFocusOut(() =&gt; { setIsOptionOpened(false); }); return ( &lt;Styled.Root ref={ref} $isOpen={isOptionOpened}&gt; // ... &lt;/Styled.Root&gt; 아래처럼 각종 드롭다운이나 열려있는 옵션 창들에 대해, 외부를 클릭해도 닫히는 자연스러운 인터랙션을 구현할 수 있게 되었다! 데모데이우연의 장난으로(?) 백신 2차 접종을 막 마친 두 명의 크루가 발표를 진행했다. 깜짝 준비한 추석 테마🌝에 대한 호응이 좋았다. 다른 팀들을 보니 우리도 성능 최적화와 웹 접근성 개선에 조금 더 공을 들여야할 것 같다. 프론트엔드애플 클론코딩 미션🍀 여기서 읽기 TypeScript declare🍀 여기서 읽기 공부하기프론트에서 안전하게 로그인 처리하기앱 로그인 시 refreshToken을 사용하여 보다 세션을 오래 유지하면서 token을 안전하게 처리할 수 있는 방법을 소개한 글이다. JWT 형식으로 생성된 accessToken은 일정 시간이 지나면 만료되지만, 클라이언트에서 refreshToken을 오래 유지하면서 지속적으로 서버에 요청을 보내면 그때마다 새로운 accessToken을 보내줄 수 있기 때문에 유용하다. 알고 있는 대로 token을 localStorage나 쿠키에 저장하는 것은 XSS 공격과 CSRF 공격에 취약할 수 있다. 이때 쿠키에 refreshToken만 저장하고 새로운 accessToken을 받아와 인증에 이용하는 구조에서는 CSRF 공격을 방어할 수 있다. 여기서 쿠키를 이용할 때는 secure 옵션과 httpOnly를 사용해야 한다. ✅ secure - HTTPS가 아닌 통신에서는 쿠키를 전송하지 않는다.✅ httpOnly - 브라우저에서 JavaScript로 쿠키에 접근할 수 없다. (오직 http를 통한 전송만 가능) 쿠키에 refreshToken만을 secure httpOnly 쿠키에 저장하고, accessToken은 앱 내 변수로 관리한다. 그러나 XSS 취약점을 이용한 API 요청 공격은 클라이언트와 서버에서 추가적으로 방어해줘야 한다. 시간이 지나 accessToken이 만료되었다면 클라이언트는 서버에 refreshToken을 보내 새로운 refreshToken과 accessToken을 전달 받는다. XSS 공격의 취약점을 방어하기 위해서는 사용자가 악의적으로 입력한 코드가 HTML 또는 JavaScript로 인식되지 않도록 escape 처리를 해주는 등의 방식이 있다. (React에서는 자동으로 처리해주기도 한다.) refreshToken과 accessToken을 결합하여 세션이 만료되어도 유저가 다시 직접 로그인하도록 유도하지 않고 조용히 자동으로 로그인을 연장하게끔 기능을 구현할 수도 있다. Ref https://velog.io/@yaytomato/프론트에서-안전하게-로그인-처리하기 비동기 처리 시 race condition 고려하기하나의 처리를 위해 다수의 작업이 동시에 수행되는 경우, 처리를 제어하는 입장에서 무엇이 먼저 완료될지 예측하는 것은 어렵다. 즉 요청 순서와 응답 순서가 반드시 같지는 않다. 여러 개의 요청을 보냈을 때 마지막 응답의 결과는 매번 바뀔 수 있기 때문에, 마지막 요청에 대한 응답만을 처리해줘야 하는 상황이 발생한다. 이때 AbortController를 사용하여 특정 시점 자체의 요청 자체를 중단시킬 수 있다. AbortController는 브라우저 Web API로, fetch 등의 요청을 취소할 수 있는 메서드를 제공한다. 123456789// AbortController 인스턴스를 생성한다.const controller = new AbortController();fetch(url, { signal: controller.signal,});// 원하는 시점에 해당 요청을 취소한다.controller.abort(); debounce, throttle 등 불필요한 이벤트의 반복을 줄일 수 있는 방법을 함께 사용한다면 비동기 처리의 안전성을 더욱 높일 수 있다! Refhttps://github.com/woowacourse/tecoble/blob/2c793ef26f3004480c822d4aff79b96a525027a2/src/content/post/2021-09-12-race-condition-handling.md (테코블 업로드되면 수정 필요)https://developer.mozilla.org/ko/docs/Web/API/AbortController 기타React Design PrinciplesRef https://ko.reactjs.org/docs/design-principles.html S3, Cloudfront, 도메인 연결, dev server 추가Ref https://wnsah052.tistory.com/199?category=922546 메모&amp;정리용 앱Refhttps://www.mindnode.com/https://botobo.kr/https://transno.com/https://workflowy.com/hello/ 마무리미션하느라 며칠 제대로 자지도 못하고 거의 울상이었다. 백신도 맞은 채로 무리한 게 확실하다. 피할 수 없었던 번아웃이 온 게 맞지만 회복할 여유조차 없다. 약간 예민해져 있었는데, 그래도 잘 컨트롤하려고 노력했던 것 같다. 마지막 데모데이 날 대유행어가 탄생하고 말았다. 이제 혼자 두 달 남짓한 기간 동안에도 잘할 수 있겠지? 그래왔던 것처럼.","link":"/2021/09/18/woowa-week-32/"},{"title":"우테코 33주차 기록","text":"SSR | 웹 접근성 미션 | EC2 배포 놀토 프로젝트이번주는 수업이 너무 많았어서, 수업만 듣고 SSR 하다가 다 끝났다. 다음주엔 수업이 더 많다! 😵 마지막 스프린트인 만큼 백엔드 팀원들과의 협업도 거의 없었고, 프론트 페어인 미키와 SSR, refreshToken에 대해서만 실컷 논의하다 끝났다. 프론트엔드SSR🍀 여기서 읽기 AWS EC2로 Next.js 서버 배포하기🍀 여기서 읽기 React 18 (alpha)🍀 여기서 읽기 공부하기웹 접근성 미션React로 간단한 SpinButton 컴포넌트를 만들고, 웹 접근성을 최대한 높일 수 있게끔 개선하는 과제를 수행했다. lighthouse의 Accessibility 점수, WAVE 등의 툴에서 에러 없이 높은 점수를 받을 뿐 아니라 실제 스크린리더를 통해 읽었을 때 문제없는 앱을 만들기 위해 고민했다. 맥북의 VoiceOver를 사용했는데, 상세한 세팅 방법을 봐도 정말 모르겠다 😵 음성도 너무 쩌렁쩌렁하고… 눈으로 모니터를 보는 데 어려움이 있는 분들이 정말 웹서비스를 이용하기가 어렵겠다는 생각이 들었다. aria- 속성은 우테코 과정을 진행하며 처음 알게 되었는데, 수 개월이 지나서 이제서야 실제로 제대로 써본다. 레진의 WAI-ARIA 가이드라인과 MDN WAI-ARIA Basics를 많이 참고했다. 이번 미션에서 사용하거나 참고한 aria- 속성들은 다음과 같다. ✔️ aria-labelledby, aria-label, aria-describedby모두 현재 요소에 설명을 제공하는 속성이다. aria-label 속성은 값에 ‘간결한’ 설명(string)을 직접 제공한다. aria-labelledby는 다른 태그의 id 속성과 연결지어 함께 사용한다. (aria-describedby도 마찬가지다.) ✔️ aria-hidden접근성 API(보조기기 접근 가능성) 차단 상태를 결정한다. 화면에 표시하지만 잠시 사용을 제한하는 콘텐츠에 적용한다. ✔️ aria-live실시간으로 내용을 갱신하는 영역을 의미한다. 값으로 polite, assertive, off(default)를 설정할 수 있으며 갱신하는 내용의 중요도에 따라 선택한다. polite 값은 중요도가 낮은 내용에 사용하여 현재 진행중인 음성 또는 타이핑을 방해하지 않고 뒤늦게 전달한다. assertive 값은 중요도가 높은 내용에 사용하여 현재 진행중인 보조기기 작업을 중단하고 갱신 내용을 즉시 사용자에게 전달한다. alert=&quot;role&quot;이면 aria-live가 암묵적으로 assertive가 된다. ✔️ aria-relevantaria-live 영역에 발생한 변화를 묘사하기 위해서 사용한다. ✔️ aria-disabled일반적으로 disabled된 버튼은 흐릿하게 변하지만, 시각적인 어려움을 겪는 유저의 경우 알아차리기 힘들다. 게다가 disabled 속성의 버튼은 스크린리더가 읽어주지 않기 때문에 aria-disabled를 사용한다. ✔️ aria-invalid주로 input 요소에 선언하여 사용자가 입력한 값이 요구하는 형식과 일치하는지 여부를 나타낸다.aria-errormessage 속성과 함께 사용하여 오류 설명을 제공할 수 있다. ✔️ aria-atomic=”true”영역의 일부만 변경되었더라도 스크린리더가 전체를 읽을 수 있게끔 설정한다. ✔️ aria-current현재 맥락과 일치하는 항목을 의미한다. token 값으로 page|step|location|date|time|true|false(default) 중 하나를 사용할 수 있다. ✔️ aria-valuemin/ aria-valuemaxrole이 slider, spinbutton, progressbar일 때 사용하는 속성이다. 스크린리더가 읽어주지는 않는다. role을 붙여 콘텐츠의 역할을 명시해줄 수도 있다.ex) role=status는 성공(또는 결과) 상태 메시지를 사용자에게 전달한다. 사용자의 현재 작업을 방해하지 않고(초점을 옮기지 않고) 보조기기 사용자에게 메시지를 전달하는 것을 의도로 한다. MDN에서 기타 다양한 role 속성들을 확인할 수 있다. React에서 eslint-plugin-jsx-a11y 플러그인을 설치하여 JSX 구문에 대하여 a11y(Accessibility) 검사를 수행할 수 있다. CRA가 기본으로 제공하는 a11y 검사 기능도 있지만, 더 많은 부분을 체크하기 위해 사용한다. CDN 알아보자✅ 리소스 전달(Resource delivery)CDN을 사용하는 것은 오리진 서버에서 리소스를 가져오는 것보다 빠르다. 하지만 CDN이 오리진 서버와 connection을 유지하는 비용도 발생한다. CDN과 오리진 서버 사이의 connection은 대역폭을 더 넓게 사용하거나, CDN과 오리진 서버 사이에 여러 개의 CDN을 배치하는 방식을 사용한다. ✅ 캐싱(Caching)CDN에 리소스를 캐싱하는 경우 클라이언트 요청 시 오리진 서버에서 매번 리소스를 받아올 필요가 없다. 이는 리소스 전달 속도를 높이고 오리진 서버의 부하를 줄여준다. 가장 일반적인 CDN 캐시 사용 방식은 CDN이 필요 시 리소스를 받아오는 것이다. 첫 번째 요청이 발생하면 CDN은 오리진 서버로부터 리소스를 받아와 응답을 캐시한다. 캐시의 스토리지 용량은 제한적이기 때문에, 최근에 요청되지 않은 데이터의 캐시를 지워 용량을 확보한다. 또는 리소스의 변경 시 purging을 통해 캐시를 강제로 지워줄 수도 있다. purging을 사용할 때는 태그를 사용해서 캐시된 리소스를 구분할 수 있다. ✅ CDN 선택하기(Choosing a CDN)CDN 선택에 있어서 일반적으로 ‘성능’이 가장 중요한 고려사항이지만, CDN이 제공하는 보안 또는 분석과 같은 다른 기능들도 살펴볼 필요가 있다. CDN의 성능은 지연을 최소화하는 것과 캐시 히트 비율(cache hit ratio)를 최대화하는 것에 달려있다. 또 CDN의 성능은 지역에 따라 달라지기도 한다. 이에 더해 CDN은 로드밸런싱/이미지 최적화/비디오 스트리밍/엣지 컴퓨팅/보안 등의 기능을 제공한다. ✅ CDN 설정CDN의 CHR(Cache Hit Ratio)를 높이기 위해서는 로직상으로 동일한 서버 응답이 따로따로 캐시되지 않도록 해야 한다. 서버 응답은 query params(순서), cookies, 리퀘스트 헤더에 따라 서로 다른 것으로 해석될 수 있다. TTL(Time To Live) 값을 높여 불필요한 오리진 서버로의 접근을 줄여주는 것도 CHR 개선에 도움이 된다. CDN 캐싱 기능을 사용하기 위해서는 아래 헤더 중 하나를 사용해야 한다. 123Cache-Control: max-ageCache-Control: s-maxageExpires 여기에 더해 Cache-Control: immutable를 추가하여 캐시된 리소스가 신선한(freshness) 동안에는 업데이트되지 않음을 명시해줄 수 있다. 브라우저는 브라우저 캐시로부터 가져온 리소스를 재검증(revalidate)하지 않아 불필요한 서버 요청을 보내지 않는다. (Firefox와 Safari에서만 지원한다 - Chrome은 지원하지 않는다고 한다 😈) 이밖에도 파일 튜닝, Vary 헤더, Set-Cookie 등이 CDN의 캐싱 기능에 영향을 줄 수 있으니 주의하자! ✅ CDN 성능 개선 CDN의 리소스는 gzip이나 brotli 등을 통해 압축할 수 있다. 성능을 가장 최적화하는 방식은 오리진 서버와 CDN에서 모두 brotli 방식의 압축을 하는 것이다. TLS 1.3 (Transport Layer Security)을 사용하여 TLS 1.2에 비해 더 나은 보안과 성능을 제공할 수 있다. TLS 1.3은 기존의 핸드셰이크 과정을 줄여준다. HTTP/2을 사용하면 멀티플렉싱, 스트림 우선순위 결정, 서버 푸쉬, 헤더 압축 등의 기능을 사용할 수 있다. 2020년부터 모든 메이저 브라우저에서 실험적으로 지원하고 있는 HTTP/3을 사용하면 head-of-line blocking을 제거하여 connection 셋업 시간을 단축시킬 수 있다. TCP 대신 UDP를 사용하여, 단일한 패킷 블록은 하나의 스트림만 블로킹하게끔 구현되었다. CDN은 exif 데이터를 제거하거나, webp등의 파일 확장자를 사용하는 방식으로 이미지 최적화를 진행한다. 또 HTML, CSS, JavaScript 파일에서 불필요한 코드를 제거하여 파일 크기를 최소화한다. 👾 가능한 모든 방식을 사용하여 콘텐츠를 최대한으로 캐시하자! Ref https://web.dev/content-delivery-networks/ 기타Github이 사용하는 Web Componentgithub은 vanilla JS를 사용한다고 한다! vanilla JS에서 제공하는 Web Component에서도 충분히 React.js같은 재사용 가능한 컴포넌트를 만들거나 lifecycle을 흉내낼 수 있다. 물론 React.js를 완전히 대체하는 것은 아니며, 서로 별개의 개념이다 😉 Ref https://www.youtube.com/watch?v=RtvSgptpfnY 크롬 개발자도구 디버깅 꿀팁 모음Elements를 뜯어볼 때 유용한 팁들을 많이 소개하고 있다. Ref https://blog.bitsrc.io/9-element-tab-features-in-chrome-devtools-for-effective-debugging-1b02aa8f000a devJang도 참여하는 Next ConfRef https://nextjs.org/conf/tickets/oct21/devJang?s=1 레진 WAI-ARIA 가이드라인친절한 설명과 예시들까지 👍 Ref https://github.com/lezhin/accessibility/blob/master/aria/README.md 마무리오징어게임을 결국 다 보고… “나 무서워~~~!”라는 유행어와 함께 총을 든 지그🔫가 되어버렸다. 요즘은 감정도 사라지고, 갈수록 해탈해 가는 느낌인 것 같다. 분명 피곤한 건 아닌데, 엄청 힘이 없다. 빨리 철분제를 사다 먹어야겠다. 머리가 텅 비어가는 느낌…! 감정이 줄어든 건 오히려 나은 점이 많은 것 같기도 한데, 장기적으로 좋은 건진 모르겠다 🤔","link":"/2021/10/02/woowa-week-33/"},{"title":"우테코 34주차 기록","text":"SSR 버그 고치는 중 놀토 프로젝트SSR로 인한 각종 버그 고치기 대잔치…react-query를 적용하여 피드 데이터까지 서버에서 미리 받아서 브라우저에 렌더링해주도록 했다. express 서버에서 react-query로 데이터 내려주기접속한 앱의 페이지가 서버 데이터를 받아서 보여줘야 하는 컴포넌트라면, SSR 적용 시 서버에서도 함께 해당 데이터를 미리 받아서 내려주는 것이 좋다. 그래야 관련 피드를 검색했을 때 SEO에 반영되기 때문이다. 클라이언트에서 서버 데이터 fetch 사용하는 라이브러리인 react-query를 express 서버에도 적용시켜 보았다. react-query 공식 문서에서 지원하는 SSR 작성 방식은 다음과 같다. 123456789101112131415161718192021222324252627// server.jsimport { dehydrate, Hydrate, QueryClient, QueryClientProvider } from 'react-query';function handleRequest (req, res) { const queryClient = new QueryClient() await queryClient.prefetchQuery('key', fn) const dehydratedState = dehydrate(queryClient) const html = ReactDOM.renderToString( &lt;QueryClientProvider client={queryClient}&gt; &lt;Hydrate state={dehydratedState}&gt; &lt;App /&gt; &lt;/Hydrate&gt; &lt;/QueryClientProvider&gt; ) res.send(` &lt;html&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;${html}&lt;/div&gt; &lt;script&gt; window.__REACT_QUERY_STATE__ = ${JSON.stringify(dehydratedState)}; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `)} 약간 변형해서 다음과 같이 사용했다. 1234567app.get('/feeds/:feedId', (req, res) =&gt; { generateResponse(req, res, async (queryClient) =&gt; { await queryClient.prefetchQuery([QUERY_KEYS.FEED_DETAIL, Number(req.params.feedId)], () =&gt; getFeedDetail(Number(req.params.feedId)), ); });}); generateResponse 함수에서는 세 번째 인자로 전달 받은 query function을 실행하고, 해당 데이터를 serialize한 query data 정보를 클라이언트의 전역 변수(window)로 내려준다. (전체 코드는 🍀 여기서 읽기) 그리고 이를 사용하는 클라이언트의 리액트 앱 진입점에서 다음과 같이 사용한다. 서버에서 내려주는 query data 정보를 window 객체에서 __REACT_QUERY_STATE__로 불러와, Hydrate를 통해 리액트 앱에 심어준다. 1234567891011121314import { Hydrate, QueryClient, QueryClientProvider } from 'react-query'const dehydratedState = window.__REACT_QUERY_STATE__const queryClient = new QueryClient()ReactDOM.hydrate( &lt;QueryClientProvider client={queryClient}&gt; &lt;Hydrate state={dehydratedState}&gt; &lt;App /&gt; &lt;/Hydrate&gt; &lt;/QueryClientProvider&gt;, document.getElementById('root')) 개발자 도구의 Network 탭을 통해 서버에서 react-query 데이터를 내려주는 것을 확인할 수 있다! Ref https://react-query.tanstack.com/guides/ssr SSR에서 React Portal 사용하기SSR을 사용하니 react portal을 사용하는 SnackbarProvider 컴포넌트가 정상적으로 동작하지 않았다. BaseLayout이 SnackbarProvider 내부에 들어가버리는 바람에, snackbar가 뜨는 위치가 완전히 꼬여버린 것이다. 도대체 뭐가 문제인지 한참을 고민했다. 첫 번째 접근은, 서버가 React Portal을 이해하지 못하기 때문에 Portal은 클라이언트 단에서 처리해주자는 것이었다. React Portal은 현재 React app의 루트 컨테이너인 &lt;div id=&quot;root&quot;&gt; 외부에 DOM을 새로 생성하고, 해당 DOM 컨테이너에 컴포넌트를 렌더링하게 되므로 &lt;div id=&quot;root&quot;&gt;만 조작하고 있는 서버 단에서는 Portal의 렌더링을 컨트롤할 수 없는 것이다. 따라서 컴포넌트가 마운트되었을 때 비로소 Portal을 사용한 컴포넌트를 렌더링하는 방식으로 코드를 변경해주었다. 12345678910111213141516const SnackbarProvider = ({ children }: Props) =&gt; { const [isMounted, setIsMounted] = useState(false); useEffect(() =&gt; { setIsMounted(true); }, []) return ( &lt;Context.Provider value={contextValue}&gt; {children} {hasWindow &amp;&amp; isMounted &amp;&amp; ReactDOM.createPortal(snackbarElement, document.getElementById('snackbar-root'))} &lt;/Context.Provider&gt; ); } 이제 SnackbarProvider는 올바른 위치에서 정상적으로 동작하지만, 어떤 이유에선지 서버에서 아무 데이터도 내려주고 있지 않았다. 그냥 다시 CSR이 된 것이다. 🤯 아래처럼 SnackbarProvider를 loadable을 이용해서 lazy loading해주어도 마찬가지였다. ({ ssr: false } 옵션을 적용했다.) 123456789101112131415// App.tsximport SnackbarProvider from 'contexts/snackbar/SnackbarProvider';const SnackbarProvider = loadable( () =&gt; import(/* webpackChunkName: &quot;SnackbarProvider&quot; */ 'contexts/snackbar/SnackbarProvider'), { ssr: false },);const App = () =&gt; { return ( &lt;SnackbarProvider&gt; // .. &lt;/SnackbarProvider&gt; )} 문제는 따로 있었다! styled-components는 하나의 전역 카운터를 두고 이를 기반으로 classname을 생성하는데, 현재 클라이언트 용 webpack.common.js와 서버 용 webpack.server.js가 서로 다른 babel 환경을 가지고 있어서 클라이언트에서 생성된 styled-component classname과 서버에서 생성된 classname이 달랐다. 이를 해결하기 위해서는 babel.config.json으로 통일된 babel 환경을 관리하거나 클라이언트와 서버가 같은 webpack 설정을 가지도록 하는 방법이 있다. 여기서는 후자의 방법을 선택하여, webpack의 merge 메서드를 활용했다. webpack.common.js와 webpack.server.js가 같은 babel-plugin-styled-components 플러그인을 사용함으로써, classname으로 컴포넌트 생성 시 서로 충돌이 발생하지 않는다. Ref https://blog.shift.moe/2021/01/ 공부하기JSON.stringify 대신 serialize를 하는 이유SSR에서 react-query를 사용하며 서버에서 미리 받아오는 react-query의 데이터를 window 객체를 이용해 전역 변수로 내려줘야 했다. 이때 공식문서에서는 react-query 데이터 타입을 string으로 바꿔주기 위해 다음과 같이 JSON.stringify를 사용하고 있다. 가장 일반적으로 생각해볼 수 있는 방식이다. 12345678res.send(` // ... &lt;div id=&quot;root&quot;&gt;${html}&lt;/div&gt; &lt;script&gt; window.__REACT_QUERY_STATE__ = ${JSON.stringify(dehydratedState)}; &lt;/script&gt; // ... `) 그러나 이때 누군가가 악의적으로 전역 변수에 script 태그를 삽입한다면? 😈 123&lt;script&gt; window.__userInJSON__ = {&quot;username&quot;:&quot;&lt;/script&gt; &lt;- 여기까지만 의도한 대로 실행 &lt;script&gt;alert(\\&quot;요건 몰랐지\\&quot;)&lt;/script&gt;&quot;}&lt;/script&gt; script 태그를 임의적으로 삽입하여 악의적인 동작을 수행하는 XSS 공격을 막기 위해 &lt;/ 같은 문자를 &amp;lt; 같은 HTML 엔티티로 바꿔줘야 한다. 이때 serialize를 사용한다. URL 쿼리 파라미터들을 자동으로 연결해주는 역할만 해주는 줄 알았는데, 이런 기능까지 해주다니! 똑똑하고 유용한 친구다. 기타Responsive Images✅ 마크업 이미지 이미지에 상대 크기 사용 높은 DPI 기기에서 srcset로 img 개선 picture가 있는 반응형 이미지에서의 아트 디렉션 압축 이미지 자바스크립트 이미지 대체 - pageload 이벤트가 실행될 때까지 이미지 로딩을 지연 이미지 인라인 처리: 래스터(png, jpeg, webp) 및 벡터(svg) 데이터 URI - img src 요소를 Base64 인코딩 문자열로 설정 CSS에서 인라인 처리 - HTTP 요청을 줄일 수 있다. ✅ CSS의 이미지 조건부 이미지 로딩 또는 아트 디렉션에 미디어 쿼리 사용 image-set을 사용하여 고해상도 이미지 제공 미디어 쿼리를 사용하여 고해상도 이미지 또는 아트 디렉션 제공 ✅ 아이콘에 SVG 적용 간단한 아이콘을 유니코드로 대체 복잡한 아이콘을 SVG로 대체 주의해서 아이콘 글꼴 사용 ✅ 성능을 위해 이미지를 최적화 올바른 형식 선택: 벡터 이미지 및 래스터 이미지 고려, 올바른 압축 형식 선택 파일 크기 줄이기 - 저장 후 이미지 사후 처리(무손실 압축 등) image sprite 사용 지연 로딩 고려 ✅ 이미지는 절대 피하세요 이미지에 삽입하는 대신 마크업에 텍스트를 배치 CSS를 사용하여 이미지 대체 Ref https://developers.google.com/web/fundamentals/design-and-ux/responsive/images#replace_complex_icons_with_svg 레스토랑에 비유해서 알아보는 운영체제Ref https://wormwlrm.github.io/2021/10/04/OS-Restaurant.html 웹 부트캠퍼 개발자를 위한 컴퓨터 과학Ref https://www.wisewiredbooks.com/csbooks/index.html 마무리끝나지 않는 SSR..!! 그 와중에 수업도 꽤 많았고, 시간도 부족했다. (하지만 타입스크립트 특강은 정말 재밌고 유익했다!) 면접도 한 개 봤다. 지난 미션을 오래오래 걸려 마쳤지만 더 대박인 마지막 미션도 나왔다. 감도 잡히지 않지만 유종의 미를 거두기 위해서 또 열심히 쏟아봐야겠다. 또 한 달 여 만에 놀토 팀원들을 만나러 갔다. 처음 가보는 잠콩에서는 오며가며 대략 20명의 크루를 만난 것 같다 🤣🤣🤣 정말 3개월 만에 루터도 가서 티셔츠와 후드티도 받아오고, 나 빼고 다 접종완료된 팀원들 덕분에 회식도 했다. 3개월 전보다 확실히 더 편해지고 끈끈해진 느낌이다. 모두 가고싶은 곳에 취업 잘 해서 한 턱씩 쏘는 날이 빨리 왔으면 좋겠다 😊","link":"/2021/10/09/woowa-week-34/"},{"title":"우테코 35주차 기록","text":"끝나지 않는 SSR | 로그인에 refreshToken 이용하기 | setState에 await을 붙이면? 놀토 프로젝트SSR을 적용하며 발생하는 각양각색의 버그에 대응하고, 갑자기 깨져버리는 mp4 파일도 대응하고, 여러가지로 고난의 세월을 보내고 있다. 그리고 refreshToken을 이용하여 기존의 로그인 방식을 개선하고 있다. 만만치 않을 것이라고는 생각했는데, 정말 생각보다 더욱 만만치 않다. 세상 일이 이렇게 뜻대로 되는 게 드문 시기다. 🤷‍♀️ 아래에서 확인 가능하다. 프론트엔드 공부로그인에 refreshToken 이용하기🍀 여기서 읽기 React의 setState에 await을 붙이면?🍀 여기서 읽기 공부하기JavaScript의 단축 평가&amp;&amp;, || 그리고 null 병합 연산자인 ??까지. 습관적으로 사용했지만 기대값을 확실하게 알고 쓰지 못했던 JavaScript의 단축 평가에 대해 정리해 보자. &amp;&amp;(논리곱) 연산자는 두 개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 1'Cat' &amp;&amp; 'Dog' // &quot;Dog&quot; 첫 번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 두 번째 피연산자까지 평가해 보아야 한다. 여기서는 논리 연산의 결과를 결정하는 두 번째 피연산자, 두 번째 피연산자인 ‘Dog’을 반환한다. ||(논리합) 연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 1'Cat' || 'Dog' // &quot;Cat&quot; 첫 번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 두 번째 피연산자까지 평가해 보지 않아도 위 표현식을 평가할 수 있다. 여기서는 논리 연산의 결과를 결정한 첫 번째 피연산자, 즉 문자열 ‘Cat’을 반환한다. 이처럼 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 단축 평가라 한다. 단축 평가 표현식 평가 결과 true || anything true false || anything anything true &amp;&amp; anything anything false &amp;&amp; anything false 🤔 이제, 헷갈리는 부분 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 12const elem = null;const value = elem &amp;&amp; elem.value; // null 위 예제에서 elem이 null이나 undefined와 같은 falsy 값이면 elem으로 평가되고, elem이 Truthy 값이면 elem.value로 평가된다. 막상 적고 보니 그리 헷갈리는 내용도 아니었다.그렇다면 마지막으로 null 병합 연산자인 ??도 살펴보자. ?? 연산자는 무려 ES11에서 도입되었다고 한다. 엊그제 생긴 셈! ??는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다. 12const foo = null ?? 'default string';console.log(foo); // &quot;default string&quot; ??는 변수에 기본값을 설정할 때 유용하다. 논리 연산자 ||를 사용한 단축 평가의 경우 좌항의 피연산자가 falsy 값이면 우항의 피연산자를 반환한다. 만약 falsy 값인 0이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생할 수 있다. 12const foo = '' || 'default string';console.log(foo); // &quot;default string&quot; 하지만 null 병합 연산자 ??는 좌항의 피연산자가 falsy 값이라도 null 또는 undefined가 아니라면 좌항의 피연산자를 그대로 반환한다. 12const foo = '' ?? 'default string';console.log(foo); // &quot;&quot; Ref 모던 자바스크립트 Deep Dive 9-4절 모두 알지만 모두 모르는 package.json(뜨끔 🙄) name과 version은 필수적으로 명시해준다. description과 keywords를 작성하여 npm search로 검색된 리스트에 표시되게끔 해준다. people fields는 author와 contributors로 구분된다. files는 프로젝트에 포함된 파일의 배열, directories는 패키지 구성을 나타낸다. bin을 사용하여 실행할 수 있는 패키지를 구성할 수 있다. scripts 항목은 패키지의 생명주기 중 다양한 타이밍에서 실행되는 script 명령어들을 포함하고 있는 사전이다. dependencies 의존성 규정을 패키지의 이름과 해당 패키지의 버전 범위를 지정한 객체를 통해 이루어진다. semver를 참고하여 버전 범위를 지정하자. devDependencies는 운영이 아닌 개발 단계에서만 필요한 의존성 모듈들을 가리킨다. peerDependencies는 어떤 패키지가 다른 (호스트) 패키지와 호환성을 가지고 있음을 표현한다. 즉 다른 모듈과 함께 동작할 수 있다는 호환성을 표시하는 것이다. 이를 일반적으로 플러그인이라고 한다. npm 2.0.0부터 로컬 경로(local paths)를 패키지에 포함시킬 수 있다. engines로 동작 가능한 node의 버전을, os로 모듈이 어떤 운영체제에서 작동하는지 지정할 수 있다. cpu는 특정한 CPU 아키텍쳐에서만 동작한다는 것을 명시한다. publishConfig는 publish할 때 사용되는 설정으로, tag와 registry, access를 다룰 수 있다. Ref https://programmingsummaries.tistory.com/385 array.filter(Boolean)webpack config를 뜯어보다가 신기한 문법을 발견했다. 123plugins: [ process.env.NODE_ENV === 'production' ? new Plugin() : false,].filter(Boolean) 배열에서 filter를 돌릴 때 조건을 Boolean으로 제공하면, 배열의 요소 중 falsy 값을 제거한 깔끔한 배열을 만들 수 있다. 즉 아래와 같이 false, 0과 같은 falsy 값들을 제외해준다. 12let array = [false, 0, -0, 0n, &quot;&quot;, null, undefined, NaN, { hello: &quot;world&quot; }];console.log(array.filter(Boolean)); // [{ hello: &quot;world&quot; }] Ref https://velog.io/@yongbum/filter-boolean JavaScript 엔진은 어떻게 내 코드를 실행하는 걸까? Ignition직역하면 ‘점화’라는 뜻이다. V8 엔진이 소스코드에서 뽑아낸 AST(추상 구문)를 바이트코드로 변환하는 인터프리터다. 자바스크립트 코드를 곧바로 기계어로 컴파일하는 것보다 바이트 코드를 컴파일하는 것이 더 효율적이기 때문에, 한 차례 인터프리터를 거친다. Ignition은 코드 한줄 한줄을 바이트 코드로 바꿔주는 친구다. 👾 바이트 코드?직접 CPU 내의 레지스터와 누산기를 어떤 식으로 사용할지 명령하는 명령문이다. 사람이 이해하긴 어렵지만 컴퓨터 입장에서는 이해하기 좋은 방식이다. TurboFanV8 엔진은 런타임 중에 Profiler라는 친구에게 함수나 변수의 호출 빈도와 같은 데이터를 모으라고 시킨다. 이렇게 모인 데이터를 가지고 자주 사용되는 코드는 TurboFan에서 최적화된 코드로 다시 컴파일한다. 최적화 기법으로는 히든 클래스(Hidden Class)나 인라인 캐싱(Inline Caching) 등의 기법을 사용한다. 아직까지는 정확히 모르겠지만, JavaScript 엔진이 굉장히 분주하게 소스코드 최적화를 위해 움직이는 것을 알 수 있었다. Ignition과 TurboFan을 이용하여 바이트코드와 최적화된 코드 사이를 왔다갔다 하는 모습이 귀엽게 느껴진다. 😗 Ref https://evan-moon.github.io/2019/06/28/v8-analysis/ 기타FEConf 2021Ref https://2021.feconf.kr/ state of css surveyRef https://stateofcss.com/ 마무리백신 2차를 맞았다. 아팠다. 그렇지만 타이레놀 갓갓. 1차 때도 사흘을 아팠던 나인데, 타이레놀 두 알 먹고 하루 반나절 아프고 나았다. 얕고 길게 아팠던 1차 때와 달리, 크고 짧게 아프고 나았다. 사이트도 만들었다. 영상도 만들었다. 또 코딩 외적으로 시간을 대거 투자했다. 회사 가면 이런 일은 없겠지? 그럼에도 글도 쓰고, 또 면접 보고, 미션도 어떻게 마무리하긴 했다. 알차게 놀기까지! 정말 가득가득 채운 삶","link":"/2021/10/16/woowa-week-35/"},{"title":"우테코 36주차 기록","text":"할로윈 테마 | 테스트가 펑펑 놀토 프로젝트지난주 마무리되었다고 생각했던 refreshToken은 만료 시 accessToken의 자동 업데이트가 되지 않았고… 😵 문제는 백엔드에서 유효기간을 잘못 내려주고 있던 것에 있었다. 여차저차 잘 해결했다. 지난 9월 중순 나름의 인기였던 추석 테마를 끝내고, 10월 마지막 주인 다음주에 진행될 마지막 데모데이를 위한 할로윈 테마를 적용했다. footer도 만들었다. 나름 귀엽고 깔끔하다고 생각한다. github, email, 그리고 우테코 홍보용인 구글 사이트 링크를 첨부했다. 그런데! React 18로 이전하고 테스트를 한번도 제대로 돌리지 않아서 그랬을까. 모든 테스트가 우수수수 터져버렸다. 🤯 정말 못 살아…일단 어떻게든 고치는 중인데, 참 막막하긴 하다. 프론트엔드 공부Inversion of Control🍀 여기서 읽기 공부하기Flux로의 카툰 안내서Redux를 사용하다보니, Flux 패턴이 프론트엔드 면접 단골 질문이라는 사실을 잊었다. 정말 오랜만에 Flux 패턴을 설명한 아래 링크의 카툰을 다시 살펴봤다. Flux는 앱의 상태를 관리하기 위한 패턴 중 하나로, Facebook이 갖고 있떤 특정한 문제점들을 해결하기 위해 개발되었다. 기존에는 앱에서 사용자와의 상호작용이 View를 통해서 일어났기 때문에 사용자의 입력에 따라 View가 Model을 직접 업데이트하는 경우들이 있었다. 그리고 의존성 탓에 한 Model이 다른 Model을 업데이트해야할 때도 있었다. 아래와 같은 사태가 일어나기도 한다. 이러한 복잡한 변경들 탓에 데이터 흐름의 디버깅은 결국 꼬이고 만다. 해결책으로 등장한 것이 단방향의 데이터 흐름이다. ✔️ 액션 생성자(action creator) 는 모든 변경사항과 사용자와의 상호작용이 거치는 액션의 생성을 담당한다. 앱의 상태를 변경시키거나 View를 업데이트하고 싶다면 액션을 생성해야 한다.액션 생성자는 타입(type)과 페이로드(payload)를 포함한 액션을 생성한다. 액션 생성자는 액션 메시지를 생성한 이후 디스패처(dispatcher)로 넘겨준다. ✔️ 디스패쳐(dispatcher) 는 액션을 보낼 필요가 있는 모든 스토어(store)를 가지며, 액션 생성자로부터 액션이 넘어오면 여러 스토어에 액션을 넘긴다. 이 처리는 동기적으로 실행된다. 다른 아키텍쳐들과는 달리 Flux 아키텍쳐에서 디스패쳐는 액션 타입과는 상관없이 등록된 모든 스토어로 액션을 보낸다. ✔️ 스토어(store) 는 앱 내 모든 상태와 그와 관련된 로직을 갖고 있다. 모든 상태 변경은 스토어에서 결정된다. 스토어에 상태 변경을 요청하기 위해서는 반드시 액션 생성자-디스패쳐를 거쳐 액션을 보내야 한다.일단 스토어에서 상태 변경이 완료되면, 변경 이벤트를 내보내 View에 상태가 변경되었다는 것을 알려준다. ✔️ 뷰(View) 는 받은 데이터를 처리해 유저가 실제로 보는 화면을 구성한다.(사실 구체적으로는 Controller View와 일반 View로 더 구분할 수 있지만, Controller View를 자주 사용해보지 않아서 여기서는 View 하나로만 작성했다.) Ref https://bestalign.github.io/translation/cartoon-guide-to-flux/ 기타OKRObjective and Key Results Objective - 목표에 대한 정성적인 설명 KR - 이것을 달성했다는 것을 알려주는 구체적인 수치 👎 Bad구성원의 동기부여되는 목표보다 성과를 내기 위한 구체적인 수치를 먼저 정하는 실수➡️ 동기부여가 아닌 압박이 될 수 있다. Objective는 단순하지만 영감을 주고 동기를 부여하기 위해 존재한다. Objective는 정성적인 문장으로 작성해야 한다. 👍 GoodKey Results는 구체적인 수치가 들어가면 좋다. 목표가 실현될 수 있도록 구체적으로 측정하고 피드백할 수 있어야 한다.Key Results가 모두 달성되었을 때, Objective가 달성되었는지에 대한 점검이 반드시 필요하다. Key Results는 Objective를 달성하기 위한 구체적인 지표일 뿐 아니라 결과여야 한다. 지금 나의 OKR은?(비밀) Refhttps://brunch.co.kr/@tanagement/183http://blog.hwahae.co.kr/all/tech/tech-tech/3737/ monitorEvents크롬 개발자 도구에서 monitorEvents(object [, events]) API를 사용해서 특정 이벤트만 모니터링해볼 수 있다. 특정 함수를 모니터링하는 monitor(function)도 있다! 1234function sum(x, y) { return x + y;}monitor(sum); 싱기방기 Refhttps://developers.google.com/web/updates/2015/05/quickly-monitor-events-from-the-console-panelhttps://developer.chrome.com/docs/devtools/console/utilities/#monitor-function Incremental DOM과 Virtual DOM 비교Incremental DOM은 Angular에서 Virtual DOM 대신 선택한 방식으로,… Virtual DOM은 UI 가상 표현을 메모리상에 두고 재조정(Reconciliation) 과정을 통해 실제 DOM이 업데이트된 부분만 렌더링하는 과정을 거친다. Incremental DOM은 코드 변경 시 메모리상에 실제 DOM에 대한 Virtual DOM을 생성하지 않고, 새로운 렌더 트리와 차이를 비교하는 데 실제 DOM을 사용한다. 메모리에 따로 저장하는 데이터가 없기 때문에, 메모리를 효율적으로 사용할 수 있어 휴대전화와 같이 메모리가 작은 장치에서 사용할 때 이점이 된다. 또 Incremental DOM은 명령 묶음을 통해 모든 컴포넌트를 컴파일한다. 이 명령들은 DOM 트리를 생성하고 변경점을 찾아낸다. 컴파일 시점에 불필요한 명령들을 제거하여 트리쉐이킹이 가능해진다. (Virtual DOM은 인터프리터로 사용되기 때문에 트리쉐이킹이 불가능하다.) Incremental DOM은 기존 Virtual DOM에서 발생하는 메모리 사용량의 문제를 줄이고, Virtual DOM끼리 비교하는 계산 과정의 오버헤드를 줄인다. 그러나 DOM 업데이트 간의 차이를 계산하는 데 Virtual DOM보다 더 많은 시간을 쓰기 때문에 대부분의 경우 Virtual DOM보다 느리다. (뭐람..🤔) Ref https://ui.toast.com/weekly-pick/ko_20210819 네이버 FE 1년차 후기 FE개발은 생각보다 개발에 온전히 집중하기보다 일정 안에 프로젝트를 완성하기 위해 기획안을 조절하는 데 초점이 맞춰진다 FE개발이란 무엇일까… 🤔 모든 이의 사랑/평화/우정 을 위해 책임감을 가지고 내 일을 제때 해내는 성실함이 중요하다 그렇다. 기획/디자인/백엔드/마크업과 모두 합이 잘 맞아야 하는 것이다…으아아 😵 혼자 일하다 쉬는 시간의 반복이다보니 인맥이 쌓이기보단 뱃살만 쌓이는 것이다. SNS 를 둘러보면 정말 많은 분들이 업무 외 활동을 하시는데 존경스러울 뿐이다. 🤣🤣🤣 웃픈 인생이다… Ref https://velog.io/@kim-taewoo/내가-개발자가-될-상인가-네이버-FE-1년차-후기 마무리하나 둘 취업에 성공하는 크루도 있고, 아쉽게 떨어지는 크루도 있다. 나 역시도 수 차례 떨어져봐서 그 허탈함을 잘 안다. 모두가 힘든 시기라고 한다. 사실 나는 그렇게 바쁘지도 않고, 싱숭생숭하지도 않고, 별 생각이 없다. 그보다는 무릎을 다친 탓에 운동을 못해서 힘든 게 가장 크다. (힘이 없다.) 이럴 때일수록 더욱 크루들과 이야기하고, 서로 힘이 되어주는 게 좋을 것 같다.","link":"/2021/10/23/woowa-week-36/"},{"title":"우테코 38~39주차 기록","text":"우아한형제들 지원 기간 놀토 프로젝트놀토 프로젝트는 마무리가 됐지만, 우리 팀은 끝나지 않았다. 내가 제안했던 롤링페이퍼와 마니또도 즐겁게 참여해주고, 아직까지 데일리도 하고 있다. 면접 질문을 주제로도 하고, 아니면 정말 자유롭게 아무 이야기나 들고 오기도 하고… 누군가에게는 아침에 일찍 일어나게 해주는 시간, 누군가에게는 팍팍한 취준생의 삶 속에서 함께 이야기 나누는 것만으로도 힘이 되는 시간일 것이다. 새삼 오늘 프로젝트를 다시 한 번 찬찬히 뜯어봤더니, 정말 잘 만들었다는 생각이 든다 🤩 프론트엔드 공부이번주는 간단하게 cookie와 session의 차이점 프로젝트에서 SSR이 필요했던 이유와 동작 원리 프로젝트에서 nginx를 사용한 이유, 프록시의 역할 OAuth와 refreshToken을 이용한 로그인 흐름 프론트엔드에서의 상태관리 Context API는 ‘상태관리’가 아니다 클라이언트와 서버가 따로 존재하는 이유 React의 render phase와 commit phase Refhttps://goidle.github.io/react/in-depth-react-intro/ 공부하기이번주는 간단하게 JavaScript callback JavaScript Proxy를 이용한 상태 업데이트 추적 TypeScript Interface vs Type any vs unknown vs never Union &amp; Intersection Type enum JavaScript는 왜 싱글 스레드 언어일까? Map vs 일반 객체 기타 취준을 앞두고 올해 작성한 모든 블로그들을 살펴보며 리팩토링을 완료했다. 소프트스킬 질문들도 준비중 자소서 뜯어보기 Deno, Recoil 간단 설명 React 선택 이유 hook으로 Context Provider 사용하기 Vue vs React WAS 간단 설명 debounce React 18, ErrorBoundary와 Suspense 고민말은 잘 하는 것 같은데, 뭐가 문제인지 모르겠다. 너무 장난스러워 보이거나, 약간 건방져 보이기도 하려나? 확실한 건 화장을 안 한 채로 면접한 영상을 돌려봤을 때 상당히 아파보인다는 것이다 😭 핼쓱해졌다는 주변의 말들이 틀린 게 아니었다. 그리고 어느 회사에 가야할지 모르겠다. 정말 실력적인 부분도 있겠지만, 각 회사에서 필요한 인재가 무엇인지 확실하게 알아야 할 것 같다. 별 고민 없던 시절 네임벨이 중요하다고 생각했는데, 그게 아닐 수도 있겠다는 생각도 조금씩 든다. 확실한 건, 지원하는 회사에 대한 애정을 보여야 한다는 것! 마무리날씨가 정말 추워졌다. 2주 사이 외투가 뽀글이에서 트렌치코트로, 그리고 겨울 코트로 바뀌었다. 다음주부터는 패딩을 꺼내야 할지도 모른다. 3월 초에 처음 패딩을 입고 만났던 크루들, 모두 다시 한겨울 복장을 하고 만났다. 자소서와 포트폴리오도 마무리하고, 매일 면접 준비를 하고 있다. 리크루팅 데이도 끝났다. 수 차례 변동이 있었지만, 다행히 정상적으로 진행됐다. 코로나 이후로 항상, 정말 이게 마지막 회식일지도 모르겠다는 사실 탓에 괜히 애틋한 마음까지 든다. 무려 4개월 간을 집에서만 진행했으니 더 그럴 수밖에… 그리고 생각보다 면접일이 뒤쪽으로 배정되었고, 마음이 붕 떠버렸다. 혼자 맘 속으로 송년회 하고 있다. 이틀 정도만 쉬었다가 다시 몰입해야겠다.","link":"/2021/11/13/woowa-week-38-39/"},{"title":"우테코 마지막 주차 기록","text":"면접 | 그리고 마지막 프론트엔드 공부(면접 주간 Pass) 공부하기(면접 주간 Pass) 기타JavaScript의 비동기와 async-await 다시 공부하기Refhttps://medium.com/sjk5766/async-await-원리-cc643f18526dhttps://velog.io/@jjunyjjuny/번역-자바스크립트-시각화-비동기-처리 TypeScript와 Redux Saga 함께 사용하기어느 회사의 과제전형을 수행하면서 오랜만에 Redux Saga를 쓰게 되었다. 네트워크 응답 상태를 REQUEST, SUCCESS, FAILURE 3가지로 구분해서 만들어주는 모듈을 작성하여 action과 reducer를 깔끔하게 작성해보자! Refhttps://vallista.kr/2020/07/20/TypeScript에서-Redux-Redux-Saga-아름답게-개발하기 msw로 테스트 데이터 mocking하기카카오 팀에서 MSW(Mock Service Worker)를 사용하여 프론트엔드 개발을 한다는 이야기. 기획자 : XX 작업은 어떻게 진행 중인가요?프론트엔드 개발자 : 그게… 아직 API가 준비되지 않아서 다음 주까지는 기다려야 합니다. 😂😂😂 그래서 나온 결론이? “API가 개발되기 전에 프론트엔드 개발을 마치자.” 😮😮😮 테스트 환경 뿐 아니라, API 문서가 나오지 않았을 때도 msw를 사용해서 실제로 개발을 할 수도 있다!이밖에도 Service Worker를 사용하는 경우들은 다음과 같다. 네트워크가 원활할 때 동기화를 시켜주는 백그라운드 동기화 기능 높은 비용의 계산을 처리할 때 푸시 이벤트를 생성할 때 🤩 네트워크 요청을 가로채는 행위도 수행 MSW는 Service Worker를 기반으로 모의 API를 만들어내기 때문에 다른 프론트엔드에서 사용하는 수많은 라이브러리나 프레임워크에 종속적이지 않고 호환성에 문제없이 동작한다 MSW의 동작 원리는 아래와 같다. 네트워크의 요청을 가로챌 뿐만 아니라, 응답 시간과 응답 상태, 응답 결과까지 제어가 가능하다. 특정 상황에서 에러를 일으킬 수도 있다. 각기 다른 네트워크 응답 상태에 따른 화면의 변경사항을 좀더 쉽게 개발하고 쉽게 디버깅할 수도 있는 것이다. MSW를 잘 활용해서 프론트엔드 개발의 생산성을 높여보자! Refhttps://tech.kakao.com/2021/09/29/mocking-fe/ FxJS 타입스크립트 버전, FxTSRxJS의 Rx는 Reactive extensions의 줄임말로, 상태관리에 반응형 프로그래밍을 사용하는 라이브러리라고 알고 있었다. FxJS는 처음 들어봤다. 공식 홈페이지에 ‘functional library’라고 표현한 것을 보아 함수형 프로그래밍에 유용한 기능들을 제공하는 것 같다. 그리고 최근 TypeScript 버전으로 출시된 것이 FxTS! 발음도 어렵고 서치도 힘들다 😵 아래와 같은 코드들을 제공한다고 한다.얼핏보면 (pipe의 메서드명 탓인가?) RxJS같기도 하다. 123456789import { pipe, range, map, filter, take, each } from &quot;@fxts/core&quot;;pipe( range(10), map((a) =&gt; a + 10), filter((a) =&gt; a % 2 === 0), take(2), each((a) =&gt; console.log(a)),); Refhttps://fxts.dev/https://github.com/marpple/FxTS 네이버 지식iN을 Flutter로 개발하는 이유네이버 지식iN 앱 개발에는 Flutter를 사용한다고 한다. 처음에는 iOS, Android 각각 따로 개발하였으나 당연히 플랫폼의 특성과 개발 인력의 차이 때문에 개발 단계에서 여러 문제에 마주하게 된다. 크로스 플랫폼 개발을 위해 Flutter를 도입하게 되었고, 그 배경이 정말 개발자스럽다(!) 크로스 플랫폼에 대한 구성원들의 평소 의견은 성능 및 러닝 커브에 문제가 있을 것이라고 했다. 그래서 여러 크로스 플랫폼으로 1차 테스트에서 간단한 프로토타입 개발 진행을 했고, 각 플랫폼 비교 시 Flutter가 가장 좋은 평가를 받았다. 성능상의 큰 차이도 없었다. 2차 테스트에서는 조금 더 난이도가 있는 과제를 진행했고, 기존 네이티브 방식으로 개발할 때보다 훨씬 수월함을 느꼈다. 그렇게 Flutter를 실제 개발에 적용하려고 했으나! 사내 라이브러리가 문제였다. 그래서 iOS와 Andriod 각 플랫폼에 라이브러리를 추가한 후 MethodChannel을 통해 Flutter에서 사용할 수 있도록 구현했다. 물론 큰 회사라서 가능한 일이겠지만, 1, 2차 프로토타입을 거쳐가며 개발자들의 의견을 모으고 라이브러리의 분리라는 또 다른 시도를 통해 기존의 레거시 코드에 과감하게 도전하고 앞으로의 생산성을 향상시켜 나가는 과정이 흥미로웠다. Refhttps://d2.naver.com/helloworld/3384599 Google Developer ProfileRefhttps://developers.google.com/profile/u/me 고민여러 회사의 연락을 기다리고 있는, 붕 떠버린 이 기간 동안 뭘 해야 할지 모르겠다.알고리즘 공부, 타입스크립트 공부, 그리고 만들어보고 싶었던 electron 앱 개발도 한번 해볼까?아이패드 새로 사서 듣고 싶었던 일러스트 강의도 들어보고…미뤄왔던 CS 공부도 지금 하면 좋을 텐데, 그건 감조차 잡히지 않는다. 아무튼 할 건 많구나재밌는 인생이야 마무리우테코 10개월 교육과정이 41주차가 맞는진 의문이지만, 아무튼 거의 1년을 달려왔던 교육과정이 모두 끝났다. 2월 겨울의 끝자락에서 만나 11월 겨울의 초입에서 마무리지었다. 중고등학교 졸업식보다 더 싱숭생숭한 이유는, 아직 아무것도 결정된 게 없기 때문이겠지. 대학 졸업도 그랬으니까. 그래도 인생의 그 어떤 곳보다 고마운 사람들이 가득한 곳에서 행복한 1년이었다. 거리두기가 다시 강화되기 전에 오프라인으로 수료식을 진행해서 정말 다행이다. 오열한다 해놓고 생각보다 너무 재밌게 진행돼서 종일 웃고만 있다가, 슬픈 노래도 아닌 ‘잔소리’ 편곡에 눈물이 찔끔 나버렸다 😂 (또 눈물날 것 같다) 뒤풀이도 전원 참석 아래 코치님들과도 정신 놓고 놀았다. 이제 서로 닉네임이 아닌 본명으로 부르는 날이 오겠지? 캡틴 포비의 말씀처럼, 조만간 멋진 선후배 개발자로 다시 만날 수 있었으면 좋겠다. ☺️","link":"/2021/11/26/woowa-week-40-41/"},{"title":"우테코 Lv1 Calculator PR로그","text":"우테코 Lv1 Calculator PR로그 cypress context() - describe()와 동일한 mocha 메소드이다. test case의 상당 부분은 함수화 가능하다. 함수 내부에 cy 메소드를 사용할 수 있다. 1234567const calculationTest = (num1, operator, num2, expectedResult) =&gt; { numberClick(num1); cy.get('.operation').contains(`${operator}`).click(); numberClick(num2); cy.get('.operation').contains('=').click(); ...} random으로 값을 입력하지 말고 상황에 따라 test 쪼개기 alert 등 window 메소드는 stub 사용하기 값이 ‘1’이고 class가 ‘digit’인 element를 구하는 코드 12cy.get('.digits') .contains('1') javascript setEventListener: addEventListener 함수들을 묶는 함수의 이름으로 적당한 것 같다. 예외 케이스 더 많이 생각하기! 🙄 MVC 패턴 고려하기 Number.isNaN 사칙연산을 객체로 다루는 방법 123456const operations = { '+': (a, b) =&gt; a + b, '-': (a, b) =&gt; a - b, '*': (a, b) =&gt; a * b, '/': (a, b) =&gt; a / b,}; 출력 형식이 복잡할 때는 this.formatTotal(this.total);과 같은 방식으로 메소드를 분리하는 방법도 있다. dom을 가져오는 변수명 앞에는 $ 붙이기 1const $calculator = document.querySelector('.calculator'); class형 컴포넌트에서 this binding 주의하기 1this.$.digits.addEventListener('click', this.onClickDigit.bind(this)); 특정 범위 안의 random number 구하기 12345function getRandomInput(max, min) { min = Math.ceil(min); max = Math.floor(max); return String(Math.floor(Math.random() * (max - min) + min));} CustomEvent() - click, change, submit 등의 이벤트와 마찬가지로 CustomEvent를 생성해서 사용할 수 있다! 넘나 신기하다. 🙄 Web Worker? - https://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API DOM의 classList에 add, remove하는 방식 생각하기 Refhttps://im-developer.tistory.com/190 JSDocjavascript 애플리케이션이나 라이브러리의 API를 문서화해준다. 소스코드 파일에 주석을 달기 위해 사용되는 마크업 언어라고 할 수 있다.기본적인 문법은 /** ~ **/를 사용하는 것이다. 123/** This is a description of the foo function. */function foo() {} JSDog tag를 활용할 수도 있다. 123456/** * Represents a book. * @constructor */function Book(title, author) {} npm으로 jsdoc을 install한 후, docdash 등의 테마를 설정할 수도 있다. 12npm i --save-dev jsdocnpm install docdash jsdoc도 뭔가 개별 설정이 필요하다 😬 어디선가 줍줍해 온 코드 복붙 1234567891011121314151617181920212223242526272829// jsdoc.conf{ &quot;source&quot;: { &quot;include&quot;: &quot;./index.js&quot;, &quot;includePattern&quot;: &quot;.js$&quot; }, &quot;plugins&quot;: [ &quot;plugins/markdown&quot; ], &quot;opts&quot;: { &quot;template&quot;: &quot;node_modules/docdash&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;destination&quot;: &quot;./docs&quot;, &quot;recurse&quot;: true, &quot;verbose&quot;: true }, &quot;templates&quot;: { &quot;cleverLinks&quot;: false, &quot;monospaceLinks&quot;: false, &quot;default&quot;: { &quot;outputSourceFiles&quot;: false }, &quot;docdash&quot;: { &quot;static&quot;: false, &quot;sort&quot;: true } }} 설정이 완료되면 아래 커맨드로 HTML로 구성된 웹사이트를 확인하면 된다. 1jsdoc [file].js 이렇게 코드를 임시로 쳐줬더니 이런 새로운 디렉토리, 파일들과 함께 이런 html 페이지가 생겼다! 😮 신기하다. 🙄 jsdoc을 global로 설치하면 잡다한 설정을 줄일 수 있다. 1npm install -g jsdoc jsdoc의 자세한 문법들은 공식 문서를 참조하도록 하자. Refhttps://jsdoc.app/about-getting-started.htmlhttps://okayoon.tistory.com/entry/JSDoc를-사용해서-Javasript-문서화해보자","link":"/2021/02/15/wtc-lv1-calculator-pr/"},{"title":"우테코 Lv1 lotto 학습로그","text":"우테코 Lv1 lotto 학습로그 PR-Step1PR-Step2PR-Step3 Step1정적 팩토리 메서드 패턴클래스의 인스턴스를 new 키워드로 생성하면, 객체의 생성 방법을 사용자측에서 너무 자세히 알아야 하는 문제가 있다. 객체를 생성하는 정적 메서드를 제공해주고 이 메서드를 사용하게끔 하여 문제를 해결할 수 있다. 👾 객체 생성을 캡슐화하는 기법 객체 생성의 역할을 하는 클래스 메서드 (static) 생성자 대신 정적 팩토리 메서드를 사용할 수 없는지 생각해보기12345678910111213141516class Lotto = { constructor() { // ... } static newLotto() { return new Lotto(genajerateRandomNumbers()); }}// badconst lotto = new Lotto(generateRandomNumbers());// goodconst lotto = Lotto.newLotto(); 링크https://johngrib.github.io/wiki/static-factory-method-pattern/https://velog.io/@ljinsk3/정적-팩토리-메서드는-왜-사용할까 DOM 선택자로 class 대신 id(단일 엘리먼트), dataset(여러 개) 사용하기class로 선택하는 경우 기능과 상관없이 스타일이 바뀌었을 때 일일이 찾아 수정해주어야 하는 번거로움이 있으며, 이는 프로그램이 깨지기 쉬운 취약한 구조이다. 문서에 한 개뿐인 단일 요소이면 id를, 특정한 데이터 속성을 가지고 있다면 dataset을 사용하자. 또, dataset은 id와 class를 사용하기 적절하지 않은 상황에서만 사용하는 것이 좋다. 링크https://stackoverflow.com/questions/17184918/best-practice-class-or-data-attribute-as-identifier/17185248 private class field, hash #JavaScript의 private class field를 나타내는 해쉬(#)는 ES2019에서 추가된 문법이다. # prefix를 추가해 private class field를 선언할 수 있다. 12345678910111213class ClassWithPrivateField { #privateField}class ClassWithPrivateMethod { #privateMethod() { return 'hello world' }}class ClassWithPrivateStaticField { static #PRIVATE_STATIC_FIELD} private class field는 class 선언문 내부의 class 생성자에서 접근이 가능하다. 링크https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes/Private_class_fields Step2모든 View들이 상속 받는 parent View class외부에서 사용 시 method chaining을 위해 class method 구현부에서 return this를 사용할 수 있다. 1234567891011121314151617export default class View { constructor() { ... } show() { // ... return this; } hide() { // ... return this; }class SomeView extends View { ... }const someView = new SomeView();someView.show().hide(); // chaining 상속과 합성상속 is-a 관계 공통적인 메서드를 부모에 두는 패턴으로 작성하여 중복 제거에 유리하다. 부모 클래스와 자식 클래스 간의 결합도가 높아지고 자식 클래스는 부모 클래스의 구현에 의존한다. 부모 클래스가 모든 내용을 갖고 있는 객체, 즉 God Object가 되어 너무 많은 역할을 하게 된다. 이는 코드의 수정을 어렵게 만든다. 부모 클래스의 구조가 변하면 이를 상속 받는 모든 자식 클래스가 영향을 받는다. 합성 has-a 관계 이미 구현되어 있는 기능을 빌려 쓰는 개념이다. 객체가 하는 일(What things do)에 초점을 맞추어, 필요한 동작드을 고유한 함수로 추상화할 수 있다. 링크https://mingcoder.me/2020/07/19/Programming/JavaScript/inheritance-vs-composition/ CustomEvent, dispatchEvent이벤트의 이름과 전달 데이터를 명시하여 이벤트를 사용자화할 수 있다. 12345obj.addEventListener(&quot;go&quot;, function(e) { console.log(e + 'going') });const event = new CustomEvent(&quot;go&quot;, { detail: 'zig' });obj.dispatchEvent(event); 링크https://developer.mozilla.org/ko/docs/Web/API/CustomEvent/CustomEvent (웹접근성) html aria-labelARIA 접근가능한 리치 인터넷 어플리케이션(Accessible Rich Internet Applications, ARIA) 장애를 가진 사용자가 웹 콘텐츠와 웹 어플리케이션(특히 JavaScript를 사용하여 개발한 경우)에 더 쉽게 접근할 수 있는 방법을 정의하는 여러 특성 role과 aria-* 속성을 사용한다. ex) 스크린 리더 등의 보조기기 사용 시 요소를 명확하게 식별하기 위해 사용한다. aria-label label의 텍스트를 표시하지 않을 경우 사용한다. 태그의 목적을 설명한다. 12345&lt;input type=&quot;number&quot; class=&quot;winning-number mx-1 text-center&quot; aria-label=&quot;winning-number-1&quot;/&gt; aria-labelledby가 우선순위가 더 높다 링크https://developer.mozilla.org/ko/docs/Web/Accessibility/ARIA 기타util의 의미하나의 프로젝트에서 util은 특정 도메인은 알지 못하고 범용적으로 사용할 수 있는 것들의 모음이다. 특정 도메인에 국한되지 않도록 작성할 수 있어야 한다. input change vs input event change - input 요소의 값이 바뀌었을 때 발생. 포커스를 잃거나, 엔터를 입력하는 등의 경우에 발생한다. input - input 요소의 value 속성이 바뀔 때마다 발생 Step3객체 프로그래밍의 기본객체 프로그래밍은 각 객체별로 역할을 나누고 객체에게 인자 처리를 요청하는 흐름으로 이루어진다. 필요한 데이터를 추상화시켜 상태와 행위르 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 것이다. 링크https://jeong-pro.tistory.com/95](https://jeong-pro.tistory.com/95 show/hide와 append웹페이지 렌더 과정 DOM, CSSOM 생성 render tree 생성 layout (reflow): 브라우저 뷰포트 내에서 각 노드들의 정확한 위치와 크기를 계산 (re)paint 페이지 초기 로딩 시 보이지 않아야 할 요소를 미리 DOM에 넣어 놓고 show/hide를 하는 경우가 필요한 상황에서 해당 요소를 append하는 것보다 빠르다. show/hide는 이미 만들어진 DOM tree에 조작만 해서 render tree에만 변경이 일어나고, append는 DOM tree와 render tree 모두 변경되기 때문이다 DOM tree: 실제 모든 html 요소들을 포함하는 트리 render tree: DOM과 CSSOM 트리가 결합된, 실제 화면에 표현되는 요소들의 트리 미리 보여도 상관없는 요소라면 show/hide를 사용하자. 링크https://stackoverflow.com/questions/31759719/what-is-the-difference-between-browser-dom-tree-and-render-treehttps://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=kohttps://boxfoxs.tistory.com/408 기타Array 내장 메서드 사용하기1const lottoTickets = Array.from({ length: this.count }, (_, idx) =&gt; `&lt;li&gt;....&lt;/li&gt;`).join('') Array.from() 메서드는 유사 배열 객체(array-like object)나 반복 가능한 객체(iterable object)를 얕게 복사해 새로운 Array 객체를 만든다. 링크https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from nextElementSibling선택한 요소의 바로 다음 요소를 리턴한다. 링크https://developer.mozilla.org/en-US/docs/Web/API/Element/nextElementSibling form.elements123const inputs = document.getElementById(&quot;my-form&quot;).elements;const inputByIndex = inputs[0];const inputByName = inputs[&quot;username&quot;]; 링크https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements","link":"/2021/03/02/wtc-lv1-lotto-log/"},{"title":"우테코 Lv1 racingcar 학습로그","text":"우테코 Lv1 racingcar 학습로그 PR-Step1,2 함수의 네이밍 행동을 먼저 말하고, 뒤에 서사를 풀어쓰는 것이 많은 경우의 코딩 컨벤션이다.ex) typeCarAndClick보다는 clickAfterTypeCar getXXX의 의미를 명확히 알고 사용하자. class를 객체로 생성하여 사용하는 곳에서 가져올 때, 또는 DOM 객체를 접근할 때 주로 사용한다.ex) Car 인스턴스 생성 시 getCars()보다는 createCars()ex) getTryCount 대신 mountTryCount class의 getter와 settergetter로 class 멤버 변수에 접근class property는 외부에서 바로 접근하지 못하도록 하는 것이 좋다. getter를 사용하여 한번 함수로 래핑한 후 가져오자. 1234567891011121314class Car { constructor(name, position) { this._name = name; this.position = position; } get name() { return this._name; } get position() { return this._position; }} setter 사용은 지양12345678910111213141516class Car { constructor(name, position) { // ... this.position = position; } // bad set position() { this._position += 1; } // good move() { this._position += 1; }} setter를 사용하는 것은, 멤버변수를 private하게 만든 수고를 무효화한다. setInterval과 requestAnimationFramesetInterval브라우저 API로, 브라우저 내부의 카운트를 진행해 콜백을 진행한다.setInterval의 콜백 함수는 Macrotask queue에 담겨 가장 나중에 실행된다. 👾 실행 순서: Microtask queue ➡️ Animation Frames ➡️ (Macro)task queue 1234567891011121314const moveEverySecond = (interval) =&gt; { if (this.tryCount === 0) { interval &amp;&amp; clearInterval(interval) this.getWinners(); return; } this.tryCount--; this.cars.forEach(car =&gt; { // ... })};moveEverySecond();const moveInterval = setInterval(() =&gt; moveEverySecond(moveInterval), DELAY.TURN_TIME); requestAnimationFrame animation을 JavaScript로 제어하기 위해 사용한다. repaint가 되기 전에 호출된 함수를 실행하고, 그 후에 repaint를 진행한다. (requestAnimationFrame queue) 애니메이션을 가장 부드럽게 보이게 하기 위해 사용한다. 디스플레이의 주사율(초당 깜빡이는 횟수)과 가장 비슷한 시점에 호출된다. 링크 이벤트 루프 JavaScript의 비동기 처리 과정 기타테스트코드 분리레이아웃 관점과 비즈니스 로직으로 테스트 코드를 분리하면 보다 직관적인 테스트가 가능하다. mounting 시점에서의 이벤트 핸들링많은 라이브러리 또는 프레임워크는 render 단계에서 DOM 객체를 생성, mount 단계에서 이벤트를 바인딩한다. 따라서 vanillaJS로 개발 시 하나의 component에서 모든 addEventListener들을 한 곳에서 처리해주는 것은 자연스러운 패턴이다. DOM 접근 예외처리document.querySelector(className)에서 해당 객체가 존재하지 않을 때를 대비한 예외처리를 하자. for loop 대신 Array 내장 객체 사용하기12345// badfor (let i = 0; i &lt; DEFAULT_TRY_COUNT; i++) { ... }// goodArray.from({ length: DEFAULT_TRY_COUNT }, () =&gt; { ... })","link":"/2021/02/16/wtc-lv1-racingcar-log/"},{"title":"우테코 Lv1 RacingCar PR로그","text":"우테코 Lv1 RacingCar PR로그 1️⃣단계docs 사용자와 프로그램이 할 일을 구분해 놓는 방식도 좋은 것 같다. 자동차 이름 등록 사용자 : 자동차의 이름을 등록한다. 프로그램 : 쉼표로 구분된 자동차 이름을 저장하고 화면에 보여준다. 이동 횟수 입력 및 경주 시작 사용자 : 이동 횟수를 입력한다. 프로그램 : 이동 횟수 한도 내에서 랜덤으로 각 자동차를 이동시킨다. cypress 테스트가 커지면 파일을 기능별로 분리하는 것도 좋아보인다. 상수 파일, utils 등으로 나눌 수 있다. 입력(비즈니스) 테스트, 레이아웃 테스트, validation을 분리하는 방법도 있다. ‘게임진행 화면에 표시된 자동차 이름과 입력된 자동차 이름이 일치한다.’와 같은, 신경 쓴 테스트 코드는 잘 작성한 것 같다. cypress에서 DOM 선택하기 123cy.document().then((doc) =&gt; { const $carContainers = doc.querySelectorAll('.car-container');}) CypressWrapper를 사용한 크루도 있었다. 차근차근 알아보고 사용해보자 🙄 input disabled를 테스트할 수 있다. dataset을 넣은 것도 좋아보인다. 1cy.get('[data-test=car-name-input]').should('be.disabled'); cy.wrap() cy.wrap()은 그것이 불린 컨텍스트에서의 객체를 반환한다. Promise(setTimeout() 등)를 test할 때도 사용된다. https://docs.cypress.io/api/commands/wrap.html#Syntax alert를 테스트하는 다른 방법 12345678910beforeEach(() =&gt; { cy.window().then((win) =&gt; cy.stub(win, &quot;alert&quot;).as(&quot;windowAlert&quot;));}it('...', () =&gt; { cy.get(&quot;@windowAlert&quot;) .should(&quot;have.callCount&quot;, callCount) .its(&quot;lastCall&quot;) .should(&quot;be.calledWith&quot;, errorMessage);}) 객체를 비교하기 위해 deep.equal()을 사용할 수 있다. javascript 각 class(컴포넌트)에 target과 props를 전달하는 방법. 복잡해 보이지만 나중에 구조가 확장되면 고려해볼 방식이다. 1234567891011121314151617181920export default class Component { $target; props; constructor($target, props) { this.$target = $target; this.props = props; this.initEvent(); } initEvent() {} render() { this.mountTemplate(); this.mountChildComponents(); } mountTemplate() {} mountChildComponents() {}} DOM의 display를 none으로 하는 것보다, classList에서 추가/제거하는 방법이 좋은 것 같다. 사용하면 안 되는 버튼에 disabled 를 먹이자 insertAdjacentHTML 을 생각보다 모두 많이 쓰고 있었다! 나만 몰랐다 😐 class에 init()을 만들어서, 이후에 class instance 생성 후 car.init()하는 방식도 있다. START_THRESHOLD_NUMBER: 4,에서와 같은, threshold라는 단어를 이용한 변수명이 좋아 보인다. App이라는 최상위 컴포넌트에서 MVC를 깔끔하게 참조하는 방법 (좋은 방법인지는 검증되지 않았지만) 12345678910111213141516171819class RacingCarApp { constructor() { this.model = new CarRacingModel(); this.view = new CarRacingView(); this.controller = new CarRacingController(this.model, this.view);}...// Controller 파일 export default class CarRacingController { constructor(model, view) { this.model = model; this.view = view; this.setEventListener(); } ...} querySelectorAll은 같은 class의 여러 DOM 뿐 아니라, 파라미터에 여러 선택자를 넣어 한 번에 여러 DOM을 선택할 수 있다. (class 이름 하나만 받는 거였으면 getElementsByClassName이 있는데 왜 그 생각을 못했을까 😬) 1const matches = document.querySelectorAll(&quot;div.note, div.alert&quot;); 객체로 구성된 array에서 max 속성값을 구하는 방법 12345getMaxDistance() { return this.cars.reduce((maxDistance, { position }) =&gt; { return Math.max(maxDistance, position); }, 0);} throw Error 123if (!isValid) { throw new Error(ALERT_VALID_LENGTH);} 그냥 콘솔에 (빨간) 에러로 찍힌다. selector로 접근하는 메소드를 분리한 것도 좋아 보인다 1234567891011export const $ = selector =&gt; { return document.querySelector(selector);};export const $$ = selector =&gt; { return document.querySelectorAll(selector);};// 실사용const $input = $('.car-name-input');const $carElements = $$('.car-wrapper'); DOMParser로 파싱하기 1234567891011export const parseHTML = (html) =&gt; { const parser = new DOMParser(); return parser.parseFromString(html, &quot;text/html&quot;).body.firstElementChild;};// syntaxlet doc = domparser.parseFromString(string, mimeType)// 실사용return parseHTML(`&lt;div class=&quot;forward-icon mt-2&quot;&gt;⬇️️&lt;/div&gt;`); 배열의 map은 동일한 length의 새 배열을 반환하는데 사용된다. 어떤 동작을 반복하여 실행만 하고 싶을 경우는 forEach를 사용한다. addEventListener들을 묶는 함수의 이름으로 bindEvents가 좋아보인다. class의 init()과 constructor()의 역할을 각각 생각해보자. isXXX() 메서드는 bool 값만을 리턴하게끔 하자. node의 innerText를 가져오는 신선한 방법 123const [{ innerText: winnerCandidate }] = $carName;console.log(winnerCandidate); constructor 내부에서 객체를 직접 생성하여 할당하는 것과 외부에서 생성하여 객체를 생성하여 constructor 에 주입하여 내부에 할당하는것은 그 결과는 똑같지만 일반적으로 후자가 더 유연한 코드를 작성 할 수 있다. constructor 내부에서 직접 new 키워드를 통해 객체를 생성하게 되면 만약 추후에 해당 객체를 생성하는 방법이 바뀌었을 때 현재 객체도 바꿔줘야 하기 때문이다. MVC가 서로 참조하는 일이 없도록 주의하자 (circular reference 이슈) 2️⃣단계cypress alert를 확인하는 또 다른 방식12export const checkAlert = alertMessage =&gt; cy.on('window:alert', message =&gt; expect(message).to.contains(alertMessage)); 객체의 비교1expect(winners).to.deep.equal(matched); javascript 100번 랜덤 실행하기 (HoF) 123const randomNumbers = [...Array(100)] .map(() =&gt; getRandomNumber(GAME.MIN_SCORE, GAME.MAX_SCORE)) .filter(num =&gt; GAME.MIN_SCORE &lt;= num &amp;&amp; num &lt;= GAME.MAX_SCORE); HoF - 함수를 리턴하는 함수, 여기서는 javascript의 내장 메소드를 체이닝해서 사용한 것을 가리킨다. 함수의 bad case 정의하여 early return하기 dataset 이용하기 setAttribute 파일을 따로 빼는 방법 123export const hideElement = (element) =&gt; { return element.setAttribute('hidden', true);}; winners를 구하는 간결한 방법 1234567getWinners() { const maxPosition = Math.max(...this.cars.map((car) =&gt; car.position)); return this.cars .filter((car) =&gt; car.position === maxPosition) .map((car) =&gt; car.name);} Promise를 활용한 delay 메서드 만들기(특정한 값을 리턴하는 것이 아니라, 그냥 주어진 시간만큼 기다리게 됨) 12export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms * 1000)); setTimeout 대신 Promise를 쓰는 이유setTimeout은 명시한 시간이 지난 후에 곧바로 실행되는 것이 아닌, 호출 스택이 모두 비워진 후에 사용되기 때문에 예기치 못한 순간에 실행될 수도 있다.Promise를 리턴하여 일정 시간을 기다린 후 원하는 동작을 실행하는 것이 좋다.😮 일부러 호출 스택을 비운 후 실행하기 위해 setTimeout을 사용할 수도 있다. classList.toggle() 활용하기 element.toggleAttribute() 추상 클래스처럼 작성하는 방법 12345678910111213141516171819202122232425export default class Component { $target; props; constructor($target, props) { this.$target = $target; this.props = props; this.initStates(); this.render(); this.initEvent(); } render() { this.mountTemplate(); this.mountChildComponents(); } initStates() {} initEvent() {} mountTemplate() {} mountChildComponents() {}} State를 모듈화하여 Component에서 활용하기 123456789101112131415161718192021222324export default class State { #value; constructor(initialValue) { this.#value = initialValue; } get = () =&gt; { return this.#value; }; set = newValue =&gt; { this.#value = newValue; };}// 사용class App extends Component { initStates() { this.cars = new State([]); this.raceTimes = new State(0); this.winners = ''; } } Array 내장 메소드 안에서 객체의 property를 사용하여 메서드 체이닝하기 1234return this.cars .get() .filter(({ position }) =&gt; position === maxPosition) .map(({ name }) =&gt; name); RacingGame 모델을 만들어서, controller의 멤버변수로 init 시켜주는 방법 12345678910111213141516171819202122export default class RacingGame { constructor() { this.cars = []; this.isEnd = false; } setCars(names) { this.cars = names.map(name =&gt; new RacingCar(name)); } runRace(count) { ... } ...}// RacingController.jsclass RacingController { initGame() { this.game = new RacingGame(); }} 전역변수의 문제? 🤔 - 모듈 시스템에서 각 모듈은 독립적인 스코프를 갖고 있기 때문에, 모듈 내 전역변수가 많아진다고 해도 나중에 관리가 복잡해지는 문제는 발생하지 않는다. object pool 객체를 필요로 할때 풀에 요청을 하고, 반환하는 일련의 작업을 수행하는 패턴이다. 메모리 관리를 플랫폼이 담당하므로 가비지 컬렉션의 발생 타이밍을 직접 컨트롤할 수 없는 언어는 예상치 못한 퍼포먼스 저하가 발생 할 수 있다. 이런 상황을 방지하기 위해 생성 가능한 인스턴스 갯수만큼의 메모리를 미리 할당해 풀에 넣어두고 필요할 때 꺼내고 사용이 끝나면 풀에 다시 반납해 나중에 재사용 할 수 있게 해주는 방식을 object pool이라고 한다. new 생성자의 남용(?)에 관한 고민에서 시작된 문제였는데, 아직까지는 조금 어려운 개념인 듯하다. 😬 element.outerText도 있지만, innerText 또는 textContent가 더 빠르다. 명령형(imperative) vs 선언형 프로그래밍(declarative) 명령형 프로그래밍 - 컴퓨터가 수행할 명령들을 순서대로 정의한다. 전체 flow를 파악하기 어렵다.ex) 1. 게임이 끝났다. 2. 화면을 로딩으로 바꾼다. 3. 결과를 계산한다. 4. 화면에 결과를 보여준다. 선언형 프로그래밍 - 프로그램의 상태를 바꾸는 명령을 통해 프로그램이 의도대로 흘러가게끔 만든다. 직접적으로 명령하지 않는다.ex) 1. 게임이 끝났다. 2. 결과를 계산한다. 이때 로딩 상태를 true로 바꾼다. 3. 계산이 끝나면 로딩 상태를 false로 바꾼다. React는 선언형 프로그래밍 방식을 채택하고 있다. 되도록 선언형 프로그래밍으로 작성해보자. 이때 flag 변수를 사용하는 것도 좋은 방법이다. javascript의 class는 결국 prototype을 이용한 syntactic sugar🍯로, 다른 언어에도 있는 class를 javascript 내부적으로 구현한 것이다.클래스와 함수 중 어떤 것이 옳다고 할 수는 없다. 클래스로\b 작성한 코드는 대부분 객체와 함수만으로도 똑같이 구현 가능하다. 추상화하고, 함수를 분리하고, 중복을 제거하는 작업은 항상 미래의 유지보수성에 도움이 되지만, 가독성을 해칠 수도 있다. 중복이 생긴다고 섣부르게, 또는 과도하게 추상화를 하면이후 요구사항이 수정되었을 때 더 보기 힘든 코드가 될 수도 있다는 점을 염두에 두자. dom selector 함수 내부에 유용한 메소들을 정의하고, 각각에서 return this를 활용하여 외부에서 사용 시 메서드 체이닝을 할 수 있다. 나아가 prototype이나 class의 factory pattern도 공부해보면 좋다. HTMLCollection 선택하여 한 번에 변수명 부여하기 1const [carNamesBtn, tryNumBtn, resetBtn] = document.getElementsByTagName(&quot;button&quot;); 영문&amp;숫자 검증하기 1const isAlphanumeric = (input) =&gt; /^[a-zA-Z0-9]+$/.test(input); EOL - 개행을 넣어야 하는 이유는 POSIX 명세에서 정의되어 있기 때문이다. 많은 시스템들이 이 표준에 따라 구현되어 있고, 규칙이 지켜지지 않을 경우 오류가 발생할 수 있다. Refhttps://dev-momo.tistory.com/entry/HigherOrder-Function-이란-무엇인가https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promisehttps://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e2f171e-ff0c-4f26-955d-8d5f8ea2a4f9/Untitled.pnghttps://codeburst.io/declarative-vs-imperative-programming-a8a7c93d9ad2https://blog.coderifleman.com/2015/04/04/text-files-end-with-a-newline/https://velog.io/@godori/factory-method-patternhttps://www.digitalocean.com/community/tutorials/js-factory-pattern","link":"/2021/02/15/wtc-lv1-racingcar-pr/"},{"title":"우테코 Lv1 subway 학습로그","text":"우테코 Lv1 subway 학습로그 PR-Step1PR-Step2,3 Step1history event customize하여 SPA Routing 흉내내기history.pushState()브라우저의 세션 기록 스택에 상태를 추가한다. 1history.pushState(state, title[, url]); history.popState() 브라우저의 백 버튼이나 (history.back() 호출) 등을 통해서만 발생한다. history.pushState() 또는 history.replaceState()는 popstate 이벤트를 발생시키지 않으며, 같은 document에서 두 히스토리 엔트리 간의 이동이 있을 때만 발생한다. CustomEvent로 pushState 재정의하기123456789101112const routeTo = (path) =&gt; { history.pushState({ path }, null, path); window.dispatchEvent(new CustomEvent('pushState', { detail: path }));};window.addEventListener('popstate', (e) =&gt; { routeTo(e.state.path);});window.addEventListener('pushState', (e) =&gt; { this.components[e.detail].init();}); 링크https://developer.mozilla.org/ko/docs/Web/API/History/pushStatehttps://developer.mozilla.org/ko/docs/Web/API/Window/popstate_event JWT Usage🍪cookie후속 요청으로 서버로 다시 보내야 하는 데이터 (token 등)를 저장한다. 주로 서버에서 읽기 위한 목적으로 사용한다. httpOnly flag와 함께 전송하면 클라이언트 측 액세스(JavaScript로 접근)이 불가하며, XSS 공격을 막을 수 있다.하지만 여전히 CSRF 공격의 위험성이 존재한다. 인증된 유저가 존재하는 페이지에 악성 코드를 심어, cookie에 저장된 token이 현재 어느 웹페이지에 있든 요청에 담길 수 있다. 📮 storageXSS (Cross-Site Scripting) 공격에 취약하다. XSS 공격은 웹 애플리케이션에 권한이 없는 사용자가 스크립트를 삽입할 때 발생한다. 사용자의 쿠키를 탈취하는 경우도 발생한다. cookie에 token 저장하기 123456789101112export const setCookie = ({ key, value, expireDays }) =&gt; { const expireDate = new Date(); expireDate.setDate(expireDate.getDate() + expireDays); document.cookie = `${key}=${value}; expires=${expireDate}`;};setCookie({ key: 'token', value: userToken, expireDays: SESSION_EXPIRE_DAYS,}); 서버에 토큰 담아 요청 보내기 1234567const response = await fetch(url, { method: 'GET', headers: { 'Content-Type': 'application/json', Authorization: token ? `Bearer ${token}` : '', },}) Bearer HTTP AuthenticationJWT 토큰을 사용하여 인증하는 경우 인증 타입을 bearer 로 사용하고, 이러한 인증 방법을 Bearer Authentication라고 한다. 링크https://techcourse.woowahan.com/s/r1RL8HTw/ls/0aOaOoeY SPA를 위한 webpack 설정SPA (Single Page App) 애플리케이션에 필요한 모든 정적 리소스를 최초 한번에 다운로드하고, 그후 새로운 페이지 요청이 발생할 경우 필요한 데이터만 전달 받아 페이지를 갱신한다. CSR (Client Side Rendering) 페이지의 일부만 바뀌고, 페이지 이동 시 전체를 새로 업데이트할 필요 없기 때문에 반응 속도가 빠르다 vs MPA (Multi Page App) (ref) SSR (Server Side Rendering) 완성된 html을 서버로부터 받기 때문에 SEO에 유리하다 HtmlWebpackPlugin 번들링 결과 dist에 html 파일을 생성해준다. 웹팩 번들링 결과의 css와 js 파일을 각각 html에 와 태그로 추가 fileName: dist 파일에서 생성해주는 파일. 디폴트는 index.html template: webpack 번들링 결과로 나온 html 파일들 중 script를 심어줘야 할 파일 12// webpack.config.jsplugins: [new HtmlWebpackPlugin({ template: './index.html' })], 링크https://velog.io/@thms200/SPA-vs.-MPAhttps://webpack.js.org/plugins/html-webpack-plugin/ Step2,3기타setCustomValidity브라우저에서 기본으로 제공하는 alert의 메시지를 사용자화할 수 있다. input에 에러가 발생하는 상황에 따라 설정이 가능하다. 123456789101112131415161718192021setInputValidity() { const validityState = this.$stationNameInput.validity; if (validityState.valueMissing) { this.$stationNameInput.setCustomValidity('역 이름을 입력해 주세요.🙀'); } else if (validityState.tooShort) { this.$stationNameInput.setCustomValidity('2글자 이상 입력해 주세요.👾'); } else if (validityState.patternMismatch) { this.$stationNameInput.setCustomValidity('공백, 특수문자를 제외한 한글을 입력해 주세요.🤓'); } else { this.$stationNameInput.setCustomValidity(''); }}// ..async handleNameSubmit(event) { event.preventDefault(); if (!this.$stationNameInput.reportValidity()) return; // ... } modal 바깥 영역 클릭 시 모달 닫기마우스 클릭 이벤트를 등록한 곳 (모달 내부)과 클릭한 곳(모달 바깥 영역)이 서로 다르면 모달을 닫는다. 1234567this.$root.addEventListener('mousedown', this.handleClickOutsideModal.bind(this));handleClickOutsideModal(event) { if (event.target === event.currentTarget) { this.close(); }} event bus (ref)http response의 값 활용하기123456if (!response.ok) { if (response.status === 400) { throw new Error(await response.text()); } throw new Error(response.status);}","link":"/2021/04/10/wtc-lv1-subway-log/"},{"title":"우테코 Lv1 youtube classroom 학습로그","text":"우테코 Lv1 youtube classroom 학습로그 PR-Step1PR-Step2PR-Step3 Lv1custom dom library 추상화 수준이 높아질수록 DOM 라이브러리는 더욱 복잡하고 비대해진다. 문서화와 유지보수가 중요하다 jQuery, React 등 잘 만들어진 라이브러리를 참고해보자 custom dom library 파일 링크 링크https://gomakethings.com/how-to-create-your-own-vanilla-js-dom-manipulation-library-like-jquery/ HTTP CacheHTTP Cache를 이용하면 이전에 가져온 리소스들을 재사용하여 성능을 향상시킬 수 있다. 저장소 내에 리소스를 저장하여, 이후 요청 시 요청을 가로채 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. 서버에서 응답을 내려줄 때 HTTP 헤더에 Cache-Control 옵션을 포함시켜 보내준다. 링크https://developer.mozilla.org/ko/docs/Web/HTTP/Cachinghttps://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Controlhttps://pjh3749.tistory.com/264 promise-then보다는 async-awaitasync-await을 사용하면 동기적 코드의 흐름으로 개발이 가능하며, 코드가 더욱 간결해진다. 또, 동작의 분기를 간편하게 작성할 수 있어 코드의 가독성을 높인다. Promise를 이용한 방법 12345678910const posts = () =&gt; { getJSON() .then(data =&gt; { return getPosts(data); .then(posts =&gt; { console.log(posts); return posts; }) })} async-await을 이용한 방법 1234567const posts = async () =&gt; { const data = await getJSON(); const posts = await getPosts(data); console.log(posts); return posts;} async-await은 try~catch로 에러 핸들링이 가능하며, 에러 발생 위치를 파악하기 쉽다. 링크https://ithub.tistory.com/223https://medium.com/@constell99/자바스크립트의-async-await-가-promises를-사라지게-만들-수-있는-6가지-이유-c5fe0add656c throttlesetTimeout으로 작성한 throttle을 이용하여 사용자 이벤트의 감지를 지연시킬 수 있다. 123456789101112export default function throttle(callback, delay) { let ticking; return function () { if (ticking) return; ticking = setTimeout(() =&gt; { ticking = null; callback.apply(this, arguments); }, delay); };} 👾 callback.apply()를 쓰는 이유현재 throttle 함수 내부의 this를 참조한 상태로(ticking을 기억한 상태로) callback(이벤트 핸들러의 콜백)을 실행하기 위해 링크https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply JSON.stringify와 LocalStorage의 저장값 - array, object배열 [1,2,3,4]가 있을 때, localStorage에 배열을 바로 저장하면 join된 형태 그대로 저장된다. (1,2,3,4) 이때 저장된 값은 JSON string 타입이 아니기 때문에 JSON.parse를 호출할 필요없이 즉시 사용 가능하다. (JSON.parse 호출 시 에러 발생) 반면 localStorage에 배열을 JSON.stringify로 변환하여 저장하면 배열 형태로 저장된다 ([1,2,3,4]) JSON.stringify의 인자에 잘못된 값이 들어왔을 때 예외처리를 하자(default 부여) 인자에 순환 참조 (cyclic object vaue) 값이 들어왔을 경우 TypeError가 발생한다 undefined, 함수, 심볼(symbol)은 변환될 때 생략되거나(객체 안에 있을 경우) null 로 변환된다(배열 안에 있을 경우) 👾JSON.stringify &amp; JSON.parse를 쓰는 이유 직접 객체를 선언하는 객체 리터럴 방식보다, 객체의 내용을 문자열로 변환 후 JSON.parse 메소드를 이용하는 것이 더욱 빠르다. JSON 문법이 JavaScript 문법보다 간단하고, 문법 파싱에 리소스가 덜 들기 때문이다. 링크https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringifyhttps://wormwlrm.github.io/2019/12/04/Why-JSON-parse-is-faster-than-object-literal.html 기타api key 관리프론트엔드만 있는 프로젝트에서는 완벽하게 API key를 숨길 수 없다. 별도 서버에 키를 두고, 그 서버에 proxy로 api를 요청하거나 api 키에 다른 보안 정책(referer 등)을 추가하는 방법 밖에 없다. toLocaleString1this._publishedAt.toLocaleDateString('ko-KR', options); 지역별로 다른 객체로 재정의된다. (문자열로 반환) 링크https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString URLSearchParams (ref)URL의 쿼리들을 조합하는 메소드를 제공한다 1234567891011const searchParams = new URLSearchParams({ key: youtubeKey, type: 'video', part: 'snippet', maxResults: VALUE.CLIPS_PER_SCROLL, q: keyword,});if (pageToken) { searchParams.set('pageToken', pageToken);} 링크https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams img 태그 작성 시 alt 명기하기 Step2Observer pattern객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. store에 앱에 필요한 데이터들을 저장하고, 이 데이터들의 상태를 구독할 observer들을 등록(register)한다.observer(또는 controller)에서 앱의 실행에 따라 store의 데이터를 update하고, 해당 데이터를 구독하는 모든 observer에게 데이터의 상태 변화를 notify하여 새로운 데이터를 반영할 수 있도록 한다. 🤓 생각하는 장점 데이터를 한 곳에 모아 관리할 수 있다 데이터를 사용하는 측(controller)에서 실시간으로 데이터의 상태 변화를 감지할 수 있다 직접 일을 요청하는 명령형 프로그래밍이 아닌, 데이터 조작(update) → store 상태 업데이트 → 상태변화 알림(notify)의 순서대로 선언적으로 흐름을 구성할 수 있다. 링크https://medium.com/@yeon22/design-pattern-observer-pattern-이란-ef4b74303359 기타이벤트 위임 동적으로 새로 추가될 요소들에 이벤트를 등록할 때, 새로 추가된 요소에 일일이 addEventListener를 등록해주는 것보다 이벤트 위임 방식을 사용하는 것이 효율적이다. 많은 핸들러를 할당하지 않아도 되기 때문에 초기화가 단순해지고 메모리가 절약된다. 요소들의 공통 조상에 이벤트 핸들러를 할당하여 여러 요소를 한꺼번에 다룰 수 있다. (컨테이너 수준에 할당된 핸들러가 응답할 필요가 있는 이벤트이든 아니든 상관없이 모든 하위 컨테이너에서 발생하는 이벤트에 응답해야 하므로 CPU 작업 부하가 늘어날 수 있다. 그런데 이런 부하는 무시할 만한 수준이므로 실제로는 잘 고려하지 않는다.) 링크https://ko.javascript.info/event-delegation DOMContentLoaded1window.addEventListener('DOMContentLoaded', App); 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다. 링크https://developer.mozilla.org/ko/docs/Web/API/Window/DOMContentLoaded_event Step3IntersectionObserver대상 요소가 화면에 보이는 부분에 따라 동작을 실행한다. 페이지 스크롤을 구현할 때 이미지 또는 iframe에 lazy loading을 등록하여 로딩을 지연시키는 경우에 사용한다. 123456789101112131415161718192021export default function lazyLoading() { const options = { threshold: 1.0, // 요소가 보이는 부분의 경계를 10%로 설정 document.querySelector('#modal-videos') // 뷰포트의 기준이 되는 root 요소 }; const callback = (entries, observer) =&gt; { entries.forEach((entry) =&gt; { if (entry.isIntersecting) { // 등록한 요소가 교차했을 때 entry.target.src = entry.target.dataset.src; // 원하는 동작 실행 observer.unobserve(entry.target); // observer를 해지한다 } }); }; const observer = new IntersectionObserver(callback, options); const modalClips = document.querySelectorAll('#modal-videos iframe'); modalClips.forEach((clip) =&gt; { observer.observe(clip); // 관찰할 요소들 });} 링크https://developer.mozilla.org/ko/docs/Web/API/IntersectionObserver/IntersectionObserverhttp://blog.hyeyoonjung.com/2019/01/09/intersectionobserver-tutorial/ CSS grid 가로-세로 2차원 레이아웃 시스템 grid container, grid item으로 구분 grid의 형태와 정렬 등을 정의할 수 있다 링크https://studiomeal.com/archives/533 기타loading=&quot;lazy&quot;페이지를 읽어들이는 시점에 중요하지 않은 리소스 로딩을 추후에 하는 기술이다. &lt;img&gt;, &lt;iframe&gt;에 사용한다. 12&lt;img src=&quot;image.jpg&quot; alt=&quot;...&quot; loading=&quot;lazy&quot;&gt;&lt;iframe src=&quot;video-player.html&quot; title=&quot;...&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt; 초기 로딩 시 필요한 이미지 또는 iframe의 수를 줄일 수 있기 때문에 성능 향상에 도움이 된다. 링크https://scarlett-dev.gitbook.io/all/it/lazy-loadinghttps://techcourse.woowahan.com/s/r1RL8HTw/ls/zgzWB3Aw","link":"/2021/03/18/wtc-lv1-youtube-classroom-log/"},{"title":"우테코 Lv2 lotto 학습로그","text":"우테코 Lv2 lotto 학습로그 PR-Step1 바로가기 PR-Step2 바로가기 1️⃣ Step1 setState의 비동기성React는 성능을 위해 여러 setState() 호출을 단일 업데이트로 한꺼번에 처리한다. setState()로 state를 변경할 때마다 리렌더링이 발생하기 때문에, 최적화를 위해 여러 setState() 호출들을 하나로 묶어 하나의 이벤트가 끝나는 시점에 일괄적으로 업데이트를 수행하는 것이다. 동기적인 상태의 업데이트를 위해서는 setState()에 객체 대신 함수를 인자로 사용한다. 우선 일반적인 형태의 setState 호출이다. 1this.setState({count: this.state.count + 1}); 이를 updater 함수로 변경하여 아래와 같이 작성할 수 있다. 1this.setState((state) =&gt; count: state.count + 1); 함수를 인자로 넘기는 경우 역시 setState()는 비동기적으로 동작하지만, 인자로 넘겨 받는 함수들이 queue에 저장되어 순서대로 실행되기 때문에 state의 정상적인 업데이트가 보장된다. 즉 함수를 실행하고, 업데이트된 state가 다음 함수의 인자로 들어가기 때문에 다음 setState() 호출은 최신 상태의 state 값을 가지고 업데이트를 수행할 수 있다. 👾 초기에는 setState가 비동기로 되어 있지 않았기 때문에 setState()의 인자로 객체를 넣어도 동기적인 상태의 업데이트가 가능했으나, 이후 setState()는 동기적 업데이트를 보장할 수 없게 되었다. 다만 기존의 컨셉을 어느 정도 유지하기 위해 setState()에 객체를 넘기는 형태가 일반적으로 사용되고 있다. setState의 두 번째 인자로 콜백을 넘기는 경우도 있다. 1setState(updater[, callback]) updater 함수가 실행된 후 callback을 실행한다.이번 미션에서는 price가 업데이트된 후 createLottos를 실행하도록 했다. 1this.setState({ price }, this.createLottos); Refhttps://ko.reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronoushttps://medium.com/@devych.code/react-setstate는-비동기-작동한다-b045737c9e41https://leehwarang.github.io/2020/07/28/setState.html 기타styled-components 확장하기styled-components로 선언한 컴포넌트를 styled의 인자로 넣어 마치 내용을 확장한 것처럼 사용할 수 있다. 1234567891011const Flex = styled.div` display: flex;`;Flex.Center = styled(Flex)` display: flex; align-items: center; justify-content: center;`;const Stack = styled(Flex)` flex-direction: column;`; padStart현재 문자열의 시작을 다른 문자열로 채워, 주어진 길이를 만족하는 새로운 문자열을 반환한다. 1String(this.state.minutes).padStart(2, '0') Refhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/padStart state는 어디에?앱의 모든 상태를 App.js가 갖고 있는 것은 좋지 않다. 컴포넌트별로, 사용하는 곳과 가장 가까운 곳에 state를 배치하는 것이 좋다. 2️⃣ Step2useRefuseRef는 DOM element를 조작하는 경우가 아닐 때에도 사용할 수 있다. useRef로 생성한 객체는 컴포넌트의 전 생애주기를 통해 유지된다. 이 객체는 렌더링을 할 때 동일한 ref 객체를 제공한다.따라서 컴포넌트의 전 생애주기를 통해 유지되는 값에 사용한다. 앱의 플로우 상 변화가 거의 발생하지 않거나, 잦은 변화가 발생하지만 그때마다 컴포넌트를 리렌더링하지 않아야 하는 경우에 사용하면 좋다. 1const refContainer = useRef(initialValue); useRef는 .current 프로퍼티에 변경 가능한 값을 담고 있는 “상자”와 같다. class의 instance 필드를 사용하는 것과 유사하게, 가변값을 유지하는 데 사용할 수 있다. 123456789101112131415function Timer() { const intervalRef = useRef(); useEffect(() =&gt; { const id = setInterval(() =&gt; { // ... }); intervalRef.current = id; return () =&gt; { clearInterval(intervalRef.current); }; }); // ...} 👾 왜 ref가 아닌 .current를 쓸까?useRef()도 클로저를 리턴하는데, 이때 한번 생성된 ref의 내부값을 변경할 수가 없다. 하지만 객체로 생성된 useRef 객체의 프로퍼티 값인 ref.current값은 변경이 가능하기 때문에 .current를 사용한다. Refhttps://ko.reactjs.org/docs/hooks-reference.html#userefhttps://ko.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variableshttps://woowacourse.github.io/javable/post/2021-05-15-react-ref/ useEffect 안에서 비동기 함수 호출하기useEffect의 두 번째 인자인 dependency에 아무 값도 넣어주지 않으면, 컴포넌트가 마운트될 때 timer를 세팅해주고 1초마다 시간을 갱신해준다. 12345678910const [currentTime, setCurrentTime] = useState({ minutes: 10, seconds: 0 });useEffect(() =&gt; { const timer = setInterval(() =&gt; timePass(), 1000); const { minutes, seconds } = currentTime; if (minutes === 0 &amp;&amp; seconds === 0) clearInterval(timer); return () =&gt; clearInterval(timer);}); 기타React 컴포넌트 관리 방법 앱의 확장성을 고려하여 재사용 가능한 컴포넌트 분리하기 컴포넌트를 말랑말랑하게 만드는 것이 좋다. 컴포넌트가 받는 props에 따라서 상황에 맞는 일을 해줄 수 있어야 한다. 기능과 레이아웃(presentational, container) 컴포넌트를 분리하는 방법도 있다. 컴포넌트는 독립적인 단위모듈이어야 한다. 즉 컴포넌트는 해당 기능에 대해서 독립적으로 수행이 될 수 있고, 새로운 모듈로 교환될 수 있어야 한다. Refhttps://jeonghwan-kim.github.io/dev/2020/01/28/component-design.htmlhttps://vallista.kr/2020/03/29/Component-%EB%B6%84%EB%A6%AC%EC%9D%98-%EB%AF%B8%ED%95%99","link":"/2021/04/21/wtc-lv2-lotto-log/"},{"title":"우테코 Lv2 payments 학습로그","text":"우테코 Lv2 payments 학습로그 PR-Step1 바로가기 PR-Step2 바로가기 1️⃣ Step1 Prop drilling데이터를 직접적으로 사용하지 않고 전달에만 사용하는 컴포넌트에서 발생한다. React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 프로세스이다. prop drilling의 depth가 깊어지면 실제 데이터가 사용되는 컴포넌트 로직을 알기 어려우며, 관련 있는 상태는 될 수 있으면 가까운 곳에 선언하는 것이 좋다. 또는 React 계층에서 깊숙이 위치한 상태라면 Context API 등을 사용하여 상태를 전역 변수로 관리할 수 있다. 그러나 단순 데이터 전달만을 위한 컴포넌트가 과도하게 만들어지는 것이 아니라면, Context API 등은 오히려 복잡도를 증가시키는 오버엔지니어링이 될 수도 있으므로 상황에 따라 도입해야 한다. Refhttps://kentcdodds.com/blog/prop-drillinghttps://github.com/woowacourse/react-payments/pull/17#issuecomment-830758509 React Portal부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링한다. portal을 띄울 DOM node 만들기 123456// index.html// ...&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;div id=&quot;keyboard&quot;&gt;&lt;/div&gt;// ... React.createPortal로 Portal 컴포넌트 만들기 12345678910111213141516// VirtualKeyboard.jsexport const KeyboardPortal = ({ children }) =&gt; { const el = document.getElementById('keyboard'); return createPortal(children, el);};const VirtualKeyboard = (props) =&gt; { // ... return ( &lt;Style.Root className=&quot;keyboard-inner&quot;&gt; {keypads} &lt;Style.Keypad&gt;&lt;/Style.Keypad&gt; &lt;Style.Keypad onClick={onDeleteKeypad}&gt;DELETE&lt;/Style.Keypad&gt; &lt;/Style.Root&gt; );}; Portal 컴포넌트 사용하기 123456789// SomeComponent.jsconst SomeComponent = (props) =&gt; { // ... return ( &lt;KeyboardPortal&gt; {isVirtualKeyboardOpened &amp;&amp; &lt;VirtualKeyboard inputNumbers={secureCode} setInputNumbers={setSecureCode} /&gt;} &lt;/KeyboardPortal&gt; );}; Dialog나 Modal 등, 상위 컴포넌트의 스타일에 영향을 받지 않으면서 컴포넌트를 렌더링하고 싶을 때 Portal을 사용한다. 애니메이션 등을 사용할 때 트리 구조브 앱으로 구현했다면 키보드가 뜰 때 input이 가려지지 않게 조정하는 방법이 있었을 테지만, 웹으로 구현하다 보니 그냥 화면이 아래로 내려가게끔 하는 수밖에 없었다 (scrollTo 메서드 이용) 상의 위치에 따라 성능 문제가 발생하는 경우에도 사용한다고 한다. 👾 Portal, React 컴포넌트 트리 어디에?Portal이 DOM 트리의 어디에도 존재할 수 있다 하더라도 모든 다른 면에서 일반적인 React 자식처럼 동작한다. (context와 같은) React의 기능은 자식이 portal이든지 아니든지 상관없이 정확하게 같게 동작한다. 이는 DOM 트리에서의 위치에 상관없이 portal은 여전히 React 트리에 존재하기 때문이다. (HTML DOM 구조만 바뀌며, React 컴포넌트 트리는 바뀌지 않는다.) 따라서 어떠한 부모 컴포넌트 하위의 자식 컴포넌트가 portal을 사용해서 DOM 트리에서는 부모-자식 관계가 아니더라도, React 트리 상에서는 여전히 부모-자식 관계로 이루어져 있기 때문에 부모 컴포넌트는 자식 컴포넌트의 이벤트를 포착할 수 있다. Refhttps://reactjs-kr.firebaseapp.com/docs/portals.html 기타컴포넌트에 전달하는 prop method의 네이밍사용되는 컴포넌트의 관심사가 아닌, 사용하는 컴포넌트의 관심사 측면에서 prop을 네이밍해야 한다. 12345678910111213141516171819202122232425262728293031// bad😕const CardRegisterForm = () =&gt; { // ... return ( // ... &lt;CardNumbersInput cardNumbers={cardNumbers} setCardNumbers={setCardNumbers} /&gt; )}const CardNumbersInput = ({ cardNumbers, setCardNumbers }) =&gt; { // ... return ( // ... )}// good 😉const CardRegisterForm = () =&gt; { // ... return ( // ... &lt;CardNumbersInput cardNumbers={cardNumbers} onChange={setCardNumbers} /&gt; )}const CardNumbersInput = ({ cardNumbers, onChange }) =&gt; { // ... return ( // ... )} setCardNumbers라는 함수가 구체적으로 무엇을 수행하는지는 CardNumbersInput 컴포넌트가 아니라 CardNumbersInput을 사용하는 CardRegisterForm 측의 관심사다. Refhttps://github.com/woowacourse/react-payments/pull/17/files#r624647027 2️⃣ Step2useEffect 내부에서 비동기 호출useEffect의 시그니처는 다음과 같다. 123function useEffect(effect: EffectCallback, deps?: DependencyList): void; type EffectCallback = () =&gt; (void | (() =&gt; void | undefined)); Promise를 리턴하는 async 함수는 useEffect의 첫 번째 인자로 들어갈 수 없으며, void 형의 함수 또는 void 형의 함수를 반환하는 함수만 사용할 수 있다. effect에는 callback 함수가 들어가기 때문에 async 함수를 그대로 전달해주면 된다. (useEffect 내부에서 즉시 호출되는 것이 아니라, 해당 함수를 등록해놓는 것일 뿐이다.) 12345678910111213const SomeComponent = () =&gt; { async fetchData = () =&gt; { await something... } useEffect(() =&gt; { fetchData(); }, []) return ( // ... )} useEffect 내부에서 비동기 호출 시 try~catch를 이용하여 에러 핸들링을 해주었다. 1234567891011121314151617181920212223242526// 비동기 함수 한번 wrapping하기useEffect(() =&gt; { const fetchData = async () =&gt; { try { const cardsData = await getCardsRequest(); // do something... } catch (error) { console.error(error); // error handling... } }; fetchData();}, []);// 즉시실행함수useEffect(() =&gt; { (async function() { try { const cardsData = await getCardsRequest(); // do something... } catch (error) { console.error(error); // error handling... } })();}, []); Refhttps://github.com/woowacourse/react-payments/pull/33#discussion_r627522014 컴포넌트에 props로 함수 전달하기자식 컴포넌트인 A와 B는 동일하게 작동한다. (각 컴포넌트에 props로 메소드를 전달한다.)f2와 같은 형태로 전달하면 함수에 파라미터를 전달할 수 있다. 12345678910const SomeComponent = () =&gt; { const f = () =&gt; {} const f2 = () =&gt; () =&gt; {} return ( &lt;A f={f} /&gt; &lt;B f={f2()} /&gt; );} 기타input.focus &amp; input.blurinput에 focus 활성화 &amp; 비활성화하기 12ref.current.focus();ref.current.blur(); 서로 떨어진 submit button과 form 연결하기form에 id값을 부여하여 연결할 수 있다. 12345678910// Button.jsconst Button = (props) =&gt; { const { type, text, formId } = props; return ( &lt;Style.Root type={type} form={formId}&gt; {text} &lt;/Style.Root&gt; );}; 1234567891011121314// CardRegister.jsconst CardRegister = (props) =&gt; { const onSubmitForm = () =&gt; { // ... } return ( &lt;&gt;&lt;form id=&quot;register-form&quot; onSubmit={onSubmitForm} /&gt; &lt;Button type=&quot;submit&quot; text=&quot;다음&quot; formId=&quot;register-form&quot; /&gt; &lt;/&gt; )}","link":"/2021/05/04/wtc-lv2-payments-log/"},{"title":"우테코 Lv2 subwaymap 학습로그","text":"우테코 Lv2 subwaymap 학습로그 PR-Step1 바로가기 PR-Step2 바로가기 1️⃣ Step1 CRA 앱에서 babel 설정을 도와주는 친구들CRA로 React 앱을 만들면 babel 설정을 마음대로 하기가 어렵다. .babelrc 파일을 생성해도 적용이 되지 않는다. 이를 해결해주는 모듈이 몇 개 있다. 가장 대표적인 것은 react-app-rewired이다. 1$ yarn add react-app-rewired package.json의 scripts를 수정해준다. 1234567// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, ...}, config-overrides.js 파일을 만들어 설정을 바꿔준다. 이때 customize-cra를 사용하면 편리하다. 1234// config-overrides.jsconst { override, useBabelRc } = require('customize-cra');module.exports = override(useBabelRc()); → 이제 CRA에 설정된 값을 필요에 따라 override하여 사용할 수 있다. Refhttps://www.npmtrends.com/@craco/craco-vs-customize-cra-vs-react-app-rewiredhttps://micalgenus.github.io/articles/2019-02/React-eject-없이-babelrc-적용 NavLinknavigation bar를 구현할 때 사용한다. Router 구현 시, 현재 활성화된 URL에 해당한 링크만 하이라이팅해줄 수 있다. 123456789101112131415const NavBar = () =&gt; { const selectedNavStyle = { backgroundColor: PALETTE.DEFAULT_CREAM, borderRadius: '8px', }; return ( &lt;NavLink to={ROUTE.LOGIN} activeStyle={selectedNavStyle}&gt; &lt;Styled.NavItem&gt;로그인&lt;/Styled.NavItem&gt; &lt;/NavLink&gt; &lt;NavLink to={ROUTE.SIGNUP} activeStyle={selectedNavStyle}&gt; &lt;Styled.NavItem&gt;회원가입&lt;/Styled.NavItem&gt; &lt;/NavLink&gt; )} Refhttps://reactrouter.com/web/api/NavLink useFetchuseFetch는 일반적으로 get method를 사용하고, 어떤 데이터를 가져오는지 endpoint나 데이터의 키값을 정의한다. 일반적으로 GET요청을 가장 많이 사용하기 때문에 GET을 default method로 두고,(fetch의 기본 method도 GET) 나머지 요청이 필요할땐 인자로 넣어주자! 👍 이번에는 GET 요청 뿐 아니라 POST, PUT, DELETE에 대한 요청들도 한번에 처리해주기 위해 fetchData 메서드를 함께 리턴해주었다. 👾 제네릭을 이용하여 리턴할 데이터에 대한 타입도 명시해주면 좋다. 123456789101112131415161718192021222324252627282930type HTTP_METHOD = 'GET' | 'POST' | 'PUT' | 'DELETE';const useFetch = (method: HTTP_METHOD = 'GET') =&gt; { const [loading, setLoading] = useState&lt;boolean&gt;(false); const BASE_URL = useAppSelector((state) =&gt; state.serverSlice.server); const fetchData = async (endpoint: string, data?: unknown) =&gt; { setLoading(true); try { const response = await axios({ method, url: `${BASE_URL}/${endpoint}`, data, }); return { status: API_STATUS.FULFILLED, data: response.data }; } catch (error) { console.error(error); return { status: API_STATUS.REJECTED, message: error.response?.data.message || ALERT_MESSAGE.SERVER_ERROR, }; } finally { setLoading(false); } }; return [fetchData, loading] as const;}; useFetch hook을 사용하는 컴포넌트에서는 다음과 같이 작성한다. 12345678const StationPage = () =&gt; { const [getStationsAsync, getStationsLoading] = useFetch(); const [addStationAsync, addStationLoading] = useFetch('POST'); const [deleteStationAsync, deleteStationLoading] = useFetch('DELETE'); const [editStationAsync, editStationLoading] = useFetch('PUT'); // ... } type assertionuseFetch hook에서 다음과 같이 리턴하면, 사용하는 측에서 배열의 각 원소에 대한 타입을 확신할 수 없다. 12345678910111213141516171819// useFetch.tsconst useFetch = (method: HTTP_METHOD = 'GET') =&gt; { // ... return [fetchData, loading];}// SomeComponent.tsxconst StationPage = () =&gt; { const [getStationsAsync, getStationsLoading] = useFetch(); const fetchStations = () =&gt; { const res = await getStationsAsync(END_POINT.STATIONS); } // ... }// This expression is not callable.// Not all constituents of type 'boolean | ((endpoint: string, data?: unknown) =&gt; Promise&lt;{ status: API_STATUS; data: any; message?: undefined; } | { status: API_STATUS; message: any; data?: undefined; }&gt;)' are callable.// Type 'false' has no call signatures. 변수가 const로 선언되었다 할지라도, 객체 내부의 속성에 대한 타입은 넓은 범위로 추론되기 때문에 TypeScript 에러가 나는 것이다. 이런 경우, 타입 추론의 범위를 좁혀주기 위해 const assertion을 사용할 수 있다. as const 를 사용한다. 1return [fetchData, loading] as const; 그냥 객체로 리턴 시 as const로 리턴 시 (readOnly가 추가된다) 123const returnVal: readonly [typeof fetchData, boolean] = [fetchData, loading];return returnVal; 코드가 아주 별로기 때문에 as const를 쓰는 편이 낫겠다. Refhttps://medium.com/@seungha_kim_IT/typescript-3-4-const-assertion-b50a749dd53bhttps://www.typescriptlang.org/docs/handbook/2/objects.html etcRedux toolkit slice에서 store값에 접근하기createAsyncThunk의 thunkAPI.getState를 사용한다. 12345678export const requestGetUser = createAsyncThunk&lt; { user: User }, string, { dispatch: AppDispatch; state: RootState }&gt;('auth/getUser', async (accessToken, { rejectWithValue, getState }) =&gt; { const BASE_URL = getState().serverSlice.server; // ... }); 2️⃣ Step2 etcuseSelector에 제네릭으로 타입 넘겨주기12345const StationPage = () =&gt; { // const user: User | undefined = useAppSelector((state) =&gt; state.authSlice.data); const user = useAppSelector&lt;User | undefined&gt;((state) =&gt; state.authSlice.data); // ... }","link":"/2021/06/03/wtc-lv2-subwaymap-log/"},{"title":"우테코 Lv3 - 개발 정리","text":"우테코 Lv3 학습로그 - 개발 정리 왜 forwardRef를 사용할까?부모 컴포넌트에서 자식 컴포넌트의 props로 명시적으로 ref를 넘겨줄 때 사용한다.🍀 여기서 읽기 TS index signatureTypeScript에서는 string literal과 string 타입을 구분하기 때문에, 객체에서 사용되는 인덱스 타입을 명시해줄 필요가 있다.🍀 여기서 읽기 TS type guard함수 인자의 타입을 알 수 없을 때, 검사하고자 하는 타입에 해당되는지 확인하기 위해 사용한다.🍀 여기서 읽기 debounce in query사용자의 input에 따른 http request 요청 횟수를 줄이기 위해 사용한다.🍀 여기서 읽기 context API 유연하게 활용하기context API와 custom hook을 사용하여 앱 전체에서 유연하게 사용할 수 있는 Provider 컴포넌트를 만들어줄 수 있다.🍀 여기서 읽기","link":"/2021/08/19/wtc-lv3-log-2/"},{"title":"우테코 Lv3 - 프론트엔드 테스트","text":"우테코 Lv3 학습로그 - 프론트엔드 테스트 🤔 고민페어와 함께 프론트엔드 테스트를 고민했던 부분은 다음과 같다. 작은 독립적인 단위부터, bottom-up 방식으로 테스트를 견고하게 쌓아가고 싶다. 코드를 수정할 때마다 빠르게 피드백을 받아볼 수 있는 테스트를 원한다. 앱 전체가 정상적으로 작동하지 않아도 부분적인 테스트가 가능하길 바란다. 함수와 데이터 모킹을 통해 실제 동작을 확인하고 싶다. 무엇을 믿을지, 그리하여 무엇을 테스트하지 않을지 생각해야 했다. 예를 들어, React 컴포넌트에서 렌더링하는 JSX 요소에 등록한 이벤트 핸들러는 잘 동작할 것이라 믿는다. 그러나 컴포넌트에 전달되는 props에 따라 렌더링되는 내용이 달라진다면 그 부분은 테스트하는 의미가 있다. 사용자의 어떤 인터랙션에 의해 api가 호출된다면 이도 유의미한 테스트라고 생각한다. 많은 경우 프론트엔드 테스트를 단위 테스트, 통합 테스트, E2E 테스트로 나누곤 한다. 현재 프로젝트에서 E2E 테스트까지 수행하기엔 테스트 비용이 너무나도 많이 들어갈 것 같고, 단위 테스트를 시작으로 서서히 통합 테스트를 해 나가기로 한 셈이다. 물론 단위 테스트와 통합 테스트의 경계는 너무나도 모호하지만. 페어는 비즈니스 로직과 UI 렌더링의 완전한 분리를 원했었다. React 컴포넌트는 정말로 마크업만 렌더링하고, 컴포넌트 내에서 상호작용이 발생하는 로직들은 전부 hook으로 분리하자는 것이었다. 실제로 다양한 출처들에서 그렇게 하고 있다는 점을 부정할 수는 없었지만, 재사용성도 없어 보이는 hook 로직들을 테스트를 위해 너무 많이 분리하는 것이 아닌가, UI만 렌더링하는 컴포넌트라면 사실상 container-presentational 컴포넌트의 관계가 되는 것이 아닌가 걱정했었다. 실제로 테스트가 어려운 코드는 잘못 짜여진 것일 수도 있다는 이야기까지 듣고 어느 정도 납득은 되었지만, 너무나도 낯설고 갈기갈기 찢겨버리는 듯한(?) 컴포넌트의 구조가 초래할 후폭풍이 괜시리 두려워 일단은 컴포넌트에 작성했던 비즈니스 로직은 그대로 두기로 했다. 서비스/렌더링 로직이 혼재되어 있는 각 컴포넌트에서 테스트를 진행하기가 아주 쉽지는 않았으나, 차근차근 채워 나가고 있다. react hook test기존에 작성했던 react hook test 포스팅은 아래 링크에서 읽을 수 있다.msw를 이용하여 서버 api 호출을 대신했다.🍀 여기서 읽기 unit test유닛 테스트라고 해야할지, 컴포넌트 단위 테스트라고 해야할지는 모르겠지만 최소단위의 컴포넌트에서 동작하는 로직에 대한 테스트 코드도 작성 중이다. 사용자의 특정 인터랙션에 따라 react-query hook이 호출되어야 하는 경우 jest의 toHaveBeenCalled 등의 assertion으로 확인하여 hook의 호출 여부를 확인하고자 했었는데, 해당 부분은 신뢰할 수 있는 부분, 즉 테스트할 필요가 없는 부분이라는 페어의 의견에 따라 따로 테스트를 해주지 않았다. 대신 jest로 해당 hook을 mocking하여 반환해야 하는 mock data들을 심어주었다. 👾 이때 jest.mock에 걸려 있는 콜백은 함수를 리턴하는 함수여야 한다. 애초에 함수의 동작을 mocking하는 것이기 때문에. 리턴되는 함수의 리턴값(말장난 같지만)의 타입에 정확히 맞춰서 mock data를 넣어주자! 1234567jest.mock('hooks/queries/useMember', () =&gt; { return () =&gt; ({ userData: MOCK_USER.ZIG, isLogin: true, logout: () =&gt; console.log('logout'), });}); useMember hook은 LikeButton 컴포넌트에 click 이벤트가 발생하면 특정 동작을 수행한다. 따라서 아래처럼 작성해주면, mocking된 브라우저의 공간에서 UI의 렌더링이 바뀌는 것을 확인할 수 있다. 123456789101112131415161718describe('LikeButton 테스트', () =&gt; { it('좋아요하지 않은 피드에서 좋아요 버튼을 누르면 좋아요 수가 1 증가한다.', async () =&gt; { const { getByRole, container } = customRender(&lt;LikeButton feedDetail={MOCK_FEED_DETAIL} /&gt;); const likeButton = getByRole('button'); const likeCountBefore = container.querySelector('span'); expect(likeCountBefore).toHaveTextContent(MOCK_FEED_DETAIL.likes.toString()); fireEvent.click(likeButton); const likeCountAfter = container.querySelector('span'); await waitFor(() =&gt; { expect(likeCountAfter).toHaveTextContent((MOCK_FEED_DETAIL.likes + 1).toString()); }); });}) 지금까지 깔끔하게 테스트 성공! 테스트 자동화github husky를 통해 리모트 저장소에 push 전 테스트코드를 돌릴 수 있도록 해주었다.🍀 여기서 읽기 Refhttps://jbee.io/react/testing-1-react-testing/https://jbee.io/react/testing-2-react-testing/https://meetup.toast.com/posts/174https://blog.mathpresso.com/모던-프론트엔드-테스트-전략-1편-841e87a613b2https://www.daleseo.com/jest-mock-modules/","link":"/2021/08/20/wtc-lv3-log-4/"},{"title":"우테코 Lv3 - 에러 핸들링","text":"우테코 Lv3 학습로그 - 에러 핸들링 프로젝트를 진행하며 적용해보았던 Error Boundary와 Suspense 코드는 다음과 같다.🍀 여기서 읽기 여기서 일부 코드 모듈화와 에러 상황에서의 사용자의 경험 개선을 위해 코드를 수정한 부분들이 있다. 1. 팀의 error code 매칭하기기존의 HttpError가 http 응답에 기본적으로 담겨있는 statusCode를 갖는 대신 우리 팀에서 합의한 (커스텀한) errorCode 키들을 갖기로 했다. errorCode를 따로 만든 이유는, 같은 400 Bad Request라도 어떤 필드가 빠졌는지, 무엇을 잘못 입력해서 전송했는지 등 여러 가지 경우의 수가 있을 수 있기 때문이다. 123456789class HttpError extends CustomError { errorCode: ERROR_CODE_KEY; // custom한 errorCode 저장 constructor(errorCode: ERROR_CODE_KEY, message?: string, errorHandler?: ErrorHandler) { super(message, errorHandler); this.name = 'HttpError'; this.errorCode = errorCode; }} 2. 공통적인 에러 처리 함수 모듈화하기react-query hook에서 사용하는 함수들에서 공통적으로 반환하거나 throw하는 세부 구현 내용을 resolveHttpError라는 함수로 모듈화했다. error 객체와 errorMessage, 그리고 대다수의 경우 snackbar를 띄워줄 목적의 errorHandler를 인자로 받는다. 1234567891011121314151617const loadHotFeeds = async (errorHandler?: ErrorHandler) =&gt; { try { const { data } = await api.get('/feeds/hot'); return data; } catch (error) { resolveHttpError({ error, defaultErrorMessage: '인기 피드에 에러가 발생했습니다', errorHandler, }); }};const useHotFeedsLoad = ({ errorHandler, ...option }: CustomQueryOption) =&gt; { return useQuery&lt;Feed[], HttpError&gt;(['hotFeeds'], () =&gt; loadHotFeeds(errorHandler), option);}; resolveHttpError의 세부 구현 내용은 아래와 같다. 디버깅용 console.error를 출력하고, 에러 응답의 타입에 따라 알맞는 에러 객체를 throw해준다. 매칭되는 에러 코드-메시지 쌍이 없을 경우를 대비하여 defaultErrorMessage를 넣어주었다. 1234567891011121314151617181920212223242526export const resolveHttpError = ({ error, defaultErrorMessage, errorHandler,}: ResolveHttpErrorResponseArgs) =&gt; { const errorResponse = error.response; console.error(error); if (!isHttpErrorResponse(errorResponse)) { console.error('에러 응답이 ErrorResponse 타입이 아닙니다'); throw new CustomError(defaultErrorMessage, errorHandler); } const { data } = errorResponse; console.error(data.message); throw new HttpError( data.errorCode, ERROR_CODE[data.errorCode] || defaultErrorMessage, errorHandler, );}; 3. 두 가지 방식으로 에러 알리기미리 계획했던 대로, 컴포넌트에서 에러가 발생하면 아래 순서로 로직이 수행된다. snackbar를 통해 사용자에게 에러 상황을 알린다. 정상적인 컨텐츠가 보여야 할 자리에 custom한 error page를 렌더링한다. 12345678910const HotFeedsContent = () =&gt; { const { data: hotFeeds } = useHotFeedsLoad({ errorHandler: (error) =&gt; { snackbar.addSnackbar('error', error.message); }, }); return ( // ... ) 여기서 useQuery(위 컴포넌트에서는 useHotFeedsLoad)에 넘겨주는 errorHandler는, 이후 useQuery가 실행하는 콜백에서 에러 발생 시 throw할 에러 객체에 저장된다. 이 에러 객체는 CustomError를 상속받은 HttpError 클래스의 객체이며, CustomError 내부의 코드는 다음과 같다. 123456789101112131415161718export default class CustomError extends Error { name: string; errorHandler: ErrorHandler; constructor(message?: string, errorHandler?: ErrorHandler) { super(message); this.name = new.target.name; this.errorHandler = errorHandler; Object.setPrototypeOf(this, new.target.prototype); } // errorHandler를 실행한다. executeSideEffect() { if (this.errorHandler) { this.errorHandler(this); } }} errorHandler의 실제 실행은 ErrorBoundary에서 처리해주고 있다. 1234567891011121314export default class ErrorBoundary extends Component&lt;Props, State&gt; { // ... componentDidCatch(error: Error, errorInfo: ErrorInfo) { console.error('Uncaught error in Error Boundary:', error, errorInfo); if (error instanceof CustomError) { error.executeSideEffect(); // errorHandler를 실행한다. } } render() { // ... }} 👾 왜 react-query의 onError 옵션을 사용하지 않고?useQuery의 onError 콜백은 매 Observer, 즉 동일한 useQuery를 사용하는 곳에서 모두 호출된다. useQuery를 이용한 데이터의 fetch가 실패하면 모든 Observer에게 통지가 간다. 앱 전체에서 useHotFeedsLoad를 3번 사용하면, 3번의 onError 콜백이 호출되는 것이다!스낵바가 3번씩 표시되는 문제를 해결하려면 Suspense와 ErrorBoundary를 걷어내고 useQuery 내부에서 useEffect를 사용해서 앱 전체에서 동일한 query key에 대한 에러핸들링을 1번만 수행할 수 있지만, 소중한(!) ErrorBoundary를 걷어낼 수 없어서 errorHandler를 따로 넘겨주는 방식을 사용했다. 이제 ErrorFallback 컴포넌트를 보여주는 로직을 살펴보자. HotFeedsContent는 부모 컴포넌트에서 AsyncBoundary에 감싸져 있다. 에러가 발생하면 throw된 error 객체는 AsyncBoundary에 걸려 rejectedFallback에 들어가는 컴포넌트를 보여준다. 12345678910111213const Home = () =&gt; { // ... return ( &lt;AsyncBoundary rejectedFallback={ &lt;ErrorFallback message=&quot;데이터를 불러올 수 없습니다.&quot; queryKey=&quot;hotFeeds&quot; /&gt; } &gt; &lt;HotFeedsContent /&gt; &lt;/AsyncBoundary&gt; // ... )} 아래와 같이 snackbar와 errorFallback 두 가지 방법으로 에러를 표시한다. 4. ErrorFallback에 queryKey 전달하기여기서 뭔가 발견했다면 당신은 천재! 👀 커스텀한 에러 페이지를 가리키는 ErrorFallback에 queryKey라는 props를 넣어주었다. 1234567891011121314151617181920import { useQueryClient } from 'react-query';const ErrorFallback = ({ message, queryKey }: Props) =&gt; { const queryClient = useQueryClient(); // prop으로 queryKey를 받았다면, 해당 queryKey가 갖는 데이터를 reset시켜준다. useEffect(() =&gt; { queryClient.resetQueries(queryKey &amp;&amp; queryKey); }, []); return ( &lt;Styled.Root&gt; &lt;Styled.Image width=&quot;480px&quot; src={catError} alt=&quot;error&quot; /&gt; &lt;Styled.Message&gt; &lt;Styled.ErrorText&gt;ERROR&lt;/Styled.ErrorText&gt; &lt;Styled.ErrorDetail&gt;{message}&lt;/Styled.ErrorDetail&gt; &lt;/Styled.Message&gt; &lt;/Styled.Root&gt; );}; 에러가 터져 기존의 컴포넌트 대신 ErrorFallback 페이지를 보여줄 경우, react router를 통해 다른 페이지로 갔다가 다시 돌아왔을 때 기존 컴포넌트에서 api 호출을 다시 할 수가 없다. (기존 컴포넌트 대신 ErrorFallback 컴포넌트가 렌더링되고 있기 때문에) 따라서 ErrorFallback에서 react-query의 resetQueries를 통해 ErrorBoundary에 걸린 react-query의 queryKey에 해당하는 서버 데이터를 초기화해주었다. 그러면 새로고침 없이 다시 동일 페이지에 접속했을 때 필요한 서버 데이터를 다시 요청할 수 있다. 사실 이 부분에서 아무리 react-query의 각양각색 query refetch 메서드를 사용해도 문제가 풀리지 않아 며칠을 고생했는데, 완벽하진 않지만 ErrorFallback에 걸려버린 SPA의 한계를 인정하고 조금 복잡하더라도 원하는 목적대로 동작을 수행하기 위해 코드를 작성해 보았다.","link":"/2021/08/19/wtc-lv3-log-3/"},{"title":"2월 2주차 기록","text":"빠름 빠름 빠름 배워가기이제 코드 구조를 어느 정도 이해하고 있는 것 같다. 사내에서 쓰는 약어들도 귀동냥으로 하나 둘 익혀가고. 세부적인 코드는 물론 보안사항일 것이기에 올릴 수 없겠지만, 앞으로 코딩하면서 마주하는 문제들, 그리고 그를 해결한 스토리들을 올리지 않을까 싶다. 사내 프론트엔드 팀원분들이 공유하는 TIL에서 유용한 내용들을 줍줍해서 정리하려고 한다. (나는 안 쓰는 주제에) 사실 매일매일 하는 건 내가 지키지 못할 것이라고 생각해서, 그리고 한번 지키지 못하면 또 울적해서 계속 안할 것이기에 내가 지킬 수 있는 ‘주 1회’ 공부 내용 업로드나 열심히 하려고 한다. React.VFC vs React.FC다른 분들과 마찬가지로, children prop을 필수적으로 포함하고 있는지 여부에 따라서 달라진다고만 생각했다. 그리고 children prop이 필요하지 않은 컴포넌트들도 많기 때문에, 굳이 컴포넌트의 타이핑을 해주지 않는 편을 택했다. 어쨌든, 여러 문서(예)에서도 React.FC와 같은 타이핑을 지양하고 있으니까… 게다가 React.VFC는 deprecated된다는 이야기가 나온지 꽤 된 것 같다. 새롭게 알게된 내용들이 있다. React에서 구현된 Component들과 Element들은 모두 -Component, -Element와 같은 네이밍을 사용하지만, 처리하는 부분에서 서로 다른 경우가 있다. 하지만 말단의 인터페이스는 동일하다. React.FC가 갖고 있는 children prop은 어떻게 보면 필요한 것일 수도 있다. 결과적으로 컴포넌트는 children이 모두 존재하기 때문이다! (JavaScript 런타임에서도 변수 슬롯이 적용되지 않았을 뿐, 변수로는 존재한다.) 그러나 문제는 TypeScript 사용 시 발생한다. TypeScript의 구조적 타이핑의 관점에서 children은 존재하면 안 된다. TypeScript의 타입 체킹은 런타임과 분리되어 있기 때문이다. 어떤 프로퍼티를 갖고 있는가에 따라 타입이 정의되는 TypeScript의 성질상 React.FC와 class component, pure component를 동일한 수준으로 취급할 수 없게 되었다. 그래서 이들을 호환시키는 atomic component의 입장에서 React.FC가 가진 children 탓에 복합적인 프로그래밍이 어려워지게 됐다. 그래서 children을 사용하지 않는 React.VFC가 나오게 되었으나, 궁극적으로 atomic component에서 이를 제대로 활용하지 못해서 여전히 골칫거리로 남게 된다. React.FC와 React.VFC라는 프레임워크를 최대한 활용하는 방법에는 장단점이 있다. 장점은 프레임워크가 달라지면 TypeScript나 트랜스파일러 등 다양한 도구에서 문법적 오류를 발견하여 에러를 내준다는 것이다. (그래서 쉽게 고칠 수 있다.) 단점은 프레임워크가 달라지면 무조건 그에 따라 변경이 필수적이라는 것이다. 가장 중요한 것은, 런타임과 타입체커 영역에 대한 분리다. 타입 체커 영역에서 불필요한 것을 왜 사용해야 하는지 논의가 이뤄질 수 있다. Ref https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680#78b9 tsconfigtsconfig의 compilerOptions의 lib에 ‘esnext’만 적어준다고 해서 es6부터 최신 문법이 다 커버되지는 않는다. 필요한 문법을 lib에 각각 넣어줘야 한다. Ref https://www.typescriptlang.org/tsconfig#lib useRef컴포넌트 밖에서 선언한 변수와 useRef의 다른점은 리액트에서 메모리를 관리하는가 아닌가에 따른 차이가 있다. useRef로 만들어진 변수는 리액트가 파괴되면 메모리상에서 함께 파괴됩니다. 다만 전역 변수는 브라우저가 종료되야 파괴된다. 메모리 오너쉽이 리액트에 있다는 것은 리액트의 렌더링 관점에서 무언가 접근할 수 있다는 것이고, 한 번만 렌더링된다는 관점에서는 리액트에서 DOM의 변경과 무관하게 static 변수(혹은 매직넘버)를 넣을 수 있다는 것이다. 또 리액트에서 메모리를 관리한다는 것은, useCallback이나 useMemo처럼 어딘가 메모리를 가용한다는 개념이니 성능적 향상을 위해 쓸 수도 있다. charlescharles은 앱과 인터넷 사이에 위치하는 web proxy 툴이다. 모든 네트워킹 요청은 Charles를 통해서 지나가고 해당 내용을 기록한다. 또한 네트워크 요청과 응답값을 살펴보는 것이 가능하고 심지어 응답 값을 변경하여 클라이언트에 적용할 수 있다. charles proxy 프로그램을 이용하면 특정 Origin에 대한 요청을 rewrite 할 수 있다. 실제와 매우 유사한 구동환경에서 개발 및 테스트할 수 있다. 앱 내에서 웹뷰 디버깅 시 실제 앱 코드를 수정하지 않고 로컬에서 띄운 웹을 볼 때 유용하다. charles의 Map Local 기능을 사용하면 응답 데이터를 마음대로 바꿀 수 있어서 다양한 상황에 따른 디버깅에 굉장히 유용하다. + USB로 모바일 디바이스를 연결했을 때 charles가 제대로 동작하게 하려면 PC와 동일한 와이파이를 사용하고, 그 와이파이에 프록시 세팅을 해줘야 한다. Ref https://www.detroitlabs.com/blog/2018/05/01/how-to-set-up-charles-proxy-for-an-ios-simulator/ https://charlesdocsy.com/2020/05/12/rewrite-redirect-url/ @ts-ignore 옵션Refhttps://365kim.tistory.com/200 DI in TS (아티클) https://velog.io/@moongq/Dependency-Injection https://darrengwon.tistory.com/1363 https://blog.shovelman.dev/964 MUIMUI에는 Material Icons를 React Component로 제공하는 @mui/icons-material이라는 패키지가 있다. svg 파일들이 일일이 React Component 파일의 형태로 되어있는 것이 아니라, svg 파일들을 읽어들이고 SvgIcon 컴포넌트로 매핑하여 빌드된다. 아이콘마다 각각 컴포넌트를 import해서 가져올 수 있다. 12import AccessAlarmIcon from '@mui/icons-material/AccessAlarm';import ThreeDRotation from '@mui/icons-material/ThreeDRotation'; Ref https://github.com/mui/material-ui/blob/master/packages/mui-icons-material/builder.js interface vs 추상 클래스 추상클래스 오직 클래스만 정의할 수 있다. JavaScript 런타임 코드를 생성한다. 다양한 기능을 제공하는만큼 더 무겁다. (접근제한자 선언, 생성자 등) interface 런타임 코드를 생성하지 않고, 컴파일 타임에만 존재한다. 추상클래스에 비해 더 가볍다. 여러 클래스에서 공유하는 구현이라면 추상 클래스를 사용하고, 클래스의 타입을 정의하고자 한다면 인터페이스를 쓰자. html/body에 height: 100% | 100vh 는 지양하자 유동적으로 변해야 할 본문의 사이즈를 한정짓는 것이기 때문에 의미적으로 어색하다. 플랫폼별 스크롤링 최적 기법에 따라 스크롤링 문제가 발생할 수 있다. 전체 컨텐츠가 명시적으로 100% 내에 위치해야 하는 경우가 아니라면 지양하는 것이 좋다. 화면에 비해 컨텐츠가 부족해 의도적 공백이 필요한 경우라면 min-height: 100vh 사용을 고려해보자. Ref Do not put height 100% on html, body in 2020 ErrorBoundary가 클래스 컴포넌트로만 가능한 이유ErrorBoundary는 getDerivedStateFromError나 componentDidCatch 생명주기 메소드를 기반으로 구현할 수 있는데, 생명주기 메소드는 클래스 컴포넌트에서만 사용할 수 있기 때문이다. 그렇다면, 생명주기 메서드를 기반으로 구현해야 하는 이유는 무엇일까? 이것저것 craco같은 CRA 서드파티는 리액트 버전이 올라감에 따라 지원이 안 되는 경우가 있기 때문에 주의해야 한다. git merge --no-ff: fast-forward의 관계더라도 merge commit을 만드는 옵션 forceConsistentCasingInFileNames: 같은 파일에 대한 일관되지 않은 참조를 허용하지 않을지 여부에 대한 설정이다. CRA + TypeScript로 프로젝트 생성 시 자동으로 true로 설정된다. mobX의 setter를 활용했을 때, makeAutoObservable이 action으로 할당해주기 때문에 runInAction 없이 상태변경을 할 수 있지만, 추가 코드량이 증가하기 때문에 runInAction을 활용하는 것이 좋을 수도 있다. npm v7 부터는 yarn.lock을 버전 지침으로 활용한다. package-lock.json을 함께 운용하는 이유는, npm이 버전 관리를 위해 남기는 데이터가 yarn의 것보다 더 많기 때문이다. react/jsx-curly-brace-presence: JSX props나 children에 대해 { &quot;text&quot; }와 같은 불필요한 중괄호를 쓰지 않도록 막아주는 린트 룰 react/no-array-index-key: 리액트 컴포넌트 리스트의 key로 index를 사용하는 것을 방지해주는 린트 룰 html/body에서의 overflow: hidden 은 모든 기기에서 유효하지는 않다. (모바일 기기에서 터치로 스크롤이 되는 등) 프록시 세팅을 할 때 로컬 IP 주소를 입력해야하는데, 통신사 중 특히 KT는 IP를 수시로 줬다 뺏기 때문에 만약 배민 앱 접속 시 503이 뜬다면 일단 IP 주소가 바뀌진 않았는지를 먼저 확인해보자. axios 에서 쿼리 파라미터를 편하게 쓰기 위해 qs 라이브러리를 활용할 수 있다.123axios.defaults.paramsSerializer = (params) =&gt; { return qs.stringify(params)} css width 속성에는 max-content와 min-content도 있다. react 제어 컴포넌트에서 유효성 검사 등의 이유로 value를 바꿔주면 cursor가 맨 뒤로 이동한다. 이 경우 input value 중간으로 커서를 이동시켜 값을 삭제/추가할 때 cursor가 계속 맨 뒤로 이동해 정상적으로 값을 수정할 수 없는 버그가 발생한다. ref를 통해 이전값과 현재값을 비교하고, setSelectionRange API를 사용해 커서 위치를 잡아줄 수 있다. aos/ios/로컬 개발 환경 등에 따라 폰트가 다르게 적용될 수 있다. 폰트에도 여백이 존재하고, 영문/한글이 섞이는지에 따라 수직 align이 조금 달라질 수도 있다. 이는 폰트별로 다 달라서 환경별로 의도한 디자인과 다른 결과물을 볼 수도 있다. styled-component 문제일 수 있다. 로컬 환경과 배포된 환경에서 개발자 도구로 확인해보면 css 위치가 달라진다. webpack plugin의 동작 구조는 각 동작 파트마다 callback을 등록하여 각 단계별 처리를 하는 구조이다. util 함수와 같이 여러 부분에서 공통적으로 사용되는 코드는 추상화 정도가 높아야 한다. 도메인-free한 공통함수를 작성하자. 무한스크롤, lottie 등에서 memory leak이 발생하지 않는지 확인하자. props로 전달받는 on- 핸들러의 경우, 옵셔널로 하는 습관을 들이는 것이 좋다. 특정 비즈니스 코드에서는 핸들러의 존재 여부가 명확하지만, 조금 더 공통 컴포넌트를 작성하다보면 on- 핸들러의 경우 반드시 전달하지 않는 경우가 많아서 이를 예상하고 공통 컴포넌트를 작성하는 편을 권장한다. id 프로퍼티를 가진 객체의 배열을 id 프로퍼티의 값을 키로 하는 객체로 변경하는 함수를 를 Object.fromEntries를 사용하여 만들 수 있다. 기존 코드에서 계속해서 배열에서 요소롤 find 하는게 시간복잡도와 가독성 측면에서 좋지 않다고 판단하여서 하였는데, 모든 요소를 순회하는 메서드의 경우, find를 줄여서 얻을 부하 감소와 Object.fromEntries를 사용에 따른 부하 증가를 면밀히 따져보아야 한다. 배열의 크기가 굉장히 크고 실제로 대부분 배열의 앞부분에 찾고자 하는 값이 있을 경우에는 Object.fromEntries에 따른 성능 감소가 더 클 수도 있다. package.json에서 private: true이면 패키지 배포가 refuse된다. 웹뷰가 focus되지 않고 있다면 JavaScript로 focus를 하더라도 해당 이벤트가 발생하지 않는다. 해당 이벤트들은 그대로 쌓여 있다가 웹뷰가 focus되면 그제서야 focus 이벤트가 발생하면서 onfocus 핸들러가 호출된다. 새로운 웹뷰 또는 새탭에서 브라우저 실행할 때 현재 웹이 active가 되지 않아서 focus()와 같은 API를 호출해도 onfocus 콜백함수가 실행되지 않는다. CRA로 build를 하면 index.html 내 빌드 파일명이 바뀌기 때문에 캐시 무효화는 /* 로 모든 파일을 무효화할 필요 없이 /index.html만 무효화 하면 된다. 폰트에 중앙 정렬 속성을 모두 줬는데도 중앙 정렬이 제대로 되어 있지 않다면 해당 폰트 자체에 위 아래 여백이 다르게 들어가있는 건 아닌지 확인해보자. styled-components를 사용하면 로컬 개발 환경에서는 head 태그 안에 주입해주는데, 빌드를 하고 나면(prod 환경) 별도의 JS 번들로 변환된다. 이때 따옴표가 누락되기도 하고 쌍따옴표가 되기도 하고 띄어쓰기가 사라지기도 한다. 크롬 개발자 도구의 Elements 탭 하단에 ‘Computed’ 탭에 들어가서 스크롤을 맨 아래로 내려보면 ‘Rendered Fonts’를 볼 수 있는데, 여기서 해당 컴포넌트에 있는 글자들 중 몇 글자가 어떤 폰트로 렌더링되었는지를 볼 수 있다. Roboto하고 (8 glyphs)라고 되어있으면 8글자가 Roboto 폰트로 렌더링됐다는 뜻. 이모지는 문자열에서 length 2를 가지며, 이모지에 대한 정규식은 라이브러리로 나와있다. onfocus의 event 객체 타입은 전역에 선언되어있는 Focus이벤트이다. React에서 FocusEvent 타입을 가져와서 사용하려할 때 충돌이 발생한다. 아이폰X 부터 상하단의 둥근 영역이 전부 디스플레이에 포함되면서, 해당 영역으로 인해 컨텐츠가 잘리는 것을 방지하기 위해 safe-area를 별도로 두고 있다. 이 safe-area 밖의 공백 영역을 위해 아이폰X 에서 사용 가능한 CSS 속성인 env() 속성과 4개의 변수가 존재한다. (iOS 11.2 이전에는 constant, 그 이후에는 env) Visual Viewport API를 사용하면 가상 키보드의 활성화 여부를 감지할 수 있다. 가상 키보드가 올라가고 내려가는 것은 window.visualViewport 에서 발생하는 resize 이벤트로 감지할 수 있다. 기타CSS line-heightCSS에서 동일한 font-size를 지정해도, font-family에 따라 글자의 높이가 서로 다르게 렌더링되는 경험이 있을 것이다. line-height의 값을 1로 정하는 것이 왜 옳지 않은지 설명한다. Ref https://mygumi.tistory.com/366 https://wit.nts-corp.com/2017/09/25/4903 조금만 신경써서 초기 렌더링 빠르게 하기JavaScript와 HTML, CSS 정적 리소스들을 활용하여 웹 애플리케이션을 구성하는 스택인 JAM Stack 구조에서 성능을 최적화시킬 수 있는 방법을 소개한다. 토스에서는 SSG(Static Site Generation)를 사용하고 있다. SSG는 앱을 빌드하는 시점에 미리 그려두고 이를 서빙하는 방식으로, JAM Stack에서 정적 리소스를 생성하는 용도로 사용한다. 컴파일 단계에서 미리 그릴 수 있는 부분을 최대한 그려서 사용자에게 도달하는 최초 index.html을 구성한다. Next.js 프레임워크를 사용하여 SSG를 활용하고 있다. 비동기를 제어할 때는 React의 Suspense를 사용하는데, Next.js와 함께 사용 시 Suspense는 서버사이드 렌더링을 지원하지 않기 때문에(알파 버전이 공개되어 있는 React18에서는 지원할 예정이다.) Suspense를 한번 감싸서 사용해주고 있다. 1234567891011121314import { useState, useEffect, Suspense as ReactSuspense } from 'react';export function Suspense({ fallback, children }: ComponentProps&lt;typeof ReactSuspense&gt;) { const [mounted, setMounted] = useState(false); useEffect(() =&gt; { setMounted(true); }, []); if (isMounted) { return &lt;ReactSuspense fallback={fallback}&gt;{children}&lt;/ReactSuspense&gt;; } return &lt;&gt;{fallback}&lt;/&gt;;} Suspense로 제어하고 있는 컴포넌트를 SSG로 빌드하면 fallback이 렌더링된다. 이때 컴포넌트와 API를 가깝게 배치시켜, 데이터가 필요한 곳에서 가장 가까운 곳에서 API를 호출해주도록 한다. 즉, 컴포넌트를 작게 쪼개 각각을 Suspense로 감싸준다. 1234567891011121314151617function UserPage() { return ( &lt;Layout&gt; &lt;h1&gt;사용자 정보&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;이름&lt;/dt&gt; &lt;Suspense fallback={&lt;dd&gt;Loading&lt;/dd&gt;}&gt; &lt;UserName /&gt; &lt;/Suspense&gt; &lt;/dl&gt; &lt;h2&gt;사용자 상세 정보&lt;/h2&gt; &lt;Suspense fallback={&lt;dd&gt;Loading&lt;/dd&gt;}&gt; &lt;UserDetailInfo /&gt; &lt;/Suspense&gt; &lt;/Layout&gt; )} UserName과 UserDetailInfo 컴포넌트를 각각 Suspense로 감쌌기 때문에 UserPage에는 먼저 데이터가 준비된 컴포넌트부터 렌더링이 시작된다. 사용자는 더 이상 멍하니 흰 화면을 보고 있지 않아도 된다. Ref https://toss.tech/article/faster-initial-rendering?fbclid=IwAR04X-6TSyHL4R385tFwtOuQYLUZceGcbFWo8isPowjQtxShaJlNipN0hcs css-in-js 라이브러리 코드로 파악해보는 css-in-js의 이모저모CSS-in-JS 방식의 하나인 emotion 라이브러리를 사용할 경우 dev와 prod에서 확인할 수 있는 스타일 태그의 형태가 다르다. prod에서는 스타일 태그들이 비어있다. dev에서는 DOM을 수정하는 방식을 선택하는 반면, prod에서는 CSSOM을 수정하는 방식을 선택하기 때문이다. 이는 runtime CSS-in-JS라는 emotion의 특성과 겹치는데, styled-component도 동일하다. prod에서도 dev와 같이 style 태그를 직접 추가한다면, 컴포넌트에서 런타임에 스타일을 수정할 때마다 style 태그가 추가되고, 그러면 DOM 트리를 다시 그리고 또 CSSOM 트리를 구축하는 과정이 반복되어 렌더링이 차단되기 때문이다. emotion은 DOM 트리는 수정하지 않고 CSSOM을 수정하는 방식을 선택하여 DOM 트리 파싱에 드는 시간을 줄이는 방식을 선택한 것이다. (styled-component도 마찬가지) 🤔 JavaScript로 조작하는 UI 스타일링들은 JavaScript 런타임과 연관이 생기고, 성능 관련 문제들을 유발시킨다. 그렇다면 아예 runtime이 아닌 라이브러리를 쓰면 되지 않을까? linaria라는 zero runtime css-in-js 라이브러리가 있기는 하다. linaria는 프로젝트 빌드 시에 CSS 파일에 스타일을 추출하고 CSS 파일을 로드하는 방식으로 동작한다. babel plugin과 webpack loader를 사용해서 빌드 시에 별도의 CSS 파일을 생성하고, 이 파일 안에서 prop이나 state 등에 의한 값들을 CSS 변수로 정의하고 CSS 변수의 값을 변경시킴으로써 동적 스타일링을 구현한다. CSS와 JavaScript가 별도의 파일에 있기 때문에 CSS와 JavaScript를 병렬로 로드할 수 있고, CSS 구문 분석과 같은 추가 작업이 런타임에 수행될 필요가 없기 때문에 런타임 성능이 향상된다. 하지만 CSS 변수를 사용한 방식인 만큼 브라우저 호환성에 문제가 있다. 🤔 atomic css는 또 뭘까? facebook… 아니 메타에서는 빌드 타임에 CSS를 생성해 atomic css를 JavaScript적인 방법으로 활용할 수 있는 stylex 라이브러리를 개발하여 CSS 파일 크기를 80% 줄이면서 최적화를 극대화했다. atomic css가 갖는 특징은 다음과 같다. tailwind와 같이 원자 단위로 css를 작성 css를 변수처럼 선언하고 해당 스타일이 필요한 HTML tag 혹은 컴포넌트가 className 등을 통해 스타일을 가져다 쓰는 방식 사용하는 컴포넌트가 많아지고 UI복잡도가 올라가면 장점은 더 극대화 Ref https://ideveloper2.dev/blog/2022-01-25--emotion으로-파악해보는-css-in-js의-이모저모/ 마무리마침 지금 듣고 있는 아이유의 unlucky에서 ‘울고 싶을지 몰라~’하는 가사가 지나갔다. 진짜 울고싶다 😫 진짜 unlucky한 인생이다. 일적으로도, 공부도 취미도 아무 문제들이 없었는데 그냥 또 불안해하던 타이밍에서 진짜 최악의 일이 터졌다. 근데 자꾸 최악이라는 표현을 쓰니까 별 거 아닌데도 최악이라고 규정지어버리는 것 같다. 누군가한테 옮은 말버릇인 것 같은데 쓰지 말아야겠다. 자꾸 스스로를 학대하면서 침잠하지 말고 벗어날 생각을 해야지 지은아. 좋은 일이 없었나. 아, 회사 사무실이 있는 롯데타워에 갔다. 38층까지 있는 사무실 건물의 38층이라니! 정말 처음 보는 뷰였다. 고소공포증이 있는 줄은 전혀 몰랐는데, 좀 무서웠다. 고작 하루였지만 팀원 분도 뵙고, 투어도 하고, 사무실이라는 공간에서 일하니 더 집중도 되는 것 같고 좋았당. 가끔씩 또 가고 싶다!","link":"/2022/02/12/2022-2-week-2/"},{"title":"2월 3주차 기록","text":"전쟁이라니 배워가기SCSS에서 믹스인 사용하기@mixin을 통해 원하는 스타일을 미리 지정하고, @include를 통해 해당 스타일을 가져다 쓸 수 있다. 12345678910111213141516171819202122SCSS SYNTAX@mixin reset-list { margin: 0; padding: 0; list-style: none;}@mixin horizontal-list { @include reset-list; li { display: inline-block; margin: { left: -2px; right: 2em; } }}nav ul { @include horizontal-list;} Ref https://sass-lang.com/documentation/at-rules/mixin for loop에서 Promise 함수 호출하기배열을 순회하며 어떤 동작을 수행할 때 for~of 구문을 쓰기도 하지만, 가독성을 위해 forEach 함수를 사용하기도 한다. 12const arr = ['a', 'b', 'c'];arr.forEach((elem) =&gt; console.log(elem)); 어떤 배열을 순회하며 배열의 각 요소에 대해 비동기 함수를 실행하고 싶을 때는 어떻게 할까? setTimeout으로 Promise를 리턴하는 함수를 만들고, forEach의 콜백 함수에 async~await을 붙여 비동기를 실행해보자. 123456789const getPromise = (elem) =&gt; { return new Promise((resolve) =&gt; setTimeout(() =&gt; resolve('promise ' + elem), 1000))}const arr = ['a', 'b', 'c'];arr.forEach(async (elem) =&gt; { const value = await getPromise(elem); console.log(value);}); ‘promise a’, ‘promise b’, ‘promise c’가 1초(1000ms)마다 순차적으로 나올 것이라고 생각했지만, 실제로는 1초 뒤에 ‘promise a’, ‘promise b’, ‘promise c’가 동시에 출력된다. forEach는 배열의 요소를 순회하면서 콜백을 실행할 뿐, 콜백이 끝날 때까지 기다려주지 않기 때문이다. 즉 forEach는 자신이 실행하는 함수가 비동기인지 아닌지 관심이 없다. 원하는 목적을 달성하기 위해서는 for~of를 사용할 수 있다. 1234for (const elem of arr) { const value = await getPromise(elem); console.log(value);} for문 자체에 await 키워드를 걸 수도 있다. 1234for await (const elem of arr) { const value = await getPromise(elem); console.log(value);} 💡 꼭 순서를 기다릴 필요 없이 배열을 순회하며 비동기 함수를 실행하고 싶다면 Promise.all을 사용할 수도 있다. Ref https://kyounghwan01.github.io/blog/JS/JSbasic/for-await-of/#for-await-of ReactElement의 type 프로퍼티ReactElement에는 type이라는 프로퍼티가 있다. type 말고도 props, key 프로퍼티도 있다! 12345interface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; { type: T; props: P; key: Key | null;} React 컴포넌트의 이름을 구분해주는 역할인 것 같다. 다음과 같이 활용할 수 있다. 123456789101112class SomeClass { get children(): JSX.Element[] { const { children } = this.props; if (!children) return []; if (isArrayLike(children)) return children as JSX.Element[]; return [children]; } hasListItem() { return this.children.find((child) =&gt; child.type === ListItem); }} TypeScript 기본 타입 증강JavaScript에서는 prototype 속성에 새로운 프로퍼티를 정의해서 사용할 수 있다. TypeScript에서도 마찬가지로 prototype을 확장해서 class나 interface 레벨의 확장이 가능하지만, 그냥 작성할 시 컴파일러가 오류를 내뱉는다. 이때는 ‘선언적 확장(Declaration Merging)’을 사용하면 된다. declare 키워드로 TypeScript 컴파일러에게 특정한 타입이 있음을 말해주는 것 과 마찬가지로, 선언적 확장을 사용하면 이미 정의된 타입의 이름과 똑같이 정의한 다른 타입을 merge할 수 있다. 위 예시에서처럼 Array나 String 같은 내장 타입(전역 타입)을 선언적 확장시켜주고 싶다면, declare global에 정의해주면 된다. 123456789declare global { interface Array&lt;T&gt; { unique(compare?: (a: T, b: T) =&gt; boolean): T[]; }}Array.prototype.unique = function &lt;T&gt;(compare?: (a: T, b: T) =&gt; boolean): T[] { // ...}; 이제 Array에서 unique 메서드를 사용할 수 있게 되었다! 12const arr = ['a', 'b', 'b', 'c', 'a'];arr.unique(); Ref https://m.blog.naver.com/mym0404/221801643812 theme color를 정의하는 방법 theme 명명법에서 gray_1보다 gray_100처럼 100 단위로 작성하면 추후에 중간값이 생기게 될 경우 처리하기 용이하다. 명명법은 통일하는게 좋다. (gray1/gray_1/gray_100/light_gray 등) React에서 DOM 건드리기를 지양해야하는 이유element에 onfocus 이벤트를 직접 설정해주는 외부 모듈이 있을 때, 해당 자식 컴포넌트를 렌더링하는 부모 컴포넌트에서 ref를 prop으로 내려줄 때 부모 컴포넌트가 리렌더링됨에 따라 해당 자식 컴포넌트도 새롭게 만들어지면서 element의 onfocus가 소멸되는 문제가 발생했다. 이렇게 ref를 사용하는 내부 컴포넌트의 경우, 컴포넌트 내부가 아닌 외부에서 ref를 직접 넘겨주는 게 방법이 될 수도 있다. html size 속성 input과 같은 텍스트 입력일 경우에 폼의 기본 너비를 문자의 수만큼 설정한다. select와 같은 입력 폼이 경우, 선택할 수 있는 아이템 개수를 초기에 몇 개를 보여줄 지 설정할 수 있다. pnpm vs yarnmonorepo의 구현을 위해 pnpm과 yarn 패키지 매니저로 dependency 목록을 설치했을 때 차이점이 있다. pnpm의 경우 각 프로젝트가 의존하고있는 패키지들을 프로젝트 루트 폴더의 node_modules 아래에 설치한다 반면에 yarn 패키지 매니저의 경우는 hoist를 통해 monorepo 최상단 node_modules 아래에 설치를 한다. 폰트의 기준선과 글자별 크기폰트의 기준선과 글자별 크기는 다음과 같은 특징을 가진다. 폰트마다 지정된 위치가 다르다. OS마다 표현하는 방식이 다르다. 브라우저마다 표현하는 방식이 다르다. 따라서 표준화되지 않은 방식으로 한 플랫폼을 기준으로 작업이 이루어지면 다른 플랫폼에서는 원하는대로 결과물이 나오지 않을 수 있다. 즉 강제조정을 위해 여백을 조정하는 css 속성을 사용하는 것은 특별한 요청이 없다면 지양해야 한다. height: 100%, 100vh상위 태그 (html, body)에서 height를 100%이나 100vh로 지정하는 것을 지양해야 한다. html, body에 height: 100% | 100vh을 지정할 경우, 데스크탑 브라우저 환경에서는 문제가 없이 느껴질 수 있다. 그러나 다른 환경에서는 컨텐츠의 정확한 높이를 브라우저가 알지 못해 스크롤에 문제가 생길 수도 있다. 만약 화면에 비해 컨텐츠가 부족할 때 공백이 필수적으로 필요한 경우에는 min-height: 100vh를 사용하는 것을 추천한다. Ref https://greggod.medium.com/css-do-not-put-height-100-on-the-body-html-e36bda3551b3 useEffect에서 DOM 요소 ref로 사용하기DOM 요소의 refObject를 useEffect에서 접근할 때는 아래와 같은 문제들이 발생할 수 있다. DO M요소가 mount 되었다는 게 보장되지 않는다. ref를 붙인 DOM 요소를 조건부 렌더링하는 경우도 있다 refObject가 null이 아니라는 것이 보장되지 않는다 TypeScript에서 객체 배열 타입 지정하기TypeScript에서 A type, B type이 있고 A가 B에 포함되는 관계라 하자. A 또는 B type의 객체 배열을 타이핑해주고 싶을 때, (A|B)[]로 선언할 경우 정확히 A 또는 B 타입의 배열로 잡아주지 못한다. A type 객체에 다른 property가 더 포함된, 즉 A도 B도 아닌 객체의 type에 대해 컴파일 에러를 안 뱉어준다. 이에 대해 infer 등의 키워드로 접근해봤으나 실패하고… 아주 맘에 들진 않지만 tagged union의 방법을 찾아보기도 했다. 그러다가 한분께 받은 해법이 아래와 같은데, 12345export type Without&lt;T, U&gt; = { [P in Exclude&lt;keyof T, keyof U&gt;]?: never };export type XOR&lt;T, U&gt; = T | U extends Record&lt;string, unknown&gt; ? (Without&lt;T, U&gt; &amp; U) | (Without&lt;U, T&gt; &amp; T) : T | U; 100% 이해하지는 못하겠다 😵 HTTP 요청할 때 호스트를 변경하는 방법(sudo) vi /etc/hosts 파일에 들어가 127.0.0.1에 원하는 호스트를 아무거나 맵핑시켜놓으면 된다. 1127.0.0.1 gift-local.baeminbaemin.com 이렇게 하면 localhost:4000 말고도 gift-local.baeminbaemin.com 으로 로컬 서버에 접속할 수 있다. 대신 요청 호스트는 gift-local.baeminbaemin.com 으로 바뀐다. typescript Record 키워드Record&lt;key, Type&gt;의 형태로 사용한다. 인덱스 시그니쳐와 역할이 비슷해보이는데, Record는 key에 문자열 리터럴/enum 을 사용할 수 있다. 즉 key를 제한할 수 있다. keyof 키워드와 조합해서 사용하면 더 유용하다. response와 request에 따라 axios 에러 처리하기axios의 에러 부분에서 response/request 필드 존재 여부를 통해 다르게 처리할 수 있다.(응답이 있을 때/없을 때/그 외) 12345678910111213private axiosErrorHandler(error: AxiosError&lt;ServerErrorData&gt; | Error) { if (!axios.isAxiosError(error)) { return error.message; } if (error.response) { return this.createRemoteServerError(error.response.data.message, error.response.data.statusCode); } else if (error.request) { return this.createNoResponseError(NaN); } return error.message;} axios instance option - validateStatus에러 시 재요청 등을 처리해줄 때, 불친절한 error 객체와 구분해서 AxiosResponse를 이용해 작업을 수행시킬 수 있다. default value는 status in [200, 300)이다. 이를 status in [200, 500)으로 처리해주면 2xx, 3xx, 4xx를 모두 AxiosResponse로 받아 에러임이 확실할 때만 error로 throw해 onError 로직을 수행시킬 수 있다. webpack v5에서 지원하지 않는 polyfillwebpack v5에서는 더이상 node polyfill을 지원하지 않기 때문에, 직접 설정에 추가해야한다. 그런데 우리가 사용하던 node 내장 모듈들의 polyfill을 추가하지 않고 web api로 변경하는 방법도 있다. 다음은 그 예시다. crypto ➡️ web crypto api Buffer ➡️ TypedArray(Uint8Array) String encoder/decoder ➡️ TextEncoder/TextDecoder 반드시 해야하는 테스트 API Response 테스트 에러 상황에 대한 테스트 (400, 500 등) 에러가 되었을때 fallback 테스트 비즈니스 로직 테스트 (hooks, models 테스트) e2e는 전체 flow를 기반으로 테스트 이것저것 ttypescript를 사용하면 tsconfig에서 플러그인을 명시하여 기능을 확장할 수 있다. typescript-transform-paths를 통해 절대 경로를 사용할 수 있다. Swiper 라이브러리를 사용하면 간단하게 Carousel을 구현할 수 있다. Object.entries나 Object.keys를 사용했을 때 TypeScript에서는 key 값이 string 타입으로 지정된다. key 값을 특정 타입으로 지정해주고 싶을 때는, 타입 단언(type assertion)이 한 가지 해법이 될 수 있다. useCallback을 사용하는 적절한 타이밍 라이브러리 관련 개발에는 rollup, 웹 애플리케이션 개발에는 webpack이 주로 사용되는데, 주된 이유는 ES Modules export 지원 여부이다. 이 덕분에 트리 셰이킹 지원이 용이해진다. 조건부 렌더링을 하는 컴포넌트에서 조건이 복잡하면, 따로 변수로 조건을 빼서 사용하는 것이 더 가독성이 좋다. 단순 전달의 의미를 가지는 props는 나머지 매개변수 문법을 사용하는 것이 가독성에 더 좋다. css의 white-space 속성은 글자뿐만 아니라 다른 element들에도 적용되는 속성이다. aws cloud front에서 behavior로 CORS를 줄 수 있다. simpleCORS 정도만 선택해도 충분하다. Joi를 사용하여 API validation이 가능하다. Joi.object({}).pattern(Joi.string(), Joi.array().items(Joi.string))으로 Record&lt;string, string[]&gt;에 대한 validation을 수행할 수 있다. toLocaleString에 minimumIntegerDigits 옵션을 통해 숫자 앞에 0을 채울 수 있다. (ex. 2 ➡️ 02, 12 ➡️ 12) 서버 post 요청 시 웹 방화벽 차원에서 에러가 발생하면 html 형태로 response가 온다. 이 경우 response header의 content-type을 검사해서 예외를 처리해주면 된다. backface-visibility 속성은 요소의 뒷면이 사용자를 향할 때 보여야 하는지 지정하는 css 속성이다. fs.existSync를 통해 파일 존재 여부를 확인할 수 있다. styled-components에서 ${(props) =&gt; props.~}가 많아질 때는, 최상위에서 ${(props) =&gt; css``} 를 반환해주면 props 쓰는 부분이 조금 더 깔끔해진다. react-router는 path-to-regexp 패키지에 의존하고 있다. 그래서 정규식으로 path 설정이 가능하다. 기본적으로 @types 폴더안에 d.ts파일들을 넣어두면 알아서 컴파일에 포함된다고 한다. 그렇지 않다면 “typeRoots”에 해당 폴더를 추가해주자. tsConfig 파일에서 extends: “A/tsconfig.json”; 속성을 넣으면 A/tsconfig.json 파일의 타입스크립트 설정들을 가져올 수가 있다. 이를 통해 monorepo에서 root에 tsconfig를 가져옴으로써 일반적인 config를 공유할 수 있다. 모노레포에서 한 패키지의 모듈이 다른 패키지에서 사용 된다면 import 구문 경로 설정을 ‘잘’ 해줘야한다. 내 패키지에만 설정되어있는 alias 혹은 단축경로로는 다른 패키지에서 못찾는다. 상대경로나 절대경로로 설정해주자. JavaScript에서 cookie를 다루기 쉽게 해주는 js-cookie라는 라이브러리가 있다. package.json의 scripts에 cross-env를 작성해주면, 운영체제나 플랫폼에 종속되지 않고 동일한 방법으로 env 변수를 주입해줄 수 있다.12345// package.json&quot;scripts&quot;: { &quot;start&quot;: &quot;npm run start:beta&quot;, &quot;start:dev&quot;: &quot;cross-env PROFILE=dev node dev_server/server.js&quot;, &quot;start:prod&quot;: &quot;cross-env PROFILE=prod node dev_server/server.js&quot; axios 요청에 timeout을 옵션으로 줄 수 있다.12345678910const instance = axios.create();// 라이브러리의 timeout 기본 값을 2.5초로 정의하여// 인스턴스의 모든 요청은 2.5초 동안 대기 후 타임아웃 처리된다.instance.defaults.timeout = 2500;// 최종적으로 인스턴스에 설정된 timeout 구성 값 5000으로 덮어쓴다.instance.get('/longRequest', { timeout: 5000}); Ref https://yamoo9.github.io/axios/guide/config-defaults.html 기타WCAG 접근성 가이드를 보기 좋게 정리해 둔 A11Y 프로젝트!Ref https://www.a11yproject.com/ TypeScript 4.6 RCRC는 Release Candidate의 약자라고 한다. 아래와 같은 기능들이 등장했다. Allowing Code in Constructors Before super() Control Flow Analysis for Destructured Discriminated Unions Improved Recursion Depth Checks Indexed Access Inference Improvements Control Flow Analysis for Dependent Parameters –target es2022 More Syntax and Binding Errors in JavaScript TypeScript Trace Analyzer Breaking Changes Ref https://devblogs.microsoft.com/typescript/announcing-typescript-4-6-rc/ State of JS 2021JavaScript 기념 티셔츠를 주는데, 진짜 못생겼다. 사진도 안 가져올란다. 아래는 대체 어떤 의도의 차트인지 모르겠다. 😬 Ref https://2021.stateofjs.com/en-us/ 마무리3일 동안 배민컬쳐캠프를 했다. 열심히 나대서(?) 쿠폰을 4장 받았다. 다 배민쿠폰이라, 당분간은 또 배민 공짜로 이용할 듯하다. 배민의 철학과 역사, 서비스 각 분야에 대한 소개, 그리고 구성원들을 생각하는 가치관이 정말 뚜렷한 회사라는 생각이 들었다. 자부심을 가질 만하다! 드디어 운동을 시작했다. 2회는 필라테스, 1회는 헬스장 가서 유산소를 할 생각이다. 근데 내가 시작하자마자 필라테스 선생님이 코로나에 걸리셨다… 나 때문도 아니고, 내 수업 이후에 접촉하신 거라 상관은 없지만 그냥 속상하다. 그리고 나도 증상이 있어서 자가검진키트를 급하게 사와서 써봤다. 다행히 음성이다. 그냥 피곤했나보다.","link":"/2022/02/19/2022-2-week-3/"},{"title":"2월 4주차 기록","text":"첫 월급 flex~ 배워가기React.cloneElement()12345React.cloneElement( element, [config], [...children]) React.cloneElement()에 대한 공식문서 설명을 아래와 같다. element를 기준으로 새로운 React 엘리먼트를 복사하고 반환합니다. config는 key와 ref 그리고 모든 새로운 props를 포함합니다. 새로운 엘리먼트에는 원본 엘리먼트가 가졌던 props가 새로운 props와 얕게 합쳐진 뒤 주어집니다. 새로운 자식들은 기존의 자식들을 대체합니다. config에 key와 ref가 없다면 원본 엘리먼트의 key와 ref는 그대로 유지됩니다. 그냥 children을 렌더링하는 것과 대체 어떤 차이가 있는지 궁금했었는데, 코드 사례를 보고 나니 조금 이해가 되었다! inGroup이라는 이름의 prop을 받는 Button 컴포넌트가 있다고 치자. (이때 inGroup = true일 경우 레이아웃이 달라진다.) 1234567891011export const Button = ({ inGroup, ... }: Props) =&gt; { return ( &lt;button&gt; {inGroup ? ( &lt;span&gt;Group Button&lt;/span&gt; ) : ( &lt;span&gt;Solo Button&lt;/span&gt; )} &lt;/button&gt; )} 이때 ButtonGroup이라는 상위 컴포넌트 안에 렌더링하는 Button 컴포넌트의 경우 inGroup 프로퍼티를 반드시 true로 강제하고 싶다면, 아래와 같이 작성할 수 있다. 1234567891011121314export const ButtonGroup = ({ direction, children, align }: Props) =&gt; { // 렌더링하는 children에 대해서 inGroup props를 강제해줌 const childProps = { inGroup: true, }; return ( &lt;div&gt; {React.Children.map(children, (child, i) =&gt; { return &lt;&gt;{React.cloneElement(child, childProps)}&lt;/&gt;; })} &lt;/div&gt; );} 주로 위와 같이 동일한 React element를 반복해서 렌더링할 때, 그리고 그때 렌더링되는 자식 요소들이 특정한 prop을 가져야 할 때 사용할 수 있다. TypeScript Omit vs Exclude Omit&lt;Type, Keys&gt; - Type의 프로퍼티에서 Keys를 제거한다. Exclude&lt;UnionType, ExcludedMembers&gt; - UnionType에서 ExcludedMembers에 할당할 수 있는 모든 유니언 집합을 제외한 타입을 반환한다. 얼핏 보면 Omit에서 베이스가 되는 타입은 하나의 명시적인 타입(Type)이고, Exclude에서 베이스가 되는 타입은 어떤 교차 타입(UnionType)이라는 차이처럼 보인다. 둘의 차이를 좀 더 명확히 알아보자. Omit은 Pick에 대응되는 유틸리티 타입으로, 베이스가 되는 객체 타입에서 특정한 프로퍼티들을 제거한다. 1Omit&lt;{ a: string, b: string }, 'a'&gt; === { b: string } Exclude는 유니언 타입을 베이스로, 그 유니언의 특정한 조합을 제거한다. 1Exclude&lt;string | number, string&gt; === number Exclude의 타입 시그니처는 아래와 같다. 1type Exclude&lt;T, U&gt; = T extends U ? never : T; T가 U를 extends한다면, never 타입을 반환할 것이다. 같은 타입을 제공했을 때 Omit과 Exclude가 반환하는 타입이 달라지는 경우가 생긴다. 1234type T0 = Omit&lt;{ a: string, b: string }, &quot;a&quot;&gt; // 1️⃣ type T1 = Exclude&lt;{ a: string, b: string }, &quot;a&quot;&gt; // 2️⃣ type T2 = Omit&lt;string | number, string&gt; // 3️⃣ type T3 = Exclude&lt;string | number, string&gt; // 4️⃣ 1️⃣ a가 제거되어 { b: string } 타입을 반환한다.2️⃣ a는 { a: string, b: string }를 extends하지 않기 때문에, { a: string, b: string } 타입을 반환한다.3️⃣ string | number에서 모든 string key를 제거하기 때문에 (결국 모든 key를 제거하게 된다.) {} 타입이 반환된다.4️⃣ string은 string을 extends하므로 제거되고, number 타입을 반환한다. Ref https://stackoverflow.com/questions/56916532/difference-b-w-only-exclude-and-omit-pick-exclude-typescript 딥링크웹에서 http 혹은 https로 시작하는 주소로 특정 서비스의 웹페이지로 이동할 수 있듯이, 모바일 앱에서 특정 주소 혹은 값을 입력하여 앱 내부의 특정 주소로 이동하는 방법이다. 웹에서 바로 모바일 앱으로 이동할 때 이 모바일 딥링크를 사용한다. 앱은 youtube://처럼 주로 애플리케이션의 이름이 프로토콜이 되는 경우가 일반적이다. 이러한 방식을 URI 스킴 방식이라고 하는데, 스킴값이 서로 중복되는 문제가 발생한다. 이를 근본적으로 해결하기 위해 유니버셜 링크(iOS)와 앱링크(Android)가 탄생했다. 유니버셜 링크는 애플에서 만든 앱에서만, 앱링크는 구글에서 만든 앱만 지원하기 때문에 원활한 광고 운영을 위해서는 URI 스킴 방식을 적절히 활용해야 한다. Ref https://help.dfinery.io/hc/ko/articles/360039757433-딥링크-Deeplink-URI스킴-유니버셜-링크-앱링크-구분과-이해 배열의 원소 타입을 추론하는 코드12345/** 배열의 원소 타입을 추론한다. * ex. ElementOf&lt;string[]&gt; === string*/export type ElementOf&lt;ArrayType extends readonly unknown[]&gt; = ArrayType extends readonly (infer ElementType)[] ? ElementType : never; infer와 never 키워드를 이런 경우 사용할 수 있다. 또, 배열 원소 타입을 추론할 때 원소는 추론하고자 하는 배열 타입에 readonly를 붙여야 한다. Type PredicateType Predicate를 활용하면 효과적으로 타입을 좁힐 수 있다. 123function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined;} 이렇게 사용자 정의 타입 가드를 만들어 사용하면 as 키워드로 타입 단언을 사용하지 않아도 타입 추론을 잘할 수 있다. git submodulesubmodule이란 git 저장소 안에 다른 git 저장소를 디렉토리로 분리해 넣는 것이다. 다른 독립된 git 저장소를 clone 해서 내 git 저장소 안에 포함할 수 있으며 각 저장소의 커밋은 독립적으로 관리한다. 코어 로직들을 별도의 레포로 구성하고 이를 submodule로 가져와서 사용할 수 있다, 이때 submodule 레포를 수정한 후 이를 import 해와서 쓰는 경우, merge 순서가 중요하다(submodule 레포를 먼저 merge해야 한다.) Ref https://git-scm.com/book/ko/v2/Git-도구-서브모듈 PerlPerl은 High Level에서 동작하는 동적 타입 언어이며, 쉘 스크립트에서 기원했기 때문에 시스템 관리에 사용하기 좋은 언어이다. 특히 텍스트 데이터 처리에 용이하다. 정규 표현식과 Perl의 패턴 매치 연산자를 이용하여 특정 문자열에 대해 replace 동작도 수행할 수 있다. 예를 들어 s/(^|-)./uc($&amp;)/ge;s/-//g 는 kebab-case를 PascalCase로 변환한다. s/A/B/g : 모든 A를 B로 변환한다 s/A/B/ge : 모든 A를 B로 변환하는데 eval을 wrapping한다 (^|-). : 문자열의 시작 부분 혹은 `` 가 앞에 있는 모든 문자열의 경우 (1번째 그룹) uc($&amp;) : 대문자로 변환한다 ; : 식의 끝. 이후에 이어서 작성하면 새로운 식 적용 가능 (세미콜론 역할) s/-//g : 모든 ``를 빈 문자로 변환한다 모노레포 빌드 도구모노레포 빌드를 도와주는 대표적인 도구로 lerna가 있으며, 이밖에도 Nx, Turborepo 등 모노레포 빌드를 돕기 위한 다양한 툴들이 있다. 해당 툴들은 아래와 같은 기능들을 제공한다. 로컬 작업 오케스트레이션 변화된 패키지(와 그로부터 영향을 받는 패키지)를 감지 컴퓨테이션 캐싱 패키지간 의존성 시각화 이러한 툴들을 사용하지 않고 직접 yml 파일을 수정 할 수도 있다. yml 파일의 rules를 수정하여 해당 패키지에 변화가 있을 때에만 script를 실행하도록 설정할 수도 있ek. 12345rules: - if: 'BRANCH_NAME' changes: - packages/common/**/*script: yarn build 하지만 이 경우에 변화된 패키지를 의존하는 패키지들은 변화 감지가 되지 않아 공통 패키지의 변경사항(공용 컴포넌트의 스타일이 변경되는 등)이 다른 패키지에 반영되지 않을 수 있다. DDL vs DML vs DCL DDL(Data Define Language, 데이터 정의어) 예) Create, Alter, Drop, Truncate 데이터베이스를 정의하는 언어 데이터를 생성, 수정, 삭제하는 등의 데이터 전체 골격을 결정 DML(Data Manipulation Language, 데이터 조작어) 예) Select, Insert, Update, Delete 데이터베이스 사용자가 데이터를 실질적으로 처리하는데 사용 데이터베이스에 입력된 레코드를 조회, 수정, 삭제 DCL(Data Control Langauge, 데이터 제어어) 예) Grant, Revoke, Commit, Rollback 데이터의 보안, 무결성 등을 정의하는 언어 데이터베이스에 접근하거나 객체에 권한을 줄 때 사용 SuperstructTypeScript를 사용하며 무려 런타임에 데이터를 검증할 수 있도록 설계된 라이브러리다! 인터페이스를 보다 쉽게 정의하고, 그 인터페이스에 대한 JavaScript 데이터 검증을 할 수 있다. API로 받아온 임의의 값을 필요할 때, 런타임에서 데이터의 구조를 검증할 때 유용하다. object, number, string 등 함수로 타입을 정의하고 assert 함수로 검증을 실행하며, 실패 시 Error를 throw한다 Ref https://docs.superstructjs.org/ 정규표현식의 Lookahead와 Lookbehind X(?=Y) (Positive Lookahead) : 본래 패턴에 맞는 곳을 우선 찾고, Lookaround 조건이 맞으면 매칭한다. X(?!Y) (Negative Lookahead) : Positive Lookahead와 다르게 조건에 충족하지 않으면 매칭된다. (?&lt;=Y)X (Positive Lookbehind) : Positive Lookahead와 반대로 조건 Y에 충족하는지 먼저 체크하고 맞는 패턴 X를 찾는다. (?&lt;!Y)X (Negative Lookbehind) : 조건 Y에 충족하지 않는지 체크하고 맞는 패턴 X를 찾는다. Lookaround는 조건을 겹칠 필요가 있을 때 유용하게 사용할 수 있다. 예를 들어, 숫자와 영문자와 특수문자 3종류가 모두 포함된 문자열을 찾아야 할 때, 즉 3가지 조건에 충족하는 문자열을 매칭할 때 다음과 같이 작성할 수 있었다. 특수문자의 경우 일일이 모든 경우의 수를 입력해주어야 하기 때문에 정규식이 좀 길어질 수밖에 없었다. 1/^(?=.*[A-Za-z])(?=.*[0-9])(?=.*[!@#$%^&amp;*()_+\\-=\\[\\]\\{\\}\\;\\'\\,\\.\\/\\&lt;\\&gt;\\?\\~\\`])[A-Za-z0-9!@#$%^&amp;*()_+\\-=\\[\\]\\{\\}\\;\\'\\,\\.\\/\\&lt;\\&gt;\\?\\~\\`]{0,}$/ Ref https://ko.javascript.info/regexp-lookahead-lookbehind TypeScript의 객체 키 추론 방식TypeScript는 Record&lt;Key, Value&gt; 타입의 객체에 대해 Object.keys()나 Object.entries()의 키타입이 무조건 Key[]가 아니라 string[]을 추론하게 된다. Object.entries에서 key를 string 타입으로 지정하는 이유는 여기서 찾을 수 있다. Object.entries를 순회할 대상이 되는 객체가 특정 객체를 확장한 타입의 객체일 때, key의 타입 추론에 실패하기 때문이다. Ref https://www.reddit.com/r/typescript/comments/rc1wwd/objectentries_on_record_type_is_incorrect_and/ lock 파일의 중요성package.json에 명시되어있지 않은 라이브러리어도 lock 파일에 포함되어 있으면 설치된다. 하지만 그러면 버전 관리를 하기 힘들 것이다. ex) emoji-regex 라이브러리를 통해 이모지 정규식을 사용하는데, 이모지를 제대로 잡아내지 못하길래 보니 emoji-regex 라이브러리가 package.json 파일에 명시되어 있지 않았고 lock 파일에만 존재했다. 버전이 낮아서 제대로 잡아내지 못했던 것이다. 💡 lock 파일을 정리하는 법 yarn v2 : yarn dedupe 명령어를 통해 중복 dependency를 정리할 수 있다. 번들 사이즈도 줄여주는 효과가 있다. yarn v1 : yarn dedupe 명령어는 v2부터 지원한다. v1에서는 yarn-deduplicate 라이브러리가 지원한다 setTimeout vs setIntervalsetTimeout과 setInterval의 차이는 콜백함수를 실행시키는 간격이다. 1234567setInterval(fn, 1000)setTimeout(function cbFn() { fn(); setTimeout(cbFn, 1000)}, 1000) 위 코드에서 setInterval은 1초가 지날 때마다 콜백함수를 바로바로 호출한다. 콜백함수의 종료는 신경쓰지 않고, 그냥 냅다 실행만 시키고 시간은 흘러간다. 반면 setTimeout은 setTimeout이 재귀 호출되기 전에 fn함수가 실행 및 종료가 된 후에 setTimeout을 다시 호출한다. 즉, 함수가 종료된 후에 다시 1초를 기다리기 때문에 정확히 1초 간격으로 진행된다. 그렇기 때문에 잘못 사용(ex. 잘못된 위치에서 interval을 clear)하면 더이상 요청하지 않아도 되는 요청을 엄청 많이 실행하게 될 수도 있다. 123456789101112let count = 0;let counter = setInterval(() =&gt; { count++; if (count &gt; 5) { if (await dialog('다이얼로그 확인')) { //... } clearInterval(counter); // dialog 지옥이 펼쳐짐! }}, 200); Ref https://velog.io/@proshy/JS일정-간격으로-함수를-호출할-때-setTimeout-vs-setInterval dot notationantd 라이브러리 일부 컴포넌트의 네이밍은 같은 결의 컴포넌트를 응집하여 정의한다. 123Typography.TextTypography.TitleTypography.Paragraph notation의 최상단 컴포넌트는 하위 컴포넌트들이 공유할 state와 update logic을 추상적으로 제공하고, 하위 컴포넌트에서는 공유되는 값을 이용해서 원하는 대로 렌더링 제어를 할 수 있게되는 구조로 이해할 수 있다. Compound ComponentsKent C. Dodds가 제시한.. 건진 모르겠지만 작성한 포스팅에서 등장하는 개념이다. HTML에서 제공하는 기본 태그인 &lt;select&gt;와 &lt;option&gt;은, 암묵적으로 로직을 공유하는 부분이 있는 컴포넌트의 관계로 생각해볼 수 있다. Dodds는 이를 활용하여 같은 context를 공유하는 Toggle 컴포넌트와 Toggle.On, Toggle.Off, Toggle.Button 컴포넌트의 예시를 제공하고 있다. 중재자 패턴 (Mediator Pattern)객체들이 서로 직접 통신하지 않고 중재자를 통해서 통신하도록 구성하는 패턴으로, 각 객체 간의 의존성을 줄여 결합도를 감소시킬 수 있다. 채팅을 할 때 사람들끼리 모두 직접적으로 연결되어 있는 것이 아니라, 채팅방이라는 매개체를 통해서 통신하는 구조와 같다. (M:N → M:1) 이것저것 stale-while-revalidation 캐시전략 - API 요청에 대해 캐시된 데이터가 있는 경우 캐시 데이터를 사용하여 사용자에게 화면을 제공하고, 후에 도착한 최신 API응답을 사용해서 화면을 최신화하는 캐시 전략 Recoil과 jotai의 데이터 관리법은 다르다. Recoil은 문자열 키값, jotai는 object reference를 통해 데이터를 관리한다. 도메인 계층은 뒤에서부터 순차적으로 탐색을 진행하기 때문에 AWS Route 53에서 도메인 확인을 할 때에도 devbaemin.in 처럼 뒤에서부터 검색해야한다. Optimistic UI(낙관적인 UI)란, 특정 요청이 성공할 것이라 가정하고 먼저 그 요청의 결과를 보여주는 방식이다. 페이스북의 좋아요 버튼을 누르면 바로 좋아요 누르기에 성공한 것처럼 UI에 표시되지만, 실제 네트워크 탭을 보면 요청과 완료는 그보다 늦게 진행되는 것이 그 예시다. 반대로 비관적 업데이트는 서버의 응답을 기다리고 처리하는 방식이다. blue-green 배포란, blue(원본), green(대체) 두 버전 모두 실행 상태를 유지시켜 놓고 blue에 배포가 진행되면 green으로 잠시 사용자 트래픽을 이전해두는 방식의 무중단 배포 아키텍쳐다. 심볼릭 링크란, 링크를 연결하여 원본 파일을 직접 사용하는 것과 같은 효과를 내는 링크이다. package.json에 패키지 의존성을 추가할 때, ^(캐럿)을 붙임으로써 자동 업데이트의 위험성은 존재하지 않는지 고려해봐야 한다. 또, yarn에서는 패키지 버전에 ^을 붙여도 자동 업데이트를 하지 않는다. outline-offset - outline과 요소의 border 영역 사이의 여백을 정의할 수 있는 속성이다. Next.js(10 버전 이상)에서는 이미지 lazy loading이 자동으로 적용되어 있다. core-js는 폴리필 라이브러리로 ES 최신 문법에 대한 폴리필을 지원한다. 단독으로 사용할 수도 있지만, babel이나 swc에 통합되어 있기 때문에 자연스럽게 같이 사용할 수 있다. 개발자를 농락하는 이모지의 재미있는 사실123const test = '해피👨‍👨‍👧‍👦뉴이어';test.slice(0, 4); // '해피👨'test.slice(0, 7); // '해피👨‍👨' 이모지를 포함한 문자열을 원하는 길이로 자를 때는 반드시 주의하자! (이모지를 제거 후에 순수한 문자열을 자르는 것도 좋은 방법이다.) optionalDependencies - npm install --no-optional 명령어로 실행하며, optionalDependencies에 추가한 디펜던시는 설치되지 않는다. 네이밍에 대한 컨벤션을 강제할 수 있는 lint rule이 있다. CSS shadow 모아보기 Ref https://kdydesign.github.io/2020/08/25/mono-repo-lerna/ https://www.typescriptlang.org/docs/handbook/advanced-types.html https://docs.npmjs.com/cli/v6/configuring-npm/package-json#optionaldependencies 기타요번주는 읎당 ㅎㅎ 이번주에 읽은 &amp; 본 것들을 모아보자. React.cloneElement()https://blog.logrocket.com/using-react-cloneelement-function/ Headless 컴포넌트https://medium.com/@nirbenyair/headless-components-in-react-and-why-i-stopped-using-ui-libraries-a8208197c268 TypeScript로 React Generic Component 정의하기https://medium.com/@hamzazaheer721/generic-components-in-react-typescript-ea8e77735f84 svg viewport * viewboxhttps://puterism.com/svg-viewport-and-viewbox/ ‘세이클럽의 아버지’ 남세동 대표의 인공지능 강의①https://www.youtube.com/watch?v=mDqCC3i14bI 마무리첫 월급을 받았다! 많이 주는 줄 알았지만 진짜 많이 줘서… 이래도 되나 싶고… 그만큼 또 열심히 해야겠당. ‘나에게 주는 선물’ 중독자는 이틀동안 2만 보 가까이 걸으며 알차게 플렉스를 즐기고 앓아눕진 않았다. 고작 지난 2주 운동한 게 효과가 있나보다 ㅎㅎ 운동 더 열심히 해서 짱 쎄져야겠다고 다짐했다.","link":"/2022/02/27/2022-2-week-4/"},{"title":"3월 첫주차 기록","text":"운동조와 배워가기tsconfig의 baseURLtsconfig.json에 있는 baseURL 에 따라 타입 체킹 타임에서 모듈의 위치를 판단한다. src는 루트 디렉토리에 존재하고, src/component 디렉토리 하위에 있는 모듈을 import하고자할 때 baseURL: ‘.’일 경우에는 import ‘src/component/...’;처럼 작성하지만, baseURL: ‘src’일 경우에는 import ‘component/...’;와 같은 식으로 경로를 작성할 수 있다. 하지만 IDE에서 인지했다고 해서 빌드 중 해당 파일을 반드시 찾을 수 있는 것은 아니다. 빌드 시에는 webpack config 파일의 resolve.modules 항목에 따라 모듈의 위치를 판단한다. 1234567// webpack.config.jsmodule.exports = { //... resolve: { modules: ['node_modules'], },}; Ref https://webpack.js.org/configuration/resolve/#resolvemodules Template Literal Types로 타입 안전하게 코딩하기Template Literal Type이란 기존 TypeScript의 String Literal Type을 기반으로 새로운 타입을 만드는 도구이다. 여기서 살펴볼 것은, Template Literal Type을 Union type(합 타입)과 함께하면, 결과물도 Union Type이 된다는 사실이다. 12345type Baemin = 'baemin';type Teams = 'store' | 'riders' | 'b-mart' | 'ceo-square';// type BaeminTeams = 'baemin store' | 'baemin riders' | 'baemin b-mart' | 'baemin ceo-square';type BaeminTeams = `${Baemin} ${Teams}` Ref https://toss.tech/article/template-literal-types SVG vs Canvas SVG 벡터 그래픽 기반이다. 확대하거나 해상도가 바뀌어도 그림이 깨지지 않는다. 데이터가 적으면 퍼포먼스가 빠르지만, 데이터가 클 경우 계산이 필요해서 속도가 떨어진다. 크기가 작은 이미지에 적합하다. 이벤트 핸들러를 사용할 수 있다. Canvas 비트맵 그래픽 기반으로, 반응형에 취약하다. 많은 데이터를 한번에 보여주거나, 큰 이미지의 경우에 적합하다. 고성능 애니메이션, 동영상 조작 작업, 게임 제작에 적합하다. canvas 요소는 width, height 속성값이 변경되면 이미 그려져있는 canvas가 초기화된다. 이벤트 핸들러를 사용할 수 없다. 안티 앨리어싱앨리어싱(Aliasing)이란, 컴퓨터 그래픽 해상도의 한계로 선 등이 우둘투둘하게 되는 현상을 말한다. 계단 현상이라 부르기도 한다. 안티 앨리어싱(Anti-Aliasing)이란 이를 방지하는 것을 의미한다. 브라우저는 이미지를 확대했을 때, 원래 픽셀에 해당하는 부분을 매끈하게 처리하는 안티 앨리어싱 처리를 한다. 그래픽이 중요한 게임 등의 서비스에서 많이 사용하는 개념이다. Ref https://post.naver.com/viewer/postView.nhn?volumeNo=21010728&amp;memberNo=42689664 .ts 파일 내 모듈 순서(import 순서)를 정렬하기eslint의 sort-imports 룰을 이용하면 같은 import 라인 상에서 named export 된 모듈명을 정렬할 수 있다. 12345678910{ &quot;sort-imports&quot;: [&quot;error&quot;, { &quot;ignoreCase&quot;: false, &quot;ignoreDeclarationSort&quot;: false, &quot;ignoreMemberSort&quot;: false, &quot;memberSyntaxSortOrder&quot;: [&quot;none&quot;, &quot;all&quot;, &quot;multiple&quot;, &quot;single&quot;], &quot;allowSeparatedGroups&quot;: false }]} 🤓 참고 eslint-plugin-import의 import/order 룰을 사용하면, path에 따라 그루핑을 하여 각 줄들을 정렬할 수 있다. eslint-import-resolver-typescript로 settings를 설정하면 tsconfig에 설정해둔 path alias를 internal로 인식해준다. Ref https://eslint.org/docs/rules/sort-imports OAuth 2.1에서 달라진 것OAuth 2.1에서는 2.0에서 주로 보안 이슈를 제거했다. Password Grant Type 폐지 (grant_type=password) Implicit Grant 폐지 (response_type=token) PKCE 도입 (부가적인 코드 챌린지 과정) Client에서의 토큰 노출을 피하길 권고 Glob 패턴Glob 패턴은 와일드카드 문자를 사용해서 일정한 패턴을 가진 파일 이름들을 지정하기 위한 패턴이다. tsconfig.json과 같은 설정 파일 내에서 경로 지정 시 사용할 수 있다. 예를 들어, /**/*.js와 같이 경로를 지정해주었다면, 현재 디렉토리와 그 하위 디렉토리 내에 존재하는 모든 .js 파일들을 선택한다. Ref https://velog.io/@k7120792/Glob-패턴과-정규표현식 Record&lt;Keys, Type&gt; vs 인덱스 시그니처TypeScript에서 객체 타입을 지정할 때 사용하는 Record&lt;Keys, Type&gt;와 인덱스 시그니처 중에서, key를 명확하게 표현하고자 할 때는 인덱스 시그니처를 사용하는 것이 바람직하다. 1type example = { [name: string]: number } 위 예제와 같이 key가 name이라는 의도를 명확하게 표현할 수 있기 때문이다. 하지만 key를 특정 타입으로 제한하고자 할 때는 Record 타입을 쓰는 것이 좋다. 인덱스 시그니처의 key는 number나 string 타입만 허용하며, 문자열 리터럴을 허용하지 않기 때문이다. 🤓 생각해보기 런타임 때까지 객체의 속성을 알 수 없을 경우에만(예를 들어 CSV 파일에서 로드하는 경우) 인덱스 시그니처를 사용하도록 한다. 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 한다. z-index와 쌓임 맥락‘쌓임 맥락’은 가상의 Z축을 사용한 HTML 요소를 3차원으로 개념화한 것이다. Z축 사용자 기준으로 보여지는 화면과 각각의 HTML 요소는 자신의 속성에 따른 우선순위를 사용해 3차원 공간을 차지하고, 그렇게 쌓여가는 것을 쌓임 맥락이라 부른다. z-index만을 이용하면 원하는 대로 쌓임 맥락을 만들 수 없다. 새롭게 만들어진 쌓임 맥락은 이전에 만들어진 쌓임 맥락보다 무조건 앞에 존재하기 때문이다. 따라서 뒤에 있는 쌓임 맥락에 z-index를 아무리 큰 숫자를 주더라도 앞에 있는 쌓임 맥락보다 앞에 올 수 없게 된다. 모든 쌓임 맥락에는 그것의 뿌리(root) 요소인 HTML 요소가 있다. 어떤 요소에서 쌓임 맥락이 새롭게 만들어질 때, 그 쌓임 맥락은 자식 요소들이 쌓임 순서에서 특정 범위를 벗어나지 못하도록 한계를 정하게 된다. 이는 맨 뒤의 쌓임 맥락에 있는 요소는 그보다 앞의 쌓임 맥락에 있는 요소보다 앞에 나올 수 없다는 것을 의미한다. 🤓 isolation: isolateisolation CSS 속성은 요소가 새로운 쌓임 맥락을 생성해야 하는지 지정한다.isolation: isolate은 항상 새로운 쌓임 맥락을 생성합니다. Ref http://b1ix.net/295 https://developer.mozilla.org/ko/docs/Web/CSS/isolation 크롬 개발자 도구의 Console Utilities API크롬 개발자 도구에서 제공하는 Console Utilities API는 특정 태스크들을 수행하기 위한 편리한 메서드들을 제공한다. 주로 DOM을 선택하고 탐색하거나, 데이터를 읽기 쉬운 형식으로 변환하거나, 프로파일러를 멈추고 실행시키거나, DOM 이벤트들을 모니터링할 때 사용할 수 있는 도구들이다. $0 : 현재 inspector로 선택한 element, 그 다음 선택한 것은 $0에 계속 갱신이 되고, 이전에 선택했던 것은 $1, $2, $3, $4에 차례로 할당된다. 즉 내가 inspector로 선택한 element 총 5개를 기억해두고 쓸 수 있다. $_ : console 창에서 맨 마지막에 계산된 값을 불러올 수 있다. $(selector) : jQuery처럼 document.querySelector를 줄여서 쓸 수 있다. 이밖에도 $ 표시로 시작하는 다양한 셀렉터들이 존재하니 구경 가보자~!1 Ref https://developer.chrome.com/docs/devtools/console/utilities/#0-4 useEffect와 useMemo의 실행 순서A 컴포넌트가 B 컴포넌트를 감싸는 형태일 때, 각 컴포넌트에 useEffect와 useMemo가 구현되어 있다고 가정해보자. useEffect : B 실행 후 A가 실행된다. 즉 useEffect는 컴포넌트를 모두 그린 뒤 실행되며, 이에 따라 자식-부모 순서로 실행된다. useMemo : A 실행 후 B가 실행된다. 즉 useMemo는 컴포넌트를 그리기 시작할 때 실행되며, 이에 따라 부모-자식 순서로 실행됨 논리 픽셀과 물리 픽셀논리 픽셀(css 상의 픽셀)과 물리 픽셀(실제 디바이스 픽셀)이 따로 존재한다. 디바이스, 또는 브라우저마다 논리 픽셀과 실제 픽셀의 비율이 다를 수 있다. 그래서 디바이스에 따라 경계선이 흐리게 보이는 sub-pixel rendering 이슈가 발생할 수 있다. 예를 들어, 아이폰 4가 구현하는 해상도는 640960 이고(물리 픽셀), CSS로 표현할 수 있는 값은 320480일 때 (논리 픽셀), CSS로 구현하는 화면은 320px이지만 실제 해상도는 640px로 2배의 밀도를 가지게 된다. (ratio 2) 만약 아이폰4에 디자인 작업을 할 때 320px의 디자인 파일을 받아서 작업을 하게 된다면, 640px의 해상도 화면에 320px의 디자인이 적용되기 때문에 이미지를 늘여 놓은 것과 같은 뿌연 화면이 나타나게 된다. 그렇기 때문에 모바일 작업을 할 때는 물리 픽셀에 맞춘 디자인으로 작업을 해야 한다. 이는 window.devicePixelRatio를 통해 해결 가능하다. width나 height에 window.devicePixelRatio를 곱해주면 된다. 논리픽셀을 적용하기 위한 수단으로 meta 태그를 사용할 수도 있다.&lt;meta name=“viewport” content=“width=device-width”&gt; Ref https://abcdqbbq.tistory.com/47 객체의 결합도 / 응집도결합도는 서로 다른 모듈 간에 상호 의존하는 정도 또는 연관된 관계를 의미한다. 응집도는 한 모듈 내부의 처리 요소들이 서로 관련되어 있는 정도를 말한다. 객체의 응집도란, 객체들간의 응집도가 아니라 객체 내 정의된 메서드들 간의 응집도를 가리킨다. 응집도가 높으면, 변경 대상과 범위가 명확해지는 장점이 있어서 코드를 수정하기 쉬워진다. 객체는 제너럴리스트가 아니라 스페셜리스트일수록 응집도가 높다. GNB/LNB/SNB/FNB GNB(Global Navication bar) 어느페이지에 들어가도 공통적으로 사용할 수 있는 메뉴 리액트 공홈에서 문서, 자습서, 블로그, 커뮤니티 부분에 해당하는 곳 LNB(Local Navigation Bar) GNB를 누를 경우 소제목 형식으로 나오는 메뉴 SNB(SIde Navigation Bar) 사이드 메뉴 일반적으로 왼쪽에 있어서 LNB(Left Navigation Bar)라고 부르기도 한다. FNB (Foot Navigation Bar) setInterval과 setTimeout으로 custom hook 만들기리액트의 함수 컴포넌트를 이용하여 1초마다 증가하는 카운터를 만들어보자. 가장 먼저 드는 생각은 useEffect에서 setInterval을 사용하는 것이다. 123456789101112function Counter() { let [count, setCount] = useState(0); useEffect(() =&gt; { let id = setInterval(() =&gt; { setCount(count + 1); }, 1000); return () =&gt; clearInterval(id); }); return &lt;h1&gt;{count}&lt;/h1&gt;;} 위 코드는 괜찮아 보이지만, count값은 시간이 지나도 계속 1일 것이다. 리액트는 기본적으로 매 렌더링마다 effect를 다시 등록하기 때문이다. 그러면, useEffect의 두 번째 인자로 [] (빈 배열)을 넣어 컴포넌트 초기 마운트 시에만 effect를 실행할 수 있도록 코드를 수정해보자. 123456789101112function Counter() { let [count, setCount] = useState(0); useEffect(() =&gt; { let id = setInterval(() =&gt; { setCount(count + 1); }, 1000); return () =&gt; clearInterval(id); }, []); return &lt;h1&gt;{count}&lt;/h1&gt;;} 그러나 이 역시 정상 작동하지 않는다! count 값은 한번 1로 증가한 후 계속 멈춰 있는다. useEffect가 첫 번째 렌더링 시에 count의 값(즉, 0)을 capture하기 때문이다. 다시 말하면, setInterval이 만든 클로저가 첫 번째 렌더 시의 count의 값을 계속 참조하고 있기 때문에, count + 1은 항상 1이다! 문제를 해결하기 위한 두 가지 방법이 있다. 첫 번째는 setCount(count + 1) 대신 setCount(c =&gt; c + 1)와 같은 형식의 ‘updater’ 함수를 사용하는 것이다. 그러면 항상 count가 가리키는 최신값을 가지고 업데이트를 수행할 수 있다. 두 번째는 useReducer()를 사용하는 것이다. reducer 안에 현재 상태와 새로운 props를 넣으면, dispatch 함수는 변하지 않기 때문에 어떤 클로저에서든 데이터를 집어넣을 수 있다. 여기서 나아가, Dan abramov는 그의 블로그에서 setInterval hook을 제안한다. 12345678910111213141516function useInterval(callback, delay) { const savedCallback = useRef(); useEffect(() =&gt; { savedCallback.current = callback; }); useEffect(() =&gt; { function tick() { savedCallback.current(); } let id = setInterval(tick, delay); return () =&gt; clearInterval(id); }, [delay]);} setInterval은 기존의 값을 계속해서 기억하고 있으며, 개발자가 언제든 새롭게 상태(ex. delay 값)를 변경할 수도 있다. useRef hook을 통해 setInterval에 넘어오는 콜백 함수를 붙잡아두고, 렌더링 전후로 해당 함수를 기억하게 되는 것이다. 이제 정상 작동하는 카운터를 실행할 수 있게 되었다! Ref https://overreacted.io/making-setinterval-declarative-with-react-hooks/ https://www.aaron-powell.com/posts/2019-09-23-recursive-settimeout-with-react-hooks/ 이것저것 useQuery를 사용했을 때, return 값이 undefined가 나오는 이유는 (당연히) 데이터가 비동기로 오기 때문에 아직 값이 없는 상태일 수 있기 때문이다. undefined가 아닌 데이터만을 원한다면 isSuccess 메서드를 통해 데이터를 활용하면 된다. package.json의 main 옵션은 프로그램의 시작점이 되는 모듈의 ID를 가리킨다. 즉 ‘foo’라는 패키지가 있다면, 이 패키지를 사용자가 설치한 뒤, require('foo')를 실행했을 때 main으로 지정한 모듈의 exports 객체가 반환된다 next 빌드 타임에는 환경이 브라우저가 아닌 node기 때문에 window 객체에 접근할 수 없다. stale-while-revalidate 캐시 전략: API 요청에 대한 캐시 데이터가 있다면, 일단 캐시 데이터를 이용해서 사용자에게 UI를 제공하고, API 요청이 완료되면 최신 데이터로 화면을 최신화하는 전략 TTS(Text-to-Speech): 텍스트를 음성으로 변환하는 기술이다. 토스페이스 이모지에서 의미를 바꿔버린 탓에 문제가 될 수 있다고 한다. css 스크롤 체이닝과 overscroll-behavior-x: contain; 속성은 자식 컴포넌트의 스크롤이 끝까지 도달했을 때 스크롤 체이닝으로 묶여 있는 부모 컴포넌트가 스크롤이 시작되는 것을 막아주는 속성이다. window.onClickNativeBack - 안드로이드 뒤로가기 버튼 누를 때 등 웹뷰에서 제어할 수 없는 뒤로가기 action에 대한 구현이 필요할 때 사용할 수 있다. TypeScript의 infer 키워드는 CSS parser나 Router params에서 요소들을 추출하여 타입 체크를 수행할 때 사용할 수 있다. 조건에 따라 다른 값의 변수를 선언하고 싶을 때 즉시 실행함수를 사용할 수 있다.1234567const value = (() =&gt; { if(condition) { return 1 } else { return 2 }})() 배열의 모든 원소의 값이 true인지 확인할 때, 아래와 같이 작성할 수 있다.1arr.every(Boolean); TypeScript 4.5에 새로 등장한 유틸리티 타입 중에 Awaited 가 있다. Promise 타입의 반환값을 가리킨다. 123456// A = stringtype A = Awaited&lt;Promise&lt;string&gt;&gt;;// B = numbertype B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;;// C = boolean | numbertype C = Awaited&lt;boolean | Promise&lt;number&gt;&gt;; Ref https://docs.npmjs.com/cli/v7/configuring-npm/package-json#main https://github.com/ghoullier/awesome-template-literal-types 기타github에서 Markdown으로 다이어그램 그리기123456```mermaid graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; 위와 같이 작성하면 아래와 같이 그려진다고 한다! 나날이 발전하는 github… 질수 없다. 따라잡아야지… Ref https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/ Remix vs Next.js요새 최고로 핫해보이는… Remix 그리고 목숨을 위협 받는(?) Next.js Ref https://blog.bitsrc.io/remix-vs-next-js-a-detailed-comparison-6ff557f7b41f 프론트엔드 테스트오랜만에 다시 살펴보는 프론트엔드 테스트. 우테코 프로젝트를 하며 실제로 많이 사용했던 react-testing-library와 hook 테스트에 대한 자세한 사용기가 있어서 추억(?)이 새록새록했다. Ref https://tech.madup.com/front-test-tips/ React hook이 별로인 이유공감하는 부분들도 있다! 뭐든 모두를 만족시킬 수 있는 도구는 없는 것 같다. 시간이 흐르고 기술이 발전해도 늘 사람들은 불평투성이야 😬 Ref https://blog.bitsrc.io/some-reasons-for-disliking-react-hooks-80f1e18eb9b3 2022년 UI/UX 디자인 트렌드Ref https://medium.com/codeart-mk/ux-ui-trends-2022-31023ae36fa 마무리벌써 3월이당. 동생을 포함해서 아직 학교 다닐 사람들은 학교 개강하고, 괜히 봄이 찾아오는 것 같은 기분이다. 내 일상은 3월이 되어도 달라지는 게 없어서 그런가 이전만큼 봄이 새롭거나 설레진 않지만, 지금처럼 잔잔한 일상이 더없이 소중하게 느껴지는 하루하루다. 진짜 드라마 안 보는 성격인데 작년부터 왜 그렇게 보고싶은 게 하나씩 생기는지 모르겠다. 살만해져서 그런가… 며칠전엔 친구에게 넷플릭스 &lt;소년심판&gt;을 추천받아서 조금씩 보는 중이다. 성악설에 조금 기운 내게, 양아치 미자들을 정말 싫어하는 내게 딱 맞는 내용이다. 😬 일단 여유가 있을 때니 마저 봐야겠다.","link":"/2022/03/05/2022-3-week-1/"},{"title":"3월 2주차 기록","text":"유캔두 100일 종료! 배워가기2개 이상의 modal이 떴을 때 순서대로 닫기document.activeElement를 통해 현재 focus 된 element 요소를 가져올 수 있다. modal이 띄워진 상태에서 새로운 modal을 띄울 때, 가장 최근에 focus 된 element (기존에 띄워진 modal의 자식 element)를 저장해두고, 새로운 modal을 focus한다. 그리고 focus된 새로운 modal을 닫을 때, 이전에 저장해둔 element를 다시 focus 함으로써 focusing 대상이 첫번째 modal의 자식이 될 수 있게 구현한다. (실제 이벤트 동작을 위해서는 이벤트 버블링을 이용한다.) 위와 같은 방식으로 띄워진 modal의 순서에 맞춰 focusing이 가능해졌다. react-component dialog가 위와 같은 방식으로 구현되어 있다. TypeScript에서 Discriminated union을 구조 분해 할당하면?TS 4.6 이전 버전에서는 Discriminated union(Tagged union)을 구조 분해 할당할 경우 TypeScript가 문맥을 잃어 태그에 따른 나머지 필드에 대한 타입을 잡아주지 못했지만, 이제는 잡아줄 수 있다. 123456789101112131415161718192021222324252627282930313233343536type Action = { tag: 'a'; payload: number; } | { tag: 'b'; payload: string; }type A = { tag: 'a'; payload: number;}type B = { tag: 'b'; payload: string;}type AorB = A | B; // tagged unionfunction typeCheck(param: AorB) { const { tag, payload } = param; if (tag === 'a') { // v4.6 : payload는 number로 추론됨 // v4.5 : payload는 number | string으로 추론됨 console.log(payload.toFixed()); // v4.5에서만 error } else { // v4.6 : payload는 string으로 추론됨 // v4.5 : payload는 number | string으로 추론됨 console.log(payload.toLocaleUpperCase()); // v4.5에서만 error }}// v4.5에서 error가 나지 않으려면function typeCheckAgain(param: AorB) { if (param.tag === 'a') { console.log(param.payload.toFixed()); } else { console.log(param.payload.toLocaleUpperCase()); }} 추가적으로, 이전에는 jsx 코드를 컴파일할 경우 의미 없는 void 0 이라는 코드가 붙어서 컴파일되었지만, 이제는 이 부분이 제거되었다. 그래서 번들 사이즈가 향상되었다. Ref https://devblogs.microsoft.com/typescript/announcing-typescript-4-6/#removed-unnecessary-arguments-in-react-jsx react-router v6에서 달라지는 것React-Router v6부터 Routes 이하에는 Route와 React.Fragment만 들어갈 수 있다. Routes 이하의 컴포넌트에 제약을 걸어, 복잡하지 않고 효과적인 경로 분기 처리를 위함이다. 1234567// 가능&lt;Routes&gt; &lt;Route path={...} element={&lt;Foo/&gt;}/&gt; &lt;&gt; &lt;Route path={...} element={&lt;Bar/&gt;}/&gt; &lt;/&gt;&lt;/Routes&gt; 12345678910// 불가능&lt;Routes&gt; {routes.map(({ path, element }) =&gt; ( &lt;RouteWrapper key={path} path={path} element={element}/&gt; )}&lt;/Routes&gt;// ... function RouteWrapper(info: RouteInfo): React.ReactNode { return &lt;Route {...info} /&gt;} Art DirectionArt direction은 각기 다른 디스플레이 사이즈에 맞추어 보여지는 이미지를 제공하고자 하는 것이다. 데스크톱 화면에서는 전체 풍경을 보여 주는 가로 이미지를 보여주고 모바일 화면에서는 좀 더 편하게 볼 수 있게 세로 이미지를 제공한다. 미디어 쿼리를 통해 웹페이지 가로모드 / 세로모드에 맞춰 css를 작성할 수 있다. @media (orientation: portrait) 세로모드 @media (orientation: landscape) 가로모드 Ref https://studiomeal.com/archives/1068 hooks &amp; presentational pattern리액트에서 비즈니스 로직과 뷰를 분리하기 위해 custom hook을 사용할 수 있다. 이를 hooks &amp; presentational pattern 이라고 한다. 많은 경우 custom hook은 반복되는 로직을 줄이는 목적으로 사용을 하는데, 컴포넌트 서비스 로직의 대부분을 custom hook에 넣고 컴포넌트에서 사용되는 데이터들만 따로 반환해 줌으로써 view와 logic을 분리할 수 있다. 하지만 잘못 사용하게 되면, 어떤 내용으로 코드가 동작하는지 로직들이 훅에 가려져서 코드 파악이 어려워 지니, 당장 몰라도 되는 디테일만 custom hook으로 빼내고, 코드 파악에 핵심이 되는 요소들은 컴포넌트에서 직접 다루는 연습이 필요하다. Ref https://felixgerschau.com/react-hooks-separation-of-concerns/ https://vallista.kr/Component-분리의-미학/ dangerouslySetInnerHTML리액트에서 innerHTML 대신 string 형태의 HTML 문자열을 렌더링하기 위한 속성이다. innerHTML은 XSS 공격에 취약하기 때문에 위험하다는 걸 상기시키는 역할을 한다. &lt;div dangerouslySetInnerHTML={ {__html: ${stringHTML}} }&gt;와 같은 방식으로 작성한다. dangerouslySetInnerHTML을 사용하면 리액트는 해당 요소의 컨텐츠가 동적이라는 것을 알고, 해당 노드의 자식에 대해서는 가상 DOM을 비교하는 과정을 수행하지 않는다. 유저가 많은 양의 텍스트를 입력하여 해당 내용을 보여주고자 할 때와 같은 경우, 데이터에 html 태그가 표함되어 있는 경우 등에서 사용할 수 있다. 예를 들어, 1234567891011const App = () =&gt; { const data = 'lorem &lt;b&gt;ipsum&lt;/b&gt;'; return ( &lt;div&gt; {data} &lt;/div&gt; );}export default App; 위와 같은 경우 &lt;b&gt; 태그는 html 태그로 인식되지 않고 &lt;b&gt;ipsum&lt;/b&gt;가 문자열 그대로 화면에 출력될 것이다. 이럴 때 dangerouslySetInnerHTML을 사용하여 &lt;b&gt; 태그를 올바르게 인식하여 html을 출력하게 해준다. 123456789101112const App = () =&gt; { const data = 'lorem &lt;b&gt;ipsum&lt;/b&gt;'; return ( &lt;div dangerouslySetInnerHTML={{__html: data}} /&gt; );}export default App; Ref https://ko.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml https://blog.logrocket.com/using-dangerouslysetinnerhtml-in-a-react-application/ ReactNode vs ReactElement vs JSX.Element의 타입ReactNode는 ReactElement이자 &amp; JavaScript의 원시타입이다. 가장 넓은 타입을 가지고 있고, 클래스 컴포넌트에서 render() 메소드의 반환 값으로 사용된다. 123456type ReactText = string | numbertype ReactChild = ReactElement | ReactTextinterface ReactNodeArray extends Array&lt;ReactNode&gt; {}type ReactFragment = {} | ReactNodeArraytype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined ReactElement는 type과 props를 가지는 타입으로 props 및 type의 타입을 지정할 수 있다. 함수형 컴포넌트의 반환 값으로 사용된다. 12345678interface ReactElement&lt; P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; { type: T props: P key: Key | null} JSX.Element는 ReactElement의 제네릭 타입에 any가 지정된 타입이다. JSX.Element는 글로벌 네임스페이스로 정의되어있어 각 라이브러리에서 지정하는 방식으로 설정할 수 있다. 1234// React에 지정된 JSX.Elementdeclare global { namespace JSX { interface Element extends React.ReactElement&lt;any, any&gt; { } toPrecision()toPrecision() 메서드는 Number 객체를 지정된 정밀도로 나타내는 문자열을 반환한다. 인자로는 유효 자릿수를 지정하는 정수를 넣는다. 아무것도 넣지 않으면 값을 그대로 반환한다. 123456789101112function precise(x) { return x.toPrecision(4);}console.log(precise(123.456));// expected output: &quot;123.5&quot;console.log(precise(0.004));// expected output: &quot;0.004000&quot;console.log(precise(1.23e5));// expected output: &quot;1.230e+5&quot; 123.455.toPrecision()과 같이 number 값을 그대로 사용할 수는 없다. 12const num = 123.456;num.toPrecision(); // 유의할 점은, 숫자가 아닌 문자열을 반환한다는 것이다! 그리고, 유효자릿수가 작아 큰 자리 단위수를 반환하면 e+ 형태의 지수로 값을 표현한다. 1234let num = 927;let n = num.toPrecision(1);console.log(n); // '9e+2' Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number/toPrecision 이것저것 Array.prototype.every()은 빈 배열 순회 시 true를, Array.prototype.some()은 빈 배열 순회 시 false를 반환한다. every()는 ‘어긋나는 게 있는지 검사’하고, some은 ‘충족하는 게 있는지 검사’한다고 생각하면 편하다. Git Submodule은 A 저장소 하위에 B 원격 저장소를 두고 관리하는 것으로, B 저장소 내용을 업데이트(커밋)하더라도 A 저장소에 기록이 남지 않는다. CSS font-style의 기본값은 none이 아니라 normal이다. monorepo를 사용할 때, 에디터의 워크스페이스에 따라 eslint 룰이 적용될 수도, 안될 수도 있다. 내가 올리는 코드가 다른 팀원들과 같은 lint 룰을 적용받고 있는지 체크하자. shell 코딩 시 유용한 툴 zx git remote prune origin 명령어를 사용하여 local에 존재하는 유효하지 않은 ref를 제거할 수 있다 Next.js는 src/pages 하위에 존재하는 모든 .tsx 파일을 자동으로 직접 접근이 가능한 라우트로 취급한다. 따라서 도메인 컴포넌트(페이지가 아닌 다른 컴포넌트)는 다른 디렉토리에 옮겨야한다 (ex. src/common/pages) Artifact라는 용어는 Deploy를 위해 최종적으로 관리되는 산출물이라는 뜻으로 사용되어진다. a 태그의 href 속성에는 파일이 존재하는 경로를 지정하고, download 속성에는 파일명을 집어넣어 클릭 메소드를 호출해서 원하는 파일을 다운로드 받을 수 있게 구현할 수 있다. .code-workspace 파일을 이용해 monorepo에서 multi-root workspace를 구현할 수 있다. (Ref) enum도 Object.keys()의 인자로 들어갈 수 있다. React에서 렌더링하는 JSX에 넣는 key를 통해 렌더링을 컨트롤할 수 있다. element에 심어둔 key값을 바꿀 때 컴포넌트를 리렌더링시킬 수 있다. (Ref) CSS의 only-of-type은 같은 유형의 형제가 없을 때 적용된다. 기타TypeScript로 구현한 SOLID 원칙 Single Responsibility Principle (SRP; 단일 책임 원칙) Open-Close Principle (OCP; 개방-폐쇄 원칙) Liskov Substitution Principle (LSP; 리스코프 치환 원칙) Interface Segregation Principle (ISP; 인터페이스 분리 원칙) Dependency Inversion Principle (DIP; 의존관계 역전 원칙) 여태 본 SOLID 원칙에 대한 설명 예제 중에 가장 이해가 잘 된다! 🤓 Ref https://blog.bitsrc.io/solid-principles-in-typescript-153e6923ffdb 조건부 로직 테스트코드에서 사용하지 않기테스트 코드는 작동 원리를 쉽게 이해할 수 있게끔 작성해야 하며, 주석이 필요 없을 정도로 간단해야 한다. 조건부 (if~else) 테스트 로직은 테스트를 실제보다 더 복잡하게 만드는 요인 중 하나다. 조건부 로직을 테스트에서 사용한 경우에 어떻게 개선할 수 있을까? 첫 번째, 테스트 실행마다 결과가 달라지는 경우다. 매번 테스트를 수행할 때마다 테스트 환경이 변경되는 경우 하나의 테스트 코드가 수많은 케이스를 고려해야만 한다. 이런 경우 테스트 환경을 직접 제어하는 코드를 작성한다. 여러 케이스를 하나의 테스트로 검증하고 싶다면 Parameterized Test를 작성하면 된다. 두 번째, 테스트에서 프로덕션 로직을 사용한 경우다. 하나의 메소드에서 모든 입력값에 대한 결과를 검증하기 위해서 테스트 내부에 로직을 넣게 된다. 이렇게 작성된 테스트는 프로덕션 로직에 변경이 있을 때마다 테스트 코드도 함께 변경해야만 한다. 이러한 SUT(System Under Test)를 테스트하기 위해서는 미리 계산된 값을 사용할 수 있다. 또는 첫 번째 경우와 마찬가지로 Parameterized Test를 사용할 수 있다. 세 번째, 중복 코드를 리팩토링하는 과정에서 발생한다. 테스트 코드에서 중복되는 코드를 제거하고자 검증 부분만 조건문으로 작성하게 된다면 테스트 코드를 이해하기 더욱 어려워진다. 이 경우, 리팩토링을 하더라도 2가지의 전제조건을 가져가면 좋다. 해당 테스트가 무엇을 하는지 테스트 코드만으로 확인이 가능해야 한다. 조건문을 최대한 피한다. 관련 코드는 링크에서 다시 확인해보자! Ref https://jojoldu.tistory.com/642?fbclid=IwAR39pHWihFnYuudqUr5ScRVFpFhKDeNX0nLZiz4Xs_AvwmzmCe51TsqkgIA Hype Driven Development - 설레발 주도 개발팀에서 핫한 최신 기술만을 좇다가는 어떻게 되는지 보여주고 있다. 기술의 등장 배경이나 원리, 사용 시 장단점을 제대로 파악해보지도 않은 채 그저 트렌드라는 이유로, 작성법이 fancy해보인다는 이유로 여러 라이브러리/프레임워크 등을 써왔던 지난 날들을 반성하게 해준다… 결정하기 전에 연구하고 테스트하기 가 좋은 방법이라는 것은 알지만, 실제 바쁘게 업무를 하면서 신기술에 대한 연구와 테스트를 진행하는 것도 많은 경우 현실적으로 어려운 상황이라는 것도 안다. 😵 Ref https://lazygyu.net/blog/hype_driven_development 기능별로 폴더 구조 나누기리액트에서 디렉토리 구조를 나누는 것은 정말 귀찮은 일이다. 하나의 best practice라는 게 존재하지도 않고 (구글에 ‘react folder structure best practice’를 검색하면 수많은 글들이 나온다…), 도메인마다, 또는 팀의 스타일에 따라서 달라지는 법이다. 이 아티클에서는 기능별로 폴더의 구조를 나누는 방법을 소개하고 있다. 파일의 ‘타입’이 아닌 ‘기능(feature)’를 중심으로 폴더 구조를 나누는 것이다. 1234└── src/ ├── components/ ├── contexts/ └── hooks/ 위와 같은 폴더 구조는 ‘나는 리액트 앱이다’라고 강력하게 얘기하고 있는 반면, 123456789101112131415└── src/ ├── features/ │ ├── todos/ │ ├── projects/ │ ├── ui/ │ └── users/ └── pages/ ├── create-project.js ├── create-todo.js ├── index.js ├── login.js ├── privacy.js ├── project.js ├── signup.js └── terms.js 위 폴더 구조를 보고 우리는 이 앱이 ‘프로젝트 관리 툴’이라는 것을 알 수 있다. 아래는, 덧붙여 소개하고 있는 Best Practices들의 내용이다. 절대 경로 import를 사용한다. index.js를 public API로 사용한다. 폴더 안의 파일들을 묶어 한 번에 export하는 역할을 한다. 파일과 폴더 이름에 kebab-case를 사용한다. MacOS가 case-insensitive하기 때문에 발생할 수 있는 문제를 예방하기 위함이라는데, 개인적으로는 잘 모르겠다 🤔 Ref https://profy.dev/article/react-folder-structure 페이스북 개발자의 성과 만들기글의 요약은 다음과 같다. 데이터 기반의 명확한 목표 작업자가 스스로 할 일을 결정하는 능동적인 업무 A/B 테스트 위주의 개발 데이터 기반의 성과 측정 연예인 매니저같은 매니저 체계적이고 합리적인 성과 관리 및 평가 페이스북을 비롯한 실리콘 밸리의 이름난 기업들, FAANG 아니 MAANG… 실제로 이렇게 일하고 있는지 궁금하다! 한번 찾아가 보고 싶다. 자칫하면 국내의 그 어떤 기업들보다도 성과 중심적인 치열한 분위기가 되지 않을까 싶기도 하고. 아래 문장이 기억에 남는다. 개발자의 성과에는 책임이 있더라도 성장에는 책임이 있지 않습니다. 그리고, 개발자로서 증명해보일 수 있는 성과를 만들어내기 위해 구체적으로 생각해볼 지표들. 즉 ‘프로젝트 영향력’을 잊지 않고 잘 챙겨야겠다. 프로젝트 영향력은 그 명칭으로 짐작하실 수 있듯 프로젝트에 공헌한 성과들입니다. “AA 를 유지 보수했음.” 혹은 “BB 파트를 맡아 스프린트를 N 개 진행했음” 이런 것은 성과로 증명할 수 없는 내용입니다. 내가 한 작업으로 인해 클릭률 혹은 방문율이 몇 퍼센트 올랐는지 내가 한 작업으로 KPI를 어떻게 얼마나 달성했는지 어떤 중요한 아이디어를 냈고 그것이 어떻게 반영됐는지 퍼포먼스를 어떻게 얼마나 향상시켰는지(이게 제일 중요함) 기타 프로젝트 자체에 기여한 성과 Ref https://blog.shiren.dev/2022-03-07/?fbclid=IwAR0XXlVfXZZedoGLRnyfrDrdS4IOVZDIXDKgBIm6kDpBvmFGvZGKwtbE0Mk v8n메서드 체이닝 형식으로 유효성 검사를 할 수 있는 라이브러리다. custom한 rule을 만들어서 적용할 수도 있다. v8n의 풀네임은 당연하게도 ‘validation’이다. 아래와 같이 작성한다. 상당히 fancy하다! (하지만 설레발 주도 개발)의 위험성을 잊어서는 안될 것이다…) 12345v8n() .string() .first(&quot;H&quot;) .last(&quot;o&quot;) .test(&quot;Hello&quot;); //true Ref https://imbrn.github.io/v8n/#what-s-v8n 마무리대통령이 바뀌었다. 아직 취임을 안했으니 바뀐 건 아니지만… 앞으로의 5년이 어떻게 될지… 어떻게든 되겠지… 작년 12월 1일에 시작했던 유캔두도 끝났다! 진짜로 내가 100일 연속 인증을 채웠다. 유캔두 주최자였던 웨지에게 기프티콘을 선물로 받았다. ㅋㅋㅋ 그리고 포코가 지정한 다음 유캔두 공동 주최자가 되었다. 😱 열흘 쉬고, 다시 시작!!! 대선일과 주말에 쉬는 동안 운전 연수를 받았더니 갑자기 자신감이 생겼다. 면허 딴지 4년 만에 처음 운전대를 잡아보는데, 시내도로와 고속도로도 타고, 꽉꽉 막힌 강남대로와 올림픽대로를 지나 양평까지 다녀왔다. 셀프 주유도 해봤다. 다음 달부터 쏘카 빌려서 드라이브 다녀야지 😎 회사에서 맡은 티켓은 끝날 듯 끝나지 않고 있다. 수많은 코드리뷰를 받고, QA에서 잘못된 부분들을 검수받고 나니 아직 갈 길이 먼듯 싶다. 운전은 “초보인데 어쩌라고” 마인드로 했지만, 회사에서는 ‘신입이니까 그럴 수 있어’로 살 수만은 없다. 그런 시간은 아아아주 짧게 가지고, 신입이어도 능력을 낼 수 있는 팀원으로 거듭나기 위해 분발해야겠다. 너무 스트레스는 받지 말구 🤩","link":"/2022/03/12/2022-3-week-2/"},{"title":"3월 3주차 기록","text":"매일매일 어디론가 배워가기Groovydocker와 함께 Jenkins 환경설정 및 플러그인설치 등 수동작업을 자동화하는 데 Groovy 파일을 사용할 수 있다. Groovy 파일은 Java를 발전시킨 객체지향 프로그래밍 언어로, 젠킨스에서 파이프라인을 구성하기 위한 파이프라인 문법 작성에 Groovy를 사용한다고 한다. Ref https://blog.voidmainvoid.net/104 HTML &lt;form&gt;의 유효성 검증 방식HTML &lt;form&gt; 태그의 유효성 검증은 아래 순서로 이루어진다. submit 버튼을 클릭한다. 검증을 통과하지 못한 부분에 경고가 나타난다. 고치면 경고가 사라진다.(실시간 유효성 검증) 다시 잘못 입력해도 submit 버튼을 누르기 전까지는 실시간 검증이 되지 않는다. 이는 react-hook-form의 UX 정책과 유사한 방식이다. 하지만 실시간 검증을 계속 할 경우 성능상 이슈가 생길 수 있다. exhaustiveness checkingTypeScript에서 타입 체크할 때 모든 케이스에 대해 철저히 검사하는 것으로, 절대 나타나지 않을 경우에 대해 never를 사용한다. 123const exhaustiveCheck = (param: never): never =&gt; { throw new Error('type error!');} 조건문(if-else 또는 switch)으로 타입 가드를 쭉 작성하다가, 마지막 else 또는 default문에 위 함수를 넣어주면 된다. 모든 경우에 대해서 개발자가 확인했음을 보장하는 것이다. 타입 가드를 철저히 작성하지 않았다면 위 함수에서 TypeScript 컴파일 에러가 발생하게 된다. 따라서 철저한 타입 체크 및 런타임 에러를 방지할 수 있다. 123456789type Fruit = 'banana' | 'orange' | 'mango'function makeDessert(fruit: Fruit) { switch(fruit) { case 'banana': return 'Banana Shake' case 'orange': return 'Orange Juice' } exhaustiveCheck( fruit ) // 🚫 ERROR! `mango` is not assignable to type `never`} 위 예제에서는 파라미터에 mango가 들어오는 경우 조건문에서 처리해주지 못해 에러가 발생했다. mango의 케이스를 추가해 컴파일 에러를 제거한다. 12345678910type Fruit = 'banana' | 'orange' | 'mango'function makeDessert( fruit: Fruit ) { switch( fruit ) { case 'banana': return 'Banana Shake' case 'orange': return 'Orange Juice' case 'mango' : return 'Mango Smoothie' } exhaustiveCheck( fruit ) // ✅ no error, all values handled.} Ref https://dev.to/babak/exhaustive-type-checking-with-typescript-4l3f 유용한 &lt;picture&gt; 태그&lt;picture&gt; 태그는 &lt;source&gt; 요소와 &lt;img&gt; 요소를 포함하여 화면/디바이스 별로 서로 다른 대체 이미지를 제공할 수 있게 해준다. 이때, picture 태그로 다양한 DPI와 이미지 확장자를 처리할 때에 반드시 하나의 img 태그를 자식으로 포함해야 한다. 123456&lt;picture&gt; &lt;source srcset=&quot;/media/cc0-images/surfer-240-200.jpg&quot; media=&quot;(min-width: 800px)&quot;&gt; &lt;img src=&quot;/media/cc0-images/painted-hand-298-332.jpg&quot; alt=&quot;&quot; /&gt;&lt;/picture&gt; 수많은 srcset 중에서 현재 렌더중인 src는 &lt;img&gt; 태그의 currentSrc 프로퍼티로 확인 가능하다 많은 경우 &lt;picture&gt; 태그에 display: contents 를, &lt;source&gt; 태그에는 display: none을 적용한다. display: contents 는 자신의 box를 만들지 않는다. 따라서 &lt;picture&gt;의 래퍼 컴포넌트를 만들 때에 &lt;picture&gt;에 display: contents를 적용하고 forwardRef로 ref를 &lt;img&gt; 태그에 주면, 사용하는 측에서는 img 태그를 사용하는 것과 똑같이 사용할 수 있다. &lt;source&gt; 태그는 렌더링될 게 없으나 default로 display: inline 이 되어있어 불필요하게 렌더트리에 포함된다. 따라서 깔끔하게 display: none으로 보이지 않게끔 적용한다. 이는 picture의 동작에는 영향을 미치지 않는다. CSS remedy 에서도 위 속성들을 사용하는 코드를 볼 수 있다. Ref https://developer.mozilla.org/en-US/docs/Web/CSS/display#box https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture optional한 타입의 추론optional한 타입은 undefined | type 으로 추론되기 때문에, 특정한 type만을 가지는 변수에 optional 타입을 직접 삽입할 수 없다. 이 때 undefined가 되는 상황을 안다면 default 값을 설정을 하여 값이 undefined인 경우를 배제시킬 수 있다. 1234567891011121314151617181920212223242526interface props = { inRange?: boolean}// isFirstDayOfMonth는 boolean 타입의 값을 받는다const testFunc = ({ inRange }) =&gt; { function returnBoolean(): boolean {} // 🚨 타입 에러 return &lt;Day isFirstDayOfMonth={inRange &amp;&amp; returnBoolean()} /&gt;}/*inRange 타입이 undefined | boolean으로 추론되기 때문에inRange &amp;&amp; returnBoolean()의 추론타입은 undefined | boolean이 된다.결과적으로 Boolean(inRange &amp;&amp; return Boolean()) 과 같이 캐스팅 작업이 필요해지게 된다.하지만 위의 경우는 inRange가 props로 넘어오지 않는 상황의 값이 false인 경우와 동일하다.그러므로 inRange의 default 값을 false로 지정해줌으로써 타입이 undefined인 경우를 배제시킬 수 있다.*/const testFunc = ({ inRange = false }) =&gt; { function returnBoolean(): boolean {} // ✅ 정상 작동 return &lt;Day isFirstDayOfMonth ={inRange &amp;&amp; returnBoolean()} /&gt;} 함수 컴포넌트에 Generic 사용하기함수 컴포넌트도 함수기 때문에 Generic한 component를 만들 수 있다. props에 Generic Type을 사용해야 할 때 유용하다. 123456789101112131415interface Props&lt;T&gt; { renderItem: (item: T) =&gt; React.ReactNode; keyExtractor: (item: T) =&gt; string; data: T[];}const GenericComponent = &lt;T extends unknown&gt;({ data, renderItem, keyExtractor}) (props: Props&lt;T&gt;) =&gt; { return ( // ... )} Ref https://medium.com/edonec/creating-a-generic-component-with-react-typescript-2c17f8c4386e &lt;iframe&gt; 태그와 &lt;object&gt; 태그두 태그 모두 웹페이지(html) 내에서 다른 웹페이지(html)나 멀티미디어 객체를 보여줄 수 있는 태그다. &lt;iframe&gt; 태그는 종종 볼 수 있지만, &lt;object&gt; 태그는 낯설 수도 있다. 아래와 같이 사용한다. 12345&lt;object type=&quot;application/pdf&quot; data=&quot;/media/examples/In-CC0.pdf&quot; width=&quot;250&quot; height=&quot;200&quot;&gt;&lt;/object&gt; 💡 HTML5에서 표준화된 &lt;embed&gt;라는 태그도 존재한다. html이 아닌 외부 요소들을 통합하는 데 사용한다. 주로 svg나 정적인 데이터를 표시한다. 1234&lt;embed type=&quot;video/webm&quot; src=&quot;/media/cc0-videos/flower.mp4&quot; width=&quot;250&quot; height=&quot;200&quot;&gt; 말줄임표 CSS 구현방법 1줄 제한12345.selector { text-overflow: ellipsis; /* 끝 처리를 ... 으로 한다. */ white-space: nowrap; /* 줄바꿈을 하지 않는다. */ overflow-x: hidden; /* ...뒤에 나머지 내용을 숨긴다. */} n줄 제한1234567.selector { display: -webkit-box; /* 해당 영역을 box 형태로 관리한다. */ -webkit-box-orient: vertical; /* webkit box 내의 정렬을 수직으로 한다. */ -webkit-line-clamp: 1; /* 영역 내 컨텐츠의 최대 라인수를 결정한다. */ text-overflow: ellipsis; /* 끝 처리를 ... 으로 한다. */ overflow-x: hidden; /* ...뒤에 나머지 내용을 숨긴다. */} (정)규식이형 이것저것 정규식의 기본은 3연산이다. - 반복, 집합, 선택 정규식에서 그룹 연산자는 모든 연산자보다 우선 순위가 높다. 정규식을 파싱할 때 서브패턴 ()를 사용하면 정규식 엔진은 서브패턴을 하나의 정규식으로 인식한다. 즉, (ab)|(cd)는 (정규식|정규식)으로 정의되어 정규식의 성능을 저하시키는 원인이 될 수 있다. JavasSript에서 전방 일치는 match(), 부분 일치는 search()를 사용한다. 대부분의 언어에서는 부분 일치와 완전 일치 메서드를 제공한다. 부분 일치와 완전 일치 메서드를 활용하면 전방 일치와 후방 일치를 구현할 수 있다. 정규식에서는 위치도 문자와 동등하다. &quot;abcd&quot; === &quot;위치a위치b위치c위치d위치&quot; overflow-wrap vs word-breakCSS overflow-wrap(word-wrap) 속성은 어떤 문자가 내용 칸 밖으로 넘치지 않게 브라우저가 단어 마디 안에 줄을 바꿔야 할 것인지를 정할 때 사용한다. overflow-wrap: break-word로 설정하면, 한 줄에서 단어가 길어질 때 임의의 지점에서 줄을 바꾼다. 기존에는 word-wrap이라는 이름으로 사용됐지만, overflow-wrap으로 바뀌었고, word-wrap은 동의어로 계속 사용되고 있다. word-break 속성은 텍스트가 자신의 콘텐츠 박스 밖으로 오버플로할 때 줄을 바꿀지 지정한다. 즉 각 글자를 띄어쓰기 단위를 고려해서 줄바꿈할 것인지, 어디서든 끊게끔 할 것인지 결정할 수 있다. word-break: break-word라면 실제 overflow-wrap 속성에 상관하지 않고, word-break: normal과 overflow-wrap: anywhere를 설정한 것과 같은 효과를 낸다. Ref https://developer.mozilla.org/ko/docs/Web/CSS/overflow-wrap https://developer.mozilla.org/ko/docs/Web/CSS/word-break ZWSP: Zero Width Space별다줄…인 말이 있다. ZWSP. 두번 다시 떠올리기도 힘들 단어다. ‘Zero Width Space’ 즉 ‘폭 없는 공백’은 공백이 아닌 공백 문자를 가리킨다. 유니코드 문자셋 U+200B에 해당한다. 일반 사용자에게서는 직접 사용할 상황이 없는 기능이지만, 윈도우 XP 이상의 메모장에서는 우클릭을 눌러 나오는 메뉴에서 유니코드 제어 문자 삽입을 통해 이 문자를 직접 추가할 수 있다. (대표적으로 ZWJ, ZWNJ) 드래그해서 이 문자를 선택할 수 있고 복사, 붙여넣기 등의 작업도 정상적으로 가능하다. 여기서 문제가 발생할 수 있다! 유저가 다른 곳에서 어떤 문자열을 드래그해서 붙여넣기 했는데, 우리가 만든 플랫폼에서 form validation 등에 의해 보이지 않는 문자에 대한 검증이 이뤄져 오류인 것처럼 보이는 상황을 만들어낸다. 폭 없는 문자라는 이름에서 알 수 있듯이 아무리 많이 이 글자를 추가하더라도 문장의 길이가 늘어나지 않기 때문에 육안으로는 얼마나 이 글자가 추가되어 있는지 식별할 방법이 없다. 미리 유니코드 문자셋 /u200b를 사용하여 제거해주도록 하자! Ref https://unicode-table.com/kr/200B/ TypeScript1const numbers = [1, undefined, 2, undefined, 3]; 위와 같은 배열이 있을 때, numbers의 타입은 (number | undefined)[]로 추론된다. filter() 메서드를 통해 배열의 원소 중 falsy값 즉 undefined를 제거해보자. 12const realNumbers = numbers.filter(Boolean);console.log(realNumbers); // [1, 2, 3] 그런데 realNumbers의 타입은? number[]가 아니라 여전히 (number | undefined)[]다. 😫 생각해보면, filter()를 통해서 falsy값을 제거했다고 한들 filter()에서 실제로 뭘 했는지는 TypeScript가 알 길이 없다. 그래서, 타입을 올바르게 추론하게끔 하기 위해 아래와 같이 타입 가드를 작성해서 해결했다. TypeScript에 기본 유틸리티 타입으로 존재하는 NonNullable&lt;Type&gt;은, Type에서 null과 undefined를 제거한 타입을 반환한다. 12345function nonNullable&lt;T&gt;(value: T): value is NonNullable&lt;T&gt; { return value !== null &amp;&amp; value !== undefined;}[1, 2, 0, null].filter(nonNullable) // number[] Ref https://stackoverflow.com/questions/47632622/typescript-and-filter-boolean -ms-high-contrast디스플레이가 high contrast mode, 즉 고해상도 모드에서 동작하고 있는지를 나타낸다. -ms-high-contrast: active라면 시스템이 색상과 관계없이 고대비 모드로 설정되었을 때 후속 스타일링 규칙이 적용됨을 나타낸다. 글자 등이 겹쳐 보일 때 스타일링을 다르게 주어 사용자가 컨텐츠를 올바르게 인지할 수 있게끔 해준다. 123@media screen and (-ms-high-contrast: active) { /* 모든 고대비 모드에 대한 스타일 규칙입니다 */} Ref https://developer.mozilla.org/en-US/docs/Web/CSS/@media/-ms-high-contrast &lt;img&gt; 태그의 display&lt;img&gt; 태그의 display 기본값은 inline이다. 기본적으로 display 는 inline이나, 기본 크기는 내장한 이미지의 고유 크기로 정해지므로 마치 inline-block처럼 보인다. &lt;img&gt; 태그는 ‘대체 요소’로, 문서 스타일과는 별개의 스타일이 적용되어 있을 수 있다. 대체 요소CSS의 대체 요소(replaced element)란 자신의 표현 결과가 CSS의 범위를 벗어나는 요소로서, CSS 서식 모델과는 분리된 외부 객체인 요소다. 간단히 말해서, 대체 요소는 자신의 콘텐츠가 현재 문서 스타일의 영향을 받지 않는 요소라고 할 수 있다. 예를 들면, &lt;img&gt; 태그에 아무 설정도 하지 않았지만 알 수 없는 margin이 적용되어 있을 때가 있다. 이는 &lt;img /&gt; 태그의 display 속성이 inline이라 기본적으로 갖고 있는 white-space, line-height 등의 속성이 적용되어 있기 때문이다. display: block을 적용하면 콘텐츠가 차지하는 영역을 올바르게 조정할 수 있다. Ref https://developer.mozilla.org/ko/docs/Web/CSS/Replaced_element https://stackoverflow.com/questions/20788232/remove-unexplainable-img-margin-space-css 이것저것 git checkout &lt;브랜치명&gt; &lt;파일명&gt; 으로 해당 브랜치의 파일으로 변경할 수 있다. react-scripts 를 실행시킬 때 DISABLE_ESLINT_PLUGIN=true 로 주고 실행시키면 webpack 내 eslint plugin을 off 할 수 있다. 크롬 개발자 패널에서 런타임 퍼포먼스 측정방법을 제공하고 있다. React의 useMemo는 1) 참조 동일성 2) 계산이 복잡한 작업 에 사용하는 것이 좋다. (Ref) 정규식의 수량자는 syntax sugar다! (ex. {a|aa|aaa} ➡️ a{1,3}`) eslintConfig에서 직접 prettier룰을 넣어 설정할 수 있다.123456&quot;prettier/prettier&quot;: [&quot;error&quot;, { &quot;semi&quot;: false, &quot;singleQuote&quot;: true, &quot;trailingComma&quot;: &quot;none&quot;, &quot;printWidth&quot;: 80}], vscode 설정에서 .ts 파일에 대해서만 prettier formatter를 off할 수 있다.1234567891011121314151617{ &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.formatOnSave&quot;: true, &quot;[typescript]&quot;: { &quot;editor.formatOnSave&quot;: false, // ⬅️ 여기만 off &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.eslint&quot;: true } }, &quot;[typescriptreact]&quot;: { &quot;editor.formatOnSave&quot;: false, // ⬅️ 여기만 off &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.eslint&quot;: true } }, // ...} svg 파일을 클라이언트 디렉토리에 저장하지 않고, 문자열만으로 직접 만들어서 상용할 수 있다. createIcon 함수를 만들어두고, svg의 값들을 넘겨서 만들어서 사용한다. addEventListener 메서드의 옵션 중 once라는 옵션은 수신기가 최대 한번만 동작해야함을 나타내는 boolean 값이다. 해당 옵션을 true로 지정할 경우, 수신기가 발동한 후에 스스로를 대상으로부터 제거하게 된다. 부모의 max-height 값이 선언되어있더라도, 자식은 부모의 height 값을 기준으로 삼지 못한다. 부모가 max-height: 80%, height: auto로 선언되었다면 자식은 부모로부터 height 기준을 알지 못하게 되고, height: auto에 의해 내용물의 크기를 기준으로 삼는다. Next.js는 빌드 시 env가 있으면 process.env.~ 부분을 해당 값으로 교체하고, 없으면 .next에 그 구문을 그대로 남겨둔다. next start 런타임에서 주입될 env들은 이렇게 사용할 수 있다. react-hook-form 라이브러리를 사용하면 reValidateMode 옵션을 활용해서 onChange일 경우, onBlur일 경우, onSubmit일 경우에 각각 유효성 검사를 할 수 있게끔 설정할 수 있다. JavaScript includes()는 객체 비교 시 참조값으로 비교하기 때문에, 객체의 배열에서 검사 시 includes() 대신 find()나 filter() 메서드를 사용하는 것이 좋다 &lt;table&gt; 태그 사용 시, &lt;tr&gt; 태그에는 border를 적용할 수 없다. 그렇다고 &lt;td&gt; 태그에 border를 넣으면 각 셀에 맞춰 끊긴 border가 그려진다. 이때는 &lt;table&gt; 태그에 border-collapse: collapse를 적용한 후 &lt;td&gt; 태그에 border를 넣어야 한다. 기타공변과 반변이전에 정리한 글에서 TypeScript 함수 타입 정의에서의 공변과 반변을 다뤘었는데, 이번에 새롭게 알게 된 좋은 아티클이 있다. Ref https://seob.dev/posts/공변성이란-무엇인가/ https://sorto.me/posts/2021-03-16--variance React 18의 IE 지원 종료이렇게 세상이 바뀐다… Ref https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#dropping-support-for-internet-explorer Node 모듈의 malwareVue CLI와 Unity Hub에서 쓰는 node-ipc의 개발자가 우크라이나 전쟁을 반대한다는 이유로 패키지 dependency에 ‘peacenotwar’라는 malware를 심어뒀다고 한다. 바탕화면에 임의로 텍스트 파일 생성하고, 사용자 IP가 러시아/벨라루스 지역이면 시스템의 모든 파일 내용을 하트 이모지로 변경 (지금은 제거)한다. 엄청난 역따봉이 달리고 있는데, 신기하다… 오픈소스 커뮤니티 세상… Ref https://github.com/RIAEvangelist/node-ipc/issues/233 JavaScript에서 Type 문법 사용하기 (Proposal)Stage 0에 등록된 내용으로, JavaScript에서 Type 문법을 사용할 수 있게 해주자는 것이다. TypeScript는 결국 JavaScript의 superset이기 때문에 코드상으로 다른 문제는 일으키지 않을 것이며, 타이핑을 comment와 같은 역할을 할 수 있게끔 만들 수 있다. 1234567/** * @param a {number} * @param b {number} */function add(a, b) { return a + b;} 위와 같은 식으로, JSDoc에 타입을 사용할 수 있게끔 제안하는 것 같다. JavaScript에서 이런 방식으로 타입을 사용할 수 있게 된다면, TypeScript의 컴파일(트랜스파일) 단계가 필요하지 않아서 실행 시간을 단축시킬 수 있다는 장점을 이야기하고 있다. Ref https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/ https://github.com/giltayar/proposal-types-as-comments/ 크롬 99 Release무엇보다 벌써 크롬이 99버전이나 됐다는 게 놀랍다… 시도때도 없이 나타나는 크롬 업데이트 버튼이 이를 보여주는 것이었을까. 크롬 99 업데이트에서 달라지는 것은 다음과 같다. 웹소켓 요청 쓰로틀링 새로운 Reporting API (Application 탭) 요소가 보일 때까지/클릭할 수 있을 때까지 기다림 (Recorder 탭) 더 나은 콘솔 스타일링/포맷팅/필터링 소스맵 개선 자동 다크 테마 업데이트 터치하기 쉬운 color picker와 split pane 기타 다양한 기능들 cookie 편집 Shift + Tab으로 이전 명령어 선택하기 CORS preflight 요청 리포트 (Issues 탭) User-Agent Client Hints 리포트 (Issues 탭) … Ref https://developer.chrome.com/blog/new-in-devtools-99/ 프론트엔드 개발자가 알면 좋은 11가지 툴그중에서도 가장 첫 번째에 소개된 Responsively은 정말 멋진 것 같다! 이 툴을 써보고 싶어서 빨리 반응형을 작업해보고 싶다(?) Ref https://blog.devgenius.io/11-amazing-frontend-development-tools-that-you-should-use-in-2022-b12c64caa346 사망한 개발팀 살리기Ref https://pfdev.medium.com/사망한-개발팀-살리기-6f2d22a53242 10배 이상 뛰어난 개발자가 되는 법 사용하는 도구에 대한 연구를 한다. 도움을 요청한다. 비즈니스 가치를 제공한다. Ref https://yozm.wishket.com/magazine/detail/1373/ 마무리이번주 정말정말 업무 외적으로 일이 정말 많았다. 용케 다 해온 게 대견스럽다. 결국 주말에 하루 기절했지만… 날씨도 갑자기 쌀쌀해지고 비까지 온다. 그래도 이 봄비가 지나가니 정말 봄이 올 것 같다. 배민X오늘의집에서 이벤트를 해서 지난주 급 뽐뿌가 왔던 모션데스크와 그 폭풍으로 인한 각종 가구들을 쇼핑했다! 이렇게 매달 flex해버려도 되는 걸까.. 싶지만 뭐 오래 쓸 거니까 ㅎㅎ 배민 사내 신춘문예에서 아깝게(!) 2등을 했다. 근데 후보까지 갈 줄도 몰랐는데.. 너무 이미지 이상한 사람 되는 거 아닌가 모르겠다 🤷‍♀️","link":"/2022/03/19/2022-3-week-3/"},{"title":"3월 4주차 기록","text":"첫 판교 드라이브 배워가기React 18의 상태 변경 BatchingReact 18 미만에서 사용자 이벤트에 대한 상태 변경은 일괄처리(Batching)되었다. 즉 일반적인 핸들러 내에서는 setState를 여러번 호출하더라도 일괄적으로 처리되어 리렌더링이 한번만 발생했다. 그러나 Promise나 setTimeout으로 발생하는 상태 변경은 일괄처리되지 않았다. setTimeout에서 setState를 두 번 호출하면 두 번 렌더링되었던 것이다. React 18에서는 상태 변경이 발생한 원인에 상관없이 모든 상태 변경은 일괄처리된다.이때, 의도적으로 일괄처리하지 않으려면 flushSync를 사용하면 된다. Ref https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#automatic-batching useImperativeHandleuseImperativeHandle은 ref를 사용할 때 부모 컴포넌트에 노출되는 인스턴스 값을 사용자화(customizes)합니다. forwardRef와 함께 쓸 수 있는 hook이다. 부모 컴포넌트가 자식 컴포넌트 내의 DOM에 접근하고 싶을 때, 자식 컴포넌트에서 forwardRef를 통해 넘겨받은 ref를 특정 DOM에 지정할 수 있다. 이때, 자식 컴포넌트에서 부모 컴포넌트에 노출하고 싶은 ref에 대한 인스턴스를 커스터마이징하고 싶다면 useImperativeHandle hook을 통해 정의할 수 있다. 즉 부모 컴포넌트로부터 forwarding된 ref를 재정의하는 것이다. 12345678910111213// 자식 컴포넌트function FancyInput(props, ref) { // 자식 컴포넌트의 ref를 새롭게 생성한 뒤, // useImperativeHandle의 두 번째 인자로 들어가는 함수 바디에서 사용한다. const inputRef = useRef(); useImperativeHandle(ref, () =&gt; ({ focus: () =&gt; { inputRef.current.focus(); } })); return &lt;input ref={inputRef} ... /&gt;;}FancyInput = forwardRef(FancyInput); 부모 컴포넌트는 자식의 DOM에 직접 접근하는 것이 아니라, useImperativeHandle로 전달된 메서드에만 접근이 가능해진다. 이로써 더욱 컴포넌트 간의 독립성을 보장할 수 있게 된다. 🤔 ‘imperative’는 ‘반드시 해야 하는’, ‘긴요한’이라는 뜻이라고 한다. 뭐가 그렇게 긴요했을까. 이름만 봐서는 예측하기가 어렵다. 토스의 김 모 개발자에 의하면, ‘명령적이다’라는 뜻도 있다고 한다. 😑 Ref https://ko.reactjs.org/docs/hooks-reference.html#useimperativehandle https://kelly-kh-woo.medium.com/react-hook-useimperativehandle-89fee716d80 enum vs const enum vs as constTypeScript의 enum은 서로 연관된 상수들을 하나로 관리하기 위해 사용한다. 1234567enum COLOR { RED, BLUE, GREEN}let red = COLOR.RED; 위 코드를 babel로 컴파일하면 결과는 아래와 같다. 123456789var COLOR;(function (COLOR) { COLOR[(COLOR[&quot;RED&quot;] = 0)] = &quot;RED&quot;; COLOR[(COLOR[&quot;BLUE&quot;] = 1)] = &quot;BLUE&quot;; COLOR[(COLOR[&quot;GREEN&quot;] = 2)] = &quot;GREEN&quot;;})(COLOR || (COLOR = {}));var red = COLOR.RED; enum은 즉시 실행 함수 ((function())()의 형태)로 컴파일된다. 따라서 트리셰이킹(tree-shaking)이 불가능하다. enum에 const를 붙인 const enum은 그냥 enum과 조금 다르게 동작한다. 1234567const enum COLOR { RED, BLUE, GREEN}let red = COLOR.RED; const enum을 babel로 컴파일하면 결과는 아래와 같다. 1let red = 0; const enum은 일반적인 enum과 달리 컴파일 과정에서 완전히 제거되고, 값에 해당하는 상수만 남는다. 트리셰이킹이 되기 때문에 용량 측면에서 그냥 enum보다 낫다고 할 수 있지만, TypeScript 사용 시 패키지 등에서 const enum을 사용한다면 값이 상수로 치환되어버리기 때문에 타이핑이 불가능해진다는 단점이 있다. 이때는 일반 객체에 as const를 사용하는 방식으로 enum을 대체할 수 있다. 12345const COLOR = { RED: 0, BLUE: 1, GREEN: 2,} as const; as const는 타입 단언(type assertion)의 한 종류로써 리터럴 타입의 추론 범위를 줄이고 값의 재할당을 막아준다. enum을 흉내낼 수 있으며, 컴파일 후에 용량도 enum보다 작은 편이다. Ref https://velog.io/@logqwerty/Enum-vs-as-const https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/ https://darrengwon.tistory.com/1310 docker container와 VMdocker는 linux 기반의 가상환경으로, VM(virtual machine)과는 뚜렷한 차이점이 있다. VM은 일종의 x86 하드웨어를 가상화한 형태다. VM 위에 다양한 종류의 OS를 설치할 수 있다. docker container는 하드웨어를 가상화하지 않고, Host OS에서 Guest OS를 isolation해주는 형태다. 다양한 종류의 OS에서 사용 가능한 VM과 달리, docker container는 linux 기반 OS에서만 수행할 수 있다. 이는 docker container 자체에는 kernel 등의 OS 이미지가 들어가 있지 않기 때문이다. kernel은 host OS의 kernel을 그대로 사용하기 때문에 container에서 명령어를 수행하면 실제로는 host OS에서 수행된다. host OS와 container OS에의 diff만 container에 같이 패키징하는 개념이다. Ref https://bcho.tistory.com/805 datalist 태그datalist 태그는 다른 컨트롤에서 고를 수 있는 가능한, 혹은 추천하는 선택지를 나타내는 &lt;option&gt; 요소들을 담는다. select 태그와 유사한 기능을 제공하지만, option으로 지정된 값 외에도 직접 타이핑하여 값을 입력할 수 있다는 점에서 특징적이다. 그래서 주로 input 태그와 함께 많이 쓰인다. 1234567891011&lt;label for=&quot;ice-cream-choice&quot;&gt;Choose a flavor:&lt;/label&gt;&lt;input list=&quot;ice-cream-flavors&quot; id=&quot;ice-cream-choice&quot; name=&quot;ice-cream-choice&quot; /&gt;&lt;datalist id=&quot;ice-cream-flavors&quot;&gt; &lt;option value=&quot;Chocolate&quot;&gt; &lt;option value=&quot;Coconut&quot;&gt; &lt;option value=&quot;Mint&quot;&gt; &lt;option value=&quot;Strawberry&quot;&gt; &lt;option value=&quot;Vanilla&quot;&gt;&lt;/datalist&gt; 타이핑 중에 자동완성 기능을 통해 option list에 존재하는 매칭되는 결과를 보여주기 때문에 더욱 멋지다! Ref https://developer.mozilla.org/ko/docs/Web/HTML/Element/datalist .toPrecision(number).toPrecision(number)은 JavaScript의 내장 메서드로, 앞에서부터 센 number의 자릿수 기준으로 반올림을 한다. 123const num = 185num.toPrecision(1); // '2e+2'num.toPrecision(2); // '1.9e+2' 반환값의 타입이 number가 아닌 string임에 주의하자! 그리고 소수점을 위한 .이 들어갈 수 있기 때문에, 넘버 리터럴의 메소드 호출엔 .을 두 개 사용해야 한다. 12185.toPrecision(1) = ‘2e+2’; // 🚨 SyntaxError: Identifier directly after number.185..toPrecision(1) = ‘2e+2’ git switchGit 2.23 버전에서 checkout 명령어를 대신하는 switch, restore가 새로 나왔다. (꽤 됐다..) 변경한 이유는 checkout 명령어가 가진 기능이 너무 많기 때문에 switch, restore로 분리했다. checkout: Switch branches or restore working tree files switch: Switch branches restore: Restore working tree files mouseover vs mouseentermouseover는 직접 이벤트를 걸지않은 자식요소에 마우스 포인터가 와도 발생하지만 mouseenter는 오로지 자기 자신에게 마우스 포인터가 와야만 발생한다. mouseover는 mouseout과 짝꿍, mouseenter는 mouseleave와 짝꿍이다. setState에 함수를 넣으면리액트의 함수 컴포넌트에서 state를 다루는 법은 조금 특별하다. constructor()에서 state의 초기값을 지정해주는 클래스 컴포넌트는, 컴포넌트 리렌더링 시 기존 컴포넌트의 인스턴스를 재활용하기 때문에 state가 무분별하게 재계산되지 않는다. 반면 함수 hook을 사용하는 함수 컴포넌트에서는 컴포넌트가 리렌더링될 때마다 함수를 새롭게 렌더링하기 때문에 불필요한 state 값이 재계산된다. 특히 state의 초기값이 복잡한 계산의 결과이거나, props를 바탕으로 한 값이라면 더욱 곤란해진다. 아래는 state의 초기값으로 복잡한 계산(expensiveCalculation)과 props를 넣은 극단적인 예시다. 1234function NaiveHooksComponent(props) { const [result, setResult] = useState(expensiveCalculation(props.arg)); // ...} 이럴 때는 useState()의 초기값에 함수를 넣어주는 방법을 사용해볼 수 있다! 1234function FunctionHooksComponent(props) { const [result] = useState(() =&gt; expensiveCalculation(props.arg)); // ...} useState()의 초기값으로 들어간 함수는 컴포넌트의 오직 첫 번째 렌더링에만 계산될 것이다. 처음 렌더링 시에만 setState() Ref https://medium.com/@_m1010j_/how-to-avoid-this-react-hooks-performance-pitfall-28770ad9abe0 이것저것 정규식은 좌에서 우로 해석되기 때문에 부분집합이 선택 중 앞에 오게 되면 뒤에 있는 내용은 선택되지 않는다. 따라서, 가장 큰 집합부터 좌측에 두는게 좋다. 아이콘 트리셰이킹 - 아이콘을 웹폰트로 받아오면 사용하지 않는 것도 가져오는 단점이 있다. JSX 조건부 렌더링에서는 표현식을 사용하기보다는 삼항연산자로 일관되게 사용하는 것이 좋다(는 의견) (Ref) 브라우저에서 사용자가 select 태그를 클릭했을 때 option 리스트들이 보여지는데, 이를 event로 직접 컨트롤 할 수 있는 방법은 없다. 즉 focus, click 등과 같이 이벤트를 직접 적용해서 select 태그의 리스트를 열 수 있는 방법은 없다. 비동기 로딩이나, 동적 페이지에서 anchor의 사용은 부정확한 동작을 일으킨다. Lerna는 모노 레포를 위한 CLI 도구이다. 모노 레포란 분리된 패키지를 하나의 리파지토리로 합쳐 관리해준다. (Ref) Java와 TypeScript는 다중상속을 지원하지 않는다. 자신이 가지고 있지 않은 메소드를 부모로부터 가져올 때, 두 부모가 모두 같은 메소드를 가지고 있다면 어느 것을 선택해야 할지 꼬여버리는 문제가 발생하기 때문이다. (Ref) Sentry transaction URL이 파라미터가 포함되어 있어 그루핑하기 어렵다면, transaction 그루핑을 통해 파라미터를 하나의 이름으로 통일해서 볼 수 있다. (Ref) 기타명확한 리액트 파일/디렉터리 구조미디엄 유료회원이 아니라 못 읽는다 ㅡㅡ Ref https://junghan92.medium.com/번역-명확한-리액트-파일-디렉터리-구조-a5f03a174b9e CSS peeper요소간 간격을 디테일하게 보여주는 크롬 익스텐션이다. 대박 짱 좋다. 스물 여섯 먹고 할 수 있는 최대의 감탄 표현이 ‘대박 짱’이라니 정말 한심스럽다. 아무튼 이걸 보고 디자이너 분들의 QA가 조금이나마 수월해지길 바란다! Ref https://chrome.google.com/webstore/detail/css-peeper/mbnbehikldjhnfehhnaidhjhoofhpehk Partytown이름부터 벌써 신난다. 내용이랑 무슨 상관이 있는지는 모르겠다. JavaScript는 싱글 스레드라 서드파티 라이브러리의 로드로 인해 성능이 저하될 수밖에 없는 문제가 있었는데. 이를 Web Worker를 통해 불러올 수 있게 하여 웹 앱의 로딩 성능을 올려줄 수 있는 라이브러리라고 한다. Ref https://github.com/BuilderIO/partytown 배포 전에 보면 좋을 프론트엔드 체크리스트별게 다 있다. 유용하게 사용해볼 만한 것들은 아래와 같다. 조건부 주석: Internet Explorer 를 위한 조건부 주석을 사용한다. Critical CSS - 페이지가 로딩되는 즉시(펼쳐지는 그 순간) 컨텐츠에 영향을 끼치는 CSS를 Critical CSS라고 한다. 이는 당신의 실질적인 어플리케이션의 CSS 가 로딩되기 이전에 &lt;style&gt;&lt;/style&gt; 태그 사이에 최소화 된 상태로 한 줄로 추가되어 임베딩 된다. W3C 규격 - 페이지 내의 모든 HTML 이 표준에 맞게 정상적으로 작성되었는지 W3C 의 validator를 이용하여 테스트 한다. 자바스크립트 보안 - 자바스크립트를 활용하여 보안에 안전한 어플리케이션 개발 가이드라인 서드 파티 컴포넌트 - 공유하기 버튼처럼 외부 자바스크립트 파일에 의존하는 서드파티 iframe이나 컴포넌트의 경우, 가급적 정적인 컴포넌트로 교체하여서 외부 API 호출을 제한하고 사용자들의 활동들을 외부로 유출되지 않도록 한다. (간단한 공유하기 버튼 생성하기) Progressive enhancement - 메인 네비게이션이나 검색과 같은 대다수의 기능들이 자바스크립트가 작동하지 않고도 동작해야 한다. 포스팅에 참고 링크도 엄청 많다! 시간 내어 차근차근 읽어보기로. Ref https://github.com/kesuskim/Front-End-Checklist &amp;&amp; 대신 삼항 연산자Dodds 형님은 예기치 못한 falsy값 (예: 0)이 렌더링되는 걸 방지하고자 일관되게 삼항 연산자를 사용하는 방법을 추천하고 있다. 하지만 나는 그냥 falsy값을 명확하게 boolean으로 치환한 후 (!!) &amp;&amp; 연산자를 사용하고 싶다. Ref https://kentcdodds.com/blog/use-ternaries-rather-than-and-and-in-jsx React18이 온다그러하다. 드디어 올 것이 온다! Ref https://twitter.com/reactjs/status/1506720582200705033?cxt=HHwWkoC-3d6Y-egpAAAA 노션 API 정식 출시우선 똥💩 느린 노션 code snippet부터 개선해줬으면 좋겠다~ 불편한 건 불편한 대로 그냥 사는 나조차도 노션을 대체할 도구가 나온다면 그걸 쓰리라 마음 먹었는데, 뭐가 더 화려해지고 있다. 졸업한 주제에 학교에서 주는 노션 무료 계정을 잘 써먹고 있는데, 돈 내라 하는 거 아닌지 몰라~ 아무튼, Jira와 Slack 쓰레드가 노션과 연결된다는 건 정말 신기하다. 이렇게 얽히고설켜 하나가 망하면 우르르 망해버리는.. 어떤 CASCADING..의 효과가 나타나지 않을까. 하여간 나와 라포를 잘못 형성한 모든 것은 내게 부정적인 인상을 남긴다. 하지만 나는 그래도 노션을 좋아하는 편이다. (?) 오~ 대박짱신기~ Ref https://www.notion.so/ko-kr/integrations?utm_campaign=March+release+email+Personal&amp;utm_campaigntype=newsletter&amp;utm_content=March+release+email+Personal&amp;utm_medium=email&amp;utm_source=customer.io Storybook for Vite스토리북도 정말 똥느렸는데~ 맥북에서는 램이 8GB만 되어도 때려쳐야 한다. 아니 M1 맥은 다르려나? 아무튼 스토리북은 딱 보기에도 느릴 수밖에 없어 보였다. 이번에 내놓은 새로운 builder를 도입하면 HMR(Hot Module Replacement)이 엄청나진다! 어머 이건 한번 해봐야 돼 Ref https://storybook.js.org/blog/storybook-for-vite/ 마무리월요일에는 새벽배포를 해봤다. 정말 얼마만에 새벽 5시 전에 일어난 건지… 그리고 다시 못잘 줄 알았는데, 비몽사몽하다가 조금 평화로워졌을 때 잠깐 눕는다는게 그대로 잠들었다. 꿀잠잤다. 쪽팔리다 🤷‍♀️ 한 달에 한 권 책 읽기(개발서적 X) 실천 중이다. 이번 달 책, &lt;불편한 편의점&gt;도 완독! 가볍게 읽을 수 있는 내용이었다. 백엔드 크루였던 조이와 항상 존경하는 크루 하루가 추천해준 책도 한 권씩 샀다. 우리회사 갓복지 미장은 금리 인상에 대한 불확실성이 줄어들어서, 국내장은 새롭게 출범할 정부가 플랫폼 사업에 대한 규제를 풀어줄 예정이라 그런지 내 주식창도 웬일로 쭉쭉 오르고 있다. 정말 처음 보는 현상이라 오히려 더 불안하다. 역시 가진 자가 더 무섭다. 사실 아직 가진 돈도 아닌데. 까불지 말고 적당한 때에 팔아야겠다. 우테코 코치님을 만나러 판교까지 갔다왔다. 운전연습이 하고 싶어서 판교까지 간다 그랬다. 처음으로 쏘카를 빌려서 무사히 잘 다녀왔고, 차를 사고 싶어졌다… 🤦‍♀️ 아니 아무튼, 2개월 차 (ㅋㅋ) 개발자로서 여기서 내가 할 수 있는 일들을 적극적으로 찾아 해 나가야겠다는 생각을 했다. 평화로운 울타리 안에서 조금씩 nagaboza","link":"/2022/03/25/2022-3-week-4/"},{"title":"4월 첫주차 기록","text":"꽃가루를 날려~ 배워가기literal template 타입 활용 및 정의 방법분 단위를 문자열로 나타낼 수 있는 경우는 ‘00’ ~ ‘59’로 60가지 케이스가 존재한다. 이 60가지를 손수 타이핑하여 type을 지정하기에는 너무나 버겁다. 이럴 때 literal template을 활용하여 간편하게 타이핑할 수 있다. 아래와 같은 코드로 타입을 정의하면 ‘00’~’59’ 까지 받을 수 있는 타입이 완성된다. 123type ZeroToFive = '0' | '1' | '2' | '3' | '4' | '5'type ZeroToNine = ZeroToFive | '6' | '7' | '8' | '9'type minute = `${ZeroToFive}${ZeroToNine}` git range cherry pick여러 개의 커밋을 cherry pick 하고 싶을 때, range cherry pick을 하면 된다. 1git cherry-pick {cherry pick할 시작 커밋}^..{cherry pick할 마지막 커밋} cherry pick할 시작 커밋 뒤에 ^ 를 빼면, cherry pick할 시작 커밋 의 바로 다음 커밋부터 cherry pick이 된다. 개발중 API 모킹이 필요할 때 시간이 없다 → 더미데이터 사용(json | JS object) 장점: 쉽다. await sleep(3000) 처럼 호출 지연이 포함된 자유로운 형태로 만들 수 있다. 단점: 데이터를 fetching해오는 것이 아니라서 API 호출 환경과 완전 다르다. (함수를 호출하거나 import 해서 사용..) 시간이 있다 → Mock 서비스워커 사용. mswjs 장점: 네트워크 수준에서 요청을 인터셉트 해주기 때문에 실제 API 호출와 동일한 환경 구성이 가능하다. / restful 한 api 응답을 직접 구현할 수 있다. / 한번 구성해놓으면 테스트환경이나 스토리북에 통합해서 모킹할 수 있다. 단점: 응답 핸들러를 작성할 때 걸리는 시간 + 러닝커브 수동으로 프록시 설정하기개발중인 프론트의 origin 과 호출 할 API의 origin이 다를 경우 CORS 이슈가 발생할 수 있다. 이때 API 서버에서 응답 헤더에 매번 Access-Control-Allow-Origin을 설정해주는 것 보다 프록시를 수동으로 설정해주는 것이 리소스 절약에 도움이 된다. 프록시 설정 방법 http-proxy-middleware: react-script 2.0.0 이상을 사용하는경우 express 인스턴스 미들웨어에 자체 프록시를 연결할 수 있다. 예시 package.json 에 proxy 추가 예시 tsconfig lib의 역할tsconfig에 lib가 지정되지 않으면 target에 따라 기본 리스트가 삽입된다. target ES5: [“DOM”, “ES5”, “ScriptHost”] target ES6: [“DOM”, “ES6”, “DOM.Iterable”, “ScriptHost”] ScriptHost: Window Script Hosting System(WSH) API와 관련된 라이브러리다. 예를 들어, lib: [&quot;ES2020&quot;]과 같은 식으로만 lib을 추가하면 DOM 관련 코드를 사용하는 곳에서 에러가 발생하여 타겟 버전으로 빌드가 안될 수 있다. 이때, lib를 처음 추가하면 기본적으로 제공되는 리스트가 덮어씌어지기 때문에 함께 넣어주는 것이 좋다. 1lib: [&quot;DOM&quot;, &quot;ES5&quot;, &quot;ES2020&quot;, &quot;ScriptHost&quot;] Next.js의 Link 태그Next의 Link 태그는 child에 따라 처리해야할 일이 달라진다. child가 단순 문자열이라면, &lt;a&gt; 태그로 감싸기만 하면 된다. child가 styled-components 또는 emotion으로 만든 styled 컴포넌트라면 Link에 passHref prop을 추가해야 한다. child가 함수 컴포넌트라면 해당 컴포넌트를 React.forwardRef로 감싸고, Link에 passHref prop을 추가해야 한다. Refhttps://nextjs.org/docs/api-reference/next/link#if-the-child-is-a-custom-component-that-wraps-an-a-tag cypress 이것저것 cypress에서 input value를 가져오기 위해서는 invoke 메서드를 활용해야 한다. (공식문서 링크)1234.invoke('val').then(value =&gt; { // 이 value 값이 input value}); cypress는 기본적으로 rtl에서 사용하는 getByText같은 메서드가 없는데, 이때 cypress용 rtl을 설치하거나 아래와 같은 방식으로 구현할 수 있다.1cy.get('tbody').contains('배달상세페이지').click(); cypress에서 cy.get(&quot;body &gt; div&quot;)는 cy.get(&quot;body&quot;).within(() ⇒ {cy.get(&quot;div&quot;)}) 으로 풀어쓸 수 있다. dynamic routingdynamic routing을 리터럴 그대로 활용할때는 (ex. 특정페이지를 찾거나 페이지가 맞는지 확인하는 로직) : 문자를 염두에 두고 코드를 작성해야 한다. 1234567891011121314151617const route = routes.find((it) =&gt; { const compareTargetPath = it.path .split('/') .map((it_) =&gt; (it_.includes(':') ? ':id' : it_)) .join('/') const compareLocationPath = `/${location.pathname .split('/') .filter((it_) =&gt; !!it_) .map((it_) =&gt; { if (!isNaN(Number(it_))) return ':id' return it_ }) .join('/')}` return compareTargetPath === compareLocationPath}) 이때, react-router-dom의 matchPath를 활용하면 코드를 더 간략하고 직관적으로 작성할 수 있다. 1return matchPath(location.pathname, { path: it.path, exact: true }) !== null route config 한번에 관리하기각 페이지에 관한 route config 파일을 만들고 모든 페이지를 한번에 관리하면, 타입추론 및 공통화된 속성을 통한 코드 작성이 용이하다. 12345678910111213141516171819export interface RootComponentProps { readonly path: string readonly name: string viewport?: string exact?: boolean}export interface RouteConfigure&lt;P extends { exact?: boolean; sidebar?: boolean }&gt; extends Omit&lt;RootComponentProps, 'exact'&gt; { readonly id: string component: React.FC&lt;P&gt; props?: Partial&lt;P&gt;}export function createRouteConfigure&lt;T extends RouteConfigure&lt;P&gt;, P = Pick&lt;RootComponentProps, 'exact'&gt;&gt;( params: Readonly&lt;T[]&gt;): (RouteConfigure&lt;P&gt; &amp; T)[] { return params as unknown as (RouteConfigure&lt;P&gt; &amp; T)[]} 12345678910111213141516171819202122232425262728const routes = createRouteConfigure([ { id: '로그인', path: '/login', name: '로그인', component: LoginPage, props: { exact: true, sidebar: false, footer: false, spa: false } }, { id: '검증', path: '/authorize', name: '검증', component: AuthorizePage, props: { exact: true, sidebar: false, footer: false, spa: false, validation: false } },// ...]) CHANGELOG.md 작성하기standard-version 라이브러리를 사용하면 편하다. 장점은 다음과 같다. 커밋 컨벤션에 따라 CHANGELOG.md를 자동 작성해준다. 저희 팀 커밋 컨벤션: https://wiki.woowa.in/pages/viewpage.action?pageId=341738185 자동 tagging을 지원한다. git-flow 브랜치 전략과 잘 맞아 떨어진다. Ref https://musma.github.io/2020/07/27/changelog.html](https://musma.github.io/2020/07/27/changelog.html useQuery의 data를 다른 hook에서 사용하기useQuery의 data 값을 다른 hook에서 사용해야 하는 경우, data의 값이 최초 undefined일 때를 제외할 수 있는 최선의 방법은 무엇일까? useEffect를 사용해서 data 값이 변경되면 해당 hook의 값을 세팅한다.➡️ useEffect의 사용을 줄여주는 게 react-query의 장점이기도 한데, 이를 살리지 못한다. useQuery 전용 HOC를 만들어서 data가 undefined가 아닐 때만 하위 컴포넌트를 렌더링한다. 이렇게하면 하위 컴포넌트가 사용하는 hook의 data는 반드시 undefined 가 아니다.➡️ pending/fulfilled 상태를 구분할 수 있는 react-query의 장점을 굳이 HOC로 다시 구현하는 느낌이다. Placeholder and Initial Data in React Query 포스팅을 참고해봐도 좋을 것 같다. 컴포넌트의 optional 타입컴포넌트의 타입을 선언할 때 optional 타입은 지양하는 것이 좋다. 실제 사용부에서 props로 값을 받을 때 optional로 받을지 여부는 컴포넌트의 관심사가 아니며, 인터페이스의 타입은 원본 데이터 타입을 그대로 유지하는 것이 좋다. optional을 사용한다면 필드 하나를 필수값으로 변경해도, 모든 사용부에서 수정이 필요해져 사용성이 굉장히 나쁘다. 123456789101112// optional 사용export interface ButtonProps { id?: number name?: string disabled?: boolean onChange: (value: string) =&gt; void}// 사용부const CuteButton: VFC&lt;ButtonProps&gt; = ({ onChange }) =&gt; {}const NiceButton: VFC&lt;ButtonProps&gt; = ({ id, disabled, onChange }) =&gt; {}const GoodButton: VFC&lt;ButtonProps&gt; = ({ id, name, disabled, onChange }) =&gt; {} 위 코드에서 만약 name 필드가 필수값이 되면, ButtonProps와 CuteButton, NiceButton의 사용부에서 모두 수정이 필요하다. 혹은 만약 title이라는 필드가 새롭게 필요해진다면? ButtonProps와 title을 받지 않았던 모든 사용부에서 수정이 필요하다. 원본 데이터 타입은 유지하고 사용부에서 따로 타입을 선언해서 사용한다면, 값 하나를 필수값으로 변경한다거나 필드를 추가하는 등의 변경이 일어나도 사이드 이펙트가 적다. 123456789101112131415161718// 원본 데이터 유지export interface ButtonProps { id: number name: string disabled: boolean onChange: (value: string) =&gt; void}// 무엇을 optional로 받을 것인지 여부를 각 사용부에서 결정하고 수정한다type CuteButtonProps = Partial&lt;Omit&lt;ButtonProps, 'onChange'&gt;&gt; &amp; Pick&lt;ButtonProps, 'onChange'&gt;type GoodButtonProps = Partial&lt;Omit&lt;ButtonProps, 'name' | 'onChange'&gt;&gt; &amp; Pick&lt;ButtonProps, 'name' | 'onChange'&gt;const CuteButton: VFC&lt;CuteButtonProps&gt; = (props) =&gt; {}const GoodButton: VFC&lt;GoodButtonProps&gt; = (props) =&gt; {}// 사용부&lt;CuteButton onChange={() =&gt; {console.log('큐트')}} /&gt;&lt;GoodButton id={3} name='버튼' onChange={() =&gt; console.log('좋아')} /&gt; 위 코드에서는 ButtonProps에 title이라는 필드가 추가되어도 CuteButton, GoodButton에는 아무런 영향이 없다. 또는 GoodButton에서만 name을 필수로 받고 싶다면? GoodButtonProps만 수정하면 된다. 이때 CuteButtonProps를 사용하는 CuteButton에는 사이드 이펙트가 없음. 또 다른 방법을 살펴보자. 보통 컴포넌트의 prop은 필수값들이 optional 값보다 적은 경우가 일반적이다. 위에서 작성한 것처럼 사용부에서 따로 타입 선언을 한다면, ButtonProps 프로퍼티를 모두 optional로 만들고, 확장하는 곳(CuteButtonProps)에서 필요한 prop들만 required로 바꿔주는 접근도 가능하다. 이때 일부 프로퍼티를 optional ➡️ required로 또는 반대로 바꾸는 Utility Type을 만들어두면 유용하다. 1type WithRequired&lt;T, K extends keyof T&gt; = T &amp; { [P in K]-?: T[P] } 1type WithOptional&lt;T, K extends keyof T&gt; = Omit&lt;T, K&gt; &amp; { [P in K]?: T[P] } [P in K]-?에서 -? 표시는, 해당 인터페이스에서 optional을 모두 빼주겠다는 의미다. (optional 필드들을 required 값으로 바꿔준다.) 처음의 GoodButtonProps의 인터페이스는 아래와 같이 작성할 수 있다. 1type GoodButtonProps = WithOptional&lt;ButtonProps, 'name' | 'onChange'&gt; undefined vs nullJavaScript에서 undefined는 아직 값이 할당되지 않은 상태의 변수으 값을 나타낸다. let 키워드로 선언한 변수나 (값을 할당하지 않은 경우), 아무것도 반환하지 않는 함수의 리턴값이 undefined에 해당한다. 반면 null은 ‘할당을 위한 값’이라고 할 수 있다. null은 JavaScript 엔진이 자동으로 할당하는 것이 아니라, 개발자가 직접 특정 변수가 비어있음을 나타낼 때 사용한다. typeof null은 object며, typeof undefined는 undefined이다. null이 object 타입인 것은 JavaScript 설계 초기 단계에서의 실수라고 알려져있으며, type이 undefined인 것은 오로지 undefined뿐이다. (즉 undefined는 JavaScript에서 타입으로도, 값으로도 쓰인다) 궁금했던 것은, 동치 연산(== 또는 ===)과 falsy 연산을 쓸 때 null과 undefined의 계산이 항상 헷갈렸기 때문이다. 12null == undefined; // truenull === undefined; // false null과 undefined는 공통적으로 ‘값이 없음’을 뜻하기 때문에, 느슨한 동치 연산 비교(==)에서는 true를 반환한다. 하지만 null은 object 타입, undefined는 undefined 타입으로, 서로 타입이 다르기 때문에 엄격한 동치 연산 비교(===)에서는 false를 반환한다. 사실 대단히 어려운 문제도 아닌데 괜히 헷갈렸다. 원래 하다보면 가장 기본적인 것들이 헷갈리기 마련이라고 위로해본다. -_- Ref https://medium.com/@paytonjewell/javascript-eli5-null-vs-undefined-f7112a2b72dd https://steemit.com/kr-dev/@cheonmr/js-operator Content-Type: boundaryHTTP의 POST 메서드를 사용할 때 헤더 Content-Type에 boundary라는 key값을 사용할 수 있다. 1Content-Type: multipart/form-data; boundary=something boundary는 메시지 파트를 구분하는 역할을 하며, 메시지의 시작과 끝 부분도 나타낸다. 첫 번째 boundary 전에 나오는 내용은 MIME을 지원하지 않는 클라이언트를 위해 제공된다. 네트워크를 통해 메시지 및 파일을 전송할 때 패킷을 한번에 보내지 않고 나눠서 보내게 되는데, 여러 부분(multipart)으로 나누려면 각 부분의 경계를 표시해야 하며, 이 경우 메시지 및 파일의 전송되는 내용의 구분자로 사용한다. boundary를 선택하는 것은 클라이언트의 몫이며, 보통 무작위의 문자를 선택해 메시지의 본문과 충돌을 피한다. Ref https://lena-chamna.netlify.app/post/http_multipart_form-data/ https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Type TypeScript에서 useRef 사용하기DOM 요소에 직접 접근하거나, 리액트 컴포넌트의 리렌더링 시에도 유지되는 값을 사용하기 위해서 useRef hook을 사용할 수 있다. 이때 useRef를 TypeScript와 함께 사용한다면, useRef의 타입에 유의해야 한다. @types/react 레포를 보면 useRef는 3개의 정의가 오버로딩되어 있다. useRef&lt;T&gt;(initialValue: T): MutableRefObject&lt;T&gt; 인자의 타입과 제네릭의 타입이 T로 일치하는 경우, MutableRefObject&lt;T&gt;를 반환한다.MutableRefObject&lt;T&gt;의 경우, 이름에서도 볼 수 있고 위의 정의에서도 확인할 수 있듯 current 프로퍼티 그 자체를 직접 변경할 수 있다. useRef&lt;T&gt;(initialValue: T|null): RefObject&lt;T&gt; 인자의 타입이 null을 허용하는 경우, RefObject&lt;T&gt;를 반환한다. RefObject&lt;T&gt;는 current 프로퍼티를 직접 수정할 수 없다. current가 readonly인 RefObject를 반환하기 때문이다. useRef&lt;T = undefined&gt;(): MutableRefObject&lt;T | undefined&gt; 제네릭의 타입이 undefined인 경우(타입을 제공하지 않은 경우), MutableRefObject&lt;T | undefined&gt;를 반환한다. 이렇게 사용할 경우 useRef가 반환하는 객체를 DOM 요소의 ref 프로퍼티에 집어넣을 수 없다. 123456789101112import React, { useRef } from &quot;react&quot;;const App = () =&gt; { const inputRef = useRef&lt;HTMLInputElement&gt;(); return ( &lt;div className=&quot;App&quot;&gt; // 🚨 Type 'MutableObject&lt;HTMLInputElement | undefined&gt; is not assignable... &lt;input ref={inputRef} /&gt; &lt;/div&gt; );} 따라서 DOM을 직접 조작하기 위해 프로퍼티로 useRef 객체를 사용할 경우, RefObject&lt;T&gt;를 사용해야하므로 초깃값으로 null을 넣어줘야 한다. Ref https://driip.me/7126d5d5-1937-44a8-98ed-f9065a7c35b5 이것저것 서버의 관심사는 데이터가 클라이언트에서 어떻게 렌더링되는지가 아니다. CRUD에 따라 DB의 데이터를 읽고 내려주는 역할을 할 뿐이다. 데이터의 가공과 조합은 클라이언트가 하되, 보안/용량/성능상의 이슈가 있는 경우에만 서버가 데이터를 가공해서 내려주는 것이 좋다. CSS 의사 클래스 :focus-within은 포커스를 받은 요소를 포함하고 있는 요소를 나타낸다. form 안에 input 필드 중 하나가 focus 되었을 때 form을 컨트롤 할 수 있어 유용하다. align-items의 값이 flex-start면 flex container 기준으로 시작점에 붙고, baseline이면 text의 밑줄 부분을 기준으로 정렬된다. emotion에서 컴포넌트에 css Prop을 넘겨주면 props에 css가 아닌 className으로 들어가게 된다. Javascript에서 숫자 타입은 정수와 소수를 모두 표현하고 있는데, Javascript Parser는 정수 숫자 뒤에 점이 있으면 소숫점 이하의 수가 표현될 것으로 기대한다. 따라서 100.toString()의 경우, (소수점) 다음에 숫자가 올 것으로 기대하였지만 갑작스레 문자열이 나타난 것으로 인식하여 오류를 발생시킨다. (100).toString()이나 100..toString()으로 쓸 수 있다. [time picker], [time range picker], [date + time range picker] 와 같이 연쇄적으로 컴포넌트를 재사용하는 컴포넌트를 개발할 때, 요구 사항 분석을 작은 단위(time picker)부터가 아닌 큰 단위(date + time range picker)부터 추려나가는 것이 컴포넌트의 확장성에 좋을 수도 있다. 서로 다른 VSCode window를 합치려면 mac 상단에서 Window → Merge All Windows 해주면된다. 구글 크롬의 V8 엔진은 OKR의 결과물이다 (Object: 잡지를 넘기는 것처럼 웹을 빠르게 만들기) BHAG란 크고 위험하고 대단한 목표를 의미한다 (Big Hairy Audacious Goals) 카드목록 UI에서는 보통 이미지(thumbnail)가 상단에 배치된다. 아토믹 디자인에 대한 고민 (링크) TypeScript에는 Capitalize 내장 유틸타입이 있다. react-query와 recoil은 옵저버 패턴을 사용한다. (react-query, recoil) input이나 textarea 태그에서 글씨 영역을 선택(강조)하고 싶을 경우, select() 메소드를 사용하면 영역이 선택된다. 디자인 시안을 봤을 때, 사용성 측면에서도 확인해봐야 한다. 컴포넌트 시안만 봤을 때는, 기능상으로 문제가 없고 깔끔한 디자인으로 보일 수 있지만, 실제로 사용하는 측면에서는 여러가지 상황이 발생할 수 있다. 서버에서 open api를 bypass한다는 말의 의미는, 프론트에서 open api에 대해 요청해서 받은 응답 값을 서버에서 따로 정제 없이 그대로 내려주겠다는 의미이다. 외부 모듈을 import 할 때, 대소문자 구별을 잘 해야 한다. IDE가 자동으로 잡아주지 않는다. (webpackd을 사용하면 case-sensitive-paths-webpack-plugin 플러그인이 개발환경에서 잡아준다.) 외부와 의존성이 높은 함수들이 사용되고 있는 함수는 테스트하기 힘들다. 의존성 높은 부분이 테스트할 부분이 아니라면 분리를 해버리고 통째로 mocking하는게 좋을 수도 있다. 데이터를 모델링할 때 지향할 점들 서버 요청 모델과 서버 응답 모델, 클라이언트 모델 인터페이스 모두 선언한다. 응답 데이터와 클라이언트 모델 인터페이스를 매핑하는 함수를 만들어 활용한다. 기타Core Web VitalCore Web Vital이 개발과 비즈니스 측면에서 중요한 이유와, 그 사례들을 소개하고 있다. Ref https://web.dev/vitals-business-impact/ JavaScript에서 객체지향을 하는 게 맞나요?기술이란 지난 문제들을 해결하기 위해서 만들어졌기 때문에, 왜 이러한 기술이 필요했고 어떠한 발전 과정을 거쳤는지 파악하는 것이 중요하다. 절차적 프로그래밍에서는 실행 순서를 강제로 바꾸는 것이 아니라 일정하게 반복되는 코드를 따로 만들어두고, 그에 해당하는 코드를 호출하고 나서 다시 원래 자리로 돌아오는 방식의 프로시저(함수)를 통해 개발이 진행된다. 즉, 데이터와 데이터를 처리하는 동작을 함수 단위로 코드를 분리하고 재사용하는 형태다. 123456789101112131415var hp = 100var mp = 100gameloop:...if (key == 'A') { goto magic}...goto gameloopmagic:mp -= 10...goto gameloop 그러나 절차적 프로그래밍은 기본적으로 전역 변수를 사용하기 때문에, 코드의 규모가 커질 때 골치가 아파진다는 문제가 있다. 서로 연관이 있는 데이터들을 하나로 묶어 namespace처럼 관리하여 해당 변수에 접근을 할 수 있는 구조체라는 형식이 탄생한다. 123456789101112var character = { name: &quot;teo.yu&quot; hp: 300 mp: 500}function useSkill(character) { ... character.mp -= 100 // 변수를 직접 수정하게 됨.}do_somthing(character) 의미 있는 단위로 변수들을 하나로 묶음으로써 변수 명의 중복을 줄이고 함수나 배열 등에서도 하나의 변수처럼 활용할 수 있게 되었다. 이렇게 데이터를 중심으로 코딩하는 것의 유용성이 퍼지게 되며 객체지향 프로그래밍이 등장하였고, 구조체와 항상 쓰이는 함수들을 하나로 묶어서 구조체와 함께 함수까지 포함하는 개념을 만들어 이를 class라고 불렀다. 12345678910111213141516// classclass Character { name = &quot;teo.yu&quot; hp = 300 mp = 500 attck() {...} useSkill() {...} moveTo(toX, toY) {...}}// objectvar character = new Character();character.attck();character.useSkill()character.jump(); 서로 독립적으로 작동하는 작은 부분들을 조립하고 결합하는 방식이 되었고, Class와 Object의 개념이 등장한다. 이런 식으로 작은 문제를 해결하는 것들을 모아서 하나의 문제를 해결하는 프로그램으로 개발하는 방식을 Bottom-up 방식이라고 한다. 이렇게 프로그램을 객체로 바라보는 관점으로 프로그래밍을 하는 것을 Object-Oriented Programming (OOP) = 객체지향 프로그래밍 이라고 부르게 되었다. 🤓 뒷 이야기는 👇 아래 링크에서~ Ref https://yozm.wishket.com/magazine/detail/1396/?fbclid=IwAR15xqxPTnnP9Xh1BsH_i75ZDpvgoUt_IiFkk5vbnOfJ08rUo9zZfdC5U2w React 18 공식 문서가 나왔당. React와 함께 그 역사를 지켜보며 쑥쑥 자라나는 기분 Ref https://reactjs.org/blog/2022/03/29/react-v18.html?fbclid=IwAR1TA5jkN2h02JpfTPXjWGrhWLWV-8JLGZkgGLJiTxKjqX-ZBX5QgwNhpwo NodeJS로 객체지향의 원칙을 지키면서 시스템 구성하기Ref https://nodejs.myeongjae.kim/ CLI 자동완성을 지원해주는 툴Ref https://fig.io/ 실수한 명령어를 자동완성해주는 툴Ref https://github.com/nvbn/thefuck 일 잘하는 개발자란?‘주어진 업무를 수행할 때, 업무의 목표가 무엇인지 정확히 이해하고 수행하는 사람’! 철학자 드라이퍼스 (아무리 봐도 ‘드레퓌스’가 더 자연스러운데…)가 제안한 기술 습득의 5단계 모델을 소개하고 있다. 철학자들은 정말 별걸 다 분석한다! 드라이퍼스 모델이 5단계의 구분에서 제안하는 중요한 요소는 바로 직관 이라는 요소다. 인간은 구체적인 경험으로부터 직관을 얻을 수 있고, 이것은 컴퓨터와 같은 기계로 추론해 내는 것은 대단히 힘들다는 것이다. 소위 말하는 ‘짬’이 아닐까 생각한다. 무슨 느낌인지는 알겠다. 아직 Competent 단계까지 가기에도 멀리있는 것 같지만, 한 단계씩 조금씩이나마 성숙해지기 위해 부단히 경험을 쌓아나가야 할 것이다. Ref http://blog.lastmind.io/archives/593 마무리가구들이 하나 둘 도착했다. 독립하면 바꾸겠다고 했는데, 2년이라는 시간은 기다리기에 꽤나 긴 것 같다. 아직 다 꾸미진 않았는데, 지금까지도 맘에 든다. 일단 물건들을 정리하면서 많은 것들을 갖다 버린 게 홀가분하다. 회사에서는 2월부터 함께 해왔던 컴포넌트 하나..가 아니고 두 개를 드디어 내보냈다! 나가자마자 버그가 있어서 핫픽스했지만 ㅠ 별건 아니지만 그래도 뿌듯한 기분이다. 주말엔 전주여행을 다녀왔다. 올해 처음이기도 하고, 정말 오랜만의 여행인 것 같다… 작년 6월 이후 거의 1년만이다. 😵 날씨는 따뜻했지만 사람이 말도 안되게 많았고, 벚꽃은 아직 덜 폈다. 의도치 않게 먹짱 여행을 하고왔다. 다음 일주일은 좀 굶어야겠다.","link":"/2022/04/01/2022-4-week-1/"},{"title":"4월 2주차 기록","text":"아직 살만해요 배워가기React PortalReact portal을 이용하면 부모 컴포넌트의 DOM 계층 구조 바깥에도 자식을 렌더링할 수 있다. 주의할 점은, Portal로 렌더링한 컴포넌트는 DOM 트리에서의 위치와는 상관없이 여전히 React 트리에 존재한다는 것이다. 따라서 Portal은 DOM 트리 어디에도 존재할 수 있지만 일반적인 React처럼 동작한다. 이것에는 이벤트 버블링도 포함되어 있어, Portal 내부에서 발생한 이벤트는 React 트리에 포함된 상위로 전파된다.그렇기 때문에 stopPropagation()과 같이 이벤트 전파가 되지 않게 구현했을 때 실제 그려진 DOM 트리에서는 영향을 받을 수 없는 구조임에도 불구하고 동작에서는 영향을 받아, 기대와는 다르게 동작하는 경우가 생길 수 있다. Ref https://ko.reactjs.org/docs/portals.html || vs ??논리 OR 연산자 ||는 첫 번째 truthy 값을 반환하고, Nullish 통합 연산자 ??는 첫 번째 정의된 값을 반환한다. 1234567const foo = { count: 0 }// foo.message 피연산자의 정의 유무로 결과값 반환console.log(foo.message ?? 'bar') // 'bar'// foo.count 피연산자가 falsy 할 경우 다음 첫번째 truthy 값을 반환console.log(foo.count || '없다') // '없다' 논리 할당에서도 같은 맥락으로 사용된다. 1234567const foo = { count: 0 }foo.message ??= 'bar'console.log(foo.message) // 'bar'foo.count ||= '없다'console.log(foo.count) // '없다' npm scripts 정복하기npm scripts 내 npm scripts를 호출할 때 argument를 그대로 넘겨주고 싶다면, 대시 문자(-)를 사용한다. 12&quot;test&quot;: &quot;react-app-rewired test --watchAll=false&quot;,&quot;test:coverage&quot;: &quot;npm run test -- --coverage -를 붙이지 않으면 arguments가 전달되지 않으며, 환경변수의 경우 그대로 적용된다. 123&quot;test&quot;: &quot;react-app-rewired test --watchAll=false&quot;,&quot;test:coverage&quot;: &quot;npm run test -- --coverage ...&quot;,&quot;test:ci&quot;: &quot;TZ=Asia/Seoul JEST_JUNIT_OUTPUT_DIR=coverage npm run test:coverage -- --ci ...&quot; 위 예시에서, 중첩된 npm scripts는 어떻게 동작할까? npm@6 에서는 중첩된 npm scripts가 실패하면 실행한 npm scripts도 실패하지만, npm@8 에서는 그렇지 않다. npm@6 에서는 npm run test:ci를 호출했을 때 npm run test:coverage 가 실패하면 test:ci도 실패한다. npm@8 에서는 npm run test:ci를 호출했을 때 npm run test:coverage 가 실패해도 test:ci는 실패하지 않는다. instanceof 대신 속성 체크객체에 대한 타입 가드를 작성할 때, 인터페이스에 대한 instanceof 체크 대신 속성 체크를 통해 작성해야 한다. 1234567if (shape instanceof Rectangle) { // 🚨 }if ('height' in shape) { // ✅} instanceof 체크는 런타임에 일어나지만, Rectangle은 인터페이스이기 때문에 런타임 시점에 아무런 역할을 할 수 없다. 타입스크립트의 타입은 컴파일 과정에서 제거되기 때문이다. 따라서 런타임에 타입 정보를 체크하기 위해서는 객체 속성이 존재하는지 체크하면 된다. 또는 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 ‘태그’ 기법을 이용한다. (tagged union) 덕 타이핑 (duck typing)JavaScript는 덕 타이핑 기반 언어다. 덕 타이핑이란, 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식이다. (만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리면 그 새를 오리라고 보는 방식이다.) TypeScript의 타입 시스템은 자바스크립트의 런타임 동작을 모델링하며, 이를 구조적 타이핑(structural typing)이라는 용어로 이야기한다. 예를 들어 interface A { name: string }, interface B { name: string; type: string; }가 있을 때, 인터페이스 B는 A와 동일한 name 속성이 있기 때문에 따로 관계를 정의하지 않아도 A 타입에 속한 것으로 간주된다. React render propReact의 render prop이란 React 컴포넌트 간에 코드를 공유하기 위해 함수 props를 이용하는 테크닉이다. 컴포넌트에서 받는 children에 특정 prop을 전달하고 싶을 때 유용하다. 12345678910111213interface AProps { children: ({ isValid }: { isValid: boolean }) =&gt; ReactNode;}const A: FC&lt;AProps&gt; = ({ children }) =&gt; { const [isValid] = useState(false); return &lt;div&gt;{children({ isValid })}&lt;/div&gt;;};const B = () =&gt; { return &lt;A&gt;{({ isValid }) =&gt; (isValid ? 'O' : 'X')}&lt;/A&gt;;}; 웹팩 devtool sourcemap 옵션 inline-source-map 정확한 line과 column까지 알려주는 소스맵이다. column까지 찾아주는게 실제 디버깅에 큰 도움이 되지는 않아도, 개발환경에서 번들의 크기는 많이 증가시킨다. cheap-module-source-map 정확한 line을 알려준다. 웹팩에서 추천하는 옵션이다. props 확장하기아래 예시를 살펴보자. props에서 어떤 속성(time)이 union type을 보장하면서, 각 타입에 맞는 onChange 함수를 받아오고 싶을 때는 아래와 같이 union으로 활용하면 된다. time이 TimeFormat일 경우는 string을 parameter로 받는 onChange 함수를, Date 형식일 경우는 Date를 parameter로 받는 onChange 함수를 props로 받게된다. 123456789101112131415interface CommonTimePickerProps { time?: TimeFormat | Date}interface TimeFormatProps extends CommonTimePickerProps { time?: TimeFormat onChange(value: string): void}interface DateProps extends CommonTimePickerProps { time?: Date onChange(value: Date): void}export type TimePickerProps = TimeFormatProps | DateProps window beforeunload 이벤트beforeunload 이벤트를 사용하면 사용자가 페이지를 떠날 때 정말로 떠날 것인지 묻는 확인 대화 상자를 표시할 수 있다. 사용자가 확인을 누를 경우 브라우저는 새로운 페이지로 탐색하고, 취소할 경우 탐색을 취소하고 현재 페이지에 머무른다. 이밖에도 form 임시저장 등에도 beforeunload를 사용할 수 있다. PSUPSU란 Pre Signed URL의 약자로, AWS S3 를 접근할 수 있는 권한(업로드를 허용해주는)을 가진 URL이다. 미리 서명된 url을 가진 사용자만 객체에 액세스 할 수 있게 해준다. PSU로 HTTP GET 요청을 보내면 객체를 다운로드 할 수 있다. 또 PSU로 파일을 body에 담아서 HTTP PUT 요청을 하면 파일을 업로드할 수 있다. React에서 제공하고 있는 유틸리티 타입들 React.ComponentProps React 컴포넌트에서 쓰이는 props 타입들을 별도의 타입으로 선언해서 사용하고 싶을 때, type 컴포넌트Props = React.ComponentProps&lt;typeof 컴포넌트&gt;와 같이 작성할 수 있다. React.ComponentPropsWithoutRef forwardRef를 통해 ref를 전달받는 컴포넌트가 있을 때, 이 컴포넌트의 props에 대한 타이핑이 필요하다면 ref를 제외한 속성들에 대한 타입이 필요할 것이다. 이 때 이걸 사용한다. BFF(Backend-For-Frontend)BFF는 모놀리스 아키텍처가 점진적으로 변화하면서 생겨난 아키텍처 패턴이다. BFF가 등장하기 이전에는, 다음과 같은 문제점들이 있었다. 여러 API를 병합하여 하나의 페이지를 만드는 이전 방식의 경우 단일 웹 사이트에서 수많은 Http 요청이 발생한다. 공개 API만 사용하다가 자체 전용 기능을 만들려면 여러 곳에서 OAuth 범위를 확인해야 한다. BFF 아키텍처 도입 이후에는, 다음과 같은 장점들을 이용할 수 있게 되었다. BFF에서 클라이언트에서 필요로 하는 모든 리소스를 모아서 단일 엔드포인트로 제공한다. 다중 BFF(모바일, 웹)를 구성해서 빠르게 이동할 수 있다. 그러나 BFF가 늘어나면서 각 BFF에서 데이터를 가져오고 병합하는 중복 코드도 늘어났다. 이는 마이크로 서비스와 BFF 사이에 어플리케이션 서비스를 두어 중복된 로직을 처리하는 역할을 맡기는 방식으로 해결한다. Ref https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html p 태그는 div 태그를 품을 수 없다.반대로 div 태그는 p 태그를 품을 수 있다. div는 phrasing content가 아니고(링크), p는 phrasing content인데 (링크), phrasing content는 phrasing content로 분류되는 요소들만 포함할 수 있기 때문이다. (링크) 🤔 phrasing content?HTML 태그들은 그 특성에 따라 Metadata, Flow, Sectioning, Heading, Phrasing, Embedded, Interacticve 총 7개의 카테고리로 분류된다. 여기서 Phrasing Content(구문 컨텐츠)는 텍스트와 텍스트가 포함된 마크업을 정의한 컨텐츠를 가리킨다. HTML5 스펙(content model) 상 div는 flow content에 속해서 하위에 block 요소를 쓸 수 있다. p는 phrasing content 에 속해서 하위에 inline 요소만 쓸 수 있다. Ref https://stackoverflow.com/questions/8397852/why-cant-the-p-tag-contain-a-div-tag-inside-it https://abcdqbbq.tistory.com/6 package-lock.json의 lockfileVersionpackage-lock.json 파일에는 lockfileVersion이라는 것이 있다. package-lock.json 파일을 만들 때 사용됐던 시멘틱을 갖고 있는 문서의 버전 번호를 명시한다. npm@7부터 package-lock.json 형식이 크게 바뀌었다. npm@7은 lockfileVersion: 2를 갖고 있다. 그 외 npm 버전들의 lockFileVersion은 다음과 같다. 명시된 버전 없음: 고대의 package-lock.json 버전 1: npm@6 버전 2: npm@7 (하위 호환성 보장) 버전 3: npm@7 (하위 호환성 보장하지 않음) 버전 2를 쓰는게 현재 가장 무난하다고 한다. package-lock.json 버젼이 계속해서 2로 지속될 수 있게끔 팀원간 npm 버젼 맞추기, CI/CD 환경의 npm 버젼 맞추기가 필요할 것이다. Ref https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json#lockfileversion https://jopemachine.github.io/2021/11/09/Package-Lock-Json-Lockfile-Version/ EAFP (It’s Easier to Ask Forgiveness than Permission) vs LBYL (Look Before You Leap)EAFP는 일단 수행시키고 에러가 발생하면 그 때 처리하는 방식을 말한다. (try~catch 등) LBYL는 어떤 코드를 실행하기 전에 에러가 발생할 만한 부분을 조건문으로 미리 체크하는 방식을 말한다. (if문 등 ) 파이썬 등의 언어는 EAFP를 권장한다고 한다. (마치 선타투후뚜맞 같다.) nested form (form 안에 form) 은 HTML 5에서 지원하지 않는다.HTML의 form은 단 한번의 HTTP 요청을 위해 만들어졌다. 만약 중첩된 form의 경우 부모 form에서 submit했을 때, 자식 form은 부모의 field이기 때문에 자식 form의 submit action이 같이 되어야 하는 것인지, 혹은 자식 form의 field들만 submit되어야 하는지 애매모호해진다. superstruct에서의 union + literalsuperstruct 스키마를 아래처럼 union + literal과 enums로 정의할 경우에 infer로 타입을 빼보면, enums는 string으로만 추론되고 union + literal을 사용한 경우 더욱 상세하게 추론된다. 1234567891011const PSULinkRequestBodySchema = object({ uploadType: union([literal(`CDN`), literal(`SECURE`)]), uploadType2: enums(['CDN', 'SECURE']),})type PSULinkRequestBody = Infer&lt;typeof PSULinkRequestBodySchema&gt;type PSULinkRequestBody = { uploadType: &quot;CDN&quot; | &quot;SECURE&quot;; uploadType2: string;} superstruct의 object/type 비교 object는 비교대상 객체와 정확히 일치해야 assertion을 통과한다. type은 비교대상에 포함되기만 하면 assertion을 통과한다. API의 응답값과 정확히 일치한지 체크하려면 object, 응답값 중 일부만 비교하려면 type을 사용한다. z-index 음수z-index가 음수인 경우 요소가 화면에서 사라지는 것이 아닌, 가장 뒤로 이동하게된다. 해당 레이어를 포함하고 있는 background color가 투명하다면, z-index가 음수여도 보이게된다. 즉, z-index가 음수일 경우는 background color에 의해 가려지는 것이었다. 특정 부분의 뒷 배경만을 다루기 위해서 z-index 음수를 활용하는 경우가 있는데, 큰 틀 (Wrapper)같은 경우는 background color가 없는 케이스가 거의 없다보니 z-index가 음수인 요소가 background color에 가려지는 경우가 발생한다. 이럴 때는 필요한 부분에만 새로운 투명한 쌓임맥락을 만들어서 z-index 음수를 활용하여 해결할 수 있다. 고차 컴포넌트와 React mixins고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수로, 컴포넌트 로직을 재사용하기 위해 사용하는 패턴이다. 1const EnhancedComponent = higherOrderComponent(WrappedComponent); React mixins 역시 클래스 컴포넌트를 사용하던 당시, 컴포넌트 로직을 재 사용하기 위해 나왔던 패턴이다. 하지만 여러 문제가 있기 때문에 가능한 mixins 대신 HoC를 사용하는 것을 권장한다. 123456var PureRenderMixin = require('react-addons-pure-render-mixin');var Button = React.createClass({ mixins: [PureRenderMixin], // ...}); 믹스인의 문제 믹스인은 암시적 의존성을 만든다. 믹스인은 한 컴포넌트에 있는 파일이 아니기 때문에 종속성이 생기고, 문서화하기 어렵다. 믹스인은 이름 충돌을 야기한다. 타 패키지나, 믹스인 심지어 믹스인이 적용될 컴포넌트까지 메소드명이 충돌될 수 있다. 믹스인은 복잡성을 눈덩이처럼 불어나게 한다. 믹스인의 기능을 확장하면서 점점 다른 믹스인이 생겨나게 되고, 결과적으로 믹스인들끼리는 강한 종속성이 생겨버린다. Ref https://itmining.tistory.com/124 CSS :is :where pseudo selectorWorking Draft Level 4에 있는 문법이지만 대부분의 모던 브라우저에서 지원하고 있다. :is 는 다음과 같이 동작한다. 12345div &gt; p, div &gt; span, div &gt; h1 { /* 동일하게 */ }div &gt; :is(p, span, h1) { /* 동작함 */ }button.focus, button:focus { /* 동일하게 */ }button:is(.focus, :focus) { /* 동작함 /* } :is 와 :where 는 비슷하게 동작하지만, :where 는 명시도를 계산하지 않아 항상 0이라는 큰 차이점이 있다. 이는 가장 우선순위가 낮게 적용된다는 뜻으로, 어떤 위치에 정의했어도 가장 앞쪽에 정의한 스타일 속성처럼 동작한다. 그래서 CSS를 Reset하는 스타일을 작성할 때 사용하기 좋다. 반면에 :is 는 일반적인 CSS 선택자처럼 명시도의 영향을 받는다. Ref https://caniuse.com/css-matches-pseudo import React from “react”React 17부터 import React from &quot;react&quot;를 생략해도 되는 건 바벨7과의 협업 덕분이라고 한다. 이전에는 컴포넌트가 반환하는 jsx를 React.createElement(&quot;div&quot;) 형태로 트랜스파일링 했기 때문에 상단에 React가 있어야 했지만, 트랜스파일링 옵션에 따라서 _jsx(&quot;div&quot;, {}, void 0);와 같은 형태로 반환해주면 상단에 React를 import하지 않아도 되는 원리다. Ref https://www.typescriptlang.org/docs/handbook/jsx.html#basic-usage reduce를 사용하여 Array의 원소들을 object의 key로 변경하기1234567const arr = ['name', 'age', 'country'];const obj = arr.reduce((accumulator, value) =&gt; { return {...accumulator, [value]: ''};}, {});console.log(obj); // 👉️ {name: '', age: '', country: ''} Ref https://bobbyhadz.com/blog/javascript-convert-array-values-to-object-keys 인터페이스의 모든 필드를 Nullable하게 만들기1type Nullable&lt;T&gt; = { [K in keyof T]: T[K] | null }; Ref https://typeofnan.dev/making-every-object-property-nullable-in-typescript/ 이것저것 sql 쿼리의 실제 실행순서는 DBMS의 옵티마이저가 비용을 최소화한 실행계획에 따라 실행되어 생략되거나 순서가 바뀔 수 있다. Stage 4에 올라와 있는 Object.fromEntries 메서드는 키값 쌍의 목록을 객체로 바꿔준다. 즉 entry로 객체를 다시 만들 수 있다. (Ref) 123456789const entries = new Map([ ['foo', 'bar'], ['baz', 42]]);const obj = Object.fromEntries(entries);console.log(obj);// expected output: Object { foo: &quot;bar&quot;, baz: 42 } 앱에서 특정 페이지를 띄울 때 remote config(서버를 통해 받아오는 동적 데이터)에 있는 url로 이동한다. 그루비(Groovy) 자바에 파이썬, 루비, 스몰토크등의 특징을 더한 동적 객체 지향 프로그래밍 언어다. OKKY 서버가 그루비로 만들어져있다. i18n에는 interpolation 기능이 있다. {{}} 안에 키값을 넣어서 다국어 대응을 더 편하게 할 수 있다. (Ref) 스타일 내용을 담고 있는 style 변수명은 어떤 상황(lastDayOfMonth)을 빗대고 있는 이름을 가지기 보다는 leftGradient와 같이 스타일 친화적인 변수명을 사용하자 Verdaccio는 로컬에서 사용할 수 있는 Private NPM Registry이다. npm 패키지 배포를 테스트해보고 싶을 때 로컬에서 Verdaccio 서버를 띄워서 배포해볼 수 있어 유용하다. node의 setInterval은 객체를 반환하고, window.setInterval은 number를 반환한다. 구동 환경에 따라 env에 우선순위가 있다. CRA 기준으로 한 우선순위는 아래와 같다. npm start : .env.development.local, .env.development, .env.local, .env npm run build : .env.production.local, .env.production, .env.local, .env npm test : .env.test.local, .env.test, .env \\b는 backspace escape character로, 문자를 지우지 않고 커서만 뒤로 옮겼을 때 포함되는 문자다. 제어 컴포넌트 - 입력 폼 엘리먼트는 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트한다. 리액트에서 state는 일반적으로 컴포넌트의 state 속성에 유지되고 setState()로 업데이트된다. 리액트의 state와 입력 엘리먼트의 value를 동일하게 통일시켜 React 컴포넌트에서 사용자 값을 제어할 수 있을 때, 이를 제어 컴포넌트라고 한다. feature flag - 깃 플로우에서 개발 중인 기능을 지속적으로 통합하고 싶지만, 실제 환경에서는 보이지 않게 하거나 특정 사람에게만 보이도록 하고 싶을 때, 해당 기능과 관련된 feature flag를 코드 내에 설정하여 on/off해주는 방식으로 관리할 수 있다. 더 나아가 a/b test를 위한 발판도 쉽게 마련 가능하다. git checkout --track {remote 브랜치명} - 로컬에서 remote에 있는 브랜치를 트래킹하는 브랜치를 만든다. git checkout -t upstream/... - upstream에 있는 브랜치를 가져오기 package.json에서 peerDependencies 항목은 내가 만든 모듈이 다른 패키지에 직접 사용(require, import)되는 것은 아니지만 그 호스트 패키지와 호환성을 가지고 있는 것을 표현할 때 사용한다. npm@3~npm@6 까지는 peerDependencies가 자동으로 설치되지 않고, dependencies에 누락된 경우 경고만 띄웠다. (dependencies 지옥에 빠지지 않도록 하기 위함이다.) npm@7 부터는 자동으로 해결할 수 없는 dependencies 충돌이 없으면 peerDependencies가 자동으로 설치된다. 젠킨스에서 브랜치명에 backup이 들어가면 안된다. 개체는 객체에 포함되는 관계이다. 개체는 유일한 객체이다. 인스턴스 클래스로 비교를 하자면 instance는 개체, class는 객체라고 말할 수 있다. clickable하지 않은 element에 click 이벤트를 넣는 것은 좋지 않다. 만약 하고 싶다면 cursor: pointer를 주자. .tsbuildinfo - tsc가 컴파일할 때 참고하는 파일로, 컴파일 속도를 빠르게 하는 데에만 사용된다. ‘명시도(Specificity)’는 브라우저가 특정 요소에 CSS 속성이나 스타일을 적용하기 위해서 사용하는 가중치(weight)다. 명시도가 높을수록 해당 선택자에 정의된 스타일이 가장 우선적으로 적용된다. 기타프로그래머스 Dev Survey 2022프로그래머스에서는 생각보다 재밌는 걸 많이 하는 것 같다. 개발자들이 가장 많이 하는 고민은 ‘전문성 부족’이었다. 끊임없이 성장을 외치는 개발자들은 정말… 피곤…하지만 나도 그래야 하는 걸… 개발자라서 많이 듣는 말이 “내 컴퓨터 고쳐줘”에서 “나도 개발 배울까봐”로 바뀌었다고 한다. 나도 여러 번 들어본 말이다. 주변 사람들에게 그래 한번 해보라고 말해준다. 책상 아이템에 이산화탄소 측정기는 왜 갖고 있는지 모르겠다. 순위권에 스탠딩 데스크가 있어서 괜시리 뿌듯. Ref https://programmers.co.kr/pages/2022-dev-survey React 18 한국어 번역본아 내가 먼저 쓸 걸. Ref https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-react-v18-0-9da9a6b838bd 비동기 코드를 짤 때 도움이 되는 린트 툴Promise에서 catch를 사용하지 않는다거나, Error 객체로 감싸지 않은 에러 메시지를 던진다거나 하는 등 사소하게 코드의 퀄리티를 떨어뜨리는 경우들을 사전에 잡아주는 린트 툴들이 있다. 또 콜백 헬을 잡아주고, 불필요한 await 키워드를 남용하지 않게 해주는 린트들도 유용할 것 같다. Ref https://maximorlov.com/linting-rules-for-asynchronous-code-in-javascript/ 마무리평일에는 정말정말 바빴다. 거의 야근 풀타임으로 채우지 않았을까 🤦‍♀️ 혼자 일하는 게 아니라, 기획-디자인-백엔드 팀원 분들과 함께 일하며 마주하는 여러 상황들, 특히 예외 케이스들에 대해서 미리미리 파악하고 말씀드려야겠다는 다짐을 해본다. 주말이 되며 완연한 봄날씨가 돼버렸다. 벚꽃은 만개했고, 주말 내내 나가며 봄을 만끽중이다. 분명 며칠 전까지는 그래도 밤엔 추웠는데, 이제 가장 더운 시간엔 땀까지 난다. 다이나믹 코리아의 여름이 벌써 걱정된다. 🌻","link":"/2022/04/09/2022-4-week-2/"},{"title":"4월 3주차 기록","text":"봄엔 역시 기상이변 배워가기requestAnimationFrame화면에 새로운 애니메이션을 업데이트 할때 requestAnimationFrame() 메소드를 호출하면 브라우저가 리페인트를 수행하기 전 애니메이션 함수를 실행한다. setTimeout(), setInterval()은 비동기로 처리되므로 프레임의 시작 시간을 보장할 수 없어서, 60프레임의 프레임 시간(16ms) 를 초과하여 프레임 누락 현상이 발생할 수 있다. 60프레임이라는 것은, 1초에 60회를 콜백을 수행한다는 뜻이다. 1초 즉 1000ms동안 60회 콜백이 실행된다는 것은, 콜백이 한번 실행되는 데 약 16ms(1000ms / 60)가 걸린다는 것으로 해석할 수 있다. 일반적으로 requestAnimationFrame() 함수는 초당 60프레임에 해당하는 주기로 호출되며, 대부분 브라우저에서는 현재 모니터의 출력 주기와 같게 호출된다. requestAnimationFrame() 은 60프레임을 찍어낼 여유가 생길때마다 애니메이션 코드가 실행된다. 좀 더 정확히는 60프레임이 아닌 디스플레이 주사율(Ex: 60Hz, 144Hz 등)에 맞추어서 실행하게 된다. Ref https://blog.makerjun.com/411591d9-c47b-4d8d-8f9e-1246d8dd1a2f 206 Partial CintentHTTP 206 Partial Content는 Range 헤더에 기술된 데이터 범위에 대한 요청이 성공적으로 응답되어 바디에 해당되는 데이터를 담고 있다는 것을 알려준다. 123456HTTP/1.1 206 Partial ContentDate: Wed, 15 Nov 2015 06:25:24 GMTLast-Modified: Wed, 15 Nov 2015 04:58:08 GMTContent-Range: bytes 21010-47021/47022Content-Length: 26012Content-Type: image/gif 해당 응답값을 이용하면 동영상 스트리밍을 만들 수 있다. 미리 볼 수 있는 데이터를 206을 이용해 넣어두면, &lt;video&gt; 태그가 알아서 처리해준다. Ref https://developer.mozilla.org/ko/docs/Web/HTTP/Status/206 dp: density-independent pixeldp(density-independent pixel)는 1인치당 픽셀 밀도에 따라 크기가 일관된 UI를 보여줄 수 있는 단위다. ppi(pixel per inch) - 1인치에 들어가는 px량 dp = 1px * 160 / ppi px = 1dp * ppi / 160 ex) 아이폰 11 프로에 너비 200에 알맞는 사이즈는? 200 * 458 / 160 = 572.5px 짜리 이미지 써야한다. autocomplete텍스트와 숫자를 입력할수 있는 input, texture, selects, form 요소에 autocomplete 속성을 이용하여 자동완성 기능을 사용할 수 있다. (email, username, family-name 등) 속성에 autocomplete=off를 넣어주면 브라우저의 자동완성을 금지한다. 보안상 문제로 자동완성을 사용하지 않아야 할 경우 지정할 수 있다. 하지만 대부분의 모던 브라우저에서는 autocomplete=off로 지정하더라도, 계정 이름과 비밀번호 저장 여부에 대해서는 자동완성을 막을 수 없다. 이런 경우 autocomplete=new-password 속성을 주면 새로운 비밀번호를 입력하게끔 만들어, 자동완성을 방지할 수 있다. (하지만 new-password는 safari 브라우저 에서는 아직 지원하고 있지 않다.) Fetch APIfetch()의 request body에 File 타입의 인자를 담으려고 하면 타입 에러가 난다. 1234// body 에서 타입 에러async (file: File) =&gt; { await fetch(url, { body: file }) } fetch의 body는 ArrayBuffer | ArrayBufferView | NodeJS.ReadableStream | string | RLSearchParams | FormData | undefined 타입을 가질 수 있는데, file의 경우 Blob 타입이기 때문에 해당되지 않는다. (API 명세에는 Blob/File 를 가지는 것으로 나오기 때문에 JavaScript에서는 가능하다.) 위 문제는 두 가지 방법으로 해결할 수 있다. 첫 번째는, Blob 타입인 파일을 FileReader API 를 통해 ArrayBuffer로 읽는 것이다. 123456const reader = new FileReader()reader.onloadend = async () =&gt; { const arrayBuffer = reader.result // string | ArrayBuffer | null await fetch(url, { body: arrayBuffer as string | ArrayBuffer })}reader.readAsArrayBuffer(file) 두 번째는, FormData 인터페이스를 이용하는 것이다. 1234const formData = new FormData();formData.append('files', files);fetch(url, { body: formData }); Ref https://developer.mozilla.org/ko/docs/Web/API/Fetch_API https://developer.mozilla.org/ko/docs/Web/API/FormData 딥링크 vs 모바일 딥링크딥링크와 모바일 딥링크는 다르다. 흔히 얘기하는 딥링크는 모바일 딥링크이다. 딥링크: 특정 페이지에 도달할 수 있는 링크 그냥 링크: https://www.youtube.com/ 딥링크: https://www.youtube.com/watch?v=kHvOq16eyU8 모바일 딥링크는 모바일 어플리케이션의 특정 페이지에 도달 할 수 있는 링크로, 주로 Scheme://Path 의 형태를 가진다. 웹의 프로토콜인 http:// 처럼 유튜브는 youtube://, 배민은 baemin:// 라는 프로토콜을 가지고 있다. 딥링크에는 3가지 방식이 있다 URI Schemes - iOS (iOS9 이전까지의 표준 딥링크 형식) 유니버셜링크(Universal Links) - iOS (iOS9부터 그 이후의 표준 딥링크 형식) Android App Links - AOS (유니버셜링크와 같은 방식으로 동작) 딥링크 기술의 변화 다이렉트 딥링크(Direct Deep Link) 초창기의 딥링크 형태. 앱이 설치된 유저의 경우 앱의 특정 페이지로 이동된다. 한계점: 앱이 설치되지 않은 유저의 경우 각 플랫폼의 앱스토어로 이동하며, 설치 후 앱을 열었을 때 딥링크는 유실된다. 디퍼드 딥링크(Deferred Deep Link) 다이렉트 딥링크의 한계점 극복: 설치 후 앱을 열었을 때에도 링크가 유실되지 않고 특정 컨텐츠로 이동된다. 한계점: 플랫폼(iOS, AOS)별로 각각 링크를 만들어야 한다. 원링크(One Link) 하나의 링크에서 각각의 플랫폼으로 자동 분기처리해준다. React-Native와 React의 V-DOMReact-Native는 React의 V-DOM을 기반으로 동작한다. React의 V-DOM은 성능 최적화 기능을 수행하는 것으로 많이 알려져있다. V-DOM은 또 개발자의 코드와 실제 렌더링되는 것 사이의 중간 레이어를 담당한다. 따라서, ‘실제화면에 어떻게 보여야할지에 대한 추상화의 역할’ 도 수행한다. 즉 React가 ‘개발자 코드’를 ‘V-DOM’으로 만들어 ‘웹브라우저’에 표현하는 것이라면,’React-Native’는 ‘개발자 코드’를 ‘V-DOM’으로 만들어 ‘모바일플랫폼’에 표현하는 것이다. 단, 렌더링 정보가 담긴 V-DOM에서 실제 플랫폼 인터페이스를 호출하는 브릿지는 따로 만들어야 한다. 오픈소스 등을 보면 React를 이용하여 window/우분투/VR 어플을 개발하는 경우도 있는데, 이것도 모두 누군가 V-DOM 플랫폼을 잇는 브릿지를 개발한 것이다. React에서의 XSS(cross-site-scripting)일반적으로 리액트 DOM은 jsx 내 모든 값을 렌더링 이전에 자동으로 이스케이프 하기 때문에 일반적인 공격은 작동하지 않는다. 그러나 위지윅 에디터 같은 html 문자열을 html 형태 그대로 보여줘야되는 경우 innerHTML 을 사용해야되는데, 이때 XSS 공격에 노출될 수 있다. 이때 React에서 사용할 수 있는 것이 dangerouslySetInnerHTML이다. dangerouslySetInnerHTML은 리액트에서 innerHTML 대신에 DOM에 바인딩할 수 있는 메소드로, innerHTML과 동일한 기능이지만 위험하다는 것을 상기시키기 위해 이렇게 명명했다. innerHTML 와의 차이점은 dangerouslySetInnerHTML 은 React diffing 알고리즘에서 수정된 노드를 무시하도록 설계되어 있어 해당 노드의 검사를 우회하기 때문에 성능상의 이점이 있다는 것이다. 🧼 HTML sanitizerdangerouslySetInnerHTML의 값은 jsx처럼 자동으로 이스케이프되지 않기 때문에 기본적으로 XSS 공격에 노출되어 있다. 이를 방지하기 위해 HTML sanitizer 를 통해 HTML 의 모든 위험한 부분을 제거하고 안전한 부분만 남길 수 있다. sanitizer 를 자체적으로 개발하기보다는 오래 유지되어온 DOMPurify 같은 라이브러리를 사용하거나, JavaScript의 최신 API인 Sanitizer API를 사용하나다. 12345// XSS 공격&lt;img src=&quot;nonexistent.png&quot; onerror=&quot;alert(':fire::fire::fire:');&quot; /&gt;// HTML sanitizer 적용&lt;img src=&quot;nonexistent.png&quot; /&gt; 12345// DOMPurify sanitizer 예제import DOMPurify from 'dompurify';const content = '&lt;img src=&quot;nonexistent.png&quot; onerror=&quot;alert(\\\\':fire::fire::fire:\\\\');&quot; /&gt;'return (&lt;div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(content)}}&gt;&lt;/div&gt;); 👩‍🏫 개발자가 DOMPurify 라이브러리에 의존하지 않도록 되도록 dangerouslySetInnerHTML 속성에 할당하는 기능을 캡슐화한 컴포넌트로 구성하는 것이 좋다. fast-forwarded merge vs 3-way mergefast-forwarded mergemaster 브랜치에서 분기한 bugfix 브랜치가 있다고 가정해보자. master의 이력을 전부 포함하고 있는 bugfix 브랜치를 master 브랜치로 머지하려고 했을 때, master 브랜치가 bugfix 브랜치로 이동하기만 해도 내용을 모두 적용할 수 있다. (이때, master 브랜치는 bugfix 브랜치가 분기된 후로 변경되지 않은 상태여야 한다.)이러한 머지를 fast-forwarded merge라고 한다. 3-way merge앞선 상황에서 bugfix 브랜치가 분기된 후 master 브랜치에 새로운 커밋이 추가되었을 때는 fast-forward를 할 수 없다. 그래서, master와 bugfix의 공통 조상 커밋(base)과 각 브랜치의 가장 마지막 커밋 2개를 이용하여 새로운 커밋을 만드는데 이를 3-way merge라고 한다.이때 base 커밋을 참고하면서 각 브랜치의 마지막 커밋들의 변경사항을 서로 체크하며 머지가 이루어진다. 3-way merge가 진행되었을 때는 Merge made by the 'recursive' strategy. 라는 메시지가 뜬다. TypeScript의 interface overrideA interface를 extends하는 B interface가 있을 때, A의 프로퍼티 C를 B에서 override 하고 싶다면 override하려는 타입은 C의 서브타입이어야 한다. 1234567interface A { C: number | string;}interface B extends A { C: number; // boolean 으로 override 할 수는 없다} C의 서브타입이 아닌 다른 타입으로 override하고 싶다면 Omit 등을 이용한 유틸리티 타입을 사용해야 한다. 👩‍🏫 ambient type definition (.d.ts에서 한 타입 선언)에서는 어떤 타입이던 override 할 수 있다. React-Router v6React-Router v6 에서는 usePrompt, useBlocker가 더이상 지원되지 않기 때문에 페이지 이탈시 프롬프트 창을 띄우기 위해서는 자체적으로 로직을 구현해줘야 한다. 구현하기 위해서는 history 라이브러리 인스턴스를 사용해야 하는데, history 인스턴스에 접근하려면 라우터에 이와 같은 방법으로 주입시켜주어야 한다. 12345678910111213import * as React from &quot;react&quot;;import * as ReactDOM from &quot;react-dom&quot;;import { unstable_HistoryRouter as HistoryRouter } from &quot;react-router-dom&quot;;import { createBrowserHistory } from &quot;history&quot;;const history = createBrowserHistory({ window });ReactDOM.render( &lt;HistoryRouter history={history}&gt; {/* The rest of your app goes here */} &lt;/HistoryRouter&gt;, root); 또는 UNSAFE_NavigationContext를 이용하여 전역컨텍스트로 가져올 수 있다. 1234567891011121314151617181920import { BrowserHistory } from &quot;history&quot;;import React, { useContext } from &quot;react&quot;;import { UNSAFE_NavigationContext } from &quot;react-router-dom&quot;;export default function useHistory(): string { let [state, setState] = React.useState&lt;string&gt;(window.location.pathname); // 커스텀 라우터로 래핑하거나 라우터에 history 인스턴스를 넣어주지 않고 BrowserHistory를 가져온다 const navigation = useContext(UNSAFE_NavigationContext) .navigator as BrowserHistory; React.useLayoutEffect(() =&gt; { if (navigation) { navigation.listen((locationListener) =&gt; setState(locationListener.location.pathname) ); } }, [navigation]); return state;} history.block으로 현재 페이지에서 벗어나는것 을 사전에 차단할 수는 있지만, beforeunload 핸들러를 내부에서 컨트롤하기 때문에 라우트 이동을 직접적으로 멈추게 할 수는 없는 것 같다. Ref https://reactrouter.com/docs/en/v6/api#unstable_historyrouter webpack file-loader의 context 옵션context 옵션을 제공하면, 해당 폴더를 기준으로 asset의 위치가 결정된다. 폴더 구조가 아래와 같이 되어있을 때, 12-assets-src context: &quot;src&quot;로 설정되어 있으면 asset들은 build/_/assets에 생성된다. filter 안에서 async 쓰기JavaScript의 Array.prototype.filter() 메서드에는 콜백으로 async 함수를 전달할 수 없다. forEach()와 filter() 등의 메서드는 동기적으로 동작하기 때문이다. map()과 Promise.all()을 이용해서 우회하는 방법을 사용해야 한다. 123456789101112131415const arr = [1, 2, 3, 4, 5];const asyncFilter = async (arr, predicate) =&gt; { const results = await Promise.all(arr.map(predicate)); return arr.filter((_v, index) =&gt; results[index]);}const asyncRes = await asyncFilter(arr, async (i) =&gt; { await sleep(10); return i % 2 === 0;});console.log(asyncRes);// 2,4 Ref https://stackoverflow.com/questions/47095019/how-to-use-array-prototype-filter-with-async https://advancedweb.hu/how-to-use-async-functions-with-array-filter-in-javascript/ compilerOptions target vs libtsconfig.json의 compilerOptions에는 target과 lib을 설정할 수 있다. 12345&quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;es6&quot;, &quot;dom&quot;, &quot;es2017&quot;], // ...} 둘의 차이점은 다음과 같다. target TypeScript가 JavaScript 어떤 레벨로 컴파일될지를 명시한다. ES5로 지정할 경우 다운그레이드된다. lib 프로젝트에 사용할 타입 정의들로로, 브라우저 런타임에 어떤 문법들이 사용될 수 있는지 명시한다. target을 ES6로 올리지 않으면서도 필요한 최신 문법들을 사용할 수 있다 만약 lib 항목을 정의하지 않았다면 target 항목에서 지정한 ECMAScript의 버전에 따라 기본값이 정의된다. ES5의 기본 값: dom, es5, scripthost ES6의 기본 값: dom, dom.iterable, es6, scripthost target과 lib 외에도 module이 함께 언급되는 경우가 있다. module의 경우에는 오로지 모듈 시스템을 어떤 버전으로 할 것인지만 정한다. (commonjs, ES Module 등) Ref https://www.typescriptlang.org/tsconfig#target https://norux.me/59 try~catch에 finally까지 써줘야 하는 이유123456789try { // ... setLoading(true);} catch (e) { // ... } finally { // ... setLoading(false);} 만약 finally문이 아닌 catch문에서 setLoading(false)를 해준다면, 에러가 발생하지 않아 catch문이 실행되지 않는 경우 loading은 영원히 false로 바뀌지 않을 것이기 때문이다… 이것저것 RN은 JavaScript로 작성한 코드가 native에서 사용하는 코드로 변환되는게 아니라, RN을 사용해 만든 프로젝트에 JavascriptCore라는 엔진이 탑재되어서, 우리가 작성한 JavaScript 코드들을 앱 내에서 실행시켜주는 것이다. AxiosError - axios 요청 중 발생하는 에러 타입 (config, request, response 등의 데이터를 갖고 있다.)이다. axios.isAxiosError(error) 로 AxiosError 타입인지 여부를 체크할 수 있다. ‘can’t perform a React state update on an unmounted component.’ 에러는 컴포넌트 A를 언마운트 시킨 시점에 A의 state를 변경하려고 할 때 발생한다. useEffect 콜백의 리턴문에서 cleanup 처리를 해서 해결할 수 있다. (Ref) 배포 환경에서 실제 로컬환경과 같은 의존성 설치를 위해서 package-lock.json을 원격 저장소에 반드시 push해야 한다. URLSearchParams를 활용해서 query params를 쉽게 컨트롤할 수 있다. 하지만 모던 브라우저에서만 사용이 가능하기 때문에, query-string이라는 라이브러리를 사용하기도 한다. 타입스크립트에서 타입은 값들의 집합이라고 생각하면 된다. 그래서 공집합은 never 타입이며, 따라서 never 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 없다. git은 commit, tree, blob를 .git/objects 폴더에 저장하기 때문에 git reflog를 통해 삭제된 브랜치(commit)를 복구할 수 있다. (이때 git은 항상 로컬 브랜치의 reflog만을 저장한다.) jenkins pipeline에서 agent가 any로 설정되어 있으면 이미지를 자동적으로 불러오기 때문에 node 버전이 상황에 따라 달라질 수 있다. jest에는 istanbul이 default로 탑재되어 있어, coverage reporter로 cobertura를 설정하면 diff 에서 어떤 라인이 테스트되었는지 안되었는지를 나타낼 수 있다.1npm run test:coverage -- --ci --reporters=default --reporters=jest-junit --coverageReporters=cobertura&quot; npm 커맨드에서 --ignore-scripts를 쓰면 npm scripts의 pre-, post- scripts 실행을 막을 수 있다. 1DISABLE_ESLINT_PLUGIN=true npm run build:prod --ignore-scripts # npm run prebuild 가 실행되지 않는다 type도 [key]를 활용해 객체 형식 타입의 property의 타입을 가져올 수 있다.123456type A = { a: 'hi' | 'bye'; b: number;}type B = A['a']; // 'hi' | 'bye' tsconfig에 paths alias를 설정해두면 IDE에서는 잘 동작하는 것처럼 보이지만, 실행할 때 해당 path를 못 찾을 수 있기 때문에 webpack 설정도 함께 해줘야 한다.1234567891011121314// tsconfig.json// ...&quot;paths&quot;: { &quot;~/*&quot;: [&quot;src/*&quot;] // *를 사용하려면 배열로 적어준다.}// webpack.ts&quot;resolve&quot;: { // ... alias: { '~': path.resolve(__dirname, 'src'), },}// baseUrl에 따라 다를 수 있다. GitLab CI에서는 환경 변수를 설정해줄 수 있다. 환경 변수로 설정해준 값은 빌드 로그에 노출되지 않기 때문에 Secret Key 같은 값들을 사용할 때 유용하다. GitLab Repo → Settings → CI/CD → General → Variables 에서 설정 가능하다. 중첩 setTimeout을 이용하는 방법은 지연 간격을 보장하지만 setInterval은 이를 보장하지 않는다. setInterval은 callback을 호출하는데 소모되는 시간도 포함하기 때문이다. 그래서 CPU가 과부하 상태인 경우, 브라우저 탭이 백그라운드 모드인 경우, 노트북이 배터리에 의존해서 구동 중인 경우에 시간지연에 영향을 줄 수 있다. 컨텍스트 밖에서 스타일을 제공하는 것은 지양하자. 스타일이 변경되면서 컨텍스트 전체가 새로 렌더링 되어 성능 저하를 야기할 수 있다. table의 tr에는 border 프로퍼티가 없기 때문에, td에 먹여야 한다. 컴포넌트의 Props가 빈 인터페이스라면 Record&lt;string, never&gt;를 사용할 수 있다. 기타aws의 Lambda Function URLs 공개aws에서 람다에 https 엔드포인트를 추가 할 수 있는 Lambda Function URLs를 공개했다. 드디어 엔드포인트가 필요한 간단한 웹훅이나 기능을 구현할 때 API gateway를 따로 생성할 필요가 없어졌다고 한다. Ref https://aws.amazon.com/ko/blogs/aws/announcing-aws-lambda-function-urls-built-in-https-endpoints-for-single-function-microservices/ 제품 중심으로 사고하는 소프트웨어 엔지니어 되기 프로덕트 아이디어/의견 내기에 적극적이다. 비즈니스, 유저의 행위, 데이터에 관심 가진다. 호기심, 그리고 날카롭게 “왜”라고 질문한다. 소통을 잘하며, 비개발직군과 좋은 관계를 유지한다. 프로덕트/개발의 트레이드오프를 솔직하게 말한다. 엣지케이스를 실용적으로 다룬다. 프로덕트 검증 사이클을 빠르게 돌린다. E2E 프로덕트 피처에 오너십을 가진다. 반복되는 배움의 사이클을 통해 프로덕트에 강한 영감을 얻는다. Ref https://blog.pragmaticengineer.com/the-product-minded-engineer/ CRA의 React 18 대응급하다 급해 Ref https://github.com/facebook/create-react-app/releases/tag/v5.0.1 @types/react18에서는 children을 직접 명시해라?라는 Dan 형의 트윗이다. React.FC가 불필요하며 사용을 권장하지 않는다고도 한다. Ref https://twitter.com/dan_abramov/status/1512833611401150474 facebook/lexical페이스북에서 오픈소스로 공개한 텍스트 에디터다. 오~ 뭐지. ‘Lexical is a framework’라며 뭔가 웅장하게 선보인 것 같다. Editor 인스턴스도 있고, state도 있다. 뭔가 React스럽게 만들려고 한 것 같다. 자체적인 DOM Reconciler를 가지고 성능까지 개선했다고 한다. 역시 페이스북엔 이상한 사람들이 많다… Ref https://github.com/facebook/lexical 스타트업을 떠나며 알게된 것들슬픈 이야기들이 많다. 그중에서도 ‘실패는 그다지 도움이 되지 않는다.’라는 말은, 초기 스타트업 뿐 아니라 인생에서 마주하는 여러 상황에도 들어맞는 말인 것 같다. Ref https://velog.io/@koeunyeon/스타트업을-떠나며-알게-된-것들?fbclid=IwAR3w2lk-esiRIu5Di8wIDoAEFmaturyzUcrORD_oaVZ-A73lXv_RU8molK8 마무리예상했던 것처럼 벚꽃이 지고 또 다시 기상이변이 시작되었다. 다이내믹 코리아는 지지 않아! 비도 오고 바람이 너무 심하게 불어서 추웠다. 집에만 콕 박혀있다가, 하루는 김치전에 막걸리 먹으러 나갔당. 다음주부터는 거리두기가 완전 해제된다고 한다. 다음달이면 실외 마스크도 해제될 것 같다. 언젠간 올 날이고, 그렇게 바랐던 날이지만 괜히 엄청 이상하다. 이미 몸은 10시 귀가에 맞춰져버렸고, 마스크를 벗으면 왠지 부끄러울 것 같다. 그래도 바깥 공기 아낌없이 마셔야지. 드디어 팀원 분들도 만날 수 있게 되었다. 그때까지 제발 아무 일도 일어나지 않았으면 좋겠다… 🤷‍♀️","link":"/2022/04/15/2022-4-week-3/"},{"title":"4월 4주차 기록","text":"근데 이제 여름 배워가기CSS list-style-position::marker CSS 의사요소를 요소 내부에 둘지, 외부에 둘지 정할 수 있는 속성으로, display: list-item 속성이 있는 요소에 적용된다. 1234567.element1 { list-style-position: inside;}.element2 { list-style-position: outside;} list-style-position 속성을 inside 으로 줄 경우 마커(list-style-type) 와 list-item 콘텐츠 사이 갭이 생기는데, 마커의 값이 Non-keyword(disc, circle, square 등)일 경우 간격을 직접 컨트롤 할 수 없다. 마커의 값이 keyword 인 경우 padding-inline-start 와 같은 속성으로 조절할 수 있다. 12345678li { list-style: disc inside; &amp;:before { content: ''; margin-left: -0.5em; // 마커와 콘텐츠 사이 간격을 좁힘 }} react-queryreact query 사용 시 SSR 서버에서 데이터 prefetch 후 컴포넌트에서 useQuery로 캐싱된 데이터를 가져올 때, 첫 로드 시에 저장된 캐시값이 없어 undefined가 리턴되는 경우가 있다. 이때 화면이 깜빡이는 현상이 발생한다. 이는 SSR 서버에서 fetching된 데이터가 클라이언트에 값이 저장되어있지 않아서 발생하는 문제로, react-query에서 제안하는 2가지 해결 방법이 있다. 첫 번째는 initialData를 활용하는 것이다. 1234567export async function getServerSideProps() { const posts = await getPosts() return { props: { posts } } }function Posts(props) { const { data } = useQuery('posts', getPosts, { initialData: props.posts })} 그러나 이 역시 마찬가지로 useQuery 초기 로드 시 data에 undefined가 리턴되어 해결되지 않는다. 두 번째는 서버에서의 캐싱 쿼리를 유지하기 위해 dehydrate를 활용하는 방법이다. 123456789export async function getServerSideProps() { const queryClient = new QueryClient() await queryClient.prefetchQuery('posts', getPosts) return { props: { dehydratedState: dehydrate(queryClient), }, }} 서버에서 prefetching한 정보가 클라이언트 초기 로드 시에도 캐시에 남아있게 되어, undefined가 반환되는 일 없이 올바른 data로 렌더링을 할 수 있다. 중첩조건문 가드문으로 변경하기 참인 경우와 거짓인 경우 모두 정상 동작으로 이어지는 형태라면 if/else 절을 사용한다. if절과 else절에 똑같은 무게를 두어, 코드를 읽는 이에게 양 갈래가 똑같이 중요하다는 뜻을 전달한다. 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나온다. 이 형태를 흔히 가드문(gaurd clause)이라고 한다. 중첩 조건문을 가드문으로 바꾸는 핵심은 의도를 부각하는 데 있다. 가드문은 “이건 이 함수의 핵심이 아니다. 이 일이 일어나면 무언가 조치를 취한 후 함수에서 빠져나온다“라고 이야기한다. Blob 객체Blob은 파일류의 불변하는 미가공 데이터를 나타낸다. 사용자 시스템의 파일을 지원하기 위해 Blob 인터페이스를 상속해 기능을 확장한 것이 File 객체다. Blob에서 데이터를 읽는 방법 중 하나로 FileReader를 사용할 수 있다. File 객체의 실제 데이터에 접근하는 방법 Url로 접근하는 방법 createObjectURL() - 인자로 File 객체를 받으며, 해당 파일의 고유 URL 정보를 생성하고 반환한다. revokeObjectURL() - 메모리 누수를 막기 위해 직접 해체해주어야 한다. FileReader로 접근하는 방법 FileReader.readAsDataURL() - 파일을 읽고, result 속성에 파일을 나타내는 URL을 저장한다. 비동기적으로 동작하기 때문에, 이벤트 핸들러를 등록해 사용한다. FileReader.onload - 읽기 완료 성공 시 동작 FileReader.onloadend - 성공, 실패와 무관하게 읽기 완료 시 동작 FileReader.onerror - 읽는 도중 오류 발생 시 동작 useImperativeHandleuseImperativeHandle은 ref를 사용할 때 부모 컴포넌트에 노출되는 인스턴스 값을 사용자화(customizes)한다. useImperativeHandle을 사용하여 자식 컴포넌트에서 특정 인스턴스를 만들어 부모 컴포넌트로 노출시킬 수 있다. forwardRef와 함께 사용한다. 12345678910function FancyInput(props, ref) { const inputRef = useRef(); useImperativeHandle(ref, () =&gt; ({ focus: () =&gt; { inputRef.current.focus(); } })); return &lt;input ref={inputRef} ... /&gt;;}FancyInput = forwardRef(FancyInput); 위 예시에서 &lt;FancyInput ref={inputRef} /&gt;를 렌더링한 부모 컴포넌트는 inputRef.current.focus()를 호출할 수 있습니다. Ref https://ko.reactjs.org/docs/hooks-reference.html#useimperativehandle TypeScript !TypeScript에서 !는 어설션 연산자(Non-null assertion operator), 또는 확정 할당 어설션(Definite Assignment Assertions)으로 사용된다. 어설션 연산자는 피연산자가 null이 아니라고 컴파일러에게 전달, 일시적으로 null 제약조건을 완화한다. 123function nonNullAssertionOperator(e: string | null): string { return e!; } 확정 할당 어선셜은 이 변수에는 값이 무조건 할당되어 있다고 컴파일러에게 전달, 값이 없어도 사용할 수 있게 한다. 123let notNull!: string console.log(notNull) Ref https://velog.io/@kbm940526/Typescript-Non-null-assertion-operator-and-Definite-Assignment-Assertions useInfiniteQuery hookReact Query의 useInfiniteQuery hook을 사용하면, page state를 따로 클라이언트 코드에서 관리할 필요가 없다. pageParams를 정의해놓으면, fetchNextPage()를 호출함으로써 API 호출 시 쿼리에 적절한 page 값을 삽입할 수 있다. 검색기능 등 page를 0으로 초기화해야될 경우에도, query key의 의존성 배열에 검색어를 넣으면, 검색어가 변경될 때마다 page가 0으로 초기화되고 다시 카운팅되기 시작한다. prop으로 ref 넘겨주기?부모 컴포넌트에서 자식 컴포넌트로 ref를 넘길 때, custom prop으로 넘겨주는 방법 1Component = ({ innerRef }) =&gt; &lt;button ref={innerRef} /&gt; 그리고 forwardRef를 사용하는 방법이 있다. 1Component = React.fowardRef((props, ref) =&gt; &lt;button ref={ref}/&gt;) fowardRef는 부모 컴포넌트에서 input, form 등을 다루는 비제어 컴포넌트에 접근하기 위해 나온 것이다. 따라서 명시적으로 비제어 컴포넌트를 다룰 때에는 forwardRef를, 일반 제어 컴포넌트(함수 컴포넌트)를 다룰 때에는 prop으로 구분지어 다뤄주는 것이 좋다. DOMPurifyXXS 공격을 방지하기 위해 HTML string에서 위험성 있는 코드를 제거하는 도구를 sanitizer라고한다. 1DOMPurify.sanitizer(`&lt;p&gt;sample&lt;/p&gt;&lt;script&gt;alert('XSS공격')&lt;/script&gt;`); 위 코드의 실행 결과는 &lt;p&gt;sample&lt;/p&gt;가 된다. 위험성 있는 script 태그를 삭제해준 것이다. innerHTML 대신 리액트의 dangerouslySetInnerHTML을 사용하고, DOMPurify.sanitizer를 거친 문자열을 넣으면 조금 더 안전하게 코드를 작성할 수 있다. 서버사이드에서 사용하기 위한 isomorphic-dompurify라는 라이브러리도 있다. next를 사용한다면 서버에서 sanitizer를 한 문자열을 클라이언트에 전달해주는 방법도 좋다. Dialog vs Toast vs Snackbar Dialog 적은 양의 정보와 액션버튼으로 구성된다. 이용자로부터 즉각적인 응답이 필요한 경우 적합하다. Dialog는 백드롭을 깔아서 다른 동작을 아예 막아버린다는 점이 다른 두 개, 특히 Snackbar와 다르다. 나만 보게 만드는 UX 패턴을 “모달리티“(modality)라고 한다. Toast 동작에 대한 간단한 피드백을 텍스트 형태로 제공하는 것이다. 이용자를 방해하지 않고 메시지를 표시하고 시간이 지나면 자동으로 사라진다. 간단하고 단순한 정보를 보여주는 데 적합하다. Snackbar 메시지를 통해 작업에 대한 간단한 피드백을 제공한다. 이용자를 방해하지 않고, 시간이 지나면 자동으로 사라진다는 점에서 Toast와 비슷하다. 단일 텍스트 액션을 통해 이용자와 상호작용을 할 수 있다. 즉, Dialog보다 이용자에게 주는 영향은 적고, Toast보다는 더 커스텀하게 이용할 수 있는 것이 Snackbar이다. Dialog와 Toast 그 사이의 모든 경우에는 Snackbar를 이용하기 적합하다. Ref https://brunch.co.kr/@oemilk/91 getServerSideProps의 props가 undefined일 때Next.js의 getServerSideProps에서 props 의 값으로 undefined가 있으면 JSON으로 직렬화되지 않아 에러가 발생할 수 있다. React Query의 prefetchInfiniteQuery를 사용할 경우 이전 페이지가 없기 때문에 pageParams는 0이 아닌 undefined로 던져진다. 이 영향으로 dehydrate(queryClient)의 결과물에 undefined가 포함되고, 이를 props로 넘기려 할 때 Next.js에서 undefined를 직렬화하지 못해 에러가 발생한다. 이때는 stringify와 serialize 작업을 통해 undefined를 제거한 데이터를 props로 넘겨줘야 한다. 1234567891011export const getServerSideProps: GetServerSideProps = async () =&gt; { const queryClient = new QueryClient(); await queryClient.prefetchInfiniteQuery(...); return { props: { // pageParams 가 undefined로 정의될 때, undefined를 제거하기 위한 작업 dehydratedState: JSON.parse(JSON.stringify(dehydrate(queryClient))), }, }} event.nativeEvent.pathevent.nativeEvent.path로 이벤트 전파 순서를 확인할 수 있다. 이때 z-index도 이벤트 전파 순서에 영향을 준다. button &gt; div &gt; label &gt; input(display: none)의 순서로 엘리먼트 계층이 구성되어 있을 때, button에서 발생한 이벤트가 div에 막혀 label까지 도달하지 못하는 경우가 있다. 이때 div보다 label의 z-index를 더 높게하면 button의 이벤트가 label까지 도달한다. 참고: interactive content유저 인터랙션을 위해 만들어진 컨텐츠로, a, button, input 등이 이에 속한다. Ref https://html.spec.whatwg.org/#interactive-content npm ci vs npm installnpm install이 실행되면 패키지를 설치할 때 package.json을 읽고 package-lock.json 파일도 업데이트한다. 이는 package.json과 package-lock.json을 수정할 수 있다는 것을 의미한다. 반면에 npm ci는 package-lock.json을 기반으로 패키지를 설치하며, 파일들을 수정하지 않는다. 만약에 node_modules가 존재하면 먼저 삭제한 뒤에 패키지를 설치한다.(ci 는 clean install의 줄임말이다.) 크롬의 audio 자동플레이 정책크롬 뿐만 아니라 많은 웹브라우저들에는 비디오 및 오디오 자동 플레이 제한이 있다. 이는 사용자들이 인지 못한 채 소리가 나거나 동영상이 재생되는 경우를 막기 위함이다. audio가 자동플레이되려면 어떻게 해야 할까? 유저 입장에서, 음소거 상태이거나 음량이 0이 아니어야 한다. 유저가 확실히 의도를 가지고 재생을 시켜야 한다. (ex. 버튼 클릭, 탭) 모바일에서는 홈화면에 추가, 데스크탑에서는 PWA가 설치되어야 한다. 미디어 참여지수가 높아야 한다. (얼마나 사용자가 컨텐츠를 오래/자주 사용하는가의 비율) audio 자동플레이를 위해 공식 문서에서 권장되는 방법은 audio 재생 실패시 audio를 재생하는 버튼을 띄우는 것이다. ex) 주문접수페이지에서 소리 알람이 실패하면 새로운 주문이 왔습니다!와 같은 다이얼로그를 띄우고, 해당 다이얼로그에서 ‘확인’을 눌러야 소리가 재생되게끔 하는 방법이다. Ref https://developer.chrome.com/blog/autoplay/ getDerivedStateFromPropsgetDerivedStateFromProps는 최초 마운트 시와 갱신 시 모두에서 render 메서드를 호출하기 직전에 호출된다. state를 갱신하기 위한 객체를 반환하거나, null을 반환하여 아무 것도 갱신하지 않을 수 있다. props 로 받아온 값을 state 에 넣어주고 싶을 때 사용한다. 1234567static getDerivedStateFromProps(nextProps, prevState) { console.log(&quot;getDerivedStateFromProps&quot;); if (nextProps.color !== prevState.color) { return { color: nextProps.color }; } return null;} 그러나 state를 끌어오면 코드가 장황해지고, 이로 인하여 컴포넌트를 이해하기 어려워진다. React 팀에서 제안하는 대안들은 다음과 같다. props 변화에 대응한 부수 효과를 발생시켜야 한다면 (예를 들어, 데이터 가져오기 또는 애니메이션), componentDidUpdate 생명주기를 대신해서 사용한다. props가 변화했을 때에만 일부 데이터를 다시 계산 하고 싶다면, Memoization Helper를 대신해서 사용한다. props가 변화할 때에 일부 state를 재설정 하고 싶다면, 완전 제어 컴포넌트 또는 key를 사용하는 완전 비제어 컴포넌트로 만들어서 사용한다. Ref https://ko.reactjs.org/docs/react-component.html#static-getderivedstatefromprops https://react.vlpt.us/basic/25-lifecycle.html 비밀번호 변경을 90일 주기로 요구하는 이유OWASP(The Open Web Application Security Project)가 처음 주장했던 내용으로, 옛날에 평균적으로 암호를 뚫는 데 90일정도 소요되었기 때문에 생긴 기준이다. 그러나 최근에는 90일 기준이 전혀 도움이 되지 않는 구시대적 기준이라는 반대 진영도 있다. 해당 기준이 오늘날의 암호 추측 방해에 전혀 도움이 되지 않으며, 어차피 바꿔봤자 맨 뒤 1을 2로 바꿀 뿐이라는 것을 모두 알고 있기 때문이다! Ref https://www.sans.org/blog/time-for-password-expiration-to-die/ 리그레이션 확인테스팅(Confirmation Testing) (동의어: Re-Testing; 재테스팅) 결함이 발견되고 수정된 후에 원래의 결함이 성공적으로 제거되었는지 확인하기 위해 다시 테스트 하는 것 리그레이션 테스팅(Regression Testing) 이미 테스트된 프로그램의 테스팅을 반복하는 것 결함 수정 이후 변경의 결과로 도입되었거나 발견되지 않았던 또다른 결함을 발견할 수 있다. 결함은 테스트 중인 소프트웨어에 존재하거나 다른 관련이 있는 또는 전혀 관련이 없는 소프트웨어 컴포넌트에 존재할 수 있다. 소프트웨어 또는 환경이 변경되면 리그레이션 테스팅을 수행해야 한다. Ref https://cin-dy.tistory.com/33 이것저것 a 태그의 href 속성은 hypertext reference의 약자다. ([에이치 레프]라고 읽는다.) 무한스크롤로 구현된 페이지의 경우 추가된 내용만큼의 DOM 노드가 생기기 때문에, 노드가 생길수록 렌더링 시간도 선형적으로 증가하게 된다. 사용자가 보고 있는 부분에서 노출되고 있는 DOM 노드만 그려줌으로써 이런 경우를 해결할 수 있는데, 이를 ‘가상화’라고 한다. react-virtualized, react-window 등 가상화 라이브러리를 활용하면 무한 스크롤 시 발생하는 DOM 과부하를 방지할 수 있다. useEffect의 cleanup 함수는 컴포넌트가 마운트 해제되는 때 뿐 아니라 컴포넌트가 렌더링이 실행될 때마다 실행된다. React가 다음 차례의 effect를 실행하기 전에 이전의 렌더링에서 파생된 effect를 정리하는 이유가 바로 이 때문이다. (Ref1, Ref2) git switch c [브랜치명] - git checkout -b와 같이 새로운 브랜치를 만들고 해당 브랜치로 이동한다. 스키마를 만든다는 건 어떤 알 수 없는 타입의 값과 대조를 해보겠다는 선언이다. 주로 런타임에 들어올 API 응답값과의 대조를 의미한다. assertion에 사용하지 않는다면 interface/type으로 선언하는 것이 좋다. &lt;input type=&quot;file&quot;/&gt; 에서 파일 확장자 제한하는 방법 이미지만 받기 &quot;accept=&quot;image/*&quot; json만 받기 &quot;accept=&quot;application/JSON&quot; @types/react 18ver에서 React.VFC가 deprecated되었다. 때문에 children이 필요하다면 VFC가 나오기 이전처럼 FC&lt;PropsWithChildren&lt;Props&gt;&gt;로 타입을 선언해줘야 한다. .git/hooks/prepare-commit-msg로 커밋메세지를 원하는대로 작성할 수 있다. (Ref 인덱스 시그니처를 사용할 때, key 값의 의미를 명확하게 담아내면 좋다.12345// Bad{ [key: string]: DisplayedProduct }// Good{ [productId: string]: DisplayedProduct } Node.js 18 버전에서는 fetch와 test가 도입되었다. PC의 mouseEnter(), mouseLeave() 이벤트에 대응되는 모바일 이벤트는 onTouchStart(), onTouchEnd()다. JavaScript에서 객체가 비었는지 확인하는 방법1Object.keys(obj).length === 0 &amp;&amp; obj.constructor === Object 기타React Hook Quiz여기서 풀어볼 수 있다. 역시 난 쪼렙이었다. Node.js 18다음 피쳐들이 새롭게 포함되었다! 원래 없었다니. ㅋㅋㅋ fetch (experimental) Web Streams API (experimental) 기타 Global API Blob BroadcastChannel Test runner module (experimental) 새로운 API 말고도 향상된 부분들이 많다. Toolchain and Compiler Upgrades Build-time user-land snapshot (experimental) Ref https://nodejs.org/en/blog/announcements/v18-release-announce/ 마무리무사히 팀원 분들을 만났다! 모두 오랜만의 외출(?)에 차려입은 모습들을 보니 느낌이 새삼 달랐다. 주 1~2회 정도는 사무실 나가는 것도 좋을 것 같다. 그래서 집 와서 노트북 들고다닐 가방을 새로 장만했다. 사무실에 둘 키보드도 새로 샀다. (???) QA는 아직도 끝나지 않는다. QA해주시는 분들 정말 대단한 것 같다. 어떻게 그런 것까지 잡아내는지… 여기저기 급하게 고치면서 또 다른 버그들을 남겨두는 것 같아서 죄송하다 ㅠ 다음주에 무사히 배포가 나가면 좋겠다. 주말에는 서울숲에 다녀왔다. 섬세이 테라리움이라는 체험전시도 갔다왔다. 와! 사람 진짜 많았다. 무슨 퇴근시간 강남만큼 많았다. 서울숲엔 튤립도 폈는데, 사실 슬슬 지고 있었다. 튤립은 원래 5월에 핀다는데, 진짜 기상이변이다. 벌써 덥다. 막 아주 더운 건 아닌데, 이번 여름 큰일났구나, 느껴진다.","link":"/2022/04/24/2022-4-week-4/"},{"title":"4월 5주차 기록","text":"공포의 배포 주간 배워가기캐시의 생명주기브라우저는 요청을 보내는 URL에 직접 리소스를 요청하기 전에, 메모리에 동일한 URL에 해당하는 리소스가 캐시되어있는지 먼저 확인한다. 이때, 배포 시 요청할 파일 뒤에 해시값을 붙여 넣으면 최초 실행시 해당 해시값과 일치하는 캐시를 찾지못해 서버에 다시 리소스 요청을 보내게 된다. ex) 처음 버전에서 .../a.png?v=1 파일을 요청하다가 새로운 버전에서 .../a.png?v=2로 요청한다면 해당 URL에 해당하는 파일이 캐싱되어있지 않다고 판단하여 서버에 다시 리소스를 요청한다. 메모리에 리소스가 있으면 캐시의 유효성을 확인한다. 캐시가 유효하다면, 서버에 추가 요청을 보내지 않고 해당 리소스를 사용한다. 그렇기 때문에 서버에서 CDN Invalidation 등의 작업이 있더라도 유효한 캐시를 지우기는 어렵다. 다만 캐시의 유효기간이 지났다고 해서 캐시가 완전히 사라지는 것은 아니고, 서버에 조건부 요청을 통해 캐시가 여전히 유효한지 재검증을 수행할 수 있다. 재검증 결과 브라우저가 갖고 있는 캐시가 유효하다면 서버는 304요청 을 내려준다. 해당 응답은 HTTP 본문을 포함하지 않기 때문에 매우 빠르게 내려받을 수 있다. 재검증 결과 캐시가 유요하지 않으면 서버는 적합한 상태코드와 함께 본문을 내려준다. no-cache vs no-store no-cache 캐시를 저장은 하지만, 사용할 때마다 서버에 재검증 요청을 보낸다. max-age=0과 동일하다. no-store 캐시를 저장조차 하지 않는다. 캐시를 해서는 안되는 리소스일 때 사용한다. max-age / s-maxage max-age Cache-Control의 헤더 값으로 max-age=&lt;seconds&gt;를 지정하면 해당 초만큼 캐시가 유효해진다. Expires 헤더로 캐시 만료 시간을 정확히 지정할 수도 있다. s-maxage CDN같은 중간 서버에만 적용되는 max-age 값을 설정하기 위해 사용된다. TypeScript의 타입 공변성TypeScript는 선언된 함수의 타입보다 매개변수의 개수가 더 적은 함수도 할당이 될 수 있도록 설계되어 있다. 예를 들어, JavaScript Array의 내장 메서드인 forEach의 콜백 함수에는 currentValue, index, array 총 3개의 인자를 넘겨주게 되어있다. 1arr.forEach(callback(currentvalue[, index[, array]])[, thisArg]) TypeScript에서 forEach 메서드를 사용할 때, 항상 3가지 인자를 명시해야 하는 번거로움이 있어, 일부 인자를 생략해도 되도록 설계했다고 한다. 이는 TypeScript의 공변성(convariance) 와도 관계가 있다. (사실 이 블로그에서 공변성에 대한 주제를 몇 번이나 다뤘는데, 접할 때마다 헷갈리긴 한다…) 1234let array: Array&lt;string | number&gt; = [];let stringArray: Array&lt;string&gt; = [];array = stringArray; // ✅ OKstringArray = array; // 🚨 Error 위 예제에서, array에 stringArray를 할당하는 것은 가능하다. 그러나 stringArray에 array를 할당하는 것은 불가하다. string | number는 string을 포함하고 있으나, string은 string | number를 포함하지 않는다. string이 string | number의 서브타입이기 때문에, array에 stringArray를 할당하는 것만 가능하다. 이처럼 A ➡️ B일 때, X&lt;A&gt; ➡️ X&lt;B&gt;의 관계라면 X는 공변 타입이다. 함수에서는 어떨까? 123456789type Logger&lt;T&gt; = (param: T) =&gt; void;let log: Logger&lt;string | number&gt; = (param) =&gt; { console.log(param);};let logNumber: Logger&lt;number&gt; = (param) =&gt; { console.log(param);};log = logNumber; // 🚨 ErrorlogNumber = log; // ✅ OK 위 예제는 Array의 예제와는 정확히 반대로 동작한다. logNumber에 log를 할당할 수는 있지만, 반대로 log에 logNumber를 할당할 수 없다. number가 sring | number의 서브타입임에도 불구하고, Logger&lt;string | number&gt;가 오히려 Logger&lt;number&gt;의 서브타입이 되는 셈이다. 이처럼 A ➡️ B일 때, X&lt;B&gt; ➡️ X&lt;A&gt;의 관계라면 X는 반공변 타입이다. TypeScript에서 제공한 타입을 매개변수로 사용하는 함수 타입은 반변한다. 1type NumberParser&lt;T&gt; = (v: T) =&gt; number 따라서 앞서 설명했던 것처럼, forEach의 콜백에 모든 인자를 넣지 않도 정상적으로 동작한다. Ref https://seob.dev/posts/공변성이란-무엇인가/ https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach useState lazy initializationuseState에 직접적인 값 대신에 함수를 넘기는 것을 게으른 초기화(Lazy initial state) 라고 한다. 넘긴 함수는 넘기면 첫 렌더링 시에만 실행되고, 리렌더링 시에는 무시된다. 초기값이 복잡한 연산을 요할 때 사용하면 유용하다. 1234const [state, setState] = useState(() =&gt; { const initialState = someExpensiveComputation(props); return initialState;}); Refhttps://reactjs.org/docs/hooks-reference.html#lazy-initial-statehttps://yceffort.kr/2020/10/IIFE-on-use-state-of-react React ComponentProps리액트에서 특정 컴포넌트 A를 서로 다른위치에 여러번 사용할 때 코드간 중복을 피하기위해 HOC 로 전환해서 사용할 때가 종종 있다. 이 때 A 의 props 타입 인터페이스를 명시적으로 정의하는 대신에 ComponentProps 를 사용하여 정의할 수 있다. 123const HOC = (props: React.ComponentProps&lt;typeof AtomicComponent&gt;) =&gt; { &lt;AtomicComponent {...props} /&gt;}; 함수형 컴포넌트 vs 함수 컴포넌트함수형 컴포넌트(Functional Component) 와 함수 컴포넌트(Function Component) 중 무엇이 옳은 말일까? React에서는 처음에 Functional Component라는 네이밍을 사용하다가 “함수형 컴포넌트를 사용하면 함수형 프로그래밍 방법으로 개발하는 것”이라는 오해의 소지가 생길 수 있는 여지가 생김에 따라 Functional Component란 네이밍이 1년 가량 유지되다가 Function Component로 이름이 바뀌게 되었다. 👩‍🏫 결론 함수형 컴포넌트는 함수형 프로그래밍이라는 오해의 소지를 만들 수 있기 때문에 함수 컴포넌트 (Function Component) 라는 네이밍을 사용하는 것이 좋다. Ref https://velog.io/@nsunny0908/함수-컴포넌트와-함수형-컴포넌트가-같은-말이라고-생각하시나요 CSS animation-fill-modecss animation의 animation-fill-mode 속성은 애니메이션의 시작 또는 끝 상태를 계속 유지하고자 할 때 사용한다. 예를 들어, 어떤 요소에 대하여 from transform(20, 20) to transform(50, 50) 으로 애니메이션을 주고 싶다고 하자. animation-fill-mode 속성을 주지 않는다면 해당 요소는 transform(0, 0) 상태 깜빡거리면서 (20, 20)으로 바뀜 (50, 50)으로 바뀜 다시 (0, 0)으로 돌아옴 위 순서로 바뀔 것이다. animation-fill-mode의 값에 따라 요소의 상태가 어떻게 변하는지 살펴보자. animation-fill-mode: forwards - 애니메이션의 마지막 상태를 유지할 수 있다. 즉 애니메이션이 끝난 후 마지막 transform(50, 50) 상태가 유지된다. animation-fill-mode: backwards - 요소 즉시 애니메이션의 첫 상태를 적용할 수 있다. 즉 요소는 처음부터 transform(20, 20) 상태를 가지게 된다. animation-fill-mode: both - 애니메이션의 첫 상태와 마지막 상태를 모두 유지한다. node.js의 http(s) 기능node에서는 기본으로 제공되는 모듈인 http(s)를 활용해 GET 요청을 할 수 있다. 이때 콜백 함수의 param으로 요청의 response가 들어오고, 데이터는 여러 chunk 파일로 나뉘어져서 전송된다. (아마 전송되는 데이터가 세그먼트 단위로 나뉘어져서 전달되기 때문에 그런 것 같다.) chunk 데이터는 toString('utf8')을 통해 우리가 알아볼 수 있는 일반 문자열로 변환시킬 수 있다. 123456789101112https.get(url, (res) =&gt; { let fullChunk = ''; // 청크 데이터가 여러 번에 걸쳐서 들어온다 res.on('data', (chunk) =&gt; { fullChunk += chunk; }) res.on('end', () =&gt; { const data = fullChunk.toString('utf8'); const jsonData = JSON.parse(data); }) enum 권한 열거형의 형태enum의 권한 열거형에는 주로 0,1,2,4,8과 같은 2진수가 사용된다. 이는 비트 플래그를 효율적으로 활용하기 위한 방법이다. 메모리의 최소 크기 단위는 1byte(8bit) 이상이다. 8비트는 8가지 상태를 저장할 수 있기 때문에, 비트 플래그를 잘 활용하면 1바이트를 사용해서 1가지 상태만 저장하는 bool 자료형보다 훨씬 효율적으로 사용할 수 있다. 아래의 예시에서 바이트의 개별 비트를 비트 플래그라고 한다. 123456enum Permissions { None = 0, Read = 1, Write = 2, Delete = 4} 1234567Permissions.Read === 1 === 00000001Permissions.Write === 2 === 00000010Permissions.Delete === 4 === 00000100ReadAndWritePermission = Permissions.Read | Permissions.WriteReadAndWritePermission === 00000011 (read &amp; write 권한) 위처럼 권한과 관련해서 1byte로 다양한 경우의 수를 처리할 수 있기 때문에 enum의 값에는 0,1,2,4,8 … 의 형태가 많이 사용한다. 쿠키와 SameSite서버의 응답헤더 set-cookie 값에 Domain이 설정된 경우 해당 도메인을 대상으로 한 요청에만 쿠키가 전송된다. 1set-cookie: foo=bar; Domain=localhost 하지만 쿠키에 별도로 설정을 하지 않는다면 크롬(samesite=lax)을 제외한 브라우저들은 모든 HTTP 요청에 대해 쿠키를 전송하게 되는데, 이때 사용자가 접속한 페이지와 다른 도메인으로 전송하는 쿠키인 서드 파티 쿠키를 이용해서 csrf 와 같은 공격에 노출될 수 있다. SameSite 쿠키는 서드파티 쿠키의 보안적 문제를 해결하기 위해 존재한다. 크로스사이트로 전송하는 요청의 경우 쿠키의 전송에 제한을 건다. SameSite에 들어갈 수 있는 구체적인 값은 다음과 같다. None - SameSite를 설정하지 않았을 때와 같은 값이며, 크로스 사이트 요청의 경우에도 항상 전송된다. 즉 서드파티 쿠키도 전송된다. 크롬의 경우 SameSite = None을 설정하려면 Secure(https가 적용된 요청에만 쿠키가 전송되는 옵션)를 추가해줘야한다. Strict - 크로스 사이트 요청에는 전송되지 않고 동일 도메인일 경우에만 전송된다. (퍼스트 파티 쿠키일 때에만 전송) Lax - Strict에 비해 상대적으로 완화된 정책으로 대체로 서드파티 쿠키는 전송되지 않지만 몇가지 예외적인 요청에는 전송된다. Top Level NavigationTop Level Navigation은 &lt;a&gt; 앵커 태그를 클릭하거나, window.location.replace 등의 동작을 통해 자동으로 이뤄지는 이동을 의미한다. 302 리다이렉트를 이용한 이동도 포함한다. &lt;iframe&gt;이나 &lt;img&gt;는 navigation이라 할 수 없으며, &lt;iframe&gt; 안에서의 페이지 이동도 역시 top level이라 할 수 없기 때문에 SameSite = Lax일 때 쿠키가 전송되지 않는다. 클래스 컴포넌트에 custom hook 적용하기…이런 걸 해내는 사람이 있다. 그 사람이 내 친구이자 동료라니 useToast라는 custom hook을 만들고, 아래와 같은 클래스 컴포넌트가 있다고 하자. 12345678910111213export type Props = ReturnType&lt;typeof useToast&gt;; class ToastProvider extends React.Component&lt;React.PropsWithChildren&lt;Props&gt;&gt; { render() { const { children, title, text, theme, isVisible } = this.props; return ( &lt;&gt; &lt;ToastBase title={title} text={text} theme={theme} isVisible={isVisible} /&gt; {children} &lt;/&gt; ); }} 여기서 wrapper HoC로 클래스 컴포넌트를 감싸는 형태다. 1234567const withHasMounted = (Comp: React.ComponentClass&lt;React.PropsWithChildren&lt;Props&gt;&gt;) =&gt; { return ({ ...props }) =&gt; { return &lt;Comp {...useToast()} {...props} /&gt;; }; }; export default withHasMounted(ToastProvider); withHasMounted 함수는 리턴값으로 함수 컴포넌트를 가지는 함수를 반환한다. 클래스 컴포넌트에서 직접 hook을 사용할 수 없으므로, HoC에서 hook을 사용하고, hook의 반환 결과를 클래스 컴포넌트에 넘겨주는 것이다. 생각만 해봤지만… 직접 만든 것을 보니 괜찮은 것 같기도… 👀 Ref https://zereight.tistory.com/1175 react-query의 isLoading vs isFetchingreact-query에는 isLoading, isFetching 두 가지의 boolean 값이 있는데, 이 두 값에는 차이가 존재한다. isLoading - 사전에 데이터가 없을 때, 값을 불러올 당시에 true로 변경된다. isFetching - 데이터 요청 작업이 있기만 하면, true로 변경된다. refetch() - 이미 데이터가 있는 경우이기 때문에 query는 success 상태다. 따라서 refetch의 경우 isLoading의 값은 true로 변경되지 않는다. stale-while-revalidate 의 원리다. CSS appearance 속성얼마나 생소하면… 검색하면 MDN보다 블로그가 먼저 나온다~!! 운영체제 및 브라우저에 기본적으로 설정되어 있는 UI Control의 native appearance를 바꾸기 위한 속성이다. 12345div { appearance: button; -moz-appearance: button; /* Firefox */ -webkit-appearance: button; /* Safari and Chrome */ } 아래 케이스들에서 사용할 수 있다. iOS의 폼 요소들에 부여되어 있는 둥근 테두리값이나 그림자 효과를 제거할 때 webkit 계열의 브라우저의 type=&quot;search&quot; 필드의 둥근 테두리 값이나 reset 효과를 나타내는 버튼을 삭제하고 싶을 때 select 필드의 기본 화살표 모양을 삭제하거나 대체할 때 Ref https://developer.mozilla.org/en-US/docs/Web/CSS/appearance https://webdir.tistory.com/430 🚨 property does not exist in type union12const conditional = true;const value = conditional ? p.payload.value : p.value; 위 코드에서 property does not exist in type union 에러가 발생할 때는, 객체 프로퍼티의 소유 여부로 검사해주면 된다~! 1const value = 'payload' in p ? p.payload.value : p.value; 모바일 디바이스 픽셀은 어려워픽셀에는 물리 픽셀 과 논리 픽셀 이 있다. 모바일 디바이스는 물리적 해상도와 논리적 해상도가 다르다. 이는 모바일 프로덕트를 벡터 기반 프로그램으로 사용해야 하는 근거가 된다. 🌻 물리적(Physical) 해상도물리 픽셀 = 디바이스 픽셀로, 단말이 실제로 표현할 수 있는 물리적인 화소 기본 단위를 가리킨다. 예) 사진 기본 크기 🌻 논리적(Logical) 해상도논리 픽셀 = CSS 픽셀로, 디바이스 픽셀과 무관하게 HTML/CSS에서 논리적으로 표현할 수 있는 화소 기본 단위를 가리킨다. 예) 사진 출력 크기 프론트엔드 개발자의 고충을 덜기 위해, 디바이스의 픽셀을 확인할 수 있는 사이트가 있다. (그러나 실제 고충이 덜어진 건진 모르겠다.) 사실 아티클을 읽어봐도 무슨 말인지 잘 모르겠다. 역시 그때그때 대응법이 최고다. Ref https://velog.io/@productuidev/%ED%95%B4%EC%83%81%EB%8F%84] 이것저것 parameter vs argument parameter: 함수를 정의할 때 전달 받을 매개변수 argument: 함수를 호출할 때 입력하는 전달인자 nodejs 의 경우 버전에 따른 성능차도 존재하기 때문에 해당 결과를 맹목적으로 신뢰할 수는 없다. 단일 내장함수, prototype 메소드 뿐 아니라 종종 쓰이는 로직에 대해(배열 중복체크 등) 코드를 모두 작성하고 커밋하기 전에 한번은 비슷한 로직과의 퍼포먼스는 어떤지 확인하는 것이 나중에 같은 상황에서의 효율적인 코드 선택이 가능하다. 드래그가 안된다면 상위 컴포넌트 스타일에 `user-select: none이 걸려있지 않은지 확인해보자. 배열 타입의 요소 타입을 알아올 때 a[0] 대신 a[number]를 사용해도 된다. 클립보드에 복사하기 기능 Clipboard.writeText() web API를 사용한다. ex) navigator.clipboard.writeText(message) SAP 시스템이란, 비즈니스 프로세스를 위한 포괄적인 솔루션으로, 회계 및 재무 결산을 위한 용도로 사용되는 시스템이다. ad-hoc 테스트란 비공식적이고, 자의적이고 임의적인 테스트를 의미한다. 실제 업무에서 설계한 TC를 모두 마친 후, 말그대로 예상 결과를 정의하지 않고 테스트를 하다보면 소프트웨어의 특성상 결함이 발생할 수도 있다. (Ref) 기타m1 맥북의 고성능 모드m1 맥북에서는 고성능 모드를 켤 수 있다. MeasureThat.netMeasureThat.net은, JavaScript 코드 성능을 온라인으로 측정할수 있는 벤치마크 툴이다. prototype 메소드 중에서 어떤 메소드가 효율적인지 빠르게 확인하기 위해서 사용할 수 있다. ex) Array.prototype → indexOf vs includes vs some State of frontend 2022원래 UI가 이랬나? 🤔 낯설다. 그리고 결정적으로, 재미가 없어졌다! 그냥 블로그 형식의 줄글들만… 🤮 Ref https://tsh.io/state-of-frontend/?utm_campaign=SOFE2022&amp;utm_content=205764693&amp;utm_medium=social&amp;utm_source=twitter&amp;hss_channel=tw-1672399308 npm을 효율적으로 사용하기 위한구글에서 새로 개발한 wireit이라는 도구다. 로고가 힙하다. 세상이 발전하는구나. 근데… [와이레]라고 읽는 건가…? 와이라노… 와이라노… 아래 feature들을 자랑하고 싶다고 한다. 기존에 알고 있는 npm run 명령어를 사용할 수 있다. npm scripts들 사이의 의존성을 자동으로 병렬적으로 실행해준다. 모든 script를 watch하며, 변화가 발생했을 때 지속적으로 재실행(re-run)한다. 이미 최신 상태의 scripts는 스킵한다. 로컬과 github에서 모두 cache 결과를 확인할 수 있다 (무료로!) 단일 패키지, npm 워크스페이스, 그리고 다른 monorepo들과 함께 잘 동작한다. Ref https://github.com/google/wireit Google I/O오~ 왠지 구글에서 하는 건 다 간지나 보인다. 문화 사대주의 Ref https://io.google/2022/ 마무리주말에 놀고 와서 써야징 놀고..와서.. 인생이 뜻대로 되는 일은 없다. 거의 없다!3년 전에 두 번 다쳐서 반깁스까지 했던 발목을 기어코 또 다치고 말았다~! 언제 또 다치나 했드만 바로 이번에! 🤩 주말이라 병원도 못가고… 셀프로 붕대 툴툴 감고 쓰레빠 끌고 스터디 첫 모임 다녀왔다 ㅎㅎ 다치는 데 능숙해버린 스물 여섯살. 그리고 주말에 다시는 드라이브를 가지 않을 것 같다~! 1시간 반 거리를 3시간, 4시간 걸려서 왔당 ㅎㅎ 왕복 140km를 7시간 동안 달렸다고 하면 누가 믿으리오… 시위까지 겹쳐서 교통 통제 당하고 해탈해서 중간에 길도 잘못 들어서 울 뻔했지만 ‘나는 개짱쎈 어른이다’라고 맘을 다잡으며 다친 발을 이끌고 무사히 귀가했다… 남자친구는 그래도 왼발을 다쳐서 다행이라며 (운전은 오른발로 하니까) 🙄 벌써 까마득해져버렸지만, 공포의 새벽 배포가 있었다. 서비스를 하는 개발자의 숙명인가보다. 프론트 개발자는 조금 덜하긴 하겠지만, 그래도 정말 오랜만에 야식까지 먹고 뺨 때리며 대기탔다. 새벽에 다같이 잠긴 목소리로 대화하는 경험도 (가끔은) 추억일 것 같다. 건강 쪼렙이의 바이오리듬이 대붕괴될 것이라고 생각했으나, 대충 자고 다음날 꽤나 멀쩡했다. 꾸준한 운동으로 체력이 정말 나아진건가? 그치만 이런 긍정적 신호를 세상이 두고볼 리가 없지. 다시 발목 안녕~","link":"/2022/04/29/2022-4-week-5/"},{"title":"5월 2주차 기록","text":"양평같은 방 아니고 진짜 양평 배워가기워룸, WBS, 간트차트 워룸(War Room) 전쟁이 벌어졌을 때, 지휘관과 참모들이 모여 전쟁 상황을 한눈에 파악하고 작전을 세우는 곳이라는 의미다. 긴급한 일이나 위기 상황에 대처하기 위하여 마련한 상황실을 비유적으로 이르는 말. * 작전실, 전시 작전상황실, 종합상황실으로도 불린다. WBS 업무 분류 체계(Work breakdown structure)는 종속 관계를 바탕으로 프로젝트 결과물이 나오기까지의 단계를 여러 계층으로 나눠 시각적으로 분류한 것이다. 즉, 프로젝트를 진행하기 위해(또는 결과를 위해) 필요한 정보들을 파악할 수 있도록 하는 딜리버러블 지향(결과물을 도출할 수 있도록 하는) 분업 구조를 의미한다. 칸반보드, 타임라인, 간트 차트, 캘린더 등 특정한 수단을 활용하여 시각적으로 나타낼 수 있다. 간트차트 프로젝트 일정 추적관리를 위해 사용하는 도구로서, 각 업무별로 걸리는 시간(또는 걸릴것이라고 예상한 시간)을 가로 막대 형태(바형태)로 나타낸다. Karol Adamiecki의 하모노그램과 Henry Gantte의 공장 작업 소요시간 나타내는 차트 시스템이 통합되어 오늘날 간트 차트가 되었다. 또한 업무간의 관계도 알 수 있어서 종속관계(연관성)를 파악하기 쉽다. 보통은 일정(바), 담당자, 마일스톤, 업무간의 관계정도만 표현한다. 간트차트는 프로젝트를 설계할 때 작성하는데에 유용하다. 정보를 많이 기입해야하면 한눈에 파악할 수 있다는 장점이 사라질 수 있다. ErrorBoundary는 await 함수의 에러만!ErrorBoundary는 await하지 않은 비동기 함수에서의 에러는 감지하지 못한다. 추가로 아래 2가지 경우에서도 에러를 감지하지 못한다. 이벤트 핸들러 비동기적 코드 (예: setTimeout 혹은 requestAnimationFrame 콜백) 서버 사이드 렌더링 자식에서가 아닌 에러 경계 자체에서 발생하는 에러 await하지 않고 실행한 비동기 함수는 리액트의 render와 commit phase 밖에서 동작하기 때문이다. 우회적으로 await 하지 않은 비동기 함수의 catch 문에서 에러를 던지고 싶다면, hook 내부에서 에러를 던지는 방법으로 작성하는 방식이 있다. 123setState(() =&gt; { throw new Error('hi');}) 이를 재사용 가능한 hook으로 만들면 다음과 같다. 1234567891011const useAsyncError = () =&gt; { const [_, setError] = React.useState(); return React.useCallback( e =&gt; { setError(() =&gt; { throw e; }); }, [setError], );}; React의 render vs commit phase render phase에서는 JSX 코드를 JavaScript 표현식으로 바꿔 Virtual DOM을 생성한다. commit phase에서는 위 표현식을 실제 DOM에 반영한다.👩‍🏫 이 모든 과정을 통틀어 재조정(reconciliation) 이라고 한다. Ref https://github.com/facebook/react/issues/14981#issuecomment-468452682 https://medium.com/trabe/catching-asynchronous-errors-in-react-using-error-boundaries-5e8a5fd7b971 https://dev.to/thee_divide/reconciliation-react-rendering-phases-56g2 모노레포의 기본 모노레포(monorepo) 두개 이상의 프로젝트가 동일한 저장소를 사용하는 소프트웨어 개발 전략 프로젝트 사이에 의존성이 존재하거나 동일한 도메인과 같은 정의된 관계가 존재한다. 모노레포 도구(tools) 모노레포를 구축하고 이를 쉽게 관리하고 유지할 수 있게하는 도구. 관리/속도/구조 등 여러 측면에서 나의 프로젝트와 궁합이 잘 맞는 도구를 선택하는 것이 좋다. 모노레포 도구를 선택할 때 고려해야 할 것 로컬 캐싱 - 같은 머신에서 같은 것을 두번 빌드하거나 테스트 하지 않는다. 로컬 작업 오케스트레이션 - 여러 Task 를 올바른 순서로 병렬 실행할 수 있는 기능 분산 캐싱 - 서로 다른 환경에서 캐시 아티팩트를 공유할 수 있는 기능 분산 작업 실행 - 단일 시스템에서 실행되어 여러 시스템에 명령을 전달하는 기능 변경에 영향을 받는 프로젝트(패키지) 감지 - 변경에 영향을 받는 프로젝트만 빌드/테스트한다. 워크스페이스 분석 - 추가 구성 없이 시각적인 워크스페이스 그래프를 제공한다. 의존성 그래프 시각화 - 프로젝트 및 Task 간의 의존 관계를 시각화한다. 소스코드 공유 - 서로 다른 프로젝트 간에 소스코드를 쉽게 공유할 수 있다. 코드 제너레이터 - 말그대로 코드 스캐폴딩이 가능하다. Ref https://monorepo.tools/ Node 서버 활용하기기본적으로 노드 서버는 자바스크립트로 요청이 올 때, v8 엔진이 싱글쓰레드로 읽으므로 여러 프로세스를 동작하도록 해야한다. 만약 이게 싫다면 성능을 낮추고 작은 서버로 여러 인스턴스를 띄우는 것도 방법이다. pm2의 클러스터 모드를 활용해 여러 노드 프로세스를 띄울 수 있다. 클러스터 모드를 사용하면, 서버 안에 CPU가 처리할 수 있는 프로세스의 개수 안에서 프로세스 당 하나씩 노드 서버를 띄울 수 있다. implicit props vs explicit propsimplicit props는 @types/react에서 자동으로 추가되는 암시적인 props를 가리킨다. 1&lt;Input key=’first’ /&gt; explicit props는 명시적으로 props interface에 작성되어 있는 props를 의미한다. 12345interface InputProps { type: string; }const Input: React.FC&lt;InputProps&gt; = ({ type }) =&gt; &lt;input type={type} /&gt;&lt;Input type=&quot;search&quot; /&gt; 심볼릭 링크 vs 하드링크 심볼릭 링크는 원본 파일이 삭제되거나 경로가 바뀔 때 link가 깨진다 하드 링크는 원본 파일과 동일한 inode를 사용해서 원본 파일이 삭제되어도 hard link된 파일은 삭제되지 않아 접근이 가능하다. next-transpile-modules빌드되지 않은 형태의 TypeScript 파일을 직접 임포트해서 사용할 수 있다. Nextjs는 기본적으로 외부 패키지를 트랜스파일하지 않는다. next-transpile-modules는 Nextjs에서 지원하는 모든 확장자의 트랜스파일을 지원한다. (.js .jsx .ts .tsx .mjs .css .scss .sass) 모노레포 환경에서 다른 워크스페이스에 있는 컴포넌트를 사전 트랜스파일링 없이 바로 가져오고 싶을 때 유용하다. 12345678910// shared-ui/components/Button.jsfunction Button(props) { return ( &lt;button type='button'&gt; {props.children} &lt;/button&gt; );}export default Button; 123// next.config.jsconst withTM = require('next-transpile-modules')(['shared-ui']);module.exports = withTM(); Ref https://www.npmjs.com/package/next-transpile-modules pnpmnpm, yarn과 같은 패키지 매니저 중 하나다. 평탄하지 않은 node_modules를 생성하기 때문에 오직 직접적인 의존성을 가진 패키지만 사용된다. (자동완성도 실제로 설치한 패키지에서만 동작한다) 모노레포 프로젝트에 적합하며, 빠르다는 장점이 있다. plug and playusb를 꽂으면 바로 연결되는 것처럼, “꽂으면 실행된다”는 의미로 사용한다. 하드웨어에서는 사용자가 별다른 조작이나 설정하지 않고 바로 연결됨을 의미한다. 모노레포에서 이 개념은 상위 레포에서 필요한 모듈을 버전별로 모두 가지고 있고, 하위 레포에서 모듈 버전 정보만 소유한다는 의미를 가진다. 하위 레포에서 해당 모듈을 사용할 때 가지고 있는 버전 정보를 기반으로 상위 레포에서 필요한 모듈을 가져오는 것을 의미한다. 이것저것 MR 때 하지 않아도 되는 CI 작업이라면 MR 머지 후 release 브랜치에 커밋이 생긴 시점으로 해결하는 방법도 있다. node 13버전 이하에서는 optional chaining, nullish 문법을 쓸 수 없다. 디자인 토큰 - 브랜드 색상, 간격과 같은 스타일 변수를 말하는 용어로 쓰인다. docusaurus - 예쁜 다큐먼트 사이트를 뚝딱 만들 수 있게 도와준다. 웹뷰를 띄울 때 기존 웹뷰를 남기려면 query param에 shouldKeepPresentedView=true 옵션을 주면 된다. Logical nullish assignment (x ??= y) - x가 nullish (null 또는 undefined일 때만) 값을 할당한다. (Ref) sFTP - ssh 방식을 사용하여 안전하게 암호화된 구간에서 FTP(파일 전송)기능을 사용할 수 있다. Location.hash - # 뒤에 나오는 식별자를 value로 하는 값 해시라우터를 사용하면 주소 뒤에 #이 붙는다. 별도 서버 설정 없이도 새로고침 시 오류가 나지 않는다. webviewWillAppear 인터페이스는 웹뷰가 새롭게 띄워졌을 때가 아닌 focus out 됐다가 focus in 될 때 실행된다. 스냅샷 테스팅(Snapshot Testing) - 어떤 기능의 예상 결과를 미리 정확히 포착해두고 실제 결과에 비교하는 테스트 방식 타입스크립트에서 객체에 readonly 가 붙어도 객체의 필드는 수정이 가능하다. File 객체의 type 필드 - MIME 타입을 반환한다. (Ref) pps, ppsx 파일 확장자 - MS powerpoint XML을 가리킨다. (Ref) 기타Turborepo로 모노레포 개발 경험 향상하기LINE에서 Turborepo로 모노레포를 개발한 경험을 공유한 글이다. Turborepo의 주요 미션은 모노레포 환경에서 개발자가 조금 더 쉽고 빠르게 개발할 수 있도록 빌드 도구를 제공하는 것입니다. 고급 빌드 시스템을 구축하는 복잡한 과정을 Turborepo가 대신해 주기 때문에 개발자는 복잡한 설정과 스크립트에 신경 쓰는 대신 개발에 더 집중할 수 있습니다. 역시 개발자들은 귀찮음을 해결하기 위해 뭔가를 또 만든다..! 불편하면 불편한 대로 사는 나와는 참 다르다. Turborepo의 기본 원칙은 한 번 작업을 수행하며 수행한 계산은 이후 다시 수행하지 않는 것이다. 따라서 두 번째 실행할 때는 이전에 계산한 작업은 건너뛰고 이전에 캐싱해 놓은 로그를 다시 보여준다. 마지막에 Performance가 향상된 모습을 보여주는데, 탐난다..! :amaze: Ref https://engineering.linecorp.com/ko/blog/monorepo-with-turborepo/ Noto emoji font구글에서 공개했다. 흑백이고 가변 글꼴이어서 색상이나 굵기 설정도 가능하다. 그리고 무엇보다 귀엽다! Ref https://developers.googleblog.com/2022/04/what-is-black-and-white-and-read-all.html 리액트는 언제 컴포넌트를 렌더링 하나요?리액트에서 가장 기본이면서도 항상 골칫덩어리인 문제! 😜 TL;DR 리액트는 컴포넌트를 다음과 같은 상황일 경우 (재)렌더링한다. 컴포넌트에 예정된 상태 업데이트가 있을 경우 컴포넌트에서 사용된 커스텀 훅의 예정된 업데이트가 있을 경우도 포함 부모 컴포넌트가 렌더링 되고 리렌더링에서 제외되는 기준에 충족하지 않을 경우. 제외되는 기준은 다음의 네 가지 조건을 모두 동시에 충족해야 한다. 컴포넌트가 이전에 렌더링 되었어야 함. 즉, 이미 마운트 되었어야 함. 변경된 props(참조)가 없어야 함. 컴포넌트에서 사용하고 있는 context 값이 변경되지 않아야 함. 컴포넌트에 예정된 상태 업데이트가 없어야 함. 아래 예시가 특히 흥미로웠다! 1234567891011121314151617181920212223242526272829default function App() { return ( &lt;Parent lastChild={&lt;ChildC /&gt;}&gt; &lt;ChildB /&gt; &lt;/Parent&gt; );}function Parent({ children, lastChild }) { return ( &lt;div className=&quot;parent&quot;&gt; &lt;ChildA /&gt; {children} {lastChild} &lt;/div&gt; );}function ChildA() { return &lt;div className=&quot;childA&quot;&gt;&lt;/div&gt;;}function ChildB() { return &lt;div className=&quot;childB&quot;&gt;&lt;/div&gt;;}function ChildC() { return &lt;div className=&quot;childC&quot;&gt;&lt;/div&gt;;} 만약 Parent의 업데이트가 예정되어 있다면, 어떤 컴포넌트가 리렌더링 될까? 당연히 Parent 자체는 업데이트를 예약한 컴포넌트이기 때문에 리액트에 의해 리렌더링 될 것이다. 하지만 모든 자식 컴포넌트 ChildA, ChildB, ChildC도 리렌더링 될까? 🤔🤔🤔… 답은 ChildA만 리렌더링된다! ChildA와 달리 ChildB와 ChildC는 리렌더링 되지 않는다다. 그 이유는 ChildB와 ChildC가 렌더링 제외 기준을 충족했기 때문에 리액트가 렌더링을 건너뛰었기 때문이다. 리액트의 렌더링 제외 기준을 알기 위해 이 글에서는 소스 코드까지 살펴보고 있다. 😵 코드 내에서 리액트의 렌더링 제외 로직 관련 코드는 다음과 같다. 1234567// 보류 중인 업데이트 또는 context가 없습니다. 여기서 렌더링을 제외합니다.didReceiveUpdate = false;return attemptEarlyBailoutIfNoScheduledUpdate( current, workInProgress, renderLanes); 이 라인에 도달하기 위해서는 다음 조건이 충족되어야 한다. current !== null oldProps === newProps hasLegacyContextChanged() === false hasScheduledUpdateOrContext === false 해석하면 대략 다음과 같다. 컴포넌트가 이전에 렌더링되었다. 즉, 이미 마운트되었다. 변경된 props가 없다. 컴포넌트에서 사용되는 context 값 중 변경된 것이 없다. 컴포넌트 자체에서 업데이트를 예약하지 않았다. 처음 살펴보았던 예시에서, 1234567function Parent() { return ( &lt;div&gt; &lt;Child /&gt; &lt;/div&gt; );} Parent에서 반환된 &lt;Child /&gt;는 Babel에 의해 React.createElement(Child, null)로 컴파일되고 { type: Child, props: {} }과 같은 형태의 ReactElement가 생성된다. props는 자바스크립트 객체이기 때문에 다시 생성될 때마다 참조가 변경된다. 기본적으로 React는 ===를 사용하여 이전 props와 현재 props를 비교한다. 따라서, props는 리렌더링 되면 다른 값으로 간주된다. 그렇기 때문에 Child는 props의 일부로 Parent로부터 아무것도 받지 않지만, Parent가 리렌더링 될 때마다 여전히 리렌더링 된다. React.createElement는 Child를 위해 호출되고 새로운 props 객체를 만든다. 하지만 만약 Child를 Parent의 props로 전달할 수 있다면 어떻게 될까? 1234567891011function App() { return ( &lt;Parent&gt; &lt;Child /&gt; &lt;/Parent&gt; );}function Parent({ children }) { return &lt;div&gt;{children}&lt;/div&gt;;} 리액트에 의해 Parent가 렌더링될 때 Child에 대한 React.createElement 함수가 호출되지 않는다. 따라서 Child의 새로운 props가 생성되지 않고, 이는 위에서 언급한 네 가지 렌더링 제외 기준을 모두 충족시킨다. 이것이 처음 예시에서 Parent가 업데이트를 예약할 때마다 ChildA만 리렌더링 되었던 이유다. 123456789function Parent({ children, lastChild }) { return ( &lt;div className=&quot;parent&quot;&gt; &lt;ChildA /&gt; // ChildA만 리렌더링된다. {children} // 리렌더링 제외 {lastChild} // 리렌더링 제외 &lt;/div&gt; );} 조금 복잡한 내용이다..!! 두고두고 다시 읽어봐야겠다. Ref https://velog.io/@eunbinn/when-does-react-render-your-component VoltaNode.js용 가상환경 같은 툴로, 프로젝트 구성원끼리 노드 버전 맞출 용도라면 nvm 대신 사용할 수 있다. Ref https://volta.sh/ 자바스크립트는 왜 프로토타입을 선택했을까이전에도 두어 번 읽어보았던 글인데, 볼 때마다 신선하고 정말 재미있다. 철학적 관점에서 프로그래밍 언어를 풀어내다니, 정말 간지… Ref https://medium.com/@limsungmook/자바스크립트는-왜-프로토타입을-선택했을까-997f985adb42 파이스크립트(PyScript)아나콘다가 발표한 새로운 언어다. 이름이..!! 정말 끔찍한 혼종 파이스크립트는 사용자가 파이썬과 표준 HTML을 결합하여 브라우저에서 풍부한 파이썬 애플리케이션을 만들 수 있도록 지원하는 프레임워크다. 브라우저 내 단일-포함(single-include) 방식으로 HTML 페이지에서 자바스크립트만큼 쉽게 파이썬 스크립트를 실행할 수 있도록 한다. 파이스크립트를 사용한 예제가 올라왔다. 웹브라우저로 python 실행하기 Getting started with PyScript Ref https://www.ciokorea.com/news/234899 ts-error-translator혼란스러운 TS 로그를 사람이 보기 좋은 형태로 보여주는 VSCode 익스텐션이다. 라떼는… 에러 로그도 불친절했다 이말이야 Ref https://github.com/mattpocock/ts-error-translator Rayn Dahl의 “JavaScript Container” 한 마디한 마디가 아니고 투머치 주의… Ref https://www.facebook.com/xguru/posts/10227448129370092 Nrwl이 가져간 lernanx 를 만든 Nrwl에서 lerna를 이어서 관리한다고 한다. Ref https://github.com/lerna/lerna/issues/3121 자바스크립트 함수 합성, 뭐가 그렇게 대단할까?그동안 함수형 프로그래밍에서 종종 보았던 compose(), pipe() 등의 함수를 만들면서 원리와 flow에 대해 설명한다. 합성의 진정한 아름다움은 코드가 아니라 코드가 우리를 변화시키는데 있습니다. 코드에 대한 새로운 시각을 제공하기 때문입니다. 뭔가 굉장한 세계가 열린 것처럼..! 하지만 처음 접했을 때의 그 새로운 시야의 신비로움(?)은 잊지 못한다.아직도 혼자 코드 쓰라 하면 못하지만. Ref https://junghan92.medium.com/번역-자바스크립트-함수-합성-뭐가-그렇게-대단할까-5a2664b7c2b8 tc39/proposal-decorators벌써 stage3..! Ref https://github.com/tc39/proposal-decorators 마무리오오.. 눈치채지 못했는데 이번주는 상당히 정보공유글이 많았네. 지난주는 씨가 말랐었는데… 정리하느라 힘들었다. 사실 평일 동안 집중도 잘 안 되고 😬 이번주는 개발을 많이 하지 못한 것 같다. 마크업 정도 하고, 코드리뷰 하고, 그동안 해왔던 프로젝트 장애 대응 (프론트 문제는 아니었지만..!)하고… 사아알짝 지루했던 주였다. 금요일엔 팀 전체 워크샵을 다녀왔다! 우형 오피스의 자랑인 &lt;양평같은 방&gt; 아니고 진짜 양평으로! ㅋㅋㅋ 맛있는 해물 칼국수도 먹고, 강릉이 아닌 양평(서종)의 테라로사에서 존맛탱이었던 까눌레도 먹었다. 입사 4개월 만에 드디어 만난 팀원분들이 엄청 반겨주셔서 행복했당 🥳 빨리 깁스 풀고 싶다 🥺","link":"/2022/05/14/2022-5-week-2/"},{"title":"5월 3주차 기록","text":"썽난 부채질 배워가기React.StrictMode의 은밀한 소행버튼을 누르면 counter의 값이 하나씩 증가하는 리액트 코드를 작성한다고 해보자. 리액트의 useState로 counter의 값을 설정하고, 리렌더링될 때마다 ref.current의 값도 1씩 증가하게끔 한다. 12345678910111213141516171819import { useState, useRef } from &quot;react&quot;;export default function App() { const ref = useRef(0); const [counter, setCounter] = useState(0); ref.current += 1; console.log(&quot;rerender&quot;, counter, ref.current); const increase = () =&gt; setCounter((v) =&gt; v + 1); return ( &lt;div className=&quot;App&quot;&gt; {counter} &lt;br /&gt; renderCount: {ref.current} &lt;button onClick={increase}&gt;+1&lt;/button&gt; &lt;/div&gt; );} 그러나 코드를 실제로 실행해보면, ref.current가 2씩 증가한다. 여러 케이스가 있을 수 있겠지만, 리액트가 제공하는 StrictMode 때문일 수도 있다. StrictMode는 애플리케이션 내의 잠재적인 문제를 알아내기 위한 도구이다. Fragment와 같이 UI를 렌더링하지 않으며, 자손들에 대한 부가적인 검사와 경고를 활성화한다. 개발 단에서만 활성화되며, 프로덕션 빌드 시에는 동작하지 않는다. 12345678910111213141516import React from 'react';function App() { return ( &lt;div&gt; &lt;Header /&gt; &lt;React.StrictMode&gt; &lt;div&gt; &lt;ComponentOne /&gt; &lt;ComponentTwo /&gt; &lt;/div&gt; &lt;/React.StrictMode&gt; &lt;Footer /&gt; &lt;/div&gt; );} StrictdMode는 자동으로 사이드이펙트를 알아내진 않지만, 사이드이펙트를 약간 더 결정론적으로 발견하여 개발자에게 알려준다. 이를 위해 다음 함수들을 고의적으로 두 번 실행한다. 클래스 컴포넌트의 constructor, render, 그리고 shouldComponentUpdate메서드 클래스 컴포넌트의 (static) getDerivedStateFromProps 메서드 함수 컴포넌트 바디 state를 update하는 함수 (setState) useState, useMemo, useReducer에 전달된 함수들 즉 StrictMode는 여러 가지 경고도 날리지만, 함수들을 두 번 실행시켜 비교분석하기도 하는 것이다. 이 때문에 useReducer의 reducer를 순수하게 유지하는게 중요하다. 그렇지 않다면, 아래와 같은 문제가 발생한다. 123const [state, dispatch] = useReducer(reduce, {})// ...dispatch({ ... }) // 🚨 실행 스택에서 2번씩 실행된다. 쓰레드에서 Dan abramov는 이것은 StrictMode의 의도적인 작용이라고 설명하며, 함수를 사이드 이펙트 없이 순수(pure)하게 유지해서 함수가 두 번씩 실행되어도 애플리케이션의 로직에 문제가 없도록 해야 한다고 한다. Ref https://ko.reactjs.org/docs/strict-mode.html https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects https://stackoverflow.com/questions/50819162/why-is-my-function-being-called-twice-in-react yarn workspace의 hoistingyarn workspace는 패키지 구조를 설정하기 위한 방법이다. 여러 개의 패키지를 yarn install만 실행하면 단숨에 설치해준다. IDE에서 여러 프로젝트들이 모여 있는 공간을 작업 공간, 즉 워크스페이스라고 부른다. yarn의 workspace도 마찬가지다. yarn workspace를 사용하는 방법은 아래와 같다. 저장소의 루트에 package.json을 만들고 아래와 같이 작성한다. 1234{ &quot;private&quot;: true, &quot;workspaces&quot;: [&quot;workspace-a&quot;, &quot;workspace-b&quot;]} yarn은 이제 저장소를 워크스페이스로 인식하게 된다. 각각의 프로젝트는 마치 npm 패키지의 로컬 사본처럼 저장소 루트의 node_modules에 저장된다. 각각의 프로젝트별로 node_modules, yarn.lock 등의 파일이 생성되는 대신에, 저장소 루트에 하나만 생성된다. workspace-a와 workspace-b라는 이름으로 각각 하위폴더를 생성하고, 각 폴더 아래 package.json을 만들어준다. 123456789// workspace-a/package.json:{ &quot;name&quot;: &quot;workspace-a&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;dependencies&quot;: { &quot;cross-env&quot;: &quot;5.0.5&quot; }} 12345678910// workspace-b/package.json:{ &quot;name&quot;: &quot;workspace-b&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;dependencies&quot;: { &quot;cross-env&quot;: &quot;5.0.5&quot;, &quot;workspace-a&quot;: &quot;1.0.0&quot; }} 이제 yarn은 워크스페이스 내의 패키지와 프로젝트를 통합 관리한다. 프로젝트의 루트에서 yarn install을 실행하면 워크스페이스 전체에 대해서 패키지를 설치하고, yarn.lock 파일을 갱신한다. 이제 아마도 아래와 같은 파일 계층 구조를 갖게 될 것이다. 123456789/package.json/yarn.lock/node_modules/node_modules/cross-env/node_modules/workspace-a ('/workspace-a'라는 이름으로 symlink 연결된다.)/workspace-a/package.json/workspace-b/package.json workspace-b의 파일에서 필요로 하는 workspace-a는 npm에 공개된 패키지 대신 현재 프로젝트 안에서 정확한 패키지를 찾아다 쓸 것이다. 그리고 workspace-a와 workspace-b에서 모두 사용되는 cross-env 패키지는 프로젝트의 루트에 놓이게 된다. 이처럼 yarn workspace는 여러 프로젝트에서 공통 사용하는 유틸리티를 별도의 공유 프로젝트에 작성하고, 참조해서 사용한다. yarn workspace에서 워크스페이스 디펜던시는 파일시스템의 계층 구조에서 상위 계층으로 hoist 된다. 대부분의 패키지 매니저는 모든 의존성 모듈들을 가져다 평탄화(flatten)하기 위해 각자만의 hoisting 방식을 취한다. 단독 프로젝트에서, 디펜던시 트리는 다음과 같이 줄어든다. 호이스팅으로 A@1.0과 B@1.0의 중복을 제거할 수 있다. 많은 모듈 크롤러/로더/번들러들은 프로젝트 루트의 node_modules부터 탐색을 시작하여 모듈을 효율적으로 배치한다. 모노레포 프로젝트는 파일의 계층 구조가 node_modules로 연결되어 있지 않다. 그런 프로젝트에서, 모듈은 여러 곳에 산재된다. yarn workspace는 자식 프로젝트/패키지들의 모듈들을 부모 프로젝트의 node_modules로 hoisting하여 모듈을 공유한다. 이로써 프로젝트의 루트 node_modules에서 모든 모듈에 접근할 수 있다. 하지만 우리는 종종 로컬 프로젝트의 각 패키지를 빌드하기도 한다. 이때 모듈이 해당 로컬 프로젝트의 node_modules에 없을 수도 있다. (모든 크롤러가 symlink를 탐색하는 것도 아니다.) 이로 인해 자식 프로젝트에서 빌드할 때는 때로 ‘module not found’ 에러에 마주하기도 한다. can’t find module “B@2.0” from project root “monorepo” (symlink를 따라갈 수 없다.) can’t find module “A@1.0” from “package-1” (monorepo의 모듈 트리를 알 수 없다.) 이는 호이스팅 프로세스가 완전히 표준화되지 않아서 보장되지 않는 문제라고 한다. 🤨 이런 문제에 봉착했을 때는 nohoist 옵션을 사용하면 된다고 한다. 여기저기 한계점이 하나도 없는 기술은 아직 없나보다. 🤷‍♀️ 중첩 구조의 package.json이 존재하는 프로젝트가 있을 때, 최상위 package.json에서 yarn install을 실행하면 각자의 node_modules에 모든 의존성을 설치한다. 이때 하위 package.json의 의존성을 상위로 hoist 하려면 yarn install --production 옵션을 넣어줘야 한다. 다만 yarn github 이슈를 살펴보면, yarn classic(yarn workspace)은 호이스팅을 완전히 보장하지 않고, 이 문제를 yarn berry에서 해결했다고 한다. (v1에서의 문제를 v2에서 PnP로 해결) 호이스팅 시에 하위 모든 package.json의 의존성에 버전 충돌이 있다면 yarn 내부에서 정해둔 규칙에 따라 하나의 버전만 상위로 hoist되는데, 그 기준은 공개되어 있지 않다. 예를 들어 project A의 package.json 하위에 있는 project B, C, D의 package.json에 각각 16, 17, 18 버전의 react에 의존성이 있다면, 셋 중 어떤 버전이 호이스팅될 지 알 수 없으며, 경우에 따라 전혀 다른 버전이 호이스팅될 수도 있다. 구체적인 내부 로직은 공개되어 있지 않기 때문에 모노레포에서 사용하기에는 위험성이 있다. pnpm은 install 시 하위에서 사용하는 모든 버전의 모듈을 상위에 위치시키고, 하위에서는 symbolic link를 통해 상위의 모듈에 접근한다. 패키지매니저만 봤을 때 yarn보다 pnpm이 모노레포에 더 적합할 수도 있겠다. Ref https://classic.yarnpkg.com/lang/en/docs/workspaces/ https://classic.yarnpkg.com/blog/2018/02/15/nohoist/ https://musma.github.io/2019/04/02/yarn-workspaces.html 인덱스 시그니처 있다 없으니까인덱스 시그니처가 없는 ‘타입’은 인덱스 Record 타입에 할당할 수 있지만, 인덱스 시그니처가 없는 ‘인터페이스’는 할당할 수 없다. 1234567891011121314interface I { foo: string}declare const i: Itype T = { foo: string }declare const t: Ttype R = Record&lt;string, unknown&gt;const ra: R = i // 🚨 Error// Type 'I' is not assignable to type 'R'.// Index signature for type 'string' is missing in type 'I'const rb: R = t // ✅ OK 변화무쌍한 git log1git log [options] -online: 하나의 커밋을 커밋 체크섬과 커밋 메시지만으로 한 줄로만 표현한다. -graph: log를 그래프로 표현한다. -decorate: 커밋 옆에 브랜치를 표시한다. -all: 모든 브랜치를 표시한다. (all이 아니라면 현재 브랜치만 표시) peerDependenciespeerDependencies는 ‘이 패키지는 패키지 A의 x.x.x버전에 의존성이 있다’고 명시하는 역할을 한다. 즉, 내가 만든 패키지가 다른 패키지와 함께 사용될 때, 내 패키지가 외부 패키지 의존성의 어떤 버전과 호환되는지 나타낸다. peerdependencies에 특정 패키지의 버전을 입력한다고 해서, install 시 해당 패키지가 자동으로 설치되지는 않는다. 만약 해당 패키지를 사용하는 상위 패키지도 패키지 A에 의존하며, 그 버전이 다르다면 install 시 충돌이 일어나고 이후에는 패키지 매니저에 따라 다르게 처리된다. (ex. 패키지 A가 패키지 B, C@1.0을 의존하고 패키지 B가 패키지 C@2.0을 의존하는 경우) peerdependencies가 명시되어 있지 않다면 npm과 yarn classic은 ‘flat’한 node_modules 구조를 선택한다. (모든 의존성이 node_modules의 1-depth에 설치된다.) 그렇기 때문에 내부적으로 경합 후에 C 패키지의 단 하나의 버전을 node_modules에 설치한다. 이 경우 최종적으로 어떤 버전이 설치될 지 보장할 수 없다. 충돌이 일어난 버전 중 하나일 수도 있고, 전혀 다른 버전일 수도 있다. 따라서 peerdependencies 에 특정 버전을 지정했더라도, 그 버전이 node_modules에 있을 것이라고 보장할 수 없다. (설치는 되더라도, 버전은 보장할 수 없다) peerdependencies가 명시되어 있다면 각 패키지 매니저는 다음과 같이 동작한다. npm3 - 피어 종속성을 자동 설치한다. npm4~`npm6` - 경고 메세지를 보여준다. npm7 - 설치 자체를 막는다. yarn classic - 경고 메세지만 보여주고 설치를 진행한다. 내가 작성한 패키지에서 peerdependencies 에 버전을 명시했더라도, 외부 패키지가 peerdependencies 를 작성했을 것이라고 보장할 수 없기 때문에, 패키지 매니저가 peerdependencies를 참고해서 버전을 결정하기 어렵다. yarn classic 은 peerdependencies를 배포할 때 외에 강제하지 않기 때문에, 모노레포의 경우 배포하지 않고 그 내부에서 의존성으로 연결되어 있어서 peerdependencies 를 강제할 수 없다. non-flat 구조의 패키지 매니저non-flat node_modules 구조를 가진 패키지 매니저(pnpm, yarn berry)는 flat한 구조를 가진 패키지 매니저 (npm, yarn classic 등)보다 peerdependencies를 좀 더 적극적으로 사용할 수 있다. non-flat 패키지 매니저는 install 시 하위 패키지에서 의존하는 모든 버전의 패키지를 최상위 node_modules에 모두 설치한다. 최상위 node_modules 에는 랜덤한 버전 대신 모든 버전이 있기 때문에, peerdependencies의 명시된 버전을 명확하게 가져올 수 있다. peerdependencies 는 모든 버전의 교집합을 지정하면 문제가 발생하지 않는다. ex) 패키지A의 의존성 버전이 &gt;1.0.0 / 2.0.0 이라면 peerdependency 는 2.0.0 ex) 만약 1.0.0 / 2.0.0 이라면, 애초에 교집합을 만들 수 없으므로 의존성 버전을 수정할 필요가 있다. 위의 이유를 종합해 보았을 때, 패키지를 배포하지 않고 하나의 레포 안에서 서로 의존하면서 구성하는 모노레포의 경우 non-flat한 node_modules 구조가 더 적합하다. Ref https://pnpm.io/ko/how-peers-are-resolved Braze - User Lifecycle Orchestration 플랫폼Braze(브레이즈)는 User Lifecycle Orchestration 플랫폼이다. 이 플랫폼을 사용하게 되면 사용자에게 전파하는 여러 메시징 수단을 브레이즈로 통합해 관리할 수 있고, 가장 최적화된 시간에 최적화된 고객에게 등록한 이벤트나 메시지를 전달할 수 있다. 자주 사용하는 기능으로, A/B 테스트, 고객에 따른 개인화 메시지, 개인이 가장 많이 사용하는 시간에 푸쉬메시지 전달 등이 있다.ex) 우리가 배민앱에서 노티를 받는 것들은 마케터가 고객군을 체크하고, 가장 적절한 시간에 브레이즈를 이용해서 전달하는 것이다. 브레이즈에 커스텀 마크업 메시지 전달 기능이 있다. 해당 기능을 이용하게 되면 브레이즈에 마크업 코드를 올리고, 앱에서 해당 기능을 지원하면 브레이즈를 통해 원하는 페이지에서 마크업 요소를 자유롭게 출력시킬 수 있다. (브레이즈에서 앱에 SDK를 제공하고, 브레이즈 서버를 거쳐, 웹 데이터를 전달받는 형태) 이런 기능을 이용해, 쿠팡 메인 홈에 들어갔을때 출력되는 dialog 같은 요소를 웹으로 구현할 수 있다. 증분 빌드빌드 시에 변경사항이 있는 입력값만 빌드하고 그 외에는 기존의 결과값을 재사용하는 빌드 방식이다. 입력, 출력이 1:1로 매핑되어 있어야 한다. 1:1 매핑이 존재하는 경우 해당 출력 항목의 타임스탬프와 모든 입력 항목의 타임스탬프를 비교하지만. 1:1 매핑이 없는 출력 파일은 모든 입력 파일과 비교되기 때문이다. 🤔 증분 vs 캐싱 캐싱은 일시적인 것이고 증분은 영구적일수 있다. 캐싱은 메모리 영역에 가깝고, 증분은 그 자체가 파일일 수 있다.cf) 빌드 과정에서 캐싱을?Enabling the build cache (experimental) | Rush 자세한 내용은 incremental build를 찾아보자. Ref https://docs.microsoft.com/ko-kr/visualstudio/msbuild/incremental-builds?view=vs-2022 https://en.wikipedia.org/wiki/Incremental_build_model craco로 babel-loader 오버라이드하기craco는 CRA Config Override의 약자를 딴 툴로, eject 없이 cra의 설정을 오버라이드 할 수 있게 해주는 도구다. 모노레포 환경에서 babel-loader의 적용범위를 프로젝트 외부까지 확장시킬 때 사용할 수 있다. CRA 웹팩 설정을 확인해보기 위해 eject 을 해보면, 웹팩 모듈 중 babel-loader 가 선언된 부분의 include 범위는 /src 이다. (여기서 확인) 따라서 /src 범위 바깥에 있는 jsx, tsx 파일을 import 해서 사용하려고 해도 babel 이 실행되지 않기 때문에 (코드가 트랜스파일링되지 않는다) 리액트에서 오류를 내뱉는다. 하지만 babel-loader의 includes 옵션 값을 /src 외 우리가 필요한 경로까지 확장해준다면 jsx, tsx 파일을 정상적으로 랜더링할 수 있게 된다. CRA 앱을 craco 로 전환한 뒤 babel-loader 를 아래와 같이 오버라이드 할 수 있다. (getLoader(), loaderByName()과 같은 유틸함수는 웹팩 설정을 쉽게 도와준다.) 1234567891011121314151617181920// craco.config.jsconst { getLoader, loaderByName } = require(&quot;@craco/craco&quot;);module.exports = { webpack: { alias: {}, plugins: [], configure: (webpackConfig, { env, paths }) =&gt; { const { isFound, match } = getLoader( webpackConfig, loaderByName(&quot;babel-loader&quot;) ); if (isFound) { // &lt;https://webpack.js.org/configuration/module/#ruleinclude&gt; 참고 match.loader.include = ... // 여기서 __dirname/src 외에 필요한 경로를 추가 } return webpackConfig; } }}; 12345678// apps/cra-projectimport { Button } from '@packages/ui'...// 변경 전&lt;Button&gt;버튼&lt;/Button&gt; // 🚨 SyntaxError: Unexpected token ...// 변경 후&lt;Button&gt;버튼&lt;/Button&gt; // ✅ 정상적으로 랜더링 캡슐화상태와 행동을 하나의 객체 안에 모아 캡슐화를 하면 변경에 대한 영향을 최소화할 수 있다. 외부에서 알 필요 없는 구현 세부사항을 안정적인 인터페이스 뒤로 숨긴다. 객체지향의 유지보수성을 높이는 방법 중 하나는 변경될 수 있는 어떤 것이라도 캡슐화를 하는 것이다.객체가 수행할 책임이 아니라 내부 상태에 포커스를 맞출 경우 캡슐화를 위반할 가능성이 높아진다. 👩‍🏫 getter, setter는 객체 내부 상태를 캡슐화하지 못한다. 리액트를 사용할 때도, 클라이언트 단의 코드와 서버와 통신하는 도메인의 레이어를 나누면 외부(서버)의 변경에 유연하게 대처할 수 있다. base64 vs multipart✔️ base64 binary를 6바이트 단위의 ASCII 캐릭터로 인코딩 (radix-64 표기법) 패딩값 (문자열의 ==)에 의한 오버헤드가 발생할 수 있다. 그냥 parameter로 받으면 된다. IE9 이하에서는 파일 인코딩 불가능하다. 전체 데이터를 변환하고 서버에 보내기 때문에 큰 용량의 파일에는 부적합하다. serializable 12345// 암호화(Encode)btoa('12345'); // MTIzDNU=// 복호화(Decode)atob('MTIzDNU='); // 12345 한글 데이터의 경우 아래와 같이 사용한다. 12345// 암호화(Encode)btoa(encodeURIComponent('한글')); // JUVEJTk1JTlDJUVBJUI4JTgw// 복호화(Decode)decodeURIComponent(atob('JUVEJTk1JTlDJUVBJUI4JTgw')); // 한글 ✔️ multipart/form-data binary 형식의 데이터 ajax로는 전송 불가하다. http protocol (MIME type)의 하나 브라우저에서 서버로 HTML Form의 내용을 전송 시 사용한다. 큰 용량의 파일에 적합하다. ☝️ MIME typeMultipurpose Internet Mail Extension의 약자.클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘으로, 여러 형태의 파일 전송에 사용한다.ex) text/plain, text/html, image/jpeg, image/png, audio/mpeg, audio/ogghttp 프로토콜의 Content-type 헤더에 바로 이 MIME type이 들어간다. 멀티파트 타입일반적으로 다른 MIME 타입들을 지닌 개별적인 파트들로 나누어지는 문서의 카테고리를 가리킨다. 즉 이 타입은 합성된 문서를 나타내는 방법읻.ex) multipart/form-data, multipart/byteranges enum vs union type컴파일 후에 enum의 용량이 더 크다. 그리고, enum은 덕 타이핑이 안 된다 123456789type COLOR_TYPE = 'RED' | 'BLUE' | 'YELLOW';enum COLORS_ENUM { RED = 'RED', BLUE = 'BLUE', YELLOW = 'YELLOW',}const red: COLORS_ENUM = &quot;RED&quot; // 🚨 Error opacity vs visibility vs display display: none은 요소가 렌더링됐을 때 영역을 차지하지 않는다. 브라우저는 display: none이나 visibility: hidden 을 사용하는 요소의 이벤트에 응답하지 않는다. visibility: hidden 은 opacity: 0, pointer-events: none 과 동일하게 동작한다. 접근성 측면에서, 오직 opacity: 0 요소만 탭 순서에 따라 접근이 가능하며, 요소의 컨텐츠를 스크린리더로 읽을 수 있다. display: none 이나 opacity: 0을 적용하는 것은 자식 요소들에 영향을 준다. 반면 visibility: hidden 은 자식 요소들의 visibility에 영향을 주지 않는다. 요소의 크기를 측정하고 싶다면, 절대 display: none 을 쓰면 안 된다. Ref display: none vs opacity: 0 vs visibility: hidden - HTML DOM 타입스크립트가 null 또는 undefined를 걸러내게끔 하는 방법변수로 빼면 된다! 12345678if (!MEDIAN_PRICE[shop.categoryCode]) { return null;}// 여기서 optional 연산자 ? 안 쓰고return { &lt;span className={styles.accent}&gt;{MEDIAN_PRICE[shop.categoryCode]?.toLocaleString()}원} 123456789const medianPrice = MEDIAN_PRICE[shop.categoryCode]; // ✅ 별도의 변수로 분리한다.if (!medianPrice) { return null;}return { &lt;span className={styles.accent}&gt;{medianPrice.toLocaleString()}원&lt;/span&gt;;} UTM사용자가 어떤 경로를 통해 애플리케이션으로 유입되는지 파악할 때 사용할 수 있다. Urchin Tracking Module의 약자로, GA에서 애플리케이션 사용자의 유입을 분석할 때 사용한다. UTM 코드는 링크에 해당하는 웹사이트 주소 뒤에 붙게 되며, GA에 해당 링크의 정보를 전달하는 역할을 수행한다. 1https://airbridge.io?utm_source=google&amp;utm_medium=blog&amp;utm_campaign=july_launch&amp;utm_content=WhatisUTM 👩‍🏫 이때 source, medium은 필수값이다. UTM은 아래와 같은 정보를 수집한다. 해당 유입이 어디로부터 발생하였는가? 해당 유입이 어떻게 발생하였는가? (→ utm_medium) 해당 유입이 왜 발생하였는가? Ref https://blog.ab180.co/posts/utm-code-olbareuge-sayonghagi as unknown as [type]1234this._timer = setTimeout(() =&gt; this._send(), 100) as number;// 🚨 Conversion of type 'Timeout' to type 'number' may be a mistake // because neither type sufficiently overlaps with the other.// If this was intentional, convert the expression to 'unknown' first. 에러 메시지를 살펴보면, 타입을 한번 풀어준 다음에 써줘야 할 것 같다. 아래와 같이 작성하여 해결한다. 1this._timer = setTimeout(() =&gt; this._send(), 100) as unknown as number; 이때 any 가 아닌 unknown 을 썼기 때문에, 반드시 개발자가 type narrowing을 직접 해줘야 한다! String.charCodeAt() &amp; String.fromCharCode()String.charCodeAt()은 이름에서도 알 수 있듯이 파라미터로 주어진 인덱스에 대한 UTF-16 코드를 알아낸다. String.fromCharCode()는 물론 그 반대. 123const text = &quot;HELLO WORLD&quot;;const code = text.charCodeAt(0); // 72String.fromCharCode(code); // 'H' Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode 이것저것 체리픽을 하면 커밋 번호가 새롭게 생성된다. 웹뷰에서 파라미터를 넘겨주려면 encodeURIComponent를 활용해서 url을 인코딩한 주소를 열어야 한다. yml / yaml - JSON의 단점을 보완하는 superset으로, JSON의 완전상위호환이다. 주석/ 불필요한 따옴표 제거/ 타입명시 가능 등 좀 더 간결하고 안전한 데이터 표현이 가능하다. &lt;img /&gt;와 &lt;iframe /&gt; 태그에는 loading이라는 속성이 있다. create-react-app 의 최신 버전은 major 5인데, 여기서 리액트 18 버전을 사용한다 regexp.test()의 파라미터의 타입은 string이기 때문에, 자바스크립트에서는 undefined를 넣어도 결과가 나오지만 타입스크립트에서는 에러로 취급한다.123// 타입스크립트/ab+c/i.test(undefined); // 🚨 Argument of type 'undefined' is not assignable to parameter of type 'string'. flow content &lt;body /&gt; 태그 안에서 바로 사용할 수 있는 태그들을 가리킨다. &lt;li /&gt;는 반드시 ul/ol/menu 이하에서 사용되어야 하기 때문에 flow content가 아니다 웹 브라우저에도 page lifecycle이 있다. (Page Lifecycle API - Chrome Developers) 기타Mock Service Worker는 프론트엔드에서 모델을 설계하고, 더미 데이터를 운영하는데 있어 큰 도움이 될 수 있는 라이브러리다. 앞으로의 테스트 생태계는 Mock Service Worker로 대체 될 수 있을까? 링크의 깃헙 페이지 하위의 mswjs/data를 이용하면 데이터를 손쉽게 모델링할 수도 있다. 백엔드는 잘 모르지만, primaryKey, nullable 등의 옵션을 보아하니 거의 SQL의 여러 기능들을 가져온 것 같다? 프로젝트의 상황에 따라 백엔드가 제공되지 않은 상황에서 다음과 같은 기능을 사용한다면 충분히 도움이 될 수 있을 것이다. 또 서버가 제대로 모델링이 안되었을 경우, 프론트엔드에서 선제적 모델링이 가능해질 시기가 올 수도? Ref https://github.com/mswjs 마무리또 바쁜 일주일이 후다닥 지났다. 사실 별로 안 더운데, 일에 집중하고 있을 때는 왜 더울까 🤔 벌써 5월 말에 접어들고 있으니 더울 만도 하다. 평일 동안 부채질만 하며 살다가, 주말에 드뎌 에어컨 청소를 했다. 하지만 틀진 않을 것이다 (??) 다행히 더 더워지기 전에 깁스도 풀었다. 이제 운동도 다시 살살 하고, 다음주에 열심히 놀아야지!","link":"/2022/05/21/2022-5-week-3/"},{"title":"5월 4주차 기록","text":"배워가기mswjsmock service worker API를 사용해서 network 요청을 중간에 가로채서 대신 응답할 수 있다. 따라서 API url을 mock 전용으로 따로 구분할 필요 없으며, 서버 개발이 완료 됐거나 production 모드일 때 msw 기능을 끄면 이후 로직을 변경할 필요가 없다. (단, 조건은 msw로 제공하는 응답 스키마가 서버와 차이가 없어야 한다.) msw는 클라이언트에서 mock 서버처럼 동작하여, 클라이언트/서버 개발이 병렬로 진행될 때 서버의 데이터 스키마를 무작정 기다리지 않고 클라이언트에서 모델링을 진행할 수 있다. 리소스 로드 최적화 preload 크롬 기준 DevTools Priority: High 현재 페이지에서 사용되는 리소스에 적용하기 적합하다. (히어로이미지, 웹폰트 등) as 속성을 제대로 명시하지 않으면 브라우저가 두번 fetch 해온다. 모던 브라우저는 리소스 우선순위 적용을 알아서 잘 하기도 하고 사용자의 대역폭을 고려했을 때 선택적, 전략적으로 preload 해야한다. 모든 모던 브라우저에서 지원된다. prefetch 크롬 기준 DevTools Priority: Lowest 미래에 사용되는 리소스에 적용하기 적합하다. (다른 뷰나 페이지로 내비게이팅) 우선순위가 낮아 현재 페이지에 사용될 리소스에 적용하면 초기 렌더링 속도가 오히려 느려진다. Ref https://web.dev/i18n/en/preload-critical-assets/ https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf 크롬의 4가지 캐시첫째, HTTP 캐시가 있다. HTTP 통신에 Cache-Control 헤더를 사용했을 때 캐시된다. 둘째, 메모리 캐시가 있다. RAM 메모링 저장되는 캐시로, 빠르지만 지속적이지 않다. max-age와 같은 유효한 Cache-Control이 없으면 이곳에 캐시된다.크롬 개발자 도구의 Network 탭에서 Size 컬럼에 memory cache로 표시된다. 셋째, 서비스워커 캐시가 있다.서비스 워커는 웹 응용 프로그램, 브라우저, 그리고 네트워크 사이의 프록시 서버 역할을 한다. 서비스 워커는 연관된 웹 페이지/사이트를 통제하여 탐색과 리소스 요청을 가로채 수정하고, 리소스를 굉장히 세부적으로 캐싱할 수 있다. 이를 통해 웹 앱이 어떤 상황에서 어떻게 동작해야 하는지 완벽하게 바꿀 수 있다.서비스워커는 fetch 이벤트의 중간자 역할로 사용할 수 있다. 이 경우 서비스워커는 HTTP를 통해 정보를 요청하는 대신 가지고 있는 캐시에서 자료를 전달한다. 캐시가 삭제되지 않는 한 브라우저는 인터넷 연결 없이도 정보를 보여줄 수 있다.window.navigator에 serviceWorker 필드로 접근하여 서비스워커 캐시를 설정할 수 있다. 마지막으로, 푸시 캐시가 있다. 이에 대한 정보는 많이 나와있지 않은데, 서버 푸쉬 기능을 제공하는 HTTP2를 사용했을 때 HTTP2 세션에 저장되는 캐시인 것 같다. 정확한 명칭은 ‘unclaimed push streams container’라고 한다. Ref https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API https://stackoverflow.com/questions/54959244/where-is-chrome-push-cache-stored-physically parseInt(float) vs Number 'A1.23' (숫자 혹은 +-가 아닌 문자로 시작할 때) 12parseInt('A1.23') // NaNNumber('A1.23') // NaN 123A (중간에 문자가 나올 때) 12parseInt('123A') // 123Number('123A') // NaN 1.23 (소수점이 있을 때) 123parseInt('-1.24') // -1parseFloat('-1.24') // -1.24Number('-1.24') // -1.24 1.23A (소수점과 함께 문자가 있을 때) 123parseInt('1.23A') // 1parseFloat('1.23A') // 1.23Number('1.23A') // NaN 결론: Number는 처음부터 똑바로 된 숫자를 넣어줘야 한다. eslinteslint는 린트 대상 파일과 가까운 eslintrc 파일의 구성을 우선시한다. 그 후에 디렉토리 상위를 탐색하면서 eslintrc 파일에 root: true가 있거나, 최상단 루트디렉토리에 도달할 때 까지 발견한 모든 eslintrc 파일을 병합한다. root: true는 eslint 구성을 어디까지 병합할 지 조절할 때 사용한다. eslintrc 파일과 eslintConfig 필드가 있는 package.json이 동일한 디렉토리에 있다면 eslintrc 파일의 구성이 적용되며, package.json의 구성은 무시된다. (합쳐지지 않는다.) 시각 보정글자 디자인 시 발생하는 착시 현상들을 방지하고 글자의 시각적 결함을 찾아내어 글자의 디자인을 세밀하게 조정하는 작업을 말한다. 시각보정은 글자의 가독성과 판독성에 지대한 영향을 끼치기 때문에, 폰트디자인에 있어 가장 핵심이라고 할 수 있다. 간단하게 말하자면, 실제 수치상으로는 맞는데 사람의 시각에서는 이상하여 보정하는 작업이다. 성능 지표 TTFB (Time To First Byte) : 페이지를 요청했을 때 서버에서 데이터의 첫 번째 바이트가 도착하는 시점을 나타낸다. TTFB는 주로 서버 성능과 직결된다. FCP(First Contentful Paint) : 첫 요소가 로드 될 때까지 시간 FMP(First Meaningful Paint) : 사용자에게 의미있는 첫 요소가 로드 될 때까지 걸리는 시간 LCP(Largest Contentful Paint) : 주요 콘텐츠가 로드 될 때까지 걸리는 시간 FCP의 경우 로딩바가 첫요소가 되는 경우가 많아 제외. FMP 또한 정확하지 않다고 판단하여 LCP를 기준으로 로딩 속도를 측정한다. 구글 기존 2.5미만이면 좋음, 4.0미만이면 개선이 필요함, 4초 이상이면 형편없음으로 분류한다. 화면에서 가장 큰 요소가 계속 변경되면 LCP 속도는 늦어진다. 그 외에도 FID(First Input Delay), CLS(Cumulative Layout Shift) 등이 있다. FID(상호 작용력) : 사용자의 행동에 대해 실제로 이벤트 핸들러가 반응하기까지 걸리는 시간이다. 100ms미만 좋음. 300ms미만 개선 필요. CLS(시각적 안정성) : 시작 위치에서 레이아웃이 얼마나 변화했는지에 대한 측정이다. 0.1미만 좋음. 0.25미만 개선 필요. TTI(Time to Interactive) : 자바스크립트의 초기 실행이 완료되어서 사용자가 직접 행동을 취할 수 있는 순간이다. TTI는 FID보다 늦다. TBT (Total Blocking Time) : TBT는 주 스레드가 input 응답을 막을 정도로 오래 차단 되었을때 FCP와 TTI 사이의 총 시간을 나타낸다. 긴 작업의 차단 시간은 50ms를 초과하는 시간으로 계산한다. 즉 task의 작업 시간이 250ms이면 TBT는 200ms이다. path.join vs path.resolvepath.join은 주어진 경로 segment 를 모두 결합한 다음, 결과 경로를 정규화 한다. path.resolve는 절대 경로가 생성될 때까지 오른쪽에서 왼쪽으로 경로를 정규화 한다.이때 경로 인자를 탐색하는 도중 / 을 만나면 절대경로로 인식해서 나머지 경로인자들을 무시한다. 절대경로를 찾지 못할 경우 워킹디렉토리(루트폴더) 가 자동으로 앞에 연결된다. cf) path.resolve() === __dirname 은 실행중인 파일이 현재 작업 디렉토리에 있을 때에만 성립한다. 123456789101112const path = require('path');console.log(path.resolve()); // /home/runner/6pev2q2j72vconsole.log(path.resolve('a', 'b', 'c')); // -&gt; /home/runner/6pev2q2j72v/a/b/cconsole.log(path.resolve('/a', '/b', 'c')); // -&gt; /b/cconsole.log(path.resolve('/a', 'b', 'c')); // -&gt; /a/b/cconsole.log(path.resolve(__dirname, '/a')); // -&gt; /aconsole.log(path.join('/a', '/b', '/c')); // -&gt; /a/b/cconsole.log(path.join('/a', '/b', 'c')); // -&gt; /a/b/cconsole.log(path.join('/a', 'b', 'c')); // -&gt; /a/b/cconsole.log(path.join('a', 'b', 'c')); // -&gt; a/b/c @testing-library/user-event@testing-library/user-event는 fireEvent 의 기반으로 빌드된 패키지지만, 사용자 상호작용과 더 유사한 여러 메서드들을 제공한다. fireEvent.change 는 단순히 input의 하나의 변경 이벤트를 트리거하지만 type 호출은 문자마다 keyDown, keyPress, keyUp 이벤트들을 트리거 한다. 즉, userEvent가 실제 사용자 상호작용과 유사하다. 언젠가 @testing-library/dom에 포함될수도 있다고 한다. strict: falsetsconfig에서 &quot;strict&quot;: false 면strictNullChecks 도 false가 되어서 undefined, null 타입을 무시한다. strict 모드에 속하는 세부 옵션들은 다음과 같다. alwaysStrict strictNullChecks strictBindCallApply strictFunctionTypes strictPropertyInitialization noImplicitAny noImplicitThis useUnknownInCatchVaria 서로 다른 타입의 배열 유니온 타입서로 다른 타입의 배열 유니온 타입의 경우 몇 가지 메소드를 사용할 수 없는 경우가 있다. 예를 들면, 1type A = number[] | string[] A 타입의 배열에는 filter, reduce, every, find 등의 메소드를 사용할 수 없다. 그러나 forEach, map, some 등은 사용 가능하다. 이유는 각 메소드 콜백함수의 파라미터 타입이 number인지, string인지 알 수 없기 때문이다. 각 메소드의 인터페이스를 까보면 위에서 사용할 수 없는 메소드들은 모두 제네릭을 사용하고 있다. extends의 또 다른 사용type을 정의할 때 extends 키워드는 단순히 상속만을 위해 사용하지는 않는다. 123type A = string | numbertype B = stringtype C = B extends A ? boolean : never 위처럼 삼항연산자와 함께 사용하면 조건부 타입 정의가 가능하다. B가 A에 할당 가능한 타입이라면, 타입 C는 boolean이고 아니라면 never가 된다. window.navigator.userAgentwindow.navigator.userAgent를 파싱하여 브라우져 버젼, OS 버젼 등을 확인할 수 있다. Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.61 Safari/537.36 : 맥북 크롬 Mozilla/5.0 (iPhone; CPU iPhone OS 13_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 : IE 못지않은 극악의 iOS 13.4 TypeScript neverTypeScript의 never는 return type에 지정해도 당장의 타입체킹에 별다른 영향을 미치지 못 한다. 1⭐️ 내용 추가 후 확인 never를 함수의 파라미터에 지정한다면 체킹된다. 1234567891011121314function fn(input: never) {}// 오직 `never` 만 받는다.declare let myNever: neverfn(myNever) // ✅// 아무 값이나 전달하거나 아무 값도 전달하지 않으면 타입 에러 발생fn() // ❌ 인자 'input'에 아무 값도 주어지지 않음fn(1) // ❌ 'number' 타입은 'never' 타입에 할당할 수 없음fn('foo') // ❌ '\bstring' 타입은 'never' 타입에 할당할 수 없음// `any`도 통과할 수 없다.declare let myAny: anyfn(myAny) // ❌ '\b\bany' 타입은 'never' 타입에 할당할 수 없음 return type이 void인 경우는 관찰대상이 아니다. 따라서 return 값에 어떤 타입이 와도 타입체킹을 하지 않는다. 123const foo: () =&gt; void = () =&gt; { return 'bar' // ✅ OK} Ref https://ui.toast.com/weekly-pick/ko_20220323 react-query의 cacheTime vs staleTimecacheTime은 쿼리 인스턴스가 unmount된 후 메모리에 데이터를 캐싱해두는 시간 기본 300초 이 시간이 지나면 캐시데이터를 refetch한다. 쿼리 인스턴스가 마운트 될 때 캐시데이터가 있으면 첫 value로 사용하지만, fetch는 이루어진다. staleTime은 최초의 쿼리 인스턴스가 마운트 된 이후부터 데이터를 구식이라고 판단하는 시점이다. 기본 0초 최초 fetch 이후에 staleTime 시간이 지나면 해당 데이터는 구식이라고 판단되어 refetch한다. 쿼리 인스턴스가 마운트 될 때 staleTime이 남아있다면 fetch가 이루어지지 않는다. componentDidMount vs render리액트 클래스 컴포넌트 쓰는 사람 나야나 render() 메서드는 클래스 컴포넌트에서 반드시 구현돼야하는 유일한 메서드로, JSX를 렌더링한다. componentDidMount() 는 모든 요소가 정상적으로 렌더링되었을 때 실행된다. (render() 메서드 이후에 실행된다.) 구체적으로는 컴포넌트가 마운트된 직후, 즉 트리에 삽입된 직후에 호출된다. DOM 노드가 있어야 하는 초기화 작업은 이 메서드에서 이루어지면 된다. 외부에서 데이터를 불러와야 한다면, 네트워크 요청을 보내기 적절한 위치이다. constructor()는 React 컴포넌트의 생성자로, 해당 컴포넌트가 마운트되기 전에 호출된다. Ref React Lifecycle Methods Render And ComponentDidMount git rebase 똑바로 하기 git fetch git rebase origin/master git add . git rebase –continue 다른 옵션들 git rebase –abort git push origin HEAD -f git push –force-with-lease origin HEAD Ref https://www.w3docs.com/snippets/git/how-to-rebase-git-branch.html JavaScript array 요리조리 주물주물object의 boolean 값으로 sorting하기 123456789const arr = [ { id: 1, bool: true }, { id: 2, bool: false }, { id: 3, bool: false }, { id: 4, bool: true}];// ✅ true values firstconst trueFirst = arr.sort((a, b) =&gt; Number(b.bool) - Number(a.bool));console.log(trueFirst);// [ { id: 1, bool: true }, { id: 4, bool: true }, { id: 2, bool: false }, { id: 3, bool: false } ] 아래와 같이 해보자! 1const newArray = array.map(({ dropAttr1, dropAttr2, ...keepAttrs }) =&gt; keepAttrs) 123456789101112131415const arr = [ { id: 1, name: 'a', grade: 30 }, { id: 2, name: 'b', grade: 40 }, { id: 3, name: 'c', grade: 50 }, { id: 4, name: 'd', grade: 60 }];const newArr = arr.map(({ id, ...keepAttrs}) =&gt; keepAttrs)console.log(newArr);// [// { name: 'a', grade: 30 },// { name: 'b', grade: 40 },// { name: 'c', grade: 50 },// { name: 'd', grade: 60 }// ] Ref https://bobbyhadz.com/blog/javascript-sort-array-of-objects-by-boolean-property https://stackoverflow.com/questions/18133635/remove-property-for-all-objects-in-array 이것저것 package lock 파일을 삭제 및 변경하지 않도록 유의하자. lock 파일을 지웠다가 다시 패키지를 설치하면서 @latest 옵션으로 패키지가 설치되는 경우가 있는데, 이 때 패키지의 major 버전이 바뀌면서 예기치 못한 새로운 에러가 발생할 수 있다. test를 작성할 때 queryBy 는 실패할 게 예상되는 상황에서 사용하는 게 좋다. (Ref) 자바스크립트 Promise에서 resolve()를 호출해도 뒷 문장이 실행된다. 뒷 문장을 실행하고 싶지 않다면 return resolve()를 해주자. gif &gt; mp4 변환 같은 이미지 프로세싱은 CPU 점유율이 매우 큰 편이다. 여러 개의 요소들이 묶여있는 그룹에서 어떤 요소의 width에 의해서 텍스트가 줄바꿈이 되면서 찌부되는 경우가 있는데, 이런 경우 white-space: nowrap으로 줄바꿈되지 않도록 방지하여 찌부되는 것을 막을 수 있다. block 요소 두개 중 하나는 border line이 그려져있고, 하나는 그려져있지 않을 때, flex로 정렬되더라도 두 개의 width가 다르게 나온다. 이럴 경우 flex: 50% 를 주어서 두 개의 요소 길이를 같게 만들 수 있다. onClick등의 이벤트 핸들러 안에서 에러를 throw하면 리액트 컴포넌트의 라이프사이클 밖에서 throw 된 에러이기 때문에 ErrorBoundary에 걸리지 않는다. 컴포넌트 테스트를 작성할 때 테스트 케이스가 많아진다면 해당 컴포넌트가 너무 많은 역할을 하고 있는건 아닌지 의심해보자. tel: 링크를 활용하면 휴대전화에서 전화번호를 자동입력할 수 있다.1&lt;a href=&quot;tel:+49.157.0156&quot;&gt;+49 157 0156&lt;/a&gt; css only-of-type: 같은 유형의 형제가 없을 때 사용한다. (Ref)12345/* Selects each &lt;p&gt;, but only if it is the *//* only &lt;p&gt; element inside its parent */p:only-of-type { background-color: lime;} nexus를 이용하여 사설 npm package를 만들 수 있다. (Ref) 기타Next.js도 중첩 레이아웃 할래Vercel의 Next.js의 RFC에서 Remix처럼 중첩 레이아웃을 지원하겠다고 한다! Ref https://nextjs.org/blog/layouts-rfc 자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식C나 C++과 같은 언어는 가비지 컬렉터(GC)를 이용하여 수동으로 쓸모없는 메모리 영역을 해제할 수 있다. 하지만 자바스크립트는 그런 능력이 없다! (자바스크립트는 대체 뭘 할 수 있는 건지!) 정말로 자바스크립트의 V8 엔진은 대체 뭘 하는 걸까. V8은 힙 영역을 New/Old space으로 나누어, GC에 의해 Old space으로 옮겨진 객체는 오래된 것으로 판단하여 제거된다. 구체적으로는, 마이너 GC(Scavenger)와 메이저 GC로 나뉘어 사용하지 않는 객체들을 메모리에서 제거한다. 마이너 GC는 오래된 객체를 New space에서 Old space로 옮긴다. 메이저 GC는 Mark-Sweep-Compact 알고리즘과 Tri-color 알고리즘을 사용하여 Old space에 있는 객체들을 마킹 후에 제거한다. 전통적인 마이너 GC와 메이저 GC의 가비지 컬렉션이 수행할 때 프로그램이 멈추게 되며, 이 시간이 길어질수록 렌더링이 지연되어 UX 경험을 떨어뜨린다. 이에 최신 GC에는 여러 기술들이 추가되었다. Parallel - 기존에는 메인 쓰레드 혼자 하던 일을 헬퍼 쓰레드들과 균등하게 나누어 일을 한다. Incremental - 메인 쓰레드가 적은 양의 작업을 간헐적으로 처리한다. Concurrent - 메인 쓰레드는 더 이상 가비지 컬렉션을 하지 않고, 헬퍼 쓰레드들이 수행한다. Idle-time GC - 개발자는 GC에 직접 접근할 수 없다. 하지만 v8은 크롬과 같은 embedder에게 가비지 컬렉션을 유발할 수 있는 메커니즘을 제공한다. 크롬은 프로그램이 쉬는 free나 idle time을 알 수 있기 때문, 애니메이션 프레임 렌더링 작업이 16ms보다 빨리 끝난다면 크롬은 다음 프레임 작업 전까지 가비지 컬렉션을 유발한다. Ref https://fe-developers.kakaoent.com/2022/220519-garbage-collection/ 마무리오랜만에 프론트 정기밋업을 했다! 재밌었던 마수타와 여러 세션 발표가 있었다. 언젠가 (오랜 시간이 지난 후에…) 능력치가 쌓이면 발표해보고 싶다. 그리고 우테코 프론트 3기 엠티를 다녀왔다. 25명 전참이라니… 도른 사람들. (한 명은 입실렌티 갔다 늦게 왔당 ㅋㅋㅋ)","link":"/2022/05/28/2022-5-week-4/"},{"title":"6월 4주차 기록","text":"싱나는 여름소풍 배워가기React의 createElement()리액트에서 사용하는 JSX 문법은 트랜스파일러에 의해 createElement() 호출로 변환되며, createElement() 메서드는 오버라이딩된 여러 개의 메서드로 존재한다. 1234567891011121314151617181920declare namespace React { // ... function createElement( type: &quot;input&quot;, props?: InputHTMLAttributes&lt;HTMLInputElement&gt; &amp; ClassAttributes&lt;HTMLInputElement&gt; | null, ...children: ReactNode[]): DetailedReactHTMLElement&lt;InputHTMLAttributes&lt;HTMLInputElement&gt;, HTMLInputElement&gt;; function createElement&lt;P extends HTMLAttributes&lt;T&gt;, T extends HTMLElement&gt;( type: keyof ReactHTML, props?: ClassAttributes&lt;T&gt; &amp; P | null, ...children: ReactNode[]): DetailedReactHTMLElement&lt;P, T&gt;; function createElement&lt;P extends SVGAttributes&lt;T&gt;, T extends SVGElement&gt;( type: keyof ReactSVG, props?: ClassAttributes&lt;T&gt; &amp; P | null, ...children: ReactNode[]): ReactSVGElement; function createElement&lt;P extends DOMAttributes&lt;T&gt;, T extends Element&gt;( type: string, props?: ClassAttributes&lt;T&gt; &amp; P | null, ...children: ReactNode[]): DOMElement&lt;P, T&gt;; // ... } 이때, 모든 createElement() 오버라이딩 메서드 반환 타입의 뿌리가 되는 것이 React.ReactElement 타입이다. ReactElement는 리액트 컴포넌트를 JSON 형태로 표현해놓은 것으로, createElement()가 반환하는 객체들의 슈퍼타입(supertype)이다. 클래스 컴포넌트의 render() 메서드가 반환하는 ReactNode 역시 ReactElement를 포함하는 서브타입이 된다. 12345interface ReactElement&lt;P = any, T extends string | JSXElementConstructor&lt;any&gt; = string | JSXElementConstructor&lt;any&gt;&gt; { type: T; props: P; key: Key | null;} Ref https://simsimjae.tistory.com/426 npm workspacenpm에서 정의하는 workspaces란, 하나의 root package로 로컬 파일 시스템의 여러 개의 packages를 관리하기 위한 용어다. npm v7부터 workspaces를 지원하고 있다. npm install 명령어 자체에서 자동으로 패키지를 링크해주기 때문에, 하위 패키지들의 참조는 루트 node_modules로 이어져있다. 타입스크립트의 타입 추론타입스크립트에서 유니온 타입으로 결합된 객체를 반복시킬 때 컴파일러는 해당 객체가 어떤 유형의 객체인지 알 수 없어 내부 타입을 추론할 수 없다. 이때 타입 가드를 통해 범위를 좁히면 컴파일러에게 객체의 유형을 알려줄 수 있다. 12345678910111213141516171819202122232425262728293031interface a { id: string}interface b { name: string}type AunionB = a | bconst arr: AunionB[] = [ { id: 'foo', name: 'bar' }]const isA = (item: a | b): item is a =&gt; { return (item as a).id !== undefined}const isB = (item: a | b): item is b =&gt; { return (item as b).name !== undefined}for (const item of arr) { console.log(item.id) // Property 'id' does not exist on type 'AunionB' console.log(item.name) // Property 'name' does not exist on type 'AunionB' isA(item) &amp;&amp; console.log(item.id) // OK isB(item) &amp;&amp; console.log(item.name) // OK} Jest에서 시간 관련 메서드 테스트하기jest에서 시간 관련 메서드(setTimeout, setInterval 등)를 테스트하고 싶을 때, 물리적인 시간을 사용하지 않고 mock 타이머를 통해 테스트할 수 있다. 테스트코드 상단에 jest.useFakeTimers()를 선언한 후 다음 메서드들을 적절하게 사용한다. jest.spyOn(global, 'setTimeout'); - global에는 window와 같은 글로벌 객체를 넣는다. setTimeout 함수에 대해 mocking 하여, toHaveBeenCalled와 같은 테스트가 가능하다. jest.runAllTimers(); - 모든 타이머를 실행시킨 다음의 시점으로 바로 이동한다. jest.runOnlyPendingTimers() - 현재 대기중인 타이머에 대해서 그 타이머를 실행시킨 다음의 시점으로 바로 이동한다. jest.advanceTimersByTime(msToRun) : 타이머를 지정한 millisecond만큼 실행시킨 다음의 시점으로 바로 이동한다. 단, 리액트 컴포넌트 안에서 시간 관련 메서드를 쓰게 되어 렌더링과 관련이 있다면, fake timer를 @testing-library/react-hooks 의 act 메서드로 감싸줘야 한다. Ref https://davidwcai.medium.com/react-testing-library-and-the-not-wrapped-in-act-errors-491a5629193b Antd 디자인 철학 10가지 - 근접성 (Proximity) 정렬 (Alignment) 대조 (Contrast) 반복 (Repetition) 직관적으로 만들어라 (Make it Direct) 화면에 머물러라 (Stay on the Page) 가볍게 유지하라 (Keep it Lightweight) 가이드를 제공해라 (Provide an Invitation) 트랜지션을 사용하라 (Use Transition) Ref https://ant.design/docs/spec/proximity react-router-dom의 Outletreact-router-dom의 &lt;Outlet /&gt;을 사용하면 공통으로 사용할 Layout 등을 정의할 수 있다. 1234567891011// Layout.tsximport { Outlet } from 'react-router-dom';const Layout = () =&gt; {return ( &lt;Layout&gt; &lt;Outlet /&gt; &lt;/Layout&gt; )} 1234567891011// App.tsxconst App = () =&gt; { return ( &lt;Routes&gt; &lt;Route element={&lt;Layout /&gt;}&gt; &lt;Route path=&quot;/&quot; element={&lt;Main /&gt;} /&gt; &lt;Route path=&quot;/dashboard&quot; element={&lt;Dashboard /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; );}; 타입스크립트 template literal의 제약typescript의 template literal type도 union type으로 정의되기 때문에, 너무 많은 경우의 수를 넣을 경우 에러가 발생한다. 타입이 약 40만개 정도로 정의될 때 에러가 발생하며, TS 버전이 높아질수록 더 많은 타입을 커버하고 있는 것으로 보인다. 12345type Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;type Chunk = `${Digit}${Digit}${Digit}${Digit}`type PhoneNumberType = `010-${Chunk}-${Chunk}`; // 🚨 Error : `Expression produces a union type that is too complex to represent.` 타입스크립트에서 enum 사용 vs 반대이전에도 자주 본 글인데, 언어가 지원하는 문법을 어떻게 사용해야 하는지에 대한 선배 개발자 분들의 열띤 토론을 훔쳐볼 수 있는 영광스러운 기회(!)를 얻었다. 우선 위 글에서의 주장과 같이 트리셰이킹의 문제를 방지하기 위해 enum 사용을 지양해야 한다는 입장. enum 의 존재 의의는 타입의 역할을 수행한다는 것과 리버스 룩업이 가능하다는 것인데, 타입은 레코드로도 충분히 표현할 수 있고, 많은 수의 용례는 ‘열거형’의 성질을 전혀 활용하지 않고 단순 딕셔너리 수준에서 끝나지 않나? 그래서 결국 const enum과 같은 문법이 나온 것이다. 또 빌드 대상인 자바스크립트에 enum이 생기는 상황이 오지 않는 이상, 타입스크립트의 enum과 네이티브/바이트코드 컴파일 언어의 enum을 동일한 개념으로 생각하면 곤란하다. 이에 대한 반대(?) 의견. enum은 프로그래밍 언어에서 사용되는 값의 집합을 나타내기 위한 선택지로서, 타입스크립트에서 지원하는 문법이다. enum의 사용이 타입스크립트 컴파일 시 트리셰이킹이 되지 않는다는 문제가 있어 Union Type이라는 선택지를 제공하고 있지만, 이게 맞는 것인지는 생각해봐야 한다. 의미론적으로 ‘열거(enum)’와 ‘조합(union)’은 다르기 때문이다. 그러나 열거해야 하기 때문에 enum을 쓸 것이라면 Object.freeze() 또는 as const 문법을 사용할 수도 있다. 열거도 되고, 인덱스 접근도 되고, 사용법도 같기 때문이다.물론 트리셰이킹이라는 개념과 그렇게 할 수밖에 없는 환경 자체가 에러지만, 그게 타입스크립트의 독자적인 문법이 아닌, enum과 같은 모든 프로그래밍 언어에서 쓰이는 개념이라면 사실 개발자 수준에서 이를 바꾸기보다 언어적인 지원에서 스펙트럼이 넓혀져야 하는게 맞다. 그렇기에 정말 성능적으로 커다란 이슈가 없다면 enum을 써도 무방하다. 결국에 시장 진입을 하는 사람들이 이 글에서 쓰이는 그러한 문제를 인지하고 const enum나 Object.freeze()를 쓰는 것은 문제다. 타입스크립트에서 enum을 지원한 이상, 생태계적으로 enum에 대한 문제는 잡힐 수 밖에 없다. 많은 사람들이 타입스크립트를 쓰고, 이 부분은 해결을 아에 못하는 부분은 아니라고 생각한다. 그리고 어떤 근-본적인 말씀. 언어, 컴파일러, 런타임의 삼권 분립 체제에서 개발 시점에 컴파일러, 런타임에서의 이슈를 가정하여 코딩하지 말라는 것은 모든 언어에서, 수십년간 공학적으로 쌓인 경험에서 나오는 룰이다. 마이크로 옵티마이즈는 그로 인한 성능 이점이 명확하고 클 때만 적용해야 한다. 위 관점에서 바라보시는 enum의 트리셰이킹 논란은 다음과 같이 정리된다. 최적화만 생각해서 올라가다 보면 enum 이슈 외에 아주 많은 성능 관련 이슈들이 있다. enum은 타입 중에 하나이고 그것이 자바스크립트에서 어떻게 동작하든지 상관없이 열거형 정보들을 처리하는 추상화된 타입이다. 그 나름의 역할이 있고 매우 유용하나 다른 타입들과는 다르게 역참조가 있어서 자바스크립트 코드까지 생성되는 것이 다른 타입들과 차이가 있다. 이 이슈가 실제 서비스에서 성능적으로 크게 문제가 있다면 타입스크립트를 들여다보고 해결해서 타입스크립트 프로젝트에 백포트하는 것이 좋다고 생각합니다. 문제 해결은 본질적인 방법으로 접근해야지 코드 레벨의 추상화를 저해하는 방식은 추천하지 않는다! MobX 여러 버전 사용하기하나의 프로젝트에서 서로 다른 두 버전의 MobX를 사용하려면 아래의 configure({ isolateGlobalState: true }) 옵션을 설정해주어야 한다. 위 옵션을 활성화하면, 동일한 환경에서 여러개의 MobX 인스턴스가 활성화 되어있는 경우, 서로의 전역상태를 격리한다. (두 인스턴스의 옵저버블이 따로 작동한다) 옵션을 비활성화하면 ({ isolateGlobalState: false }), 두 인스턴스의 옵저버블이 함께 작동한다는 장점이 있지만 두 MobX의 버전이 일치해야 한다. AOS 허용 밀고당기기AOS에서 ‘이번만허용’은 앱을 껏다킬때마다 권한을 요청하겠다는 의미가 아니라, 일정시간동안 앱을 껐다 켜도 권한을 물어보지 않겠다는 의미다. 반대로, ‘허용안함’은 never_ask_again의 의미로 다시는 해당권한을 물어보지 않는다. (설정을 다시 켜고 싶다면, 설정 &gt; 어플리케이션에서 권한을 켜주도록 대응해야 한다.) validation vs verification validation은 사용자 중심의 시스템 검증 과정 최종적으로 만든 결과물이 잘 나왔는지 검증 사용자에 대한 요구 사항을 충족하는가 verification은 개발자 중심의 시스템 검증 과정 무언가를 만드는 과정을 잘 지켰는지를 검증 스펙에 대한 요구사항을 충족하는가 BFF (Backend for Frontend) 기존 API 구조 여러 플랫폼에서 동일하게 API 호출하는 문제 앱에서 사용하지 않는 불필요한 데이터 포함 CORS 이슈, 엔드포인트 이슈 등 BFF 구조 하나의 프론트엔드에 대해 하나의 BFF BFF를 프론트엔드 요구사항에 맞게 구현 가능 여러 플랫폼을 지원하지 않을 경우 BFF가 의미 없을 수도 있다. BFF는 하나의 아키텍쳐일 뿐, 실제 구현체가 필요하다! ex) graphql 데이터를 브라우저 캐시 대신 라이브러리에서 제공해줌 최적화되어있어 request 개수가 줄어듦 모바일-웹 서로 다른 에이전트에서 동일한 API를 사용할 수 있다 → 실제 비즈니스 로직의 구현과 응답 데이터를 클라이언트에서 요구되는 데이터로 파싱하는 두 가지 관점을 분리하여 복잡도를 낮추고, 필요한 작업에 집중하기 쉬워진다! Ref 카카오페이지는 BFF(Backend For Frontend)를 어떻게 적용했을까? BFF(Backend for Frontend) 란? createBrowserHistoryreact-router-dom의 &lt;BrowserRouter&gt; 는 history 객체를 자동으로 생성한다. 이때 &lt;BrowserRouter&gt; 컴포넌트는 &lt;Router&gt; 컴포넌트를 렌더링할때 props 로 history 객체를 전달하는데, 이 객체는 history 패키지의 createBrowserHistory() 함수를 호출함으로써 생성된다. Ref react-router 및 history React Router: Declarative Routing for React HTML rolediv 태그에 onClick과 같은 이벤트 핸들러를 붙이면 다음과 같은 린트 워닝이 뜬다. 1Static HTML elements with event handlers require a role. 아무래도 시멘틱한 HTML 설계에 위반돼서 그런가보다. 불가피하게 사용하는 경우에는 role=&quot;button&quot; 등을 붙여주는 것이 좋다. Ref eslint-plugin-jsx-a11y/no-static-element-interactions.md at 287854abd066704e2a9964da597e7ab7f6f7e2ad · jsx-eslint/eslint-plugin-jsx-a11y 이것저것 event.istrusted - 해당 이벤트가 사용자의 동작에 의해서 발생했는지(true), 스크립트에 의해 발생했는지(false) 알 수 있다 $0 - 브라우저에서 디버깅 시 현재 선택된 DOM을 바로 가져올 수 있다. react hook을 테스트할 때는 @testing-library/react-hooks 의 renderHook 메서드를 통해 훅을 호출해야 한다.1const { result } = renderHook(() =&gt; useMyHook(params)); jest config에서 testEnvironment을 jsdom 으로 설정할 수 있는데, 이는 가상의 브라우저 환경에서 테스트를 돌리겠다는 뜻이다. testEnvironment을 node로 설정하면 노드 환경에서 돌리게 된다. Fastlane - IOS 빌드, 배포 자동화를 위해 사용되는 툴 mobX 전역 상태 타입이 optional이면 상태의 변화가 일어나더라도 구독하는 컴포넌트가 업데이트 되지 않을 수 있다. Optional보다는 Nullable로 사용하자. 삼성인터넷은 기기가 다크모드이면 자기 마음대로 색상을 변경시킨다. prefers-color-scheme 과 메타태그도 동작을 안하며, window.matchMedia('(prefers-color-scheme:light)').matches 로 다크모드 감지가 안된다. 🤯 iOS에서 deeplink url의 한글 파라미터를 따로 인코딩해주지 않으면 제대로 동작하지 않는다. iOS 사파리에서는 딥링크 혹은 앱스토어로 리다이랙트 시킬 때 자체적인 팝업을 띄워 한번 더 확인한다. 이때 window.blur가 발생한다. :first-letter 선택자로 첫 글자에만 스타일을 지정할 수 있다. 123p:first-letter { color: #ffffff} :where() presudo-class로 여러 요소에 공통된 스타일을 적용할 수 있다. 1234567891011/* where() 미사용 */.page div,.paget .title,.page #article { color: red;}/* where() 사용 */.page :where(div, .title, #article) { color: red;} 이미지가 깨지는 현상을 방지하기 위해 화면에 보이는 것보다 2배 큰 사이즈를 원본으로 사용하면 좋다. 기타오프라인으로 돌아온 FECONF 2022Ref https://2022.feconf.kr/ ECMA 2022 승인오~ 이런게 승인되는 순간은 또 처음보는 것 같다. 2022년 6월 22일이라니. 일부러 날짜를 맞춘 건가 🤔 ECMAScript 2022에서 새롭게 추가되는 feature들은 다음 블로그 글에서 더 자세히 볼 수 있다. 몇 가지만 살펴보자. class에 새로운 멤버 추가 12345678910111213141516171819class MyClass { instancePublicField = 1; static staticPublicField = 2; #instancePrivateField = 3; static #staticPrivateField = 4; #nonStaticPrivateMethod() {} get #nonStaticPrivateAccessor() {} set #nonStaticPrivateAccessor(value) {} static #staticPrivateMethod() {} static get #staticPrivateAccessor() {} static set #staticPrivateAccessor(value) {} static { // Static initialization block }} 자바스크립트가 점점 타입스크립트스러워지는 것 같다. 이러다 자바스크립트는 아예 없어질 수도…? (나쁘지 않음) Top-level await 1234// my-module.mjsconst response = await fetch('https://example.com');const text = await response.text();console.log(text); 이건 사실 이미 되는 줄 알고 있었지 모야… at() 메서드 1234&gt; ['a', 'b', 'c'].at(0)'a'&gt; ['a', 'b', 'c'].at(-1)'c' 이런 게 나올지도 모른다고 했었는데, 정말 된다니! 이제서야 나오다니… 알고리즘적으로 많이 잡아먹지 않는 건지도 궁금하다. 배열의 원소가 만약 1억 개라면..? 😵 Ref https://www.ecma-international.org/news/ecma-international-approves-new-standards-6/ 마무리이번주는 아무래도래도… 전사행사가 있었다! 기대되는 듯 안되는 듯 시간은 슝 지나가고 금요일이 와버렸다. 행사를 준비해주신 분들이 저어어엉말 고생하셨을 것 같다. 뭐 하나 허투루 하는 게 없는 배민… 귀엽고 아기자기 키치하고 섬세하고 웅장해지고 너무너무 재밌었고 알찼다. 카더가든 씨 얼굴은 처음 본다. &lt;나무&gt; 노래 엄청 좋아해서 프뮤로도 해뒀었는데 ㅋㅋ 다른 노래들도 엄청 좋았다! 찾아들어봐야겠다. 입담이 유쾌한 아재라던데 정말 중간중간 멘트가 은은하게 웃겨서 재밌게 즐겼당. 카더가든 말처럼, ‘자기들끼리 진짜 잘 노는구나’가 딱 어울리는 말인 것 같다. 사진은 어디 외부에 올리지 말라고 하셔서.. 🤔 나중에 회사 공식 유튜브에 올라오면 또 재미나게 추억을 즐길 수 있을 것 같다. 회사뽕 차던 하루 👍🥳","link":"/2022/06/25/2022-6-week-4/"},{"title":"7월 1주차 기록","text":"여름이닷 배워가기URL에서 pathname, parameter 가져오기URL에서 pathname, parameter를 우아하게 가져올 수 있다. 123456// URL 사용하지 않고 특정 path를 가져올 때const { pathname } = window.locationconst path = pathname.split(&quot;/&quot;)[1]// URL을 사용해서 가져올 때const { pathname } = new URL(window.location.href) Ref https://developer.mozilla.org/en-US/docs/Web/API/URL inner border line 그리기inner border line을 그리고 싶을 때, 일반적으로 box-sizing: border-box를 사용하는데, 해당 케이스는 width나 height이 특정값으로 고정되어있을 때만 inner-border-line이 생긴다. width, height이 auto 값으로 쓰여지는 경우가 생기면 예상과는 다르게 outside-border-line이 생긴다. 이런 경우에는 box-shadow로 inner-border-line을 만들 수 있다. useImperativeHandleuseImperativeHandle은 ref를 사용할 때 부모 컴포넌트에 노출되는 인스턴스 값을 사용자화(customizes)한다. (즉 ref를 사용하는 부모 측에서 커스터마이징된 메서드를 사용할 수 있게 해준다.) forwardRef와 함께 사용되는 훅이며, 새로운 ref에 커스터마이징 작업을 할 수 있다. 아래 예시에서처럼 FancyInput 컴포넌트를 사용하는 곳에서 커스터마이징된 값을 이용할 수 있다. 123456789101112131415161718192021function FancyInput(props, ref) { const inputRef = useRef(); useImperativeHandle(ref, () =&gt; ({ focus: () =&gt; { inputRef.current.focus(); } })); return &lt;input ref={inputRef} ... /&gt;;}FancyInput = forwardRef(FancyInput);// FancyInput 컴포넌트를 사용하는 곳function FancyForm() { useEffect(() =&gt; { inputRef.current.focus(); // ✅ FancyInput의 `useImperativeHandle` 내 `focus` 함수를 실행한다. }, []) return ( &lt;FancyInput ref={inputRef} /&gt; )} Ref https://ko.reactjs.org/docs/hooks-reference.html#useimperativehandle &lt;a download/&gt;&lt;a /&gt; 태그에 download 속성을 넣으면 href 경로에서 파일을 다운 받을 수 있는데, 해당 경로의 파일이 이미지라면 미리보기를, docx같은 파일이면 바로 다운로드 창이 뜬다. 이미지 또한 바로 다운로드창을 띄우고 싶으면 해당 경로에 대해 fetch를 사용해서 응답값을 받고, blob, URL, createObjectURL 등을 사용해서 링크를 새로 만들어서 받아온다. 123456789fetch(url, { mode: 'no-cors' }) .then((response) =&gt; response.blob()) .then((blob) =&gt; { const blobUrl = window.URL.createObjectURL(blob) const a = document.createElement('a') a.download = fileName || 'download' a.href = blobUrl a.click() }) Basic AuthBasic Auth는 하나의 HTTP 인증 방식이다. username과 pw를 Base64 인코딩 해서 Basic -의 형식으로 보내는 방식이다. 헤더에 Bearer AccessToken 보내는 방식과 유사하지만, Basic Auth 방식에서는 username, pw을 axios 요청에 넣어주면 axios가 알아서 Base64로 인코딩 처리해준다. 그후 요청을 열어보면, Authorization: Basic ZGVtbzpwQDU1dzByZA==과 같은 형식으로 들어가 있다. Ref https://stackoverflow.com/questions/34013299/web-api-authentication-basic-vs-bearer shell command 이것저것 chmod +x - 실행권한을 부여하는 명령어이다. grep - 현재 프로젝트에서 특정 문자열의 위치들을 찾을 수 있다. (vs code 검색기능이랑 동일) 12# -I 는 binary 파일 제외, r은 재귀적으로 탐색, n은 라인넘버 추출, w는 단어가 whole matching인 것만grep --exclude-dir={&quot;/User/...&quot;, ...} -I -rnw &quot;${brosMobileDir}&quot; -e &quot;$imageName&quot; wc -w - 문자열의 word 매칭개수를 반환한다. tr -d ' ' - trim 기능을 구현할 수 있다. superstruct의 assign()superstruct 의 assign() 유틸 함수는 자바스크립트의 Object.assign()과 유사하지만 첫번째 파라미터로 전달된 것과 동일한 구조체를 반환한다. 12345678910111213141516const schema = assign( type({}), // ✅ 첫번째 파라미터가 type이기 때문에, 아래 구조체는 type이 된다. object({ name: string(), walk: func(), }))const obj = { name: 'Jill', age: 37, race: 'human', walk: () =&gt; {},}assert(obj, schema) // OK 타입스크립트 어서션(assertion)타입스크립트에서 타입가드를 위해 is를 사용할 수도 있지만, asserts 키워드와 함께 사용해서 에러를 throw하는 방식으로도 타입가드를 할 수 있다. 12345678910111213141516171819const assert = (v: unknown): v is string =&gt; { return typeof v === 'string'}const assert2 = (v: unknown): asserts v is string =&gt; { if (typeof v !== 'string') throw Error()}function fn(v: unknown){ if (assert(v)) { console.log(v) // ✅ 여기서 v의 타입은 string이 된다 } // ✅ v가 string이 아니라면 Error를 throw한다. // ✅ v가 string이라면 런타임에서 문제가 없지만, 이후에 v의 타입이 string이 된다 assert2(v) console.log(v) 위에서 throw Error가 되지 않으면 v는 string} forwardRef에서 children이 되지 않는 이유forwardRef를 사용한 아래 예시 코드를 살펴보자. 12345678910111213141516171819202122232425262728import React, { useRef } from 'react';interface ChildProps { message: string;}const ChildComponent = React.forwardRef&lt;HTMLInputElement, ChildProps&gt;((props, ref) =&gt; { const { message, children } = props; return ( &lt;div&gt; &lt;input ref={ref} /&gt; &lt;span&gt;{message}&lt;/span&gt; {children} &lt;/div&gt; );});const ParentComponent = () =&gt; { const inputRef = useRef&lt;HTMLInputElement&gt;(null); return ( // 🚨 Property 'children' does not exist on type 'IntrinsicAttributes &amp; ChildProps &amp; RefAttributes&lt;HTMLInputElement&gt;' &lt;ChildComponent message=&quot;hello child&quot; ref={inputRef}&gt; &lt;div&gt;children을 넣어주고 싶어요&lt;/div&gt; &lt;/ChildComponent&gt; );}; ParentComponent에서 ChildComponent를 렌더링할 때, ChildComponent에 children prop을 끼워넘기면 에러가 발생한다. 물론 ChildProps에 children: React.ReactNode를 명시적으로 넣어서 해결해줄 수도 있지만, forwardRef의 타입 시그니처가 아래와 같이 되어 있어서 children을 명시해주지 않아도 children prop이 자동으로 들어갈 것이라고 생각했다. 12345678function forwardRef&lt;T, P = {}&gt;(render: ForwardRefRenderFunction&lt;T, P&gt;): ForwardRefExoticComponent&lt;PropsWithoutRef&lt;P&gt; &amp; RefAttributes&lt;T&gt;&gt;;interface ForwardRefRenderFunction&lt;T, P = {}&gt; { (props: PropsWithChildren&lt;P&gt;, ref: ForwardedRef&lt;T&gt;): ReactElement | null; displayName?: string | undefined; defaultProps?: never | undefined; propTypes?: never | undefined;} forwardRef의 인자로 들어가는 render() 함수의 타입인 ForwardRefRenderFunction의 타입 시그니처에는 (props: PropsWithChildren&lt;P&gt;)가 있지 않은가? 🤔 이 문제로 몇날을 속썩이다가, 동기가 한 의견을 제시해주었다. forwardRef의 타입 시그니처 function forwardRef&lt;T, P = {}&gt;에서 P에 children이 없다면, forwardRef의 리턴 타입인 &lt;PropsWithoutRef&lt;P&gt; &amp; RefAttributes&lt;T&gt;&gt;에도 children이 들어가지 않을 것이다! render() 함수의 인자 타입이 PropsWithChildren&lt;P&gt;이라는 사실에만 꽂혀서, 리턴 타입을 보지 못했던 것이다! 😵 esconfig.ts의 typescript rules “off” - 0 (rule을 완전히 끈다.) “warn” - 1 (rule을 켜두긴 하지만, linter가 실패하진 않는다.) “error” - 2 (rule을 켜두며, linter가 실패한다.) @typescript-eslint/eslint-plugin에서 지원하는 rules@typescript-eslint/eslint-plugin Ref How to use ESLint with TypeScript | Khalil Stemmler 함수 파라미터는 반변한다는 사실의 쉬운 예시12345let items = [1, 2, 3];// Don't force these extra parametersitems.forEach((item, index, array) =&gt; console.log(item));// Should be OK!items.forEach((item) =&gt; console.log(item)); 보통의 경우 타입스크립트에서 타입 체크는 초과 속성을 허용하지만(공변), 함수의 인자 타입은 그 반대로 동작한다. (반변) forEach() 메서드를 보면 알 수 있는데, item, index, array 3가지의 인자를 모두 사용하지 않더라도 forEach() 함수의 콜백 인자로 넘겨줄 수 있다! Ref Documentation - Type Compatibility package-lock.json의 lockfileVersion 1: npm v5와 v6에서 사용하는 lockfileVersion 2: npm v7에서 사용하는 lockfileVersion으로, v1 lockfiles과 호환된다. 3: npm v7에서 사용하는 lockfileVersion으로, 이전의 버전들과 호환되지 않는다. node_modules/.package-lock.json의 숨겨진 lockfile에서 사용되며, npm v6 지원이 더 이상 필요하지 않을 때 npm의 추후 버전에서 사용될 것이다. Ref package-lock.json의 lockfileVersion에 대해 - Development Notes package-lock.json | npm Docs 이것저것 RN 테스트코드를 작성할 때에는 OS도 모킹해줘야한다. OS를 모킹하지 않으면 mac 로컬에서는 iOS로 인식하여 통과하지만, CI에서는 iOS가 아니라서 Fail이 될 수 있다. android studio로 에뮬레이터를 돌릴 때, 갤럭시 기기와 에뮬레이터 사이즈를 비교해보고 싶다면 https://developer.samsung.com/galaxy-emulator-skin/galaxy-s.html 에서 확인할 수 있다. 스킨도 다운받아서 에뮬레이터를 갤럭시처럼 꾸밀 수도 있다. 스크린 리더가 필요할 때 Mac 기준 - 시스템 환경설정 → 손쉬운 사용 → VoiceOver 를 사용하면 된다. nvm use - 현재 터미널에서의 node 버전을 변경하는 명령어이다. 새로운 터미널에서도 지정한 node 버전을 유지하려면 nvm alias default 로 지정해야 한다. uuid는 universally unique identifier의 약자로, ‘범용 고유 식별자’를 의미한다. jest 에서 실제 라이브러리의 일부만 모킹해줄 수 있다.12345678// redux mocking jest.mock('react-redux', () =&gt; { const actualRedux = jest.requireActual('react-redux'); return { ...actualRedux, useDispatch: jest.fn };}); touchstart, touchmove, touchend 이벤트가 발생하였을 때 event.preventDefault()를 호출하여 해당 event를 cancel하면 이후의 click 이벤트가 발생하지 않는다. (Ref) safari on iOS에서 체크박스 를 빠르게 클릭 시 좌표가 보정되는 이유는, dblclick 이벤트 핸들러가 설정되어 있기 때문이다. (react 에서는 root element에 모든 이벤트 핸들러를 등록해두기 때문에, 의도치않게 항상 dblclick 이벤트 핸들러가 설정되어 있다.) (Ref) jest.mock()의 3번째 인자로 { virtual: true } 를 주면 mocking하려던 모듈이 자바스크립트 상에 존재하지 않아도 모킹할 수 있다. (ex. RN에서 native module) DOM Tree를 순회할 수 있는 API가 존재한다. (Ref) 인터페이스 설계는 상황이 변경됨(추가, 수정, 삭제)에 따라 좌지우지 되면 안된다. 설계 초기에는 상황을 잘 모르거나, 달라질 수 있는 부분이 많이 존재하기 때문에 다 열어주는 형식으로 만들어서 추후 변경에 취약하지 않게끔 설계해야한다. storybook은 preview iframe을 입맛대로 다룰 수 있게 html을 사용할 수 있게 지원해준다. .storybook 폴더 아래에 preview-body.html 과 preview-head.html 을 만들어서 적절히 사용할 수 있다. storybook 에서 addons panel이 사라져 안보이는 경우가 cache로 남아서, controls 등 인터렉티브를 다룰 때 불편해질 수 있는 상황이 있다. 이는 스토리북의 고질적인 문제이며 localStorage.clear()를 통해 해결할 수 있다. storybook의 preview-body.html에 script로 localStorage.clear() 해주는 코드를 추가하면 이 동작을 자동화할 수 있다. @storybook/addon-viewport 라이브러리를 통해 기본적인 (갤럭시, 아이폰, 태블릿 기종별) 모바일 view에서 디자인을 확인할 수 있다. 추가적으로 사이즈를 커스텀해서 등록할 수 있는 기능도 포함되어있다. CRA 환경에서 ESBuild 를 사용하면(craco-esbuild plugin) babel 을 esbuild 로 대체하기 때문에 babel 구성이 사용되지 않는다. issue질문에 대한 답에 따르면 babel-loader 와 esbuild-loader 를 동시에 사용하는 신박한 방법이 있는데, esbuild 사용의 속도 이점을 누릴 수 없기 때문에 권장하지 않는 방법이라고 한다. 기타ESBuild차세대 자바스크립트 번들러로, 문서에 따르면 webpack5 보다 125배 빠르다고 한다. (5^3…? 😲) Ref https://github.com/evanw/esbuild Playwright모든 브라우저/플랫폼을 하나의 API로 테스트할 수 있는(?!) e2e 테스트 라이브러리다. Ref https://playwright.dev/ esbuild-kit/tsxts-node 를 대체할 수 있는 타입스크립트 실행 도구로, esbuild 로 컴파일 하기 때문에 빠르다. Ref https://github.com/esbuild-kit/tsx esbuild-loader웹팩 내 빌드 속도 향상을 위한 툴이다. ESBuildMinifyPlugin 이 내장 되어있어 TerserPlugin, CSSMinimizerPlugin 등 파일 축소를 위해 직접 사용했던 플러그인들을 대체할 수 있다. next.js 12.2아직 Next를 제대로 써본 않았지만~미들웨어를 여러 개 정의할 수 없는 꽤 큰 변화가 있었다고 한다! Ref https://nextjs.org/blog/next-12-2 Fresh 1.0Frech stable 첫 번째 버전으로, Deno를 위한 풀스택 웹 프레임워크라고 한다. 클라이언트에 자바스크립트 코드를 보내지 않는다는데, 정체가 뭐지? CSR은 상당히 무겁고, 몇몇 새로운 프레임워크들은 SSR을 지원한다. 하지만 대부분의 경우 모든 렌더링을 클라이언트에 위임하기 때문에 UX 경험이 좋지 않다. Fresh는 클라이언트에 자바스크립트를 전달하지 않는다! 대부분의 내용은 서버에서 렌더링이 끝나며, 클라이언트는 아주 작은 양의 상호작용만 맡게 된다. 서버에서는 JIT 방식의 렌더링을 제공하며, Fresh를 이용하여 서버 데이터를 불러오는 코드도 작성할 수 있다. 그리고 클라이언트에서는 Islands라고 불리는 컴포넌트를 사용하는데, 이들은 클라이언트에서 re-hydration된다. Preact(!)와 JSX를 사용하는 상당히 fancy한 프레임워크이며, 라우팅은 Next.js를 흉내낸, 믹스덩어리같아 보인다. Ref https://deno.com/blog/fresh-is-stable https://fresh.deno.dev/docs/introduction stackoverflow 2022Ref https://survey.stackoverflow.co/2022/ JSconf 2022노들섬~ 짱 가깝다 😆 Ref https://2022.jsconf.kr/ko 마무리너어어어무 덥다! 가 아니고 습하다! 밖에 거의 나가지 않는데도, 잠깐만 나가는 순간 바로 집 가고 싶어진다. 어쩔 수 없는 여름… 오랜만에 멋사 운영진들을 만났다. 다들 어엿한 직장인이 되어 비슷한 고민들 생각들을 나누고 있었다. 그래도 여전히 초딩같은 생각과 말과 웃음포인트들이 남아있어서 즐거웠던 시간 ☺️","link":"/2022/07/02/2022-7-week-1/"},{"title":"7월 2주차 기록","text":"npm 용서못해… 배워가기루틴 vs 코루틴 루틴: 진입하면 반드시 반환까지 한 번에 실행됨 코루틴: 진입한 뒤 중간에 반환하고 다시 그 위치부터 재시작 가능 자바스크립트에서는 yield, await 같은 특정 키워드나 약속된 함수를 호출하는 부분을 기준으로 서브루틴을 나눈다. 반면, Kotlin에서는 suspend 함수를 호출하는 위치를 기준으로 서브루틴을 나눈다. Next.js redirectsNext.js를 사용할 때 next.config.js 파일에 다음과 같은 redirects 옵션으로 특정 경로에 대한 리다이렉션을 설정할 수 있다. 123456789redirects: () =&gt; { return [ { source: &quot;/&quot;, destination: &quot;/packages&quot;, permanent: true, }, ];}, Next.js useRouterNext.js의 useRouter 가 리턴하는 NextRouter 는 유용하게 사용할 수 있는 여러 메서드들과 값들이 담겨있어서 편하게 사용 가능하다. 12345678910111213export declare type BaseRouter = { route: string; pathname: string; query: ParsedUrlQuery; asPath: string; basePath: string; locale?: string; locales?: string[]; defaultLocale?: string; domainLocales?: DomainLocale[]; isLocaleDomain: boolean;};export declare type NextRouter = BaseRouter &amp; Pick&lt;Router, 'push' | 'replace' | 'reload' | 'back' | 'prefetch' | 'beforePopState' | 'events' | 'isFallback' | 'isReady' | 'isPreview'&gt;; 스냅샷 테스트jest render의 반환값을 json으로 바꿔서 스냅샷 테스트를 할 때, RangeError: Invalid string lengthError: Invalid string length 에러가 뜨는 경우가 있다. jest내부의 prettier-format에서 JSON.stringify 값 내에 엄청나게 긴 string을 넣으면 나는 오류다. 그런데 react-test-renderer로 스냅샷을 생성하면 정상 동작한다. 그럼 jest의 render와 react-test-renderer가 같지 않다고 생각해볼 수 있다. 스냅샷의 문자열이 워낙 길다보니 테스트 코드때문에 컴퓨팅 비용이 많이든다고 생각할 수 있는데, jest는 처음부터 성능을 염두에 두고 작성되었고 스냅샷 테스트도 그렇다고 한다. txt파일이고 사이즈도 작은편(300kb미만)이라서 빠르고 안정적이라고 한다. 🐸 스냅샷 테스트는 TDD보다는 코드변경 이후 변경사항이 어떤것인지를 파악하는데 유리하다. Ref https://jestjs.io/docs/snapshot-testing#:~:text=Jest%20has%20been,than%20300%20KB. jest의 import aliasimport alias를 사용하는 파일에서 테스트를 하기 위해서는 jest.config.js에서 해당 alias에 대한 모듈 경로를 맵핑 해주어야 한다. 12345// jest.config.jsmoduleNameMapper: { // import &quot;@@module/models/...&quot; &quot;@@module/(.*)$&quot;: '&lt;rootDir&gt;/packages/my-module/src/$1'} Promise 함수의 argument 실행 순서Promise 함수에서는 argument가 먼저 판별되어야 함수가 실행된다. 다음 코드를 살펴보자. 1234567891011121314151617181920212223242526272829const d = async () =&gt; { try { const a = await Promise.all([b(), await c()]); console.trace(a, 5); } catch (e) { console.error({ e }); console.error(6); }};const b = () =&gt; new Promise((resolve, reject) =&gt; { console.trace(1); setTimeout(() =&gt; { console.trace(2); reject('b'); }, 2000); });const c = () =&gt; new Promise((resolve, reject) =&gt; { console.trace(3); setTimeout(() =&gt; { console.trace(4); reject('c'); }, 1000); });d(); Promise.all() 함수에서, argument가 먼저 판별되어야 함수가 실행된다. 코드의 최상단 함수 d()의 호출에서, Promise.all()의 인자인 b()는 실행이 되었다. 그러나 await c()가 판별 중 에러가 발생하여 Promise.all()이 실행되지 못한다. 따라서 b()의 Rejection을 Promise.all()이 해결해주지 못한다. 이 경우 14까지는 Warning(UnhandledPromiseRejectionWarning), 15부터는 Error로 처리되어 UnhandledPromiseRejection가 발생한다. 위 코드는 결국 아래의 코드와 동일하게 동작한다. (위 코드에서의 Promise.all()은 실행되지 못했기 때문) 1234567891011const d = async () =&gt; { try { b(); // ⬅️ await c(); // ⬅️ console.trace(a, 5); } catch (e) { console.error({ e }); console.error(6); }}; ++a/a++과 같은 연산의 우선순위, 비동기문맥/동기문맥이 어떻게 흘러가는지 알 수 있는 좋은 예제다! aws cli의 옵션aws cli 중 mv, cp, rm 은 하나의 파일에 대해서만 적용 가능하다. 여러 파일에 대해서 적용하고 싶다면 -exclude, -include, -recursive 옵션을 적용하면 된다. 다만, -recursive 옵션을 사용하면 해당 path 내의 서브 디렉토리까지도 포함하게 되어서, flat한 디렉토리 구조가 아닌 경우에는 불필요한 파일이 필터링될 수 있다. Ref https://docs.aws.amazon.com/cli/latest/reference/s3/index.html#use-of-exclude-and-include-filters flex 정렬 주의사항css flex 정렬 시, 2개의 요소에 각각 정확한 50% 너비를 줄 때 flex: 1 값을 활용할 수 있다. 하지만 하나의 요소에는 border-line이 그려져있고 하나의 요소에서는 border-line이 그려져있지 않을 때, border 크기에 의해서 두 요소가 정확하게 반반으로 너비가 정해지지 않는다. 이때 border line을 box-shadow로 그려줌으로써, 정확하게 반반 너비로 나눠줄 수 있었다. 또는 flex: 50%으로 설정하면 된다. Next.js의 Custom DocumentNext.js의 Document를 수정하여 html, body, head 등 HTML 마크업을 업데이트할 수 있다. 서버에서만 렌더링되므로 이벤트 핸들러 등을 사용할 수는 없다. 서버에서만 렌더링 되기 때문에 pages/_document.tsx 에 &lt;title&gt; 태그를 추가할 수 없다. 이때 &lt;meta name=”viewport” …&gt; 뷰포트 메타태그는 중복 제거를 할 수 없으므로 pages/_app.tsx에서 next/head로 처리한다. 😮 실제 프로젝트에서는 favicon 관련 태그(link, meta)는 pages/_document.tsx 에, title 및 뷰포트 등은 pages/_app.tsx 에 넣어서 사용했다. Ref https://nextjs.org/docs/messages/no-document-title https://nextjs.org/docs/messages/no-document-viewport-meta react-hook-form 이것저것 react-hook-form의 reset은 현재 value를 단순히 변경하는 게 아니라, useForm 내에 있는 defaultValue를 재설정하는 것이다. useForm의 옵션인 shouldUnregister는 input이 unmount될 때 name에 대응하는 값을 react-hook-form의 데이터에서도 함께 제거한다. 단, defaultValue값이 변경되는 것이 아니라 onSubmit 함수에 전달되는 result에서 제거된다. I-prefix, yes or no🙂 YES 이름짓기 편하다. (e.g. Button, IButton) 에디터 인텔리센스로 자동완성하기 편하다. 타입스크립트가 주는 개발편의성은 IDE의 기능에 굉장히 의존적인 편이다. prefix를 붙임으로써 IDE에서 타입스크립트를 사용하기 더 편해질 수 있다. (개발 편의성이 올라간다.) Interface만 I를 사용하는 것도 하나의 일관성이 될 수 있다. 🙁 NO 타입스크립트는 공식문서에서 헝가리안 표기를 권장하지 않고 있다. 일관성을 파괴하는 네이밍 컨벤션 하나의 프로젝트 (또는 어떤 다른 기준)에서 snake_case를 사용한다던가, camelCase를 사용한다던가 이런 표기법은 일관성이 가장 중요하다. 다른 변수나 함수 네이밍에는 헝가리식 표기법을 적용하지 않다가, 인터페이스에만 헝가리식 표기법을 적용하는 것은 잘못된 것이다. 컨벤션의 목적과 사용되는 언어가 근본적으로 맞지 않는 문제 자바스크립트와 같은 언어에서 변수 또는 함수에 자료형을 드러내기 위해서 사용하던 헝가리식 표기법을 구조적 타이핑을 기반으로 하는 타입스크립트에 적용하는 것은 좋지 않다. 언어의 컨셉에 맞는 사용에 더 높은 가치를 둘지, 개발 편의성에 더 높은 가치를 둘지의 차이! filter(Boolean)Boolean을 iterator로 사용하여 배열을 믿을 수 있는 상태로 만들어주는 방법이다. false, 0, -0, 0n, &quot;&quot;, null, undefined, NaN 을 제거할 수 있다. 12let array = [false, 0, -0, 0n, &quot;&quot;, null, undefined, NaN, { name: &quot;zig&quot; }];array.filter(Boolean) // [{ name: &quot;zig&quot; }] useEffect의 cleanupuseEffect의 cleanup 함수는 다음 변경이 일어나 업데이트 되기 전 실행되기 때문에, 이를 이용하여 컴포넌트 첫 마운트 시는 제외하고 실행하는 것처럼 보이게(?) 만들 수 있다. 1useEffect(() =&gt; () =&gt; snackbar.success({ description: '성공!' }), [_active] ) useEffect 진입 useEffect 로직 실행 cleanup 함수 등록 (등록만 했기 때문에, 처음에는 아무 동작도 하지 않는다.) _active의 상태 변경 2번 째 useEffect 함수 실행 useEffect 로직 실행 전 등록된 cleanup 함수 실행 useEffect 로직 실행 … pnpm cli에서 패키지 선택pnpm cli에서 특정 패키지가 아니라 패키지 세트를 선택할 때는 따옴표가 없으면 못알아듣는다. 패키지 세트를 선택할 때 쓰는 건 패키지 명이 아니라 glob 패턴이라서 그런 것 같다. pnpm --filter @projects/my-project cli build dev ✅ OK pnpm --filter &quot;@project/*&quot; cli build dev ✅ OK pnpm --filter @project/* cli build dev 🚨 Error Ref https://pnpm.io/ko/filtering#--filter-glob---filter-glob pre-commit-msghusky 라이브러리는 .git/hooks 폴더를 건드리지 않고도 git hook 스크립트를 제어 할수 있게 도와준다. (.git/hooks 폴더는 git으로 기록되지 않는다) Git hook 리스트 중에는 pre-commit-msg 가 있고, prefix 를 붙이는 것과 같이 커밋 메세지를 수정할 수 있다. 쉘 스크립트 명령어를 이용하여 현재의 브랜치가 feature 브랜치에서 작업중이라면 브랜치 이름으로 부터 jira 이슈번호를 가져올수 있다.그냥 커밋메세지를 커밋하면 자동으로 jira 이슈번호를 추가해준다. react 17의 새로운 JSX Transformreact 17 버전부터 새로운 JSX Transform이 도입되었고 (대표적으로 import React from 'react'가 필요 없어졌다.), 이로 인해 react-17 이상 환경에서 사용될 때 babel에서 추가 설정이 필요로 해졌다. 바로 babel 리액트 설정 중 runtime: automatic 옵션을 추가해줘야한다. 이 옵션은 새로운 JSX 형태를 transfile해주는 함수를 자동으로 import 해주는 역할을 해준다. iOS 프로젝트의 구성IOS 프로젝트는 xcode target들의 집합으로 이루어진다. target은 하나의 프로덕트이며, 하나의 프로젝트에서는 여러개의 target으로 이루어져있다. 그래서 IOS 기기 빌드할때 필요한 권한들은 프로젝트 내의 target에 모두 각각 설정해주어야한다. target들은 일반적으로 프로젝트의 빌드 속성을 상속받지만, mac업데이트 후에 상속이 풀리는 경우가 있다. 이것저것 html &lt;a /&gt; 태그의 다운로드 속성은 cross-origin requests를 지원하지 않는다. href의 이미지 파일 경로가 cross-origin이면 바로 다운로드 받지 않고 preview를 띄운다. css revert - 현재 엘리먼트에 캐스캐이딩 된 속성을 style origin으로 되돌린다. 간단히 말해 부모속성으로 돌아가거나, user agent default 상태로 돌아간다. 타입스크립트에서 객체의 value들만 뽑아서 타입으로 사용하는 방법1234567const PATH = { PACKAGES: &quot;/packages&quot;, TEAMS: &quot;/teams&quot;, STATISTICS: &quot;/statistics&quot;,} as const;export type PathNames = typeof PATH[keyof typeof PATH]; test suite - 제스트에서 사용하는 테스트 관련 단위로, 하나 이상의 테스트가 더 큰 단위의 기능을 테스트할 때 이를 묶어 테스트 스위트로 묶을 수 있다. img 태그는 기준선을 가지고 있지 않아서, 기본 vertical-align: baseline 으로 지정된 맥락에서 이미지의 아래쪽 모서리가 텍스트 기준선으로 가게된다. 기타Mobx 라이브러리의 초기 컨셉MobX는 모든 파생(derivation)을 동기적으로 실행한다. 많은 라이브러리에서 반복적으로 떠오르는 문제는 ‘예측가능성(predictability)’이다. 비동기를 사용하는 많은 프레임워크가 코드를 두 번 실행하거나, 딜레이를 두고 실행한다면, 디버깅이 어려워졌다. Flux 패턴, 특히 Redux에서는 실행되는 함수를 추적함으로써 예측가능성의 문제를 타파하여 대중적으로 인기를 얻었다. Redux에서는 불변성을 유지하는 것이 중요하다. 반면 MobX는 조금 더 근본적인 방식의 접근을 취한다. 모든 mutation의 조합과 파생(derivation)은 딱 한번만 실행되어야 한다. 파생은 절대로 stale하지 않으며, 파생의 effect는 모든 observer에게 즉시 알려져야 한다. 예를 들어보자. 1234const user = observable({ firstName: &quot;Zig&quot;, lastName: &quot;Song&quot; })user.lastName = &quot;Kim&quot;; sendLetterToUser(user); 위 코드에서, sendLetterToUser(user)가 실행될 때 해당 함수는 user의 어떤 lastName을 가지게 될까? MobX를 사용한다면 답은 항상 &quot;Kim&quot;(업데이트된 버전)이 될 것이다. MobX는 모든 변경을 동기적으로 업데이트한다. 이는 모든 예측 불가능성을 타파할 뿐 아니라, 디버깅을 쉽게 만들어준다. mutation은 여러 개의 변화를 자동으로 수행하기 위해 트랜잭션(transaction)으로 그룹지어져야한다. 트랜잭션은 파생 값의 실행을 트래잭션의 마지막까지 미루지만, 여전히 이를 동기적으로 실행한다. 만약 트랜잭션이 끝나기 전에 계산된 값(computed value)을 사용하더라도, MobX는 그 변경의 업데이트된 값을 반환해준다. 이 트랜잭션을 자동으로 트리거해주는 액션(action)은 상태를 업데이트할 함수를 가리킨다. 모든 액션이 끝난 뒤에 reaction이 나타난다. action, state, computed value와 reaction 사이의 관계는 다음과 같다. State(Observable State) - 관찰 받고 있는 상태 모델을 채우는 객체, 비객체, 원시, 참조의 그래프 어플리케이션의 데이터 셀 특정 부분이 바뀌면, MobX에서는 정확히 어떤 부분이 바뀌었는지 알 수 있음 이 state의 변화는 reaction과 computations를 일으킴 Derivation(Computed values) - 파생 값(연산된 값) Observable State의 변화에 따른 값 기존의 상태값과 다른 연산된 값에 기반하여 만들어질 수 있는 값. 즉 특정값을 연산할 때에만 처리됨 어플리케이션으로부터 자동으로 계산될 수 있는 모든 값 observable로부터 도출할 수 있으며, 값이 변경되면 자동으로 업데이트 성능최적화를 위해 사용 Reactions - 반응 Observable State의 변화에 따른 부가적인 변화 값이 바뀜에 따라 해야 할 일을 정하는 것을 의미 파생 값과 비슷하지만 값을 생성하지 않는 함수 대체로 I/O 와 관련된 작업 적당할 때 자동으로 DOM이 업데이트 되거나 네트워크 요청을 하도록 만듬 when, autorun, reaction Actions : 액션 Observable State가 사용자가 지정한 것을 포함한 모든 변경사항 상태를 변경시키는 모든 것 MobX는 모든 사용자의 모든 사용자의 액션으로 발생하는 상태 변화들이 전부 자동으로 파생값(Derivation)과 리엑션(Reactions)으로 처리되도록 함 리액션(reaction)보다는 계산된 값(computed value)를 사용하는 것이 좋다. 계산 과정에서 더욱 순수한 파생 값을 얻을 수 있으며, MobX에 의해 값이 추적되기 때문이다. 계산된 값은 사이드이펙트를 발생시키지 않기 때문에, MobX는 계산된 값의 실행 순서를 안전하게 보장할 수 있다. 또 계산된 값은 자동으로 캐시된다. 특정 작업을 처리하는 것이 아니라, 의존하는 값이 바뀔 때 미리 값을 계산해놓고 조회할 때는 캐싱된 데이터를 사용한다. Ref https://hackernoon.com/the-fundamental-principles-behind-mobx-7a725f71f3e8) https://jeffgukang.github.io/react-native-tutorial/docs/state-tutorial/mobx-tutorial/02-what-is-mobx/what-is-mobx-kr.html 삼가 IE의 명복을…이거 보러 경주 가고 싶다. Ref https://www.youtube.com/watch?v=aBLwAnubhec&amp;feature=youtu.be 올인원 자바스크립트 런타임, BunJavascriptCore 기반 자바스크립트 런타임이 새롭게 공개되었다. 로우 레벨 언어인 Zig로 작성되었으며, node와 deno보다 훨씬 빠른 성능을 보여준다고 한다. 나는 이토록 느린데 자꾸만 뭐가 생긴다… Ref https://bun.sh/ 마무리하… 월요일부터 꼬여버렸던 npm이 주말인 지금까지도 풀리지 않는다. 바쁜 팀원 분들을 수 차례 붙잡고 도움 요청을 하고, 전체 채널에도 읍소(?)해봤으나 도대체 해결될 기미가 보이지 않는다. 😭 잠잘 때도 밥먹을 때도 갑갑한 마음에 정말 도라버려… 살려줘… 우테코에서 친해졌던 동기가 우리팀에 새로 들어왔다. 내가 돌보미 역할을 했는데, 망할 npm 때문에 정신 팔려있느라 제대로 도와주지도 못하고 정신이 예민해져있던 것 같다. 빨리 해결하고 다시 정신 차려야지. 그래도 오랜만에 놀토 팀원들을 만났다. 아주 오랜만에 만난 게 아닌데도 뭐 그렇게 할 얘기가 많은지 수다수다수다수다 폭풍수다 재밌게 떨고 왔당 ☺️ 거지같은 라이브러리는 나를 배신해도 친구들은 배신하지 않는다. 해결했다! 일요일 밤이 다 가기전에 겨우 해결헀다. 정말 속 시원하다. 세상이 아름다워 보여…","link":"/2022/07/09/2022-7-week-2/"},{"title":"EC2로 Next.js 앱 배포하기","text":"EC2 | Next.js | Node.js | pm2 | nginx SSR을 사용하는 next.js 앱을 EC2에 배포하려다가 이것도 하고 저것도 하고… 결국 주말 하루를 꼬박 날리고야 만 대장정을 시작해보려고 한다. 1. AWS 인스턴스 생성aws 계정에 로그인한 후, EC2 대시보드에 들어가 우측 상단의 [인스턴스 시작] 버튼을 누른다. ✅ 단계 1: AMI 선택AMI가 뭘까? (아미? 🔫) AMI는 Amazon Machine Image의 약자로, 인스턴스를 시작하는 데 필요한 정보를 제공한다. EC2 인스턴스와 같은 가상 서버들을 생성하는 데 필요한 마스터 이미지, 즉 운영체제에 필요한 템플릿을 캡쳐해 놓은 스냅샷 이미지와 같다. 호스팅 컴퓨터로 Ubuntu 18.04 버전의 SSD Volume type을 선택한다. 👾 SSD란?Solid State Disk의 약자로, 보조기억장치를 가리킨다.(그냥 궁금해서) ✅ 단계 2: 인스턴스 유형 선택현재 테크코스의 계정으로 내 돈은 아니지만, 아무튼 간에 t2.micro 또는 t2.medium을 선택한다. 프리티어 이용 시 t2.micro만 사용 가능하다. ✅ 단계 3: 인스턴스 세부 정보 구성VPC와 서브넷을 선택하고, 퍼블릭 IP를 활성화해준다. (노출되어도 상관없는 정보라고 믿어본다…) VPC란 Virtual Private Cloud의 약자로, 사용자의 AWS 계정 전용 가상 네트워크다. VPC가 없다면 수많은 EC2 인스턴스들이 서로 거미줄처럼 연결되고 인터넷과 연결되어 복잡도를 증가시킬 것이다.VPC를 적용하여 VPC별로 네트워크를 구성하고, 독립적으로 네트워크 설정을 줄 수 있다. 또, VPC를 사용하면 리소스 배치, 연결 및 보안을 포함하여 가상 네트워킹 환경을 제어할 수 있다 서브넷은 VPC의 IP 주소 범위를 가리킨다. VPC 내부의, VPC보다 더 작은 단위를 가리킨다. 더 많은 네트워크망을 만들기 위해 서브넷을 사용한다. VPC와 서브넷은 아래와 같은 구조로 이루어져 있다. 👾 EC2? VPC? EC2는 computing service, VPC는 Virtual Private CloudEC2는 VPC의 일부이며 EC2 인스턴스에 접근을 위해서는 VPC가 필요하다. 👾 public IP vs private IP 퍼블릭 IP 주소는 인터넷을 통해 연결할 수 있는 IPv4 주소이다. 퍼블릭 주소는 인스턴스와 인터넷의 상호 통신을 위해 사용된다. 또한, 퍼블릭 IP 주소가 할당된 각 인스턴스에는 외부 DNS 호스트이름이 할당된다. 프라이빗 IP 주소는 인터넷을 통해 연결할 수 없는 IP 주소이다. 프라이빗 IPv4 주소는 동일 VPC에서 인스턴스 간의 통신을 위해 사용될 수 있다. 즉 우리끼리, 내부 네트워크 내에서 위치를 찾아갈 때 사용한다. 이때 각각의 VPC는 완전히 독립적이기 때문에 VPC간 통신을 위한다면 VPC 피어링 서비스를 고려해볼 수 있다. ✅ 단계 4: 스토리지 추가원하는 볼륨 크기를 설정한다. EC2의 하드디스크 용량을 설정하는 것이다. (30GiB 이상을 권장한다. 하지만 그냥 기본값으로 하고 넘어갔다. 내 돈이 아니니까…💸) ✅ 단계 5: 태그 추가다른 사람의 서버와 구분할 수 있도록 Name 태그를 붙여준다. ✅ 단계 6: 보안 그룹 구성보안 그룹 설정을 통해 EC2 인스턴스로 들어오고 나가는 트래픽을 세부적으로 제어할 수 있다.ex) SSH 접속 포트는 22번, 서비스 기본 포트는 80번 현재 본인 소유의 계정이 아니므로, 새로 만들지 않고 기존의 보안 그룹을 선택해주었다. 인바운드 - 외부에서 인스턴스로 들어오는 요청 아웃바운드 - 인스턴스에서 외부로 나가는 트래픽 ✅ 단계 7: 인스턴스 시작 검토앞의 모든 단계 설정을 마무리했다면, 우측 하단의 [검토 및 시작]을 눌러 이전 단계의 설정들을 확인한 후, 키페어를 생성한다. 이 키페어는 SSH로 접속 시 필요한 키로, 한번 발급 받은 후 분실하면 다시 찾을 수 없으니 잘 보관해두자! 🔑(.pem 파일 형식으로 생성된다) 기본적으로 RSA 방식으로 암호화된 공개키-비밀키 형식의 키페어를 제공하지만, 올해 8월부터 제공하는 ED25519 방식의 키페어를 발급 받으면 더욱 높은 수준의 보안 시스템을 이용할 수 있다고 한다. 클라이언트의 SSH에서 AWS EC2 인스턴스에 접속할 때 키페어는 다음과 같은 과정을 통해 교환된다. 이렇게 EC2 인스턴스가 생성되었다! 고작 첫 번째 단계가 끝났다 😑 2. SSH 접속방금 만든 인스턴스를 클릭하고, [연결] 버튼을 눌러준다. 그러면 다음과 같이 친절하게 SSH 연결을 위한 커맨드를 알려준다. 로컬에서 발급받은 pem(키페어) 파일이 있는 위치로 이동하여, 시키는 대로 입력한다. chmod(change mode)로 나(첫 번째)에게만 4(read) 즉 ‘읽기’ 권한을 제공하고, (그룹/전체에는 권한이 없다.) public IP로 EC2 인스턴스에 접속한다. 12$ chmod 400 KEY-zigsong-deploy-guidebook.pem$ ssh -i &quot;KEY-zigsong-deploy-guidebook.pem&quot; ubuntu@ec2-13-125-205-164.ap-northeast-2.compute.amazonaws.com 이때, 첫 접속 시 다음과 같은 에러가 발생할 수 있다. 원격지의 호스트를 로컬에 연결할 때 첫 번째로 자격을 증명하기 위한 과정이다. ‘yes’를 선택하여 쭉 넘어간다. 정상적으로 실행되면 다음과 같이 원격지 호스트 컴퓨터인 EC2 인스턴스에 접속된다! 3. 프로젝트 세팅Next.js로 (정말로) 간단하게 만든 페이지를 github에 올려두었다. SSH로 EC2에 접속한 상태에서, 해당 repository를 clone한다. (내 레포를 클론해도 되겠지만, 간단한 라우팅 외에 아무것도 없으므로 아주 허탈할 것이다.) 1$ git clone https://github.com/zigsong/a11y-airline.git 우선 node를 설치해준다. 다음 링크를 참조하여 설치를 진행했다. 1234$ sudo apt-get update # 기본적인 업데이트 진행$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash$ . ~/.nvm/nvm.sh$ nvm install node 👾 apt-get vs yum크게 중요한 건 아닌 것 같지만, ssh에서 사용하는 명령어를 apt-get 방식으로 사용하는 곳도 있고, yum으로 사용하는 곳도 있다. 둘의 차이는 호스트가 RedHat 계열의 CentOS라면 yum을, Debian 계열의 Ubuntu라면 apt-get 방식을 사용하는 것이라고 한다. EC2 호스트 컴퓨터로 Ubuntu를 사용했기 때문에 되도록 apt-get 명령어를 사용했다. 자세한 내용이 궁금하다면 아래 출처를 확인해 보자.Ubuntu apt(apt-get)와 Redhat/CentOS yum 명령어 비교표리눅스란 무엇인가? (센토스 vs 우분투) 아래 명령어로 node.js가 올바르게 설치되었는지 확인한다. 1$ node -e &quot;console.log('Running Node.js ' + process.version)&quot; yarn을 설치하고, 1$ curl -o- -L https://yarnpkg.com/install.sh | bash 프로젝트의 패키지들을 설치해준다. 1$ yarn install 4. next.js 앱 custom 서버 설정next start 커맨드를 사용하면 vercel에서 제공하는 기본 서버를 사용할 수 있지만, 여기서는 EC2 인스턴스에서 따로 서버를 관리할 것이기 때문에 커스텀 서버를 만들어줄 것이다.(👾 next start만으로도 EC2 서버를 돌릴 수 있다고 한다! 크루 신세한탄의 글 참고) next.js 공식문서를 참고하여 다음과 같이 express 서버 코드를 작성해 주었다. 12345678910111213141516171819202122// server.jsconst express = require('express');// 커스텀 서버를 next app과 연결시켜 준다.const next = require('next');const dev = process.env.NODE_ENV !== 'production';const PORT = process.env.PORT || 8080;const app = next({ dev });const handle = app.getRequestHandler();app.prepare().then(() =&gt; { const server = express(); server.use(express.json()); server.use(express.urlencoded({ extended: true })); server.get('*', (req, res) =&gt; handle(req, res)); server.listen(PORT, () =&gt; { console.log(`&gt; Ready on port ${PORT}`); });}); next.js 커스텀 서버에서 사용하는 포트 번호는 EC2 인스턴스의 보안 그룹에서 인바운드 규칙에 포함되어 있어야 한다. 우테코 루트 계정을 사용하는 현재 보안 그룹에 따로 손을 댈 수 없어서, 기존 보안 그룹에 있는 8080 포트를 사용했다. ‘원본’의 ‘0.0.0.0/0’은 모든 소스를 허용함을 의미한다. ssh 내부에서 아까 clone 받은 프로젝트 레포지토리로 들어가서, next build를 통해 커스텀 서버에서 관리할 파일을 생성한다. 실행 결과는 다음과 같다. 이제 next start로 서버를 실행해 준다. (모든 커맨드는 ssh 셸 안에서 이루어진다.) 인스턴스의 퍼블릭 IP 주소 또는 퍼블릭 DNS에 포트 ‘:8000’을 붙여 접속하면 정상적으로 next.js 앱이 뜨는 것을 확인할 수 있다. &lt;그렇게 탄생한 앱&gt; …앱이 아주 썰렁하다. 어쩔 수 없다. 5. pm2로 프로세스 관리이렇게 열린 서버는 ssh 셸을 나가면 그대로 죽는다. 꽤나 허탈한 기분이다. node.js의 프로세스 매니저인 pm2를 사용하여 말로만 듣던, 엄청나게 멋져 보이던 ‘무중단 서비스’를 운영해 보자. node.js는 기본적으로 싱글 스레드만 지원한다. pm2는 cluster 기능을 제공하여 최대 16개의 프로세스를 동시에 실행할 수 있게 해준다. 또 shell을 꺼도 계속 프로세스가 돌아갈 수 있도록 지원하며, 프로세스를 관찰하고 있다가 프로세스가 종료되면 다시 실행해줄 수 있다. 아래 명령어로 pm2를 설치해준다. (물론 여전히 ssh 셸에서, 우리의 next.js 앱 디렉토리 안에 있다.) 1$ npm install pm2 -g 다음 명령어로 pm2가 관리할 새로운 프로세스를 실행한다. 12$ pm2 start server.js$ pm2 start server.js --name &quot;next&quot; # 프로세스 이름을 따로 지정하고 싶은 경우 pm2 list 명령어로 현재 실행중인 프로세스들을 확인할 수 있다. 이것저것 만져보며 프로세스를 일시정지하거나, 삭제하거나, error 시 재가동해 보자. 1234$ pm2 stop [id 또는 name]$ pm2 restart [id 또는 name]$ pm2 delete [id 또는 name]$ pm2 start [id 또는 name] --watch # 코드가 변경되면 프로세스를 재시작한다. pm2가 프로세스를 관리하고 있기 때문에, (오류가 발생하지 않는 한) 셸을 꺼도 서버는 계속 가동 중이다! (돈도 계속 나간다! 오예!) 이렇게 ssh에서 pm2로 프로세스를 관리하는 것은 foreground로 프로세스를 돌리는 것에 해당한다. foreground 실행은 명령을 하나씩 실행하므로 사용자가 입력한 명령이 실행되어 결과가 출력될 때까지 기다려야 한다. pm2에서 background로 프로세스를 돌린다면 다른 작업을 수행하면서 프로세스를 계속 유지시킬 수 있다. ssh에서 background로 서버를 실행시키고 싶다면 명령어의 마지막에 &amp;를 입력하면 된다. background 작업은 터미널을 종료해도 계속 유지된다. (종료를 위해서는 프로세스를 kill해야 한다.)pm2는 데몬(Daemon) 방식을 사용하여 프로세스를 background에서 실행한다. 6. nginx 설치nginx 동시접속 처리에 특화된 웹 서버 프로그램이다. 이벤트 드리븐(Event-Driven)의 비동기 처리 방식을 채택하여, 여러 개의 요청을 효율적으로 처리할 수 있다. 👾 웹 서버?웹 서버는 HTML, CSS, JavaScript, 이미지와 같은 정보를 웹 브라우저에 전송하는 역할을 한다.(🍀참고 - Web Server와 WAS) 여기서는 nginx를 리버스 프록시(reverse proxy) 를 위해 사용할 것이다. 클라이언트가 가짜 서버에 요청을 보내면, 프록시 서버가 오리진 서버로부터 데이터를 가져오는 역할을 한다. 이때 nginx는 프록시 서버의 역할을 한다. 👾 프록시?프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다. 서버와 클라이언트 사이에서 중계 기능을 하며, 대리로 통신을 수행하는 서버이다. 프록시는 일반적으로 포워드 프록시(forward proxy) 와 리버스 프록시(reverse proxy) 로 구분된다.포워드 프록시는 실제 서버 대신 클라이언트의 요청을 받아 결과를 클라이언트에 전달하는 역할을 한다. 사용자가 google.com에 연결하려고 하면 포워드 프록시 서버가 요청을 받아서 google.com에 연결하여 그 결과를 클라이언트에 전달해주는 것이다. 이때 포워드 프록시는 캐시를 사용하여 성능 향상에 기여한다. 리버스 프록시는 클라이언트가 데이터 요청 시 요청을 받아 내부 서버에서 데이터를 받은 후 클라이언트에 전달한다. 클라이언트는 내부 서버에 대한 정보를 알 필요 없이 리버스 프록시에만 요청을 보낸다. 리버스 프록시는 로드 밸런싱 등의 기능을 제공하기도 한다.👩‍🏫 포워드 프록시는 ‘클라이언트’를 감추는 역할, 리버스 프록시는 ‘서버’를 감추는 역할을 한다. 앞 단계까지 정상적으로 진행해왔다면, EC2에서 제공한 IP 주소의 지정해준 포트(여기서는 8080)로만 접속이 가능하다. 그러나 매번 이렇게 특정한 포트 번호까지 붙여 접속하긴 여간 귀찮은 일이 아니다. 또 우리의 express 서버(next.js 앱의 커스텀 서버)가 어떤 포트로 열렸든 간에, 끝단의 사용자는 해당 정보를 알 필요가 없다. 웹 사이트의 기본 포트인 80포트(생략 가능)로 접속하기만 하면 될 뿐이다. nginx 웹 서버를 이용하여 8080 포트로 들어온 요청을 80포트로 전환시켜주고, 그 중간 과정은 숨겨줄 수 있다. 즉, 외부에서 기본 포트인 80포트로 접속해도 리벅스 프록시 역할을 해주는 nginx가 express 서버로 proxy forwarding을 해준다. nginx를 설치하고, 서버를 시작한다. 12$ sudo apt-get install nginx$ sudo service nginx start 아래 명령어를 통해 nginx가 설치된 경로를 확인할 수 있다. 1$ sudo find / -name nginx.conf nginx가 정상적으로 구동되고 있는지 확인해 보자. 1$ ps -ef | grep nginx 현재 EC2 인스턴스의 기본 포트(80, 또는 생략 가능)으로 접속하면 아래와 같은 화면이 나타난다. nginx를 정상적으로 설치했다면, 기본 포트에 우리의 next.js 앱을 띄워주도록 설정을 수정해줘야 한다. nginx의 config를 설정하는 방법을 찾다가, 구글 검색 결과 최상단에 위치한 블로그를 많이 참고했다. 그런데 그 글이 우리 놀토 팀원 아마찌의 포스트였다니 😮 123$ cd /etc/nginx/sites-available # 기본적으로 default 파일이 있다.$ sudo rm default$ sudo nano default sites-available 디렉토리는, 가상 서버 환경들에 대한 설정 파일들이 위치하는 곳이다. nano 텍스트 에디터로 기본 default 파일을 삭제 후 새로 작성해 준다. (사실 nano 에디터 쓰는 법을 몰라서 vi 편집기로 수정했다.) 1234567891011server { listen 80; listen [::]:80; access_log /var/log/nginx/reverse-access.log; error_log /var/log/nginx/reverse-error.log; location / { proxy_pass http://127.0.0.1:8080; # 현재 사용 중인 포트 번호 }} default 파일의 모든 문장의 끝에 세미콜론(;)을 붙여줘야 정상적으로 동작한다 config 파일이 정상적으로 입력이 되었는지 확인해 보자 1$ sudo nginx -t 👾 nginx.conf를 직접 수정해주는 방식도 있지만, 어차피 nginx.conf가 nginx/sites-available의 내용을 포함하고 있기 때문에 둘 중 무엇을 수정하든 상관없다. (sites-available에 있는 파일들이 sites-enabled에 symlink로 연결되어 있고, nginx.conf는 sites-enabled에 있는 파일들을 포함한다.) 참고로 nginx 서버에서 80포트를 사용하므로, EC2 인스턴스의 인바운드 규칙 역시 80포트를 포함하고 있어야 한다. 이제 EC2 퍼블릭 IP의 기본 포트로 앱 접속이 가능하다! 7. 도메인 설정 및 https 연결하지만 뭔가 아쉽다. 기본 포트인 80포트로의 연결은 동작하지만, 113.~ 으로 시작하는 못생긴 IP 주소를 누가 외우고 다닐까! 나만의 도메인을 등록해보자. 미션에까지 돈을 쓰고 싶진 않기 때문에 내도메인 한국 사이트에서 괜찮은 주소를 찾았다. EC2에서 제공하는 Public IP 주소만 연결해주면 된다. 여전히 별거없지만, 이제 나름 도메인이라고 붙인 주소로 접속할 수 있다. 그런데 아무래도 저 ‘주의 요함’ 문구가 마음에 들지 않는다. HTTPS를 붙여 보안 설정을 강화해보도록 하자. 크루 체프☕️의 가이드북의 도움을 받았다. nginx의 site-available 파일에 다시 들어가서 HTTPS 접속을 원하는 서버의 이름을 server_name으로 추가해준다. (위에서 생성한 도메인을 붙이면 된다.) Certbot을 설치한다. 👾 Certbot?Let’s Encrypt 인증서를 사용하여 자동으로 HTTPS를 활성화하는 무료 오픈 소스 소프트웨어 도구이다. 1$ sudo apt-get install python3-certbot-nginx 다음 명령어로 인증서 발급을 시작한다. 1$ sudo certbot --nginx 이메일 작성, 약관 동의를 한 후 HTTPS 설정을 할 도메인을 입력한다. (다른 설정을 만지다가 한번 꼬여서 이 화면은 캡쳐하지 못했다 😵) 그러면 다음과 같은 2가지 선택지 중 선택하라고 나온다. HTTP로 접속했을 때, HTTPS로 자동 리다이렉트되도록 설정할 것인지 묻는 옵션이다. 2번을 선택하면 Certbot에서 nginx 설정을 알아서 바꿔준다. 따로 설정하기 머리 아프기 때문에 2번을 선택한다. 마지막으로 인증서가 만료되기 전에 알아서 갱신되도록 Crontab을 설정할 것이다. 먼저 Crontab 설정 파일을 연다. 설정 파일을 열 때 편한 편집기를 고르라는 메시지가 뜨는데, 편한 편집기로 고르면 된다. 👾 Crontab이란?리눅스의 작업 예약 스케줄러로, 특정 시간에 특정 작업을 할 수 있게 해주는 도구다. 1$ sudo crontab -e 최하단에 다음 설정을 추가한다. 이렇게 설정하면 매월 1일 오후 6시마다 인증서를 갱신하고 nginx를 재시작하는 명령어가 실행된다. 1$ 0 18 1 * * certbot renew --renew-hook=&quot;sudo service restart nginx&quot; 그럼 진짜 설정 끝! 이제 HTTPS로 접속할 수 있다. ‘주의 요함’ 대신 자물쇠 아이콘이 걸려있다. 요약 AWS EC2 인스턴스 생성 SSH 접속 git clone, node, yarn 설치 next.js 커스텀 서버 설정 pm2로 프로세스 관리 nginx로 리버스 프록시 설정 도메인 설정 및 https 연결 어마어마한 과정이었다 😵 Ref https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/what-is-amazon-vpc.html https://medium.com/harrythegreat/aws-가장쉽게-vpc-개념잡기-71eef95a7098 https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/using-instance-addressing.html https://docs.aws.amazon.com/ko_kr/quicksight/latest/user/vpc-security-groups.html https://aws.amazon.com/ko/about-aws/whats-new/2021/08/amazon-ec2-customers-ed25519-keys-authentication/ https://2ham-s.tistory.com/349 https://velog.io/@hojin9622/PM2-정리 https://twpower.github.io/50-make-nginx-virtual-servers https://bcp0109.tistory.com/194 https://www.lesstif.com/system-admin/forward-proxy-reverse-proxy-21430345.html","link":"/2021/10/02/fe-aws-ec2-next/"},{"title":"프론트엔드 성능 베이스캠프","text":"프론트엔드 성능 베이스캠프 본격적인 프론트엔드 성능 개선을 시작하기 전에, 성능 개선 프로세스에 대해서 생각해보자. 성능 개선 프로세스는 측정 → 분석 → 최적화를 계속해서 반복해 나가는 과정이다. 현재 서비스의 성능 수준을 측정하고, 어떤 영역에서 성능 개선 작업이 필요한지 문제를 정의한다. 그리고 정의한 문제를 해결하기 위해 여러 방법들을 시도한다. 언제까지? 목표에 도달할 때까지! 지금 당장 완벽한 성능 수준에 도달하기보다는, 언제든 새로운 도전을 해볼 수 있도록 학습해 나가는 중이다. 프론트엔드의 성능은 1. 로딩 성능과 2. 렌더링 성능으로 나눌 수 있을 것이다. 로딩 성능 - 페이지가 얼마나 빠르게 로드되는가 렌더링 성능 - 사용자 인터랙션에 얼마나 빠르게/효율적으로 반응하는가 이에 기반해서 1. 요청 크기 줄이기, 2. 필요한 것만 요청하기, 3. 같은 건 매번 새로 요청하지 않기, 4. 최소한의 변경만 일으키기 네 가지 단계로 성능을 개선해보았다. 성능 개선 전의 사이트는 이곳에서, 성능 개선 후의 사이트는 이곳에서 확인할 수 있다. 성능 개선 이전 &lt;lighthouse 성능 지표&gt; &lt;WepPageTest, Paris Fast 3G 성능 지표&gt; 1. 요청 크기 줄이기✅ 소스코드 크기 줄이기react로 만든 웹 서비스의 경우 서비스에서 불러오는 JavaScript 번들 파일의 소스코드 크기를 줄일 수 있다. 소스코드 크기 측정을 위해 webpack-bundle-analyzer를 이용했다. 로컬 서버를 통해 번들을 구성하고 있는 요소들의 크기를 확인할 수 있다. 12345678910// webpack.config.jsconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = { // ... plugins: [ // ... new BundleAnalyzerPlugin(), ],} 👾 (추후 다룰 parsing과 gzip을 사용하면) 3가지 버전으로 각 구성요소의 크기를 확인할 수 있다. stat size - 압축(compression) 또는 최소화(minimization) 이전 크기 parsed size - 결과물의 크기(최소화가 적용되어 있는 듯 하다.) gzipped size - 압축 이후 크기 우선 gzip을 사용해서 CDN에서 가져오는 소스코드의 크기를 줄였다. aws cloudfront에서 gzip 압축에 관한 내용은 여기서 확인할 수 있다. &lt;gzip 적용 이전&gt; &lt;gzip 적용 이후&gt; CSS 최적화도 진행했다. 우선 MiniCssExtractPlugin을 이용하여 CSS 파일을 별도 파일로 추출했다. CSS 코드가 포함된 JS 파일 별로 CSS 파일을 생성하기 때문에 CSS가 헤더에 주입되는 것이 아니라 별도의 파일로 분리된다. 그래서 DOM에 &lt;style&gt; 태그로 CSS를 넣어주는 style-loader와 함께 사용할 수 없다. webpack config에 style-loader 대신 넣어준다. 123456789101112131415// webpack.config.jsconst CssMinimizerPlugin = require('css-minimizer-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { // ... plugins: [ // ... new MiniCssExtractPlugin(), ], optimization: { minimize: true, minimizer: [new CssMinimizerPlugin()], },} mini-css-extract-plugin 플러그인은 JavaScript 파일 안에서 호출되는 스타일 코드를 청크(Chunk)에서 파일로 추출하므로 개발 중에는 플러그인을 사용하지 않는 것이 좋다. 즉, 개발이 끝난 후 배포 할 때 사용하면 좋다. 개발 모드에서는 CSS를 여러 번 수정하고 DOM에 &lt;style&gt;요소의 코드로 주입하는 것이 훨씬 빨리 작동하므로 style-loader를 사용하고, 배포 모드에서는 MiniCssExtractPlugin.loader를 사용하는 것이 좋다. 그리고 CssMinimizerWebpackPlugin을 이용하여 CSS 파일을 최적화하고 축소해주었다. 번들 결과 dist 폴더 내의 css 파일이 아래와 같이 압축된 것을 확인할 수 있다. 번들 파일의 크기는 798kB에서 757kB로 줄었다. 🤔 MiniCssExtractPlugin을 이용하여 CSS 파일을 별도로 추출하는 방식이 항상 성능상으로 좋은 방식인지는 의문이다. 현재는 우선 소스코드의 크기가 줄어서 개선이 이루어졌지만, 더 공부해봐야 할 부분이다. 마지막으로(순서가 CSS 최적화보다 먼저 왔어야 할 것 같지만!) JavaScript 소스코드를 난독화하여 크기를 줄일 수 있었다. UglifyJS와 Terser가 소스코드 난독화를 해주는 대표적인 라이브러리인데, 각각 사용했을 때 압축률은 거의 동일하다. 그러나 Terser가 파싱 속도가 조금 더 빠르다고 한다. npm-trends에서도 Terser가 뜨고 있다. (추가) webpack v5 이상부터는 Terser가 기본으로 설정되어 있다. 세부 옵션을 지정해주고 싶다면 terser-webpack-plugin을 설치하여 커스터마이징해주면 되지만, 따로 설정할 것이 없다고 판단하여 사용하지 않았다. 파싱 이후 webpack-bundle-analyzer로 분석한 코드는 다음과 같다. 아래에 나올 코드 스플리팅을 적용한 후 측정했기 때문에 결과물이 청크 파일들로 분리되어 있는데, Terser 등으로 난독화(최소화)되어 있는 전체 번들의 크기가 757kB에서 231kB로 크게 줄어든 것을 확인할 수 있다. &lt;Stat 크기&gt; &lt;Parsed 크기&gt; ✅ 이미지 크기 줄이기너무나도 큰 hero 이미지의 크기 때문에 LCP(Largest Content Paint) 수치가 꽝이었다. 빌드를 하면 친절하게 warning까지 띄워준다. 게다가 현재 gif들도 많이 사용되고 있어서 성능이 처참하다. gif를 지양하고 있다는 것은 처음 알았는데, 구체적인 이유는 이곳에서 확인해볼 수 있다. png 확장자의 이미지는 webp로, gif는 비디오 포맷인 mp4로 변환하여 이미지 콘텐츠의 크기를 줄였다. 🧐 webp? 구글에서 만든 이미지 파일 포맷. 손실 압축(JPEG)과 비손실 압축(PNG, GIF)를 모두 지원하며, 손실/비손실 모두 약 30% 정도 용량을 줄여 보다 빠른 웹 사이트 로딩이 가능하다. &lt;이미지 변환 이전&gt; &lt;이미지 변환 이후&gt; 참고로 mp4를 사용하기 위해서는 &lt;video&gt;와 &lt;source&gt; 태그를 활용한다. 123456789const GifItem = ({ videoUrl = &quot;&quot;, title = &quot;&quot; }) =&gt; { // ... return ( &lt;video className={styles.gifImage} autoPlay muted loop&gt; &lt;source src={videoUrl} type=&quot;video/mp4&quot; /&gt; Sorry, your browser doesn't support embedded videos. &lt;/video&gt; )} Refhttps://www.npmjs.com/package/webpack-bundle-analyzerhttps://webpack.js.org/plugins/css-minimizer-webpack-plugin/https://webpack.js.org/plugins/mini-css-extract-plugin/https://yamoo9.gitbook.io/webpack/webpack/webpack-plugins/extract-css-fileshttps://medium.com/vingle-tech-blog/stop-using-gif-as-animation-3c6d223fd35a 2. 필요한 것만 요청하기✅ 페이지별 리소스 분리webpack 등의 모듈러로 번들링한 파일은 유용하지만, 앱이 커지면 번들의 크기도 커진다. 그리고 SPA의 특성상 이 번들을 페이지 최초 로드 시 모두 불러오게 되며, 이는 초기 로딩 속도를 늦추는 원인이 된다. 이 문제를 해결하기 위해 번들을 나누는 방법이 등장했다. 코드 스플리팅을 통해 런타임에 번들을 동적으로 만들어 필요할 때 불러오게끔 할 수 있다. React에서는 코드 스플리팅을 위해 lazy라는 기능을 제공한다. 아래와 같이 작성하며, 동적 로딩이 될 동안 화면을 대신할 Suspense와 함께 사용한다. 1234567891011const Search = React.lazy(() =&gt; import('./Search'));const Home = () =&gt; { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt; &lt;Search /&gt; &lt;/Suspense&gt; &lt;/div&gt; );} 그러나 아무래도 페이지가 전환되는 사이에 새로운 청크 파일을 불러오는 동안 로딩 화면이 깜박하는 것은 UX 상으로 뭔가 부족하다. @loadable/component를 사용하여 다르게 구현해보았다. 12345678910// SearchLoadable.jsximport React from &quot;react&quot;;import loadable from &quot;@loadable/component&quot;;const SearchLoadable = loadable(() =&gt; import(&quot;../Search/Search&quot;), { fallback: &lt;div&gt;Loading...&lt;/div&gt;})export { SearchLoadable }; lazy와 유사한 방식으로 작성해주고, 역시나 fallback 옵션으로 로딩 중일 때 보여줄 컴포넌트를 넣어줄 수 있다. loadable의 특징은, preload를 지원한다는 점이다. 12345678// Home.jsxconst Home = () =&gt; { return ( &lt;Link to=&quot;/search&quot; onMouseOver={() =&gt; SearchLoadable.preload()}&gt; &lt;button className={styles.cta}&gt;start search&lt;/button&gt; &lt;/Link&gt; )} 해당 페이지로 링크되는 DOM 요소에 마우스 호버 시, 사용자의 동작을 예측하고 미리 청크 파일을 불러온다. 이렇게 마우스를 해당하는 DOM 요소에 올리면 크롬 개발자 도구의 Network 탭에서 새로운 청크 파일을 불러오는 것을 볼 수 있다! 그밖에도 loadable은 SSR, Libary Splitting 등의 기능을 지원하고 있다고 하니, 유용하게 활용해보자. Refhttps://ko.reactjs.org/docs/code-splitting.html#reactlazyhttps://loadable-components.com/docs/prefetching/ 3. 같은 건 매번 새로 요청하지 않기✅ CloudFront 캐시 설정cloudfront의 cache를 CachingOptimized로 선택하고, 기본으로 설정된 TTL(Time-To-Live) 설정을 해주었다. ✔️ Minimum TTL객체가 업데이트되었는지 여부를 확인하기 위해 CloudFront에서 오리진으로 다른 요청을 전송하기 전에 객체를 CloudFront 캐시에 유지할 최소 시간(초)을 지정한다. ✔️ Maximum TTL객체가 업데이트되었는지 여부를 확인하도록 CloudFront에서 오리진에 쿼리하기 전에 CloudFront 캐시에서 객체를 머무르게 하려는 최대 시간을 초 단위로 지정한다. 최대 TTL에 지정하는 값은 오리진이 객체에 Cache-Control: max-age, Cache-Control: s-maxage 또는 Expires 등의 HTTP 헤더를 추가할 경우에만 적용된다. ✔️ 기본 TTL객체가 업데이트되었는지 여부를 결정하도록 CloudFront가 오리진에 다른 요청을 전달하기 전에 객체를 CloudFront 캐시에 유지하려는 기본 시간을 초 단위로 지정한다. 기본 TTL에 지정하는 값은 오리진이 객체에 Cache-Control: max-age, Cache-Control: s-maxage 또는 Expires 등의 HTTP 헤더를 추가하지 않을 경우에만 적용된다. 과제에서는 정적 파일들이 전부 제대로 캐싱이 되고 있지 않아서 성능 측정 시 해당 부분의 점수가 낮았다. 그래서 바뀔 일이 거의 없는 정적 파일들, 예를 들면 메인 페이지에서 사용되는 이미지 파일들의 경우 header에 Cache-Control: max-age를 넣어주었다. 많은 경우 정적 파일들에 대해서 max-age를 1년으로 설정해 주고 있기 때문에 그대로 적용해 보았다. max-age를 설정해 준 파일들의 경우 두 번째 이후 로드 시 memory cache에서 불러오는 것을 확인할 수 있다! 긴 캐시 지속 기간의 문제는, 새로 바뀐 코드가 푸쉬되어도 cloudfront에서 새로 업데이트되지 않는다는 것이다. webpack은 앱을 빌드할 때마다 결과물 파일들에 유니크한 해쉬 이름을 붙여주어서 새로운 파일이 업데이트되었음을 알릴 수 있게끔 해준다. 12345678// webpack.config.jsmodule.exports = { // ... output: { filename: '[name].[chunkhash].js', path: path.join(__dirname, '/dist'), clean: true, }, ✅ GIPHY의 trending API를 Search 페이지에 들어올 때마다 새로 요청하지 않아야 한다. Map과 closure를 이용하여 JavaScript로 cache를 구현했다. 12345678910111213141516171819export const fetchTrendingGifs = (() =&gt; { const cache = { current: null }; return async () =&gt; { try { if (!cache.current) { const response = await fetch(TRENDING_GIF_API); const gifs = await response.json(); const data = formatResponse(gifs.data ?? []); cache.current = data; } return cache.current ?? []; } catch (error) { return []; } };})(); Refhttps://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesMinTTLhttps://web.dev/http-cache/https://web.dev/uses-long-cache-ttl/https://joshua1988.github.io/web-development/webpack/caching-strategy/ 4. 최소한의 변경만 일으키기✅ 검색 결과 &gt; 추가 로드시 추가된 목록만 렌더되어야 한다.동일한 props로 반복적으로 렌더되는 자식 컴포넌트들을 React.memo로 감싸주었다. &lt;memoize 이전&gt; 모든 GifItem이 리렌더링 &lt;memoize 이후&gt; 기존의 GifItem은 리렌더링이 되지 않음 ✅ LayoutShift 없이 hover 애니메이션이 일어나야 한다.CSS에서 layout shift가 발생하는 top 속성 대신 transform: translate을 사용했다. Ref https://csstriggers.com/ 성능 개선 이후이렇게 여러 단계로 성능 개선을 마친 이후 재측정한 결과! &lt;lighthouse 성능 지표&gt; &lt;WepPageTest, Paris Fast 3G 성능 지표&gt; 이밖에도 웹폰트 다운로드 개선, 이미지 preload 등 성능을 개선할 수 있는 영역은 끝이 없다. 일단 이 정도로 정리하고 앞으로 우리 서비스에서 개선해나갈 수 있는 부분들을 계속해서 찾아 나가고자 한다.","link":"/2021/08/28/fe-performance-basecamp/"},{"title":"UI runtime으로서의 리액트","text":"UI runtime으로서의 리액트 어쩌다 보니 Dan Abramov의 글을 모두 번역해 버린 포스팅 Host Tree리액트는 시간이 지나면서 바뀔 수 있는 트리를 반환한다. 이 트리는 UI와 함께 그려지는데, 이를 ‘호스트 트리’라고 한다. 이 트리는 DOM 등의 형태로 리액트의 바깥에 위치한다. 리액트는 그의 상단에 놓인 레이어일 뿐이다. 리액트는 두 가지 원칙을 기반으로 한다. 안정성 - 호스트 트리는 안정적이며 전체적인 구조를 급진적으로 바꾸지 않는다. 규칙성 - 호스트 트리는 일관적인 UI 패턴들로 나눠진다. Host Instances호스트 트리는 노드들로 구성되는데, 이를 ‘호스트 인스턴스’라고 한다. DOM 환경에서 호스트 인스턴스들은 일반적인 DOM 노드를 가리킨다. 호스트 인스턴스는 자신만의 프로퍼티들을 가지고 있으며, 다른 호스트 인스턴스들을 자식으로 가질 수 있다. 호스트 인스턴스를 조작할 수 있는 API들이 있다(ex. appendChild, removeChild, setAttribute). 리액트 앱을 만들 때는 이 API들을 직접적으로 호출하지 않는다. 리액트는 이 일을 대신 해준다! Renderers렌더러는 리액트가 특정한 호스트 환경을 파악하고 호스트 인스턴스를 관리하게끔 해준다. React DOM 등이 리액트의 렌더러다. (자신만의 리액트 렌더러를 만들 수도 있다.) 렌더러의 대부분은 ‘변화 모드’(mutating mode)로 동작한다. 우리는 노드를 생성하고, 프로퍼티를 할당하고, 자식 요소를 추가하거나 삭제할 수 있다. 호스트 인스턴스는 변경 가능한 요소다. 리액트는 ‘지속 모드’(persistent mode)로도 동작한다. 부모 트리를 복제하여 항상 최상위 자식 요소를 대체하는 호스트 환경에서 사용한다. 호스트 트리의 불변성은 멀티쓰레딩을 도와준다. (cf. React Fabric) React Elements호스트 환경에서, DOM 노드와 같은 호스트 인스턴스는 구성 요소의 최소 단위다. 이를 ‘리액트 엘리먼트’라고 한다. 리액트 엘리먼트는 순수한 자바스크립트 객체다. 이는 호스트 인스턴스를 설명한다. 123456// JSX is a syntax sugar for these objects.// &lt;button className=&quot;blue&quot; /&gt;{ type: 'button', props: { className: 'blue' }} 호스트 인스턴스와 마찬가지로, 리액트 엘리먼트는 트리를 형성할 수 있다. 1234567891011121314151617// JSX is a syntax sugar for these objects.// &lt;dialog&gt;// &lt;button className=&quot;blue&quot; /&gt;// &lt;button className=&quot;red&quot; /&gt;// &lt;/dialog&gt;{ type: 'dialog', props: { children: [{ type: 'button', props: { className: 'blue' } }, { type: 'button', props: { className: 'red' } }] }} 그러나, 리액트 엘리먼트는 자체적으로 동일성을 지속하는 방법이 없다. 언제나 재생성되고 사라질 수 있다. 리액트 엘리먼트는 불변성을 유지한다. 따라서 리액트 엘리먼트의 자식 요소나 프로퍼티를 직접 바꿀 수 없다. 다른 것을 렌더링하고 싶다면, 새로운 리액트 엘리먼트 트리를 다시 만들어야 한다. 리액트 엘리먼트는 특정한 순간의 UI를 스냅샷처럼 캡쳐할 뿐, 스스로 바뀌지는 않는다! Entry Point각각의 리액트 렌더러는 ‘엔트리 포인트’가 있다. 이는 리액트에게 컨테이너 호스트 인스턴스 내부에 리액트 엘리먼트 트리를 렌더하도록 지시한다. ReactDOM의 엔트리 포인트는 ReactDOM.render로 작성한다. 12345ReactDOM.render( // { type: 'button', props: { className: 'blue' } } &lt;button className=&quot;blue&quot; /&gt;, document.getElementById('container')); ReactDOM.render(reactElement, domContainer)과 같은 코드는 리액트에게 domContainer라는 호스트 트리를 reactElement에 대응하게끔 만들 것을 지시한다. ReconciliationReactDOM.render()로 동일한 컨테이너를 두 번 호출하면 어떻게 될까? 12345678910111213ReactDOM.render( &lt;button className=&quot;blue&quot; /&gt;, document.getElementById('container'));// ... later ...// Should this *replace* the button host instance// or merely update a property on an existing one?ReactDOM.render( &lt;button className=&quot;red&quot; /&gt;, document.getElementById('containe')); 호스트 트리를 주어진 리액트 엘리먼트 트리와 동일하게 만드는 것은 리액트의 역할이다. 새로운 정보에 따라 호스트 인스턴스 트리를 구성하는 작업을 ‘재조정(reconciliation)’이라고 한다. 호스트 인스턴스 트리를 업데이트하는 간단한 방법은 기존 트리를 모두 날리고 처음부터 다시 만드는 것이겠지만, 실제 DOM에서 이 과정은 느리게 동작하며 중요한 정보들을 잃을 수도 있다. 리액트는 기존의 호스트 인스턴스를 언제 새로운 리액트 엘리먼트로 업데이트해야 하는지, 그리고 언제 새로 만들어야 하는지 결정한다. 이전과 이후의 렌더에서 요소가 트리에서 동일한 위치에 있다면, 리액트는 기존의 호스트 인스턴스를 그대로 재사용한다. 1234567891011121314// let domNode = document.createElement('button');// domNode.className = 'blue';// domContainer.appendChild(domNode);ReactDOM.render( &lt;button className=&quot;blue&quot; /&gt;, document.getElementById('container'));// Can reuse host instance? Yes! (button → button)// domNode.className = 'red';ReactDOM.render( &lt;button className=&quot;red&quot; /&gt;, document.getElementById('container')); ConditionsHTML 태그의 타입이 일치하여 재사용할 수 있는 호스트 인스턴스의 경우 리액트는 해당 인스턴스를 재사용하며, 타입이 바뀌었을 경우 새로 생성한다. 그런데 특정 시점에 생성되는 조건부 요소라면 어떨까? 123456789101112function Form({ showMessage }) { let message = null; if (showMessage) { message = &lt;p&gt;I was just added here!&lt;/p&gt;; } return ( &lt;dialog&gt; {message} &lt;input /&gt; &lt;/dialog&gt; );} 위 예제에서 &lt;input /&gt; 요소는 showMessage값이 변화할 때 새롭게 추가되는 &lt;p&gt; 요소에 의해 위치가 밀려나게 된다. 이때 단순히 위치의 이동이 필요한 요소의 경우 제거 후 다시 생성하지 않는다. &lt;input /&gt; 요소는 렌더 간에 항상 동일한 위치를 유지할 것이다. showMessage의 값이 true이든 false이든 상관없이, message 요소가 &lt;dialog&gt;의 첫 번째 자식으로 들어가있을 것이기 때문이다. showMessage의 값이 false일 때, message 요소는 null을 반환한다. 리액트는 insertBefore 등의 DOM API를 사용하여 해당하는 위치에 새로운 요소를 삽입한다. 1234let inputNode = dialogNode.firstChild;let pNode = document.createElement('p');pNode.textContent = 'I was just added here!';dialogNode.insertBefore(pNode, inputNode); Lists호스트 인스턴스의 재사용과 재생성 여부를 판단하기 위해서는 트리에에서 같은 위치에 있는 요소의 타입을 비교하는 것으로 충분하지만, 이는 자식 요소들의 위치가 정적일 때만 정상적으로 동작한다. 동적인 리스트에서, 순서는 항상 보장되지 않는다. 12345678910111213function ShoppingList({ list }) { return ( &lt;form&gt; {list.map(item =&gt; ( &lt;p&gt; You bought {item.name} &lt;br /&gt; Enter how many do you want: &lt;input /&gt; &lt;/p&gt; ))} &lt;/form&gt; )} 위 코드는 아래로 변환될 것이다. 12345for (let i = 0; i &lt; 10; i++) { let pNode = formNode.childNodes[i]; let textNode = pNode.firstChild; textNode.textContent = 'You bought ' + items[i].name;} 아이템이 추가되는 등 정렬이 바뀔 때, 위 과정을 매번 반복해야 한다. 그러나 리액트는 모든 리스트 아이템들을 다시 정렬하는 대신, 각 요소를 성능상으로 효과적으로 업데이트한다. 리액트가 이 작업을 수행하기 위해 우리는 배열의 요소들에 key prop을 전달해야 한다. 12345678910111213function ShoppingList({ list }) { return ( &lt;form&gt; {list.map(item =&gt; ( &lt;p key={item.productId}&gt; You bought {item.name} &lt;br /&gt; Enter how many do you want: &lt;input /&gt; &lt;/p&gt; ))} &lt;/form&gt; )} key를 통해 리액트는 동일한 부모 요소의 안에서 렌더 사이에 위치가 바뀌는 자식 요소들이 개념적으로는 동일하다는 것을 알 수 있다. 렌더 이후에 동일한 키를 가진 호스트 인스턴스가 있다면 리액트는 이를 재사용하고, 이에 따라 형제 요소들을 재정렬한다. key는 특정한 부모 요소 안에서만 유효하다. key는 리스트의 순서가 바뀌어도 아이템이 동일함을 보장해야 하기 때문에, 고유한 ID 값을 사용하는 것이 바람직하다. Components컴포넌트는 객체 해쉬(object hash)라는 하나의 값을 갖는다. 이는 props를 포함한다. Purity리액트 컴포넌트는 그들의 props에 대해서 순수함을 보장한다. 즉 리액트에서 props는 변경할 수 없다. 1234function Button(props) { // 🔴 Doesn't work props.isActive = true;} 그러나 지역 변수의 변경은 가능하다. 12345678910function FriendList({ friends }) { let items = []; for (let i = 0; i &lt; friends.length; i++) { let friend = friends[i]; items.push( &lt;Friend key={friend.id} friend={friend} /&gt; ); } return &lt;section&gt;{items}&lt;/section&gt;;} 위 예제에서 items는 렌더링 과정에서 생성되었으며, 다른 컴포넌트들에 영향을 미치지 않기 때문에 직접 변경할 수 있다. 컴포넌트를 여러 번 호출하는 것이 안전하고 다른 컴포넌트들의 렌더링에 영향을 주지 않는다면, 리액트는 해당 컴포넌트가 100% 순수함을 보장하지 않는다. 리액트에서는 순수성보다 멱등성(Idempotence)이 더 중요하다. Recursion컴포넌트들은 함수이므로 우리는 이를 호출할 수 있다. 12let reactElement = Form({ showMessage: true });ReactDOM.render(reactElement, domContainer); 그러나 런타임에서 우리는 컴포넌트 함수를 직접 호출하지 않는다. 이는 리액트가 할 일이다. 우리는 React Element를 이용하여 컴포넌트의 호출을 리액트에게 위임한다. 123// { type: Form, props: { showMessage: true } }let reactElement = &lt;Form showMessage={true} /&gt;;ReactDOM.render(reactElement, domContainer); 컴포넌트 함수들은 대문자로 시작해야 한다는 규칙이 있다. JSX는 대문자로 시작하는 요소들만을 리액트 컴포넌트로 인식한다. 12console.log(&lt;form /&gt;.type); // 'form' stringconsole.log(&lt;Form /&gt;.type); // Form function 리액트는 컴포넌트를 호출하고, 그 컴포넌트가 어떤 요소를 렌더하고 싶은지 파악한다. 이 과정은 컴포넌트가 렌더하는 자식 컴포넌트들에 대해서 재귀적으로 반복된다. 재조정 과정이 재귀적인 이유다. 리액트는 요소 트리를 탐색하면서. type이 컴포넌트인 요소를 만나게 된다. 리액트는 해당 요소를 호출하고 반환된 리액트 엘리먼트 트리를 따라 계속 내려간다. 모든 컴포넌트에 다다르면, 리액트 트리는 호스트 트리에서 무엇을 바꿔야 하는지 알게 된다. (이 과정에서 같은 위치에 있던 요소의 type이 바뀌면 호스트 인스턴스를 제거하고 재생성하는 것이다!) Inversion of Control왜 컴포넌트를 직접적으로 호출하지 않을까? 리액트가 컴포넌트들의 관계를 잘 알고 있기만 하다면, 우리보다 이 일을 훨씬 더 잘 수행하기 때문이다. 12345678910111213// 🔴 React has no idea Layout and Article exist.// You're calling them.ReactDOM.render( Layout({ children: Article() }), domContainer)// ✅ React knows Layout and Article exist.// React calls them.ReactDOM.render( &lt;Layout&gt;&lt;Article /&gt;&lt;/Layout&gt;, domContainer) 이는 대표적인 제어의 역전(inversion of control) 의 사례다. 컴포넌트는 함수보다 할 수 있는 것이 많다. 리액트는 트리에서 컴포넌트의 로컬 변수를 다룰 수 있으며, 기본적인 추상화를 해준다. 리액트는 UI 트리를 렌더하고 사용자 인터랙션에 반응한다. 만약 컴포넌트를 직접 호출한다면, 이 모든 기능들을 스스로 구현해야 할 것이다. 컴포넌트 타입은 재조정 과정에 관여한다. 리액트가 모든 컴포넌트를 호출하게 함으로써, 트리의 개념적인 구조를 리액트에게 알려줄 수 있다. 리액트는 재조정을 지연시킬 수 있다. 리액트가 우리의 컴포넌트에 대해 제어권을 갖는다면, 많은 일들을 할 수 있다. 예를 들면, 컴포넌트 호출 간 브라우저에게 다른 일을 시켜 큰 컴포넌트 트리가 리렌더되는 동안 메인 쓰레드를 블라킹하지 않게 해준다. 디버깅 히스토리가 남는다. JavaScript 함수로 구현한 컴포넌트는 많은 라이브러리들이 두러워하는 일급 객체(🤔)인데, 리액트를 사요하면 개발 단계에서 훌륭한 디버깅 툴을 활용할 수 있다. Lazy Evaluation자바스크립트에서 함수를 호출하면, 인자들은 호출 이전에 평가된다. 12345// (2) This gets computed secondeat( // (1) This gets computed first prepareMeal()); 하지만 리액트 컴포넌트들은 상대적으로 순수(pure)하다. 컴포넌트를 스크린에 렌더하기 전까지는 실행시킬 이유가 없다. 만약 컴포넌트를 함수처럼 호출한다면, 해당 자식 컴포넌트를 렌더하는 부모 컴포넌트가 해당 컴포넌트를 조건부로 렌더링하고 싶은 상황에서도 무조건적으로 자식 컴포넌트를 호출할 것이다. 1234567function Story({ currentUser }) { return ( &lt;Page user={currentUser}&gt; &lt;Comments /&gt; &lt;/Page&gt; );} 1234567891011function Page({ user, children }) { // early exit if (!user.isLoggedIn) { return &lt;h1&gt;Please log in&lt;/h1&gt;; } return ( &lt;Layout&gt; {children} &lt;/Layout&gt; );} Comments 컴포넌트에는 early exit 조건이 존재한다. user.isLoggedIn의 값이 false라면 Layout과 children을 렌더링하지 않아도 된다. 1234567function Component() { return ( &lt;Page&gt; {Comments()} &lt;/Page&gt; )} 그러나 위처럼 Comments 컴포넌트를 함수로 호출하면, Comments 내부의 조건에 상관없이 우선 평가되어 실행된다. 하지만 리액트 엘리먼트에서는, 개발자가 컴포넌트를 직접 호출하지 않는다. 컴포넌트의 호출 시점을 결정하는 것은 리액트의 책임이다. 위 예제에서 Page 컴포넌트가 children prop을 렌더하기 전에 early exit하게 된다면, 리액트는 Comments 함수를 호출하지 않을 것이다. 이는 불필요한 렌더링을 줄여주고, 코드의 안전성을 보장해 준다! State호스트 인스턴스는 모든 종류의 로컬 상태(local state)을 가질 수 있다. 이 값들은 컴포넌트의 업데이트 이후 동일한 UI를 렌더 시 유지되어야 한다. 반면 개념적으로 다른 내용을 렌더할 때 요소를 제거할 수도 있어야 한다. 리액트의 컴포넌트는 로컬 상태를 가질 수 있다. 이를 ‘hooks’라고 부른다. 리액트에서 기본으로 제공하는 useState hook은 값과 해당 값을 업데이트할 수 있는 함수를 반환한다. 123456789101112function Example() { const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} Consistency재조정 과정을 논-블로킹 작업으로 분리하고 싶어도, 실제 호스트 트리에서는 이를 단일한 동기적인 과정으로 구현해야 한다. 그렇게 해야 절반만 업데이트된 UI를 렌더링하지 않을 수 있고, 브라우저가 불필요한 레이아웃과 스타일 재계산의 과정을 거치지 않음을 보장할 수 있다. 이것이 리액트가 모든 작업을 ‘렌더 단계(render phase)’와 ‘commit phase(커밋 단계)’로 나누는 이유다. 렌더 단계에서 리액트는 컴포넌트를 호출하고 재조정을 실행한다. 커밋 단계에서 리액트는 호스트 트리를 조작한다. 이 과정은 항상 동기적이다. Memoization부모 컴포넌트가 setState를 호출하여 업데이트를 발생시킨다면, 리액트는 모든 자식 서브트리에 대해 재조정을 실시한다. 리액트는 부모의 업데이트가 자식을 언제 업데이트시키는지 모르기 때문이다. 트리가 너무 깊거나 넓으면, 리액트가 서브트리를 메모(memoize)할 수 있게끔 만들어줄 수 있다. 리액트는 렌더 이전의 결과와 prop 간의 얕은 비교를 통해 서브트리를 재사용한다. 12345function Row({ item }) { // ...}export default React.memo(Row); 각각의 표현식에 대해 useMemo hook을 사용할 수도 있다. 메모이제이션이 기억하는 캐시는 컴포넌트 트리에 한정적이며, 지역 변수와 함께 사라진다. 메모이제이션은 오직 마지막 값만 기억하고 있다. Raw Models아이러니하게도, 리액트는 ‘반응형(reactivity)’이 아니다. 상위에서의 모든 업데이트는 변화가 필요한 컴포넌트 뿐 아니라 모든 컴포넌트에 재조정을 유발한다. 웹앱에서는 TTI(Time To Interactive)가 중요하고, 이벤트 리스너를 등록하기 위해 모든 모델을 탐색(traverse)하는 것은 시간 낭비다. 많은 앱에서, 상호작용은 UI 업데이트를 유발하고, 세밀하게 설계된 구독(subscription) 시스템에서 이는 메모리 낭비로 이어진다. 리액트의 핵심 디자인 원칙 중 하나는 리액트는 날 것(raw)의 데이터를 다룬다는 것이다. 네트워크에서 받은 자바스크립트 객체들이 있다면, 이를 어떤 전처리 과정 없이 컴포넌트로 직접 연결할 수 있다. 직접 프로퍼티에 접근할 수 없으며, 구조 변경 시 예측 불가능한 성능 절벽이 발생하지 않는다. 주식 티커와 같은 경우 세밀하게 설계된 구독 시스템이 유리할 수도 있다. 이는 모든 것이 동일한 시점에 지속적으로 업데이트되어야 하는 경우 사용된다. 리액트는 이런 경우에는 최선의 선택지가 아니다. Batching하나의 이벤트에 대해 여러 컴포넌트가 상태를 업데이트하고 싶을 수 있다. 123456789101112131415161718function Parent() { let [count, setCount] = useState(0); return ( &lt;div onClick={() =&gt; setCount(count + 1)}&gt; Parent clicked {count} times &lt;Child /&gt; &lt;/div&gt; );}function Child() { let [count, setCount] = useState(0); return ( &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Child clicked {count} times &lt;/button&gt; );} 위 예제에서 Child의 onClick이 먼저 실행되어 setState를 호출하고, Parent의 onClick이 실행되어 setState가 호출될 때 리액트가 각각의 setState 호출에 대해 즉시 컴포넌트를 리렌더한다면 Child 컴포넌트는 두 번 리렌더될 것이다. 이때 Child 컴포넌트의 첫 번째 렌더링은 낭비된다. 리액트는 이벤트 핸들러들 안에서 업데이트를 그룹화(batch)한다. 123456789*** Entering React's browser click event handler ***Child (onClick) - setStateParent (onClick) - setState*** Processing state updates *** - re-render Parent - re-render Child*** Exiting React's browser click event handler *** setState 호출은 즉시 리렌더를 유발하지 않는다. 리액트는 모든 이벤트 핸들러를 우선 실행한 후, 그에 해당하는 업데이트들을 묶어서 한번 리렌더한다. batching은 성능상으로 효과적이지만, 아래와 같은 코드에서는 예측이 어려울 수 있다. 1234567891011const [count, setCount] = useState(0);function increment() { setCount(count + 1);}function handleClick() { increment(); increment(); increment();} handleClick 내부에서 호출되는 increment 작업들은 모두 하나로 묶여 실행되기 때문에, setCount(1)을 세 번 호출하게 된다. 이런 문제를 해결하기 위해 리액트는 setState에 updater 함수를 전달하는 것을 권장한다. 123456789101112const [count, setCount] = useState(0);function increment() { // count의 이전 상태(업데이트 이후의 상태)를 보장한다. setCount(c =&gt; c + 1);}function handleClick() { increment(); increment(); increment();} useState 호출이 복잡해진다면, useReducer hook을 사용하여 로컬의 상태를 표현하는 것을 권장한다. 12345678910111213const [counter, dispatch] = useReducer((state, action) =&gt; { if (action === 'increment') { return state + 1; } else { return state; } }, 0); function handleClick() { dispatch('increment'); dispatch('increment'); dispatch('increment'); } Call Tree프로그래밍 언어는 종종 콜 스택을 가진다. 리액트는 자바스크립트 기반으로 동작하기 때문에 자바스크립트의 규칙을 따른다. 리액트는 내부적으로 현재 렌더중인 컴포넌트를 기억하는 콜 스택을 가진다. 리액트는 UI 트리의 렌더링을 목적으로 하기 때문에, 일반적인 언어들의 런타임과는 다르다. 이 트리들은 사용자와의 인터랙션을 위해 ‘stay alive’해야 한다. DOM은 첫 번째 ReactDOM.render 호출 이후 사라지지 않아야 한다. 리액트 컴포넌트를 ‘콜 스택’보다는 ‘콜 트리’로 생각하는 것이 좋다. 특정 컴포넌트 바깥으로 나가더라도, 리액트 ‘콜 트리’는 제거되지 않아야 한다. (콜 스택에서는 함수가 호출되면 해당 함수는 콜 스택에서 사라진다.) 어디선가는 로컬 상태값과 호스트 인스턴스에 대한 참조를 유지하고 있어야 한다. (cf. React Fiber) 이 ‘콜 트리’ 프레임은 재조정이 필요하다고 판단될 때에 로컬 상태와 호스트 인스턴스와 같이 제거된다. Fiber는 로컬 상태가 실제로 살아있는 고간이다. 상태가 변경되면, 리액트는 Fiber에 재조정이 필요함을 마킹하고, 컴포넌트들을 호출한다. Context리액트에서는 다른 컴포넌트에게 props를 통해 데이터를 전달한다. 하지만 모든 계층을 따라 props를 전달하는 것은 귀찮은 일이다. 리액트는 이에 대한 대안으로 Context API를 제공한다. Context는 컴포넌트들에게 동적인 스코프를 제공하는 것과 같다. 상위(Context Provider)에 데이터를 위치시키면, 자식 요소(Context Consumer)들에서 해당 데이터에 접근하거나 데이터의 변경에 따라 리렌더를 할 수 있다. Effects리액트 컴포넌트의 리렌더링 시에는 사이드 이펙트가 있어서는 안되지만, 때때로 사이드 이펙트가 필요한 경우가 있다. focus를 조절하거나, canvas를 그리거나, 데이터의 원천을 구독할 경우 등이다. 이 경우 useEffect hook을 사용할 수 있다. 리액트는 브라우저가 스크린을 리페인트할 때까지 effect의 실행을 가능한 지연시킨다. 이로써 데이터 구독과 같은 코드가 TTI(Time to Interactive)와 TTFP(Time to First Paint)를 저하시키지 않음을 보장한다. (모든 것을 동기적으로 동작시키는 useLayoutEffect hook도 있다.) effect는 디펜던시 배열에 따라 컴포넌트의 마운트 후에도 여러 번 실행될 수 있으며, cleanup 함수를 통해 컴포넌트 언마운트(제거) 시 실행할 동작을 정의할 수도 있다. 1234useEffect(() =&gt; { DataSource.addSubscription(handleChange); return () =&gt; DataSource.removeSubscription(handleChange);}); 특정한 변수값을 넣어 해당 값이 바뀔 때만 리렌더링을 수행할 수도 있다. 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); Custom HooksuseState와 useEffect 등의 hook들은 모두 함수 호출이기 때문에, 우리는 이것들을 우리만의 hook으로 조합할 수 있다. custom hook은 서로 다른 컴포넌트들이 상태를 포함하고 있는, 재사용 가능한 로직을 공유하도록 해준다. 이때 상태(state) 자체는 공유되지 않는다. 각각의 hook 호출은 독립적인 상태를 가진다. Static Use Order리액트에서 상태는 컴포넌트에 국한된다. use prefix는 문법은 아니지만, hooks의 네이밍 컨벤션이다. 또한 hook은 오직 컴포넌트 내부에서 선언되어야 하며, 조건부로 선언되어서는 안 된다. (cf. Rules of Hooks) 각 hook은 linked list의 형태로 호출된다. useState를 호출하면, 다음 아이템으로 포인터를 옮긴다. 컴포넌트의 ‘콜 트리’를 벗어나면, 다음 렌더가 있을 때까지 hook 호출의 결과들을 리스트로 관리한다. What’s Left Out리액트 잘 쓰자! 😜 Ref https://overreacted.io/react-as-a-ui-runtime/","link":"/2021/09/26/fe-react-as-ui-runtime/"},{"title":"로그인에 refreshToken 적용하기","text":"SSR | refreshToken 기존 놀토 프로젝트에서의 로그인은, 로그인 요청을 보내면 서버에서 보내주는 accessToken을 localStorage에 저장하는 방식으로 이루어졌다. localStorage에 accessToken이 있다면 userInfo를 생성하여 현재 로그인 중인 유저의 정보를 만들어냈다. 하지만 이 방식은 XSS 공격에 너무나 취약하다! 해커가 악성 스크립트를 삽입한다면 사용자의 토큰을 탈취하여 해당 사용자의 계정을 마음대로 이용할 수 있게 된다. 이 문제를 해결하기 위해 등장한 방식 중 하나가 refreshToken이다. 사실 refreshToken은 이전에도 잠깐 언급하고 지나갔었는데, 이번 기회에 본격적으로 도입해보게 되었다. 간단하게 정리하자면 아래와 같다. accessToken, refreshToken 모두 JWT를 사용한다. refreshToken은 클라이언트의 쿠키로 저장하며, 유효기간을 길게 설정한다. accessToken은 앱 내 변수로 관리한다. 클라이언트에서 서버 데이터 요청 시 accessToken으로 인증된 사용자의 여부를 판단한다. 팀원들과 논의하여 refreshToken을 세션(브라우저의 session storage가 아닌, 클라이언트-서버를 연결하는 세션)에 담는 방법과 쿠키에 담는 방법 두 가지를 생각해봤다. 결론적으로 선택한 것은 쿠키였지만, 그전에 세션에 담는 방법을 간단하게 살펴보고 넘어가자. 🌐 세션에 refreshToken 담기 클라이언트가 백엔드 서버에 로그인을 요청한다. 서버는 JSON 형태의 accessToken과 refreshToken을 반환한다. 클라이언트는 accessToken을 앱 내 변수에 저장하고, 서버에 accessToken을 보내 userInfo를 응답 받는다. accessToken, refreshToken, userInfo를 SSR 서버로 전달한다. SSR 서버는 accessToken, refreshToken, userInfo를 담은 세션을 생성한다. 이때 세션의 유효기간은 refreshToken의 유효기간과 같다. 이렇게 생성한 세션ID를 nginx 웹서버로 전달한다. nginx 웹서버는 세션ID를 클라이언트의 쿠키로 전송한다. 😈 문제점1) 쿠키에 담겨 있는 세션ID가 탈취당할 수 있다?쿠키에 세션ID를 저장하든, refreshToken을 곧바로 저장하든 XSS 공격은 막을 수 있겠지만 CSRF 공격에는 취약하다.CSRF 공격을 받았을 경우를 생각해 보자. 이때도 해커는 refreshToken으로 accessToken에 대한 재발급 요청만 가능할 뿐, 여전히 accessToken에 직접 접근할 수는 없다. 유저 정보를 이용하여 서버의 데이터를 가져오거나 변경하는 것은 refreshToken이 아닌 accessToken이 있어야 가능한 일이다. 즉, CSRF 공격을 통해 전달받은 결과로 서버의 데이터에 영향을 미치는 행동을 할 수는 없다. 해커가 accessToken을 재발급하는 요청을 강제로 실행시킨다한들 해당 accessToken 이용하여 어떤 동작을 수행할 수는 없는 것이다. 2) SSR 서버의 세션 부하가 너무 많이 발생한다!로그인 요청이 들어오는 모든 사용자마다 세션을 생성하여 관리해줘야 한다. 클라이언트의 렌더링에 직접 영향을 미치는 우리의 소중한 SSR 서버가 너무 많은 일을 맡는 것은 좋지 않아 보인다. 🍪 쿠키에 refreshToken 담기 클라이언트가 백엔드 서버에 로그인을 요청한다. 서버는 JSON 형태의 accessToken과 refreshToken을 반환한다. 클라이언트는 accessToken을 앱 내 변수에 저장하고, 서버에 accessToken을 보내 userInfo를 응답 받는다. 클라이언트는 SSR 서버에 (내부적으로) 로그인 요청을 보낸다. 이때 refreshToken을 요청 바디에 담아 보낸다. refreshToken을 받은 SSR 서버는 응답으로 클라이언트의 쿠키에 refreshToken을 저장한다. 이때 쿠키의 유효기간은 refreshToken의 유효기간과 같다. 클라이언트는 앱 내 변수로 accessToken을, 쿠키에 refreshToken을 갖게 되었다. 이제 클라이언트는 유저 정보가 필요한 요청에는 accessToken을 담아 전송한다. 클라이언트에서 페이지 새로고침 발생 시 앱 내 변수인 accessToken은 지워진다. 이때 클라이언트는 쿠키에 보관하고 있는 refreshToken을 SSR 서버에 전송하고, SSR 서버는 클라이언트의 ip를 확인하여 백엔드 서버에 토큰 재발급 요청을 전송한다. 토큰 재발급 요청에 대한 응답으로 SSR 서버는 새로운 accessToken과 refreshToken을 갖게 되었다. SSR 서버는 새로운 토큰을 이용해서 유저 정보를 prefetch하여 로그인된/로그아웃된 상태의 html을 클라이언트에 보내주고, (nginx 웹서버를 거친다.) script에 새로운 accessToken을 심어보낸다. (추가) 유저가 로그인되어 있는 상태에서 accessToken의 유효기간이 지난다면, 다시 서버로 토큰 재발급 요청을 보낸다. 그림으로 살펴보자. 😮 왜 백엔드 서버에서 refreshToken을 직접 쿠키에 담지 않았나? 백엔드에서 쿠키를 설정하는 상황을 가정해보자. SameSite 속성값을 Lax 또는 Strict로 설정해주고, Domain 속성에는 SSR 서버의 도메인을 설정해 준다. 이렇게하면 refreshToken 요청은 SSR 서버만 사용할 수 있게 될 것이다. 문제는 개발 환경인데, 개발 중에는 localhost에서 SSR 서버를 돌리는 프론트엔드의 입장에서 쿠키의 동작을 확인하기가 어려워진다. SameSite=None 설정그렇다고 SameSite 속성값을 None으로 설정하면, 크로스 사이트 요청의 경우에도 항상 전송된다. 모든 서드파티 쿠키를 허용하는 것으로, 보안적으로 가장 취약하며 Secure 옵션을 반드시 함께 붙여줘야 한다. 보안 설정이 따로 필요하다. 즉 쿠키의 보안 옵션을 설정하는 과정에서의 번거로움(특히, 개발 단계에서 localhost를 사용하는 경우) 때문에 JSON으로 내려주게 되었다. 페이지 리로드 시 accessToken은 만료되기 때문에 refreshToken과 accessToken을 재발급받아야 한다. 이때 SSR 서버를 거쳐 토큰 재발급을 요청하게 되는데, 요청을 보내는 클라이언트의 IP가 가장 처음 로그인 시 요청을 보냈던 클라이언트의 IP와 다르다면 백엔드 서버는 401 Unauthorized 에러를 반환한다. 그렇게 해서 아래와 같은 코드가 탄생하게 되었다. 🤸‍♀️ 대망의 코드 📜 api 설명 /login/oauth/${type}/token?code=${code}: 클라이언트에서 백엔드 서버로 보내는 로그인 요청. 응답으로 refreshToken과 accessToken을 받는다. /auth/login: 클라이언트에서 SSR 서버로 보내는 로그인 요청. SSR 서버는 refreshToken을 쿠키에 담아 응답을 전송한다. /auth/logout: 클라이언트에서 SSR 서버로 보내는 로그아웃 요청. SSR 서버는 쿠키에서 refreshToken을 삭제한다. /login/oauth/refreshToken: SSR 서버에서 백엔드 서버로 보내는 토큰 재발급 요청. 클라이언트에서 페이지 리로드 시 accessToken이 사라지므로 매번 재발급을 해준다. 요청이 유효하다면 새로운 refreshToken과 accessToken을 응답으로 보내준다. 클라이언트 측 코드부터 살펴보자. 클라이언트에서 백엔드 서버에 로그인을 보내는 요청 코드는 다음과 같다. 1234567891011121314151617// src/hooks/useOAuthLogin.tsconst useOAuthLogin = (type: 'google' | 'github') =&gt; { const history = useHistory(); const { login } = useMember(); // 백엔드 서버로 OAuth 로그인 요청을 보낸다. const getAccessToken = async (code: string) =&gt; { const { data } = await api.get&lt;AuthData&gt;(`/login/oauth/${type}/token?code=${code}`); login(data); history.push(ROUTE.HOME); }; useEffect(() =&gt; { // ... }, []);}; 위에서 사용하는 useMember hook의 login 함수는 아래 Context Provider 코드에서 확인할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637// src/contexts/member/MemberProvider.tsxconst MemberProvider = ({ children }: Props) =&gt; { const queryClient = useQueryClient(); const modal = useModal(); const dialog = useDialog(); const [accessToken, setAccessToken] = useAccessToken(); // userInfo를 가져오는 요청을 보낸다. const { data: userInfo, refetch: refetchMember } = useMyInfo({ accessToken, errorHandler: // ..., // ... }); const login = async (authData: AuthData) =&gt; { setAccessToken(authData.accessToken); // 로그인 응답으로 받은 data를 SSR 서버에 전송한다. frontendApi.post('/auth/login', authData); }; const logout = () =&gt; { // member query에 캐시되어있는 값을 제거해준다. queryClient.removeQueries(QUERY_KEYS.MEMBER); setAccessToken(''); backendApi.defaults.headers.common['Authorization'] = ''; frontendApi.post('/auth/logout'); }; const contextValue: ContextValue = useMemo( // ... ); return &lt;Context.Provider value={contextValue}&gt;{children}&lt;/Context.Provider&gt;;}; accessToken을 전반적으로 관리하는 hook인 useAccessToken을 작성했다. 1234567891011121314151617181920212223const EXPIRED_IN = 71400000;const useAccessToken = () =&gt; { // 서버에서 script 태그로 받은 accessToken을 앱 내 변수로 담는다. const [accessToken, setAccessToken] = useState(hasWindow ? window.__accessToken__ : ''); // 사용자가 로그인된 상태에서 accessToken이 만료된다면, 서버에 다시 토큰 재발급 요청을 보낸다. useEffect(() =&gt; { const timerId = setTimeout(async () =&gt; { const { data: { accessToken }, } = await frontendApi.post&lt;{ accessToken: string }&gt;('/auth/renewToken'); setAccessToken(accessToken); backendApi.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`; }, EXPIRED_IN); return () =&gt; clearTimeout(timerId); }, [accessToken]); return [accessToken, setAccessToken] as const;}; SSR 서버의 코드는 다음과 같다. /auth로 시작하는 요청에 대한 엔드포인트는 모두 한 곳에서 처리해주도록 express router를 사용했다. 12// server/index.tsxapp.use('/auth', authRoute); auth와 관련된 요청들을 살펴보자. 12345678910111213141516171819202122232425262728293031323334353637383940// server/auth.tsconst router = express.Router();router.post('/login', (req, res) =&gt; { const { body } = req; const isAuthRequest = body?.accessToken &amp;&amp; body?.refreshToken &amp;&amp; body?.expiredIn; if (!isAuthRequest) { res.status(400).send('올바른 요청 양식이 아닙니다.'); return; } res .cookie('refreshToken', body.refreshToken, { httpOnly: true, maxAge: body.expiredIn, }) .status(200) .send('true');});// 로그아웃 요청 시 쿠키의 refreshToken을 제거해준다.router.post('/logout', (_, res) =&gt; { res.clearCookie('refreshToken').status(200).send('true');});router.post('/renewToken', async (req, res) =&gt; { const { accessToken, refreshToken, expiredIn } = await getNewAuthToken(req); res .cookie('refreshToken', refreshToken, { httpOnly: true, maxAge: expiredIn, }) .status(200) .json({ accessToken });});export default router; 일반적으로 axios 등의 메서드를 이용하여 서로 다른 도메인 간에 쿠키를 주고받을 때는 CORS 문제에 걸려 쿠키를 정상적으로 받을 수 없다. 이를 해결하기 위해 클라이언트에서 요청을 보낼 때 { withCredentials: true } 옵션을 설정하고, 서버에서는 응답 시 { credentials: true } 옵션을 설정해줘야 한다. 하지만 현재 앱 구조 상 SSR 서버에서 클라이언트 페이지까지 띄우고 있는 구조(isomorphic, 즉 서버와 클라이언트가 같은 도메인을 사용)이므로 해당 설정을 해줄 필요가 없다. 클라이언트에서 토큰을 재발급 받는 요청에는 아래 함수가 호출된다. 123456789101112131415161718192021222324252627282930// server/utils.tsconst PUBLIC_IP_API = 'https://api.ipify.org/?format=text';const getNewAuthToken = async (req: express.Request): Promise&lt;AuthData&gt; =&gt; { // 클라이언트에 refreshToken이 없다면 로그아웃 상태로, 토큰 재발급 요청을 하지 않는다. if (!req.cookies.refreshToken) return; const { refreshToken } = req.cookies; // nginx proxy 환경에서 client IP를 가져오는 방법 let clientIP = req.headers['x-forwarded-for']; // 처음 로그인 요청을 보낸 클라이언트의 ip와 토큰 재발급 요청을 보낸 클라이언트의 ip가 다르다면 백엔드 서버에서 401 에러를 리턴한다. if (process.env.NODE_ENV !== 'production') { const { data: publicIP } = await axios.get(PUBLIC_IP_API); clientIP = publicIP; } // 클라이언트가 전송한 stale한 refreshToken으로 새 refreshToken을 발급받는다. try { const { data: authData } = await api.post&lt;AuthData&gt;('/login/oauth/refreshToken', { refreshToken, clientIP, }); return authData; } catch (error) { console.error(error.response); }}; 리버스 프록시 역할을 하는 nginx를 거쳐 client IP를 얻기 위해서는 request header의 x-forwarded-for를 이용할 수 있다. XFF(x-forwarded-for)는 표준 헤더는 아니지만, HTTP 프록시나 로드 밸런서를 통해 웹 서버에 접속하는 클라이언트의 원 IP 주소를 식별하는 사실상의 표준 헤더라고 할 수 있다. 1let clientIP = req.headers['x-forwarded-for']; nginx 설정은 아래와 같이 작성해준다. 공식 문서를 참고했으며, $proxy_add_x_forwarded_for 변수는 요청으로 들어오는 x-forwarded-for 헤더들에 자동으로 $remote_addr를 붙여준다고 한다. 123456789// etc/nginx/sites-available/defaultserver { location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_pass http://localhost:9000/; } // ...} 또 development 모드에서는 클라이언트의 request ip가 127.0.0.1(localhost)로 되어 있기 때문에, public ip를 받아올 수 있는 API(PUBLIC_IP_API)를 사용했다. 이후 클라이언트에서 페이지 요청이 들어올 때마다 SSR 서버는 새로운 토큰을 발급받는 getNewAuthToken을 호출하여 분주하게 움직인다. 토큰 재발급이 완료되면 1. 새로운 refreshToken과 2. accessToken을 클라이언트에 전송하며, 3. 유저 정보도 미리 prefetch하여 html을 적절하게 구성한다. 1234567891011121314151617181920212223242526272829303132333435363738const newAuthData = await getNewAuthToken(req);app.get('/', (req, res) =&gt; { // 1. 재발급받은 토큰이 있다면 cookie에 refreshToken을 담아주고, // 3. 유저 정보를 새로 prefetch하여 로그인된 상태의 html을 구성한다. if (newAuthData) { res.cookie('refreshToken', newAuthData.refreshToken, { httpOnly: true, maxAge: newAuthData.expiredIn, }); await queryClient.prefetchQuery(QUERY_KEYS.MEMBER, () =&gt; getMember({ accessToken: newAuthData.accessToken }), ); } // 2. 재발급받은 accessToken을 클라이언트에 script로 전송한다. const accessTokenScript = newAuthData ? `&lt;script&gt;window.__accessToken__ = &quot;${newAuthData.accessToken}&quot;&lt;/script&gt;` : ''; fs.readFile(indexFile, 'utf8', (err, data) =&gt; { if (err) { // ... } const result = data .replace('&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;', `&lt;div id=&quot;root&quot;&gt;${reactApp}&lt;/div&gt;`) .replace( /&lt;head&gt;(.+)&lt;\\/head&gt;/s, `&lt;head&gt;$1 ${styleTags} ${scriptTags} ${reactQueryState} ${accessTokenScript} &lt;/head&gt;`, ); return res.send(result); });}) 아직도 끝나지 않은 SSR의 여정! 다음주에 계속됩니다…드디어 끝났당! 후련하다 🤩 많이 삽질하고 많이 배울 수 있었다. 페어 미키가 함께 해준 덕에 가능했다. 리팩토링은 더 해야 하겠지만 큰일 없이 돌아가기를 바란다. Ref https://pomo0703.tistory.com/208 https://velog.io/@0307kwon/CSR-앱에서-SSR-CSR-환경으로-이주하기 https://velog.io/@yaytomato/프론트에서-안전하게-로그인-처리하기 https://seob.dev/posts/브라우저-쿠키와-SameSite-속성/ https://web.dev/samesite-cookie-recipes/","link":"/2021/10/16/fe-refreshToken/"},{"title":"Next.js 없이 React 앱 SSR 적용하기","text":"SSR | express | hydration 세상에 어떤 사람들이 Next.js를 사용하지 않고 리액트 앱을 SSR로 마이그레이션할까 싶지만… 우리는 해낸다! 🐭 페어 미키의 글에도 비슷한 내용이 정리되어 있다. webpack.server.js 세팅module과 같은 기본적인 세팅은 기존의 클라이언트 webpack 설정과 비슷하게 작성해주었다. server용 webpack 설정에서 눈여겨볼 부분은 아래와 같다. 1234567891011121314151617181920212223// webpack.server.js const path = require('path');const nodeExternals = require('webpack-node-externals'); // 1️⃣module.exports = { entry: './server/index.tsx', // 2️⃣ output: { path: path.resolve(__dirname, 'dist-server'), // 3️⃣ filename: '[name].js', publicPath: '/', clean: true, }, target: 'node', // 4️⃣ mode: process.env.NODE_ENV !== 'production' ? 'development' : 'production', module: { // ... } resolve: { extensions: ['.tsx', '.ts', '.js'], modules: [path.resolve(__dirname, 'src'), 'node_modules'], }, externals: [nodeExternals()], // 1️⃣}; 1️⃣ webpack-node-externals 라이브러리를 통해 node_modules 패키지들을 번들에서 제외(import-export로 서로 의존하는 파일들을 번들 파일에 모두 넣는 것을 방지)하기 위해 사용한다. 서버의 실행 환경이 될 node는 node_modules의 패키지들을 이미 가지고 있기 때문에 빌드 과정에서 제외시켜, 빌드 시간을 단축하고 불필요한 모듈들의 의존성을 제거할 수 있다. 2️⃣ webpack 번들링의 시작점을 server 파일로 잡아준다. 3️⃣ server 번들링 결과물을 dist-server라는 디렉토리에 넣어준다. 4️⃣ server 번들링 파일이 실행되는 환경은 web이 아닌 node이므로 target에 작성해준다. server 파일 작성node 서버 실행을 위해 express 프레임워크를 사용할 것이기 때문에 express를 설치해 준다. 12$ yarn add express $ yarn add -D @types/express 기본 코드는 아래와 같이 작성했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// server/index.tsximport React from 'react';import ReactDOMServer from 'react-dom/server';import { StaticRouter } from 'react-router';import { ServerStyleSheet, StyleSheetManager } from 'styled-components';import express from 'express';import path from 'path';import fs from 'fs';import App from '../src/App';const PORT = process.env.PORT || 9000;const app = express(); // 1️⃣const sheet = new ServerStyleSheet(); // 2️⃣app.use(express.json()); // 3️⃣app.use(express.static(path.resolve(__dirname, '../dist'))); // 4️⃣app.get('/', async (req, res) =&gt; { // 5️⃣ const reactApp = ReactDOMServer.renderToString( // 6️⃣ &lt;StyleSheetManager sheet={sheet.instance}&gt; &lt;StaticRouter location={req.url}&gt; &lt;App /&gt; &lt;/StaticRouter&gt; &lt;/StyleSheetManager&gt; ); const styleTags = sheet.getStyleTags(); // 2️⃣ const indexFile = path.resolve(__dirname, '../dist/index.html'); // 7️⃣ fs.readFile(indexFile, 'utf8', (err, data) =&gt; { // 8️⃣ if (err) { console.error('Node.js 서버에서 에러가 발생했습니다.', err); return res.status(500).send('서버에서 에러가 발생했습니다. 🔫'); } const result = data .replace('&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;', `&lt;div id=&quot;root&quot;&gt;${reactApp}&lt;/div&gt;`) // 9️⃣ .replace(/&lt;head&gt;(.+)&lt;\\/head&gt;/s, `&lt;head&gt;$1 ${styleTags}&lt;/head&gt;`); // 2️⃣ return res.send(result); // 🔟 });});app.listen(PORT, () =&gt; { console.log(`Server is listening on port ${PORT}`);}); 숫자 이모지가 🔟까지밖에 없어서, 최대한 분리해보았다 😬 1️⃣ express 앱을 생성한다. 2️⃣ 클라이언트의 리액트 앱에서 styled-components를 사용하고 있기 때문에, 미리 스타일링 코드를 받아서 서버에서 내려주기 위한 용도로 사용한다. 클라이언트에 전달할 &lt;head&gt; 태그 안에 심어서 보내준다. 3️⃣ express 서버에서 json으로 이루어진 request body를 받았을 경우 이를 해석하기 위해 사용하는 메서드다. express v4 이전까지는 body-parser라는 별도의 모듈을 설치해 사용했다. 4️⃣ 이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일을 제공하기 위해서 사용하는 express의 기본 제공 미들웨어 함수이다. webpack 빌드 시 생성되는 파일들을 불러오기 위해 사용한다. 5️⃣ root url(/)로 들어오는 요청을 처리한다. 6️⃣ ReactDOMServer는 컴포넌트를 정적 마크업으로 렌더링할 수 있게 해주는 객체로, 주로 Node 서버에서 사용한다. renderToString는 리액트에서 지원하는 서버사이드 렌더링 메서드로, 리액트 엘리먼트의 초기 HTML을 렌더링한다. 클라이언트 리액트 코드의 hydrate와 함께 사용한다. 7️⃣ 번들 파일이 위치한 디렉토리의 html 파일을 가져온다. 8️⃣ node에서 기본으로 제공하는 file system 모듈로, 파일을 읽고 쓸 수 있는 메서드를 제공한다. 여기서는 번들 결과의 html 파일을 읽어 클라이언트에 내려주기 위한 목적으로 사용한다. 9️⃣ 번들 결과의 html 파일을 가져왔다면, 리액트 앱이 시작되는 &lt;div id=&quot;root&quot;&gt;에 아까 renderToString으로 마크업한 기본 HTML 파일을 심어준다. 🔟 express 서버에 요청을 보낸 클라이언트에 지금까지 생성한 응답을 반환한다. 👾 path.join vs path.resolve path.join은 나열된 인자들을 순서대로 연결해주기만 한다. 반면 path.resolve는 현재 디렉토리를 기반으로 절대경로의 URL을 반환한다. 전달 받은 인자들의 오른쪽부터 왼쪽으로 인자를 합쳐나가며, 이 과정에서 ‘/‘를 만나면 절대경로로 인식해서 나머지 인자들을 무시한다.만약 ‘/‘를 끝까지 만나지 못한다면 ‘/현재경로/생성된경로’ 형태로 결과를 리턴한다. 12path.join('/a', '/b'); // 'a/b'path.resolve('/a', '/b'); // '/b' React hydration위와 같이 서버를 구성했다면, 기존 리액트 렌더링 코드도 조금 수정해줘야 한다. SSR을 적용한 리액트 앱은 hydration을 수행한다. hydration은 직역하면 수분화, 즉 수분을 보충하는 행위다. 지금까지는 아래 코드를 통해 브라우저 DOM에 리액트 코드를 삽입했다. 1ReactDOM.render(element, container[, callback]); 컨테이너 DOM에 리액트 엘리먼트를 렌더링해준다. 컨테이너의 자식으로 리액트 컴포넌트를 넣어주는데, 기존에 이미 렌더링된 리액트 컴포넌트가 있다면 새로 렌더링하는 것이 아니라 업데이트만 해준다. 그리고 렌더링이 완료되면 세 번째 인자로 전달된 콜백을 실행한다. SSR을 사용할 때는 ReactDOM.hydrate 메서드를 사용한다. hydrate는 렌더링은 하지 않고 이벤트 핸들러만 붙여준다. 서버에서 이미 마크업된 결과물을 가져오므로 모든 걸 다시 render해줄 필요가 없다. 12345678ReactDOM.hydrate( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;, document.getElementById('root'),); 서버는 dehyration을 통해 동적인 컴포넌트를 정적으로 만들어서 완성된 HTML을 보내준다. 클라이언트(리액트 앱)는 서버로부터 받은 정적인 HTML을 동적인 리액트 컴포넌트 트리로 변환하는데, 이것을 (re)hydrate라고 한다. hydrate이 완료된 이후부터는 컴포넌트를 리액트가 관리하게 된다. 이렇게 첫 페이지에 대한 SSR을 우선적으로 완료했다! node 명령어로 앱 실행 후 브라우저를 열어 확인해보자. 1$ node ./dist-server/main.js 개발자 도구의 네트워크 탭을 열어보면, 서버에서 만든 응답에서부터 이미 모든 HTML 요소들이 마크업되어 내려오는 것을 확인할 수 있다. (왜 Happy Chuseok이 뜨는지는…) loadable components와 연결현재 리액트 앱에서 코드 스플리팅을 위해 loadable components를 사용하고 있는데, SSR을 적용할 경우 서버에서도 관련된 처리가 필요하다. 👾 SSR에서 코드 스플리팅이 필요한 이유 기본적으로 코드스플리팅된 파일들은 main.js를 모두 로드하고 나서야 로드된다. 이게 바로 서버사이드 렌더링용 코드 스플리팅이 필요한 이유다. 현재는 코드를 나누기만 했을 뿐 결국 하나의 번들과 똑같은 로딩시간을 필요로 한다. 오히려 서버에 요청하는 request 횟수만 늘린 꼴이 된다. ex) About 페이지로 초기 진입(혹은 새로고침)했을 때, SSR 코드스플리팅이 적용되어 있지 않았다면 main에서 필요한 코드를 모두 가져온 후 main에서 About 페이지 접속 시 다시 About 청크 파일에 대한 요청을 한다. 이는 SSR을 활용하지 못하고 있는 셈이다. 따라서 SSR에도 코드스플리팅을 적용하여 초기 진입 페이지에서 필요한 JS 파일을 &lt;script&gt; 태그에 넣어서 병렬적으로 로드한다. 우선 babel이 loadable component를 이해할 수 있도록 서버용 webpack 설정에 @loadable/babel-plugin을 넣어준다. 1$ yarn add -D @loadable/babel-plugin 123456789101112131415161718192021222324// webpack.server.jsmodule.exports = { // ... module: { rules: [ { test: /\\.(tsx|ts)$/, use: [ { loader: 'babel-loader', options: { presets: [ // ... ], plugins: [ // ... '@loadable/babel-plugin', ], }, }, ], exclude: /node_modules/, },} 그리고 loadable components들을 번들링한 결과물을 json 형태의 파일로 추출하기 위해 기존 webpack 설정에 @loadable/webpack-plugin을 추가한다. 1$ yarn add -D @loadable/webpack-plugin 12345678910// webpack.common.jsconst LoadablePlugin = require('@loadable/webpack-plugin');module.exports = { // ... plugins: [ // ... new LoadablePlugin(), ],} 이 상태로 빌드(클라이언트)를 하면, dist 폴더 안에 loadable-stats.json 파일이 생성된다. 내용물은 대략 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435363738{ &quot;hash&quot;: &quot;584b21677c2d7ccac8e5&quot;, &quot;publicPath&quot;: &quot;/&quot;, &quot;outputPath&quot;: &quot;/Users/songji/Desktop/woowacourse/lv3/2021-nolto/frontend/dist&quot;, &quot;assetsByChunkName&quot;: { &quot;main&quot;: [ &quot;main.55573f72591fb92bbd79.js&quot; ], &quot;About&quot;: [ &quot;About.68ffc067e6ca06e7f93c.js&quot; ], &quot;vendor&quot;: [ &quot;vendor.8782ff7e073e2517c89c.js&quot; ], // ... }, &quot;assets&quot;: [ { &quot;type&quot;: &quot;asset&quot;, &quot;name&quot;: &quot;vendor.8782ff7e073e2517c89c.js&quot;, &quot;size&quot;: 528835, &quot;emitted&quot;: false, &quot;comparedForEmit&quot;: false, &quot;cached&quot;: true, &quot;info&quot;: { // ... }, // ... &quot;chunkNames&quot;: [ &quot;vendor&quot; ], &quot;chunkIdHints&quot;: [ &quot;vendor&quot; ], // ... }, // ...} 이제 이 json 파일을 서버에서 불러와서 chunk 파일로 분리해줄 것이다. 12345678910111213141516171819202122232425262728293031323334// server/index.tsximport { ChunkExtractor } from '@loadable/server';// chunk 정보를 담고 있는 json 파일을 불러온다.const statsFile = path.resolve(__dirname, '../dist/loadable-stats.json');const extractor = new ChunkExtractor({ statsFile });app.get('/', async (req, res) =&gt; { const jsx = extractor.collectChunks( &lt;StyleSheetManager sheet={sheet.instance}&gt; &lt;StaticRouter location={req.url}&gt; &lt;App /&gt; &lt;/StaticRouter&gt; &lt;/StyleSheetManager&gt;, ); const scriptTags = extractor.getScriptTags(); const reactApp = ReactDOMServer.renderToString(jsx); // ... fs.readFile(indexFile, 'utf8', (err, data) =&gt; { if (err) { // ... } const result = data .replace('&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;', `&lt;div id=&quot;root&quot;&gt;${reactApp}&lt;/div&gt;`) .replace(/&lt;head&gt;(.+)&lt;\\/head&gt;/s, `&lt;head&gt;$1 ${styleTags} ${scriptTags}&lt;/head&gt;`); // head 태그에 scriptTags 삽입 return res.send(result); });} loadable로 분리된 청크 파일들이 모두 병렬적으로 로드되어 scripts에 들어갈 때까지 기다리도록 리액트 진입점의 코드도 수정해준다. 1234567891011121314// src/index.tsximport { loadableReady } from '@loadable/component';// loadableReady로 감싸준다.loadableReady(() =&gt; { ReactDOM.hydrate( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;, document.getElementById('root'), );}); About 페이지에서 접속 시 아래와 같이 script 태그로 About의 청크 파일을 불러오는 것을 볼 수 있다. 다른 페이지에서부터 리액트 라우터를 통해 접속 시에는 여기서 가져오지 않고, 클라이언트에서 새로 요청을 통해 받아온다. (서버 코드 파일에서 ‘/about’ url 요청에 대한 처리를 위해 app.get 코드도 추가해준 상태다.) React 18 설치짜잔! … SSR이 정상적으로 적용된 줄 알았더니, 한 가지 고비가 더 있었다. 1Error: ReactDOMServer does not yet support Suspense. 😑 그렇다. loadable components는 SSR을 지원하지만, Suspense까지는 지원하지 않는 것이었다. 그래서 코드 스플리팅 도구를 선택할 때, Suspense를 필수적으로 써야하는 React.lazy는 SSR을 지원하지 않는다고 한 것 같다. react-query까지 이용하는 마당에 Suspense를 걷어낼 수는 없어서, 불과 몇 달 전 발표된, Suspense를 지원하는 React 18을 사용하기로 했다! 1$ yarn add react@alpha react-dom@alpha React 18의 최신 기능에 대한 내용은 여기서 확인할 수 있다. TroubleShootingnode에서는 못 찾는 window 분리하기(아직 해결 중인 문제) localStorage나 window.Kakao 등 window 객체에 접근해야 하는 코드가 이곳저곳 산발되어 있었는데, node 서버로 실행한 환경에는 window가 없다. 문제를 해결하기 위해 급한 대로 말도 안 되는 이름(windowDetector)의 util을 만들어 node 환경에서는 window를 실행하는 코드를 무시하고 넘어가도록 했다. 1234// windowDetector.jsconst hasWindow = typeof window !== 'undefined' ? true : false;export default hasWindow; 사용하는 곳에서는 대략 이런 느낌… 12345if (process.env.KAKAO_API_KEY &amp;&amp; !window.Kakao.isInitialized()) { if (hasWindow) { window.Kakao.init(process.env.KAKAO_API_KEY); }} ESModule 타입의 패키지를 nodeExternals에서 제외하기(아직 해결 중인 문제) 서버 번들링 파일에서 node_modules를 제외하기 위해 webpack-node-externals를 사용했다. 그 결과 node_modules로 설치한 패키지들은 번들 파일에 모두 들어가지 않고, 개별적으로 require 메서드를 통해 불러오게 된다. 그런데! 프로젝트에서 사용하고 있는 라이브러리 중 react-markdown이 require를 사용하는 CommonJS 형태의 모듈 방식을 지원하지 않아 문제가 발생했다. (해당 라이브러리의 package.json을 보면 &quot;type&quot;: &quot;module&quot;이라고 적혀있는 것을 확인할 수 있다.) Must use import to load ES Module: 그래서 이 친구는… externals에서 제외시켜줘야 한다. 다행히 allowlist 옵션을 통해 원하는 모듈만 번들에 다시 포함시킬 수 있게 해줄 수 있을 줄 알았는데, peerDependency 문제인지 하나를 해결하면 줄줄이 다 위와 같은 에러가 발생하여 일단은 어디까지 가나 보자, 하는 심정으로 모조리 넣어주었다. 굉장히 못생긴 코드가 탄생했고, 다른 방법을 계속해서 찾아볼 예정이다. 😑 1234567// webpack.server.jsconst nodeExternals = require('webpack-node-externals');module.exports = { // ... externals: [nodeExternals()]} 1234567891011121314externals: [ nodeExternals({ allowlist: [ 'react-markdown', 'unified', 'bail', 'is-plain-obj', 'trough', 'remark-rehype', 'mdast-util-to-hast', 'unist-util-generated', ], }),], 서버의 express.static이 index.html을 가져가버리는 문제1234// server/index.tsxapp.use(express.static(path.resolve(__dirname, '../dist')));app.get('/', async (req, res) =&gt; { }); 위와 같이 작성하면, ‘../dist’ 폴더로 접근했을 때의 root url(/)이 index.html을 가리키고 있기 때문에 클라이언트에서 root url로 요청을 보내는 경우 app.get 요청까지 갈 수가 없어 원하는 응답을 받을 수 없다. 아래와 같이 { index: false } 옵션을 제공하여 static 미들웨어가 root url(/)에서 index.html을 포함시킬 수 없도록 해주면 문제가 해결된다. 123// server/index.tsxapp.use(express.static(path.resolve(__dirname, '../dist'), { index: false })); 정리최종적으로 작성한 코드는 다음과 같다. (아마 수정될 것이다) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// server/index.tsximport React from 'react';import ReactDOMServer from 'react-dom/server';import { StaticRouter } from 'react-router';import { ServerStyleSheet, StyleSheetManager } from 'styled-components';import { ChunkExtractor } from '@loadable/server';import express from 'express';import path from 'path';import fs from 'fs';import App from '../src/App';const PORT = process.env.PORT || 9000;const app = express();const sheet = new ServerStyleSheet();app.use(express.json());app.use(express.static(path.resolve(__dirname, '../dist'), { index: false }));const statsFile = path.resolve(__dirname, '../dist/loadable-stats.json');const extractor = new ChunkExtractor({ statsFile });app.get(['/', '/about', '/feeds/:feedId'], async (req, res) =&gt; { const jsx = extractor.collectChunks( &lt;StyleSheetManager sheet={sheet.instance}&gt; &lt;StaticRouter location={req.url}&gt; &lt;App /&gt; &lt;/StaticRouter&gt; &lt;/StyleSheetManager&gt;, ); const scriptTags = extractor.getScriptTags(); const reactApp = ReactDOMServer.renderToString(jsx); const styleTags = sheet.getStyleTags(); const indexFile = path.resolve(__dirname, '../dist/index.html'); fs.readFile(indexFile, 'utf8', (err, data) =&gt; { if (err) { console.error('Node.js 서버에서 에러가 발생했습니다.', err); return res.status(500).send('서버에서 에러가 발생했습니다. 🔫'); } const result = data .replace('&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;', `&lt;div id=&quot;root&quot;&gt;${reactApp}&lt;/div&gt;`) .replace(/&lt;head&gt;(.+)&lt;\\/head&gt;/s, `&lt;head&gt;$1 ${styleTags} ${scriptTags}&lt;/head&gt;`); return res.send(result); });});app.listen(PORT, () =&gt; { console.log(`Server is listening on port ${PORT}`);}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// webpack.server.jsconst path = require('path');const nodeExternals = require('webpack-node-externals');module.exports = { entry: './server/index.tsx', output: { path: path.resolve(__dirname, 'dist-server'), filename: '[name].js', publicPath: '/', clean: true, }, target: 'node', mode: process.env.NODE_ENV !== 'production' ? 'development' : 'production', module: { rules: [ { test: /\\.(tsx|ts)$/, use: [ { loader: 'babel-loader', options: { presets: ['@babel/preset-env', '@babel/preset-react', '@babel/preset-typescript'], plugins: [ '@babel/plugin-transform-runtime', 'babel-plugin-styled-components', '@loadable/babel-plugin', ], }, }, ], exclude: /node_modules/, }, { test: /\\.svg$/, use: ['@svgr/webpack'], }, { test: /\\.(png|jpe?g|gif|webp|mp4)$/i, type: 'asset/resource', generator: { filename: 'static/[name][ext]', }, }, ], }, resolve: { extensions: ['.tsx', '.ts', '.js'], modules: [path.resolve(__dirname, 'src'), 'node_modules'], }, externals: [ nodeExternals({ allowlist: [ 'react-markdown', 'unified', 'bail', 'is-plain-obj', 'trough', 'remark-rehype', 'mdast-util-to-hast', 'unist-util-generated', ], }), ],}; 12345678910111213141516171819// src/index.tsximport React from 'react';import ReactDOM from 'react-dom';import { BrowserRouter } from 'react-router-dom';import { loadableReady } from '@loadable/component';import App from './App';loadableReady(() =&gt; { ReactDOM.hydrate( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;, document.getElementById('root'), );}); (추가) react-query 데이터 prefetch와 React Portal 문제 해결🍀 여기서 읽기 Ref https://simsimjae.tistory.com/389 https://minoo.medium.com/next-js-처럼-server-side-rendering-구현하기-7608e82a0ab11 https://www.digitalocean.com/community/tutorials/react-server-side-rendering https://www.npmjs.com/package/webpack-node-externals https://jamong-icetea.tistory.com/349 https://ko.reactjs.org/docs/react-dom-server.html https://www.hanumoka.net/2018/11/08/node-20181108-node-path-join-vs-resolve/","link":"/2021/10/02/fe-ssr/"},{"title":"git 명령어 부셔보기","text":"이제는 정복해 보자 3년이나 개발을 공부해왔음에도 불구하고 매번 답이 안 나오는 git… 🤦‍♀️ 회사 코드를 본격적으로 뜯어보기 전, 설날 기념 잉여인간일 때 git을 정복해야겠다는 생각이 들었다. GUI 도구인 Git Kraken을 사용하고 싶기도 하고… (2/6 추가)많이 공부하긴 했으나 더 알아야 할 내용이 많다. 언젠간 추가할 것. 이라고 해놓으면 분명 안하겠지만 두번째 민족 대명절인 추석이 오기 전에는 (…) 할 것이라고 믿는다. ✅ 변경 이력 등록하기git을 사용하는 로컬 저장소의 workflow는 크게 세 가지 단계로 나뉜다. 작업 디렉토리(working directory): 현재 작업중인 공간으로, 마음대로 편집할 수 있다. 스테이징 영역(staging area): commit할 준비가 된 파일을 잠시 올려두는 공간으로, 작업 디렉토리와 HEAD 사이 징검다리 역할을 한다. 💡 스테이징 영역은 공식적으로는 인덱스(index) 라고 표현하고 있지만, 여기서는 일상적으로 사용하는 용어인 스테이징 영역을 사용한다. HEAD: 스테이징 영역에 있는 데이터의 스냅샷을 찍어 커밋(commit)을 생성하여 git이 관리하게 되는 공간이다. 가장 최근 변경본을 가리킨다. 이때 작업 디렉토리의 파일들은 다시 두 가지로 나뉜다. 한번이라도 git의 관리 대상이 되어 스냅샷이 있는 파일의 경우에는 tracked, 새롭게 추가되어 git이 아직 모르는 파일은 untracked 파일로 구분한다. ‘a.txt’라는 파일을 생성하고 내용을 입력한 뒤, git status를 통해 작업 트리를 확인해보자. 💡 git status 명령어는 작업 디렉토리와 스테이징 영역의 상태를 확인하기 위해서 사용한다. 아직 한번도 git이 관리한 적이 없는 a.txt 파일이 Untracked files에 빨간색 글씨로 표시된다. git add 명령어로 스테이징 영역에 파일을 올려보자. 1git add a.txt 💡 git add에 옵션을 붙여 스테이지(stage)할 파일의 목록을 선택할 수 있다. git add .: 현재 디렉토리의 모든 변경 내용을 스테이징할 때 git add -A: 모든 디렉토리의 모든 변경 내용을 스테이징할 때 그러면 다음과 같이 a.txt가 commit할 준비가 되어있음을 알려준다. 이제 변경된 파일을 커밋해보자. git commit 명령어로 현재 스테이징된 파일들을 커밋한다. 1git commit 위 명령어만 입력하면 다음과 같이 커밋 메시지를 입력할 수 있는 쉘이 뜬다. 쉘을 이용하는 건 상당히 무섭고 귀찮은 일이므로, 명령어 자체에 커밋 메시지를 추가해보도록 하자. 1git commit -m [커밋 메시지] 이제 git log로 커밋 내역을 확인해보자. 로그를 살펴보면 HEAD -&gt; main이라고 되어있는 것을 확인할 수 있다. 여기서 HEAD는 현재 브랜치를 가리키는 포인터이며, 지금의 HEAD가 가리키는 커밋은 바로 다음 커밋의 부모가 된다. 여기서 다시! a.txt 파일의 내용을 수정한 후, git status를 실행해 보자. 여전히 빨간 글씨로 표시되지만, 처음에 a.txt를 만들어 Untracked 영역에 있을 때와는 달리 Changes not staged for commit이라는 메시지를 볼 수 있다. Tracked 영역, 즉 이미 git이 관리하고 있는 파일에 수정이 발생한 것이기 때문이다. 이렇게 작업을 했던 워킹 디렉토리의 변경사항을 날리고 싶다면 git restore a.txt 명령어를 실행해준다. 💡 git restore 명령어는 작업 디렉토리에서 수정한 파일을 되돌리는 명령어다. 이미 스테이징한 파일을 되돌릴 때는 git restore --staged 명령어를 사용하면 된다. 🥊 리모트 저장소 이용하기remotegit remote 명령어를 통해 로컬과 연결되어 있는 모든 저장소의 이름을 확인할 수 있다. git clone을 통해 리모트 저장소를 복제했다면 리모트 저장소 이름은 기본적으로 origin이 되며, git remote rename [이전 이름] [새로운 이름] 명령어로 로컬에서 사용할 리모트 저장소 각각의 이름을 바꿀 수 있다. git remote add [단축 이름] [URL] 명령어를 통해 기존 워킹 디렉토리에 새 리모트 저장소를 추가할 수도 있다. 💡 유용한 git remote 옵션 git remote -v: 리모트 저장소들의 이름을 URL과 함께 볼 수 있다. git remote show [리모트 저장소 이름]: 리모트 저장소의 구체적인 정보(브랜치 등)를 확인할 수 있다. pushgit commit으로 파일의 변경 이력을 로컬 저장소에 남겼다. 이제 리모트 저장소인 github에 코드의 변경 이력을 반영하기 위해서는 git push 명령어로 로컬 저장소의 내용을 전송해줘야 한다. git push 명령어는 기본적으로 리모트 저장소 이름과 브랜치 이름을 인자로 받는다. 1git push [저장소 이름] [브랜치 이름] git push 명령어를 사용할 때마다 매번 저장소명과 브랜치명을 입력하는 게 귀찮다면, -u 옵션을 사용하여 최초 한번만 저장소명과 브랜치명을 입력하고 그 이후에는 인자들을 생략할 수 있다. 1git push -u origin main git log로 확인해보면 아래와 같이 커밋에 빨간 글씨로 origin/main과 origin/HEAD가 추가된 것을 볼 수 있다. fetch리모트 저장소에서 데이터를 가져올 때는 fetch 명령어를 사용한다. 1git fetch [리모트 저장소 이름] 이 명령은 로컬에는 없지만, 리모트 저장소에는 있는 데이터를 모두 가져온다. 이때 데이터를 ‘가져오기’만 하고 merge 시켜주지는 않는다. pullpull 명령어는 리모트 저장소의 브랜치에서 데이터를 가져올 뿐 아니라, 자동으로 로컬 브랜치의 현재 코드에 merge시켜준다. fetch와 merge를 합친 명령어다. pull 명령어는 아래 브랜치 시스템을 이해하며 더 자세히 알아보자. 🌴 브랜치 시스템 이해하기브랜치 만들고 이동하기모든 버전 관리 시스템은 브랜치를 지원하며, git 역시 훌륭한 브랜치 전략을 지원한다. 잘 사용하지 못하는 것은 우리의 책임인 것이다. git은 데이터를 change set이나 변경사항(diff)으로 기록하지 않고 일련의 스냅샷으로 기록한다는 점이 특징적이다. 새로 브랜치를 만들 때 프로젝트를 통째로 복사하는 대신, git의 브랜치는 어떤 한 커밋을 가리키는 SHA-1 체크섬 파일에 불과하기 때문에 생성과 삭제가 쉽고 효율적인 메모리 관리가 가능하다. 브랜치를 직접 만들어보자. 1git branch feat1 위 명령어로 브랜치를 만들 수도 있지만, 브랜치 생성과 동시에 해당 브랜치로 이동까지 해줄 수도 있다. 1git checkout -b feat1 git은 지금 작업 중인 (로컬) 브랜치를 HEAD라는 특수한 포인터로 파악한다. 방금 전 feat1 브랜치로 이동했으므로 이제 HEAD는 feat1 브랜치를 가리키게 된다. 이 상태에서 ‘feat1.txt’ 파일을 생성하고 커밋을 새로 해보자. 12git add feat1.txtgit commit -m &quot;create feat1.txt&quot; 이제 HEAD가 가리키는 feat1 브랜치가 main보다 한 단계 앞서있다. 다시 main 브랜치로 되돌아가보자. 1git checkout main 이제 main 브랜치가 가리키는 커밋을 HEAD가 가리키게 되었으며, 워킹 디렉토리의 파일도 그 시점으로 되돌려 놓았다. 💡 유용한 git branch 옵션들 git branch -r: 리모트 브랜치 목록 보기 git branch -a: 로컬 브랜치 목록 보기 git branch -m [이전 이름] [새 이름]: 브랜치 이름 바꾸기 git branch -d [브랜치 이름]: 브랜치 삭제하기 브랜치 merge하기현재 main 브랜치에서 작업을 하다가 특정한 이슈를 처리하기 위해 feat1 브랜치를 만들었다. 이때 갑자기 프로젝트에 문제가 생겨서 급하게 버그를 해결해야 하는 경우가 발생한다. hotfix 내용에 feat1의 작업 내역이 섞이는 것을 방지하기 위해 다시 main 브랜치로 돌아간 후 hotfix1 브랜치를 만들어 이동한다. 12git checkout maingit checkout -b hotfix1 💡 이때 feat1에 아직 커밋하지 않은 파일이 있고, 해당 파일이 main 브랜치와 충돌이 난다면 main 브랜치로 checkout할 수 없다. 이때는 git stash 명령어를 통해 워킹 디렉토리를 정리할 수 있다. hotfix1 브랜치에서 버그 수정 후 커밋을 하면 브랜치 히스토리는 아래와 같이 그려질 것이다. hotfix 내용을 운영 환경에 적용하기 위해 hotfix1 브랜치를 main 브랜치에 합쳐야 한다. 여기서 git merge를 사용한다. 12git checkout maingit merge hotfix1 hotfix1 브랜치가 가리키는 커밋이 main이 가지고 있는 커밋 히스토리를 모두 포함하고 있기 때문에 브랜치 포인터는 그저 최신 커밋으로 이동한다. 이렇게 단순히 브랜치 포인터를 이동하는 merge 방식을 Fast-forward(빨리감기)라고 부른다. 이때는 merge commit이 생기지 않는다. 이제 main과 hotfix1 브랜치 포인터는 같은 커밋을 가리키게 되었다. 이제 필요 없어진 hotfix1 브랜치는 삭제하고, 원래 작업하던 feat1 브랜치로 돌아가 작업을 계속한다. 12git branch -d hotfix1git checkout feat1 feat1에서 어느 정도 작업을 한 이후에는 해당 작업 내용을 main 브랜치에 merge해야 한다. 현재 브랜치 히스토리는 아래와 같다. 12git checkout maingit merge feat1 hotfix1을 merge했을 때와는 메시지가 다르다. 현재 브랜치가 가리키는 커밋이 merge할 브랜치의 조상이 아니므로 (merge할 브랜치의 모든 커밋을 포함하고 있지 않으므로) Fast-forward merge가 불가능하다. 이 경우 git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way merge를 한다. 단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라, 3-way merge의 결과를 별도의 커밋으로 만든 후 해당 브랜치가 그 커밋을 가리키도록 이동시키는 것이다. 이때 만약 hotfix1 브랜치와 feat1 브랜치가 같은 부분을 수정했다면 작업 내역에 충돌이 발생할 수도 있다. 이 경우 git은 자동 merge를 하지 못하며, 개발자가 Conflict를 해결해줘야 한다. 충돌한 부분을 모두 해결하고 git add 명령어로 다시 git에 저장한 후, 커밋을 해주면 merge가 완료된다! 리모트 브랜치와 싱크 맞추기지금까지의 작업은 모두 로컬 브랜치에서 진행한 내용이다. 이제 리모트 저장소로 가보자! 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 레퍼런스이며 브랜치다. 리모트 트래킹 브랜치는 일종의 북마크로, 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다. 리모트 트래킹 브랜치의 이름은 [리모트 저장소 이름]/[브랜치 이름] 형식으로 되어 있다. github의 레퍼지토리를 clone 받는다면 git은 이 리모트 저장소에 자동으로 origin이라는 이름을 붙이고, main 브랜치를 가리키는 포인터를 만든다. 이 포인터가 바로 origin/main이며, 로컬의 main 브랜치는 origin/main을 가리키게 된다. 리모트 저장소의 main 브랜치에 누군가 다른 내용을 변경한 커밋을 push했다면 로컬의 main 브랜치와 히스토리가 서로 달라지게 된다. 이때는 우선 fetch 명령어로 리모트 저장소에 있는 브랜치의 내용을 가져온다. 1git fetch origin 💡 이때 리모트 저장소에서 가져온 최신 커밋 이력은 이름 없는 브랜치로 로컬에 불러와지며, 임시로 FETCH_HEAD라는 특수한 이름을 가진다. git checkout FETCH_HEAD 명령어로 리모트 저장소에서 가져온 업데이트를 확인해볼 수 있다. 그러면 브랜치 히스토리는 아래와 같아진다. fetch를 통해 서버의 데이터를 받아와서 저장했지만, 워킹 디렉토리의 파일 내용은 변경되지 않고 그대로 남아있다. 새로 받은 브랜치의 내용을 합쳐주기 위해서 merge를 실행한다. 1git merge origin/main pull 명령어를 사용하면 fetch와 merge를 한번에 해줄 수 있다. 1git pull origin main 💡 협업 시 사용했던 리모트 브랜치를 만든 후 작업을 마쳐 더 이상 해당 브랜치가 필요하지 않게 되었다면, git push origin --delete [브랜치 이름] 명령어로 리모트 브랜치를 삭제해준다. 👩‍🔧 고통의 rebase고통의 rebase 단계에 진입했다… merge 말고도 git에서 한 브랜치에서 다른 브랜치로 합치는 방법이 있다. 바로 rebase다. 위 그림과 같이 브랜치가 분기되어있을 때, merge 명령어를 사용하여 합치면 3-way merge로 새로운 커밋이 생성된다. 이때 C4의 변경 사항을 Patch로 만들고 이를 다시 C5에 적용시키는 방법이 있다. 이를 바로 rebase라고 한다. rebase 명령어로 한 브랜치의 변경 사항을 다른 브랜치에 적용할 수 있다. 12git checkout feat1git rebase main 실제로 rebase가 진행되는 과정은 다음과 같다. main, feat1 두 브랜치가 나뉘기 전인 공통 브랜치(C3)로 이동한 후 그 커밋부터 지금 checkout한 브랜치가 가리키는 커밋까지 diff를 차례대로 만들어 어딘가에 임시로 저장해 놓는다. rebase할 브랜치(feat1)가 합칠 브랜치(main)이 가리키는 커밋을 가리키게 하고, 아까 저장해 놓았던 변경사항을 차례대로 적용한다. rebase 이후의 브랜치 히스토리는 아래와 같다. 이제 main 브랜치도 C4' 커밋을 가질 수 있도록 main 브랜치를 Fast-forward시켜준다. 12git checkout maingit merge feat1 짠!✨ 새로운 머지 커밋 없이 히스토리가 예쁘게 정리되었다. 💡 merge vs rebase merge: 변경 내용의 이력이 모두 그대로 남아 있기 때문에 이력이 복잡해진다. rebase: 이력은 단순해지지만, 원래의 커밋 이력이 변경된다. 정확한 이력을 남겨야 할 경우에는 사용하면 안 된다. rebase 방식을 사용할 때는 병합 충돌(merge conflict)이 발생하는 모든 커밋들에 대해 충돌을 일일이 해결해줘야 한다. 충돌난 커밋이 너무 많을 때는 rebase보다는 단순 병합(pull)을 하는 것이 더 나을 수도 있다. rebase ontorebase --onto는 다른 토픽 브랜치에서 갈라져 나온 토픽 브랜치와 같은 히스토리가 있을 경우에 사용할 수 있는 명령어다. server 브랜치를 만들어서 서버 기능을 추가하고 그 브랜치에서 다시 client 브랜치를 만들어 클라이언트 기능을 추가한다. 마지막으로 server 브랜치로 돌아가서 몇 가지 기능을 더 추가한다. 아. 그림 그리기 너무 힘들다. 여기서부터는 출처서 가져온 그림을 그대로 활용하자. 그림의 master를 main으로 바꿔서 생각하면 된다. 아무튼 요즘 github은 main이라는 이름을 사용하고 있으니. 이때 server 브랜치는 그대로 두고 client 브랜치만 main으로 합치는 상황을 생각해보자. server와는 아무 관련 없는 client 커밋은 C8, C9이다. 이 두 커밋을 main 브랜치에 적용하기 위해서 --onto 옵션을 사용한다. 첫 번째 인자로는 새로운 조상이 될 베이스 커밋을 넘겨주고, 두 번째 인자로는 기존 베이스 커밋을 넘겨준다. 1git rebase --onto main server client server 브랜치와 server 브랜치와 client 브랜치의 공통 조상까지의 커밋을 client 브랜치에서 없애고 그 이후의 client 커밋들을 main 브랜치를 새로운 베이스로 하여 rebase해준다. 어려워서 토나올 것 같지만, 분명 이런 게 필요한 경우도 맞닥뜨려봤다. 이제 main 브랜치로 돌아가서 Fast-forward시킬 수 있다. 12git checkout maingit merge client 이제 홀로 남겨진 server 브랜치의 작업이 마무리되면, server 브랜치로 이동 후 git rebase main 명령어로 server를 main에 rebase시켜준다. 결과는 아래와 같다. 💡 Tip!git rebase [베이스 브랜치] [토픽 브랜치]로 인자를 입력하면, 토픽 브랜치로 checkout하지 않고도 rebase할 수 있다. 1git rebase main server 이제 다시 main 브랜치를 Fast-forward시키면 최종적인 브랜치 히스토리가 완성된다. 12git checkout maingit merge server 💡 rebase 시 주의사항이미 공개 저장소에 push한 커밋을 rebase하면 안 된다. rebase는 기존의 커밋을 그대로 이용하는 것이 아니라, 내용은 같지만 다른 커밋을 새로 만든다. 새 커밋을 push하고 동료 중 누군가가 그 커밋을 pull해서 작업을 한다고 하자. 그런데 그 커밋을 git rebase로 바꿔서 push해버리면 동료가 다시 push했을 때 동료는 다시 merge해야 한다. 그리고 동료가 다시 merge한 내용을 pull하면 내 코드는 정말 엉망이 되어버린다. 🤯 pull rebase리모트 저장소와 로컬 저장소가 각각 다른 변경 사항을 가지고 있는 경우, Fast-forward merge가 불가능하다. 단순 pull을 하는 경우 별도의 merge commit이 생긴다. 1Merge branch 'main' of https://github.com/zigsong/git-commands-test 이러한 병합 커밋을 만들지 않으려면 --rebase 옵션으로 rebase merge를 하면 된다. 이는 git fetch와 git rebase 명령어를 순서대로 실행하는 것과 같다. 12git checkout feat1git pull --rebase origin main 이렇게 하면 로컬 저장소의 브랜치가 리모트 저장소의 브랜치의 최신 커밋으로 rebase되어 병합 커밋이 남지 않는다. rebase로 모든 병합 충돌을 해결했다면, 강제(force) 푸쉬를 해줘야 한다. 1git push -f origin feat1 강제 푸쉬를 하지 않으면 리모트 저장소의 feat1 브랜치를 pull 받아야 하는데, 그러면 로컬 저장소에서 rebase한 커밋과 리모트 저장소의 커밋이 중복되어 동일한 내용의 커밋이 생겨버리기 때문이다. 🚪 작업 이력 되돌리기resetreset 명령어는 현재 HEAD를 특정한 상태로 되돌린다. 다만 checkout 명령어처럼 HEAD가 가리키는 브랜치를 바꾸지는 않으며, 계속 현재 브랜치를 가리키면서 현재 브랜치가 가리키는 커밋을 바꾼다. reset에는 크게 3가지 옵션이 있는데, 각 옵션을 통해 워킹 디렉토리(working directory) 와 스테이징 영역(staging area), 그리고 현재 브랜치를 가리키는 HEAD 를 어떻게 업데이트할 것인지 결정할 수 있다. 첫 번째로, reset에 --soft 옵션을 붙여 실행하면 워킹 디렉토리와 스테이징 영역은 건드리지 않고 브랜치가 가리키는 커밋만 이전으로 되돌린다. 1git reset --soft HEAD~1 💡 HEAD 뒤에 오는 숫자는 돌아가고 싶은 커밋의 개수이다. HEAD~1 대신 특정 커밋의 해쉬를 입력해도 된다. 바로 직전 커밋으로 돌아가고 싶다면 HEAD^를 사용할 수 있다. 다음으로, reset 명령을 실행할 때 아무 옵션도 주지 않았을 때는 기본적으로 --mixed 옵션을 생략한 것과 같다. 이때 스테이징 영역을 현재 HEAD가 가리키는 스냅샷으로 업데이트할 수 있다. 1git reset [--mixed] HEAD~1 이 경우 워킹 디렉토리는 건드리지 않지만, 스테이징 영역을 비운다. git commit 명령과 git add 명령을 모두 되돌리는 것이다. 마지막으로 reset에 --hard 옵션을 사용하면 워킹 디렉토리까지 되돌린다. 1git reset --hard HEAD~1 --hard 옵션을 사용한 경우 워킹 디렉토리의 파일까지 강제로 덮어쓰게 되며, 결과를 되돌리는 것이 불가능하므로 주의해서 사용해야 한다. reset 명령어를 정리하면 다음과 같다. HEAD가 가리키는 브랜치를 옮긴다. (--soft 옵션이 붙으면 여기까지) 스테이징 영역을 HEAD가 가리키는 상태로 만든다. (--hard 옵션이 붙지 않았으면 여기까지) 워킹 디렉토리를 스테이징 영역의 상태로 만든다. 💡 이때 reset을 취소하고 싶다면?git reflog를 통해 작업 내역을 확인한 후, 몇 번째 HEAD로 돌아갈지 선택한 후 아래와 같이 실행한다. 1git reset HEAD@{1} revertreset 명령어는 github과 같은 온라인 원격 저장소에 올라가지 않은 상태의, 로컬 커밋을 되돌리는 명령어다. 작업 내역을 원격 저장소에 올린 경우라도 해당 브랜치를 자기 자신만 사용하고 있다면 문제가 되지 않겠지만, 다른 동료도 해당 브랜치를 사용하는 경우 함부로 reset을 해서는 안 된다. 이때는 revert를 사용한다. revert는 reset과 달리 커밋을 삭제하는 것이 아니라, 커밋을 추가한다. 커밋을 추가하기 때문에 아래와 같은 메시지가 추가된다. 1Revert '...' revert는 reset과 마찬가지로 soft, hard 등의 옵션이 붙을 수 있다. 아래의 예시를 살펴보자. 12345git commit -m &quot;1번 커밋&quot;git commit -m &quot;2번 커밋&quot;git commit -m &quot;3번 커밋&quot;git revert [1번 커밋의 해쉬] 위처럼 명령어를 실행하면 ‘1번 커밋’ 이후의 커밋들이 삭제되는 것이 아니라, ‘1번 커밋’에 해당하는 내용만 삭제된다. 그리고 revert 커밋이 남게 된다. git log 명령어를 통해 확인할 수 있다. 1234Revert &quot;1번 커밋&quot;3번 커밋2번 커밋1번 커밋 여러 개의 커밋을 되돌릴 때는 아래와 같이 사용한다. 1git revert [from 커밋의 해쉬]..[to 커밋의 해쉬] reset과 revert의 차이를 그림으로 정리해 보자. reset과 달리 revert는 중간 커밋만 삭제할 수 있고, 이전으로 되돌린 커밋의 이력이 모두 커밋 메시지를 통해 남기 때문에 히스토리 유지 차원에서 더 유용하다고 할 수 있다. ☀️ 추가! Pull Request &amp; Merge PRgithub에서 PR(Pull Request)을 보내는 경우, merge하려는 베이스 브랜치와 충돌이 없다면 Merge Pull Request 버튼이 활성화된다. 이때 오른쪽의 역삼각형 모양을 눌러보면, 아래와 같이 3가지 옵션이 표시된다. 팀 프로젝트를 할 때 항상 헷갈렸던 세 가지 옵션들에 대해 살펴보자! 🔖 Create a merge commit PR의 베이스가 되는 main 브랜치와 토픽 브랜치(여기서는 feat1이라고 하겠다.)의 작업 이력이 다르다면 새로운 merge commit을 생성하게 된다. 히스토리는 아래 그림과 같다. 🔖 Squash a merge squash는 한국어로도 스쿼시란다. ㅡㅡ ‘찌부러뜨리다’라는 말 정도로 해석이 가능한데, 여기서는 PR에 딸려 있는 모든 커밋들을 하나로 합쳐 새로운 커밋으로 만들어 베이스 브랜치인 main에 추가시키는 방식이다. 토픽 브랜치의 커밋 히스토리를 합쳐서 깔끔하게 만들기 위해 사용한다. 역시나 새로운 merge commit이 추가된다. 🔖 Rebase a merge PR에 포함된 모든 커밋들이 합쳐지지 않고 각각 main 브랜치에 추가된다. 각 commit은 모두 하나의 부모를 가진다. 이때 새로운 merge commit을 생성하지 않기 때문에 커밋 히스토리를 하나로 깔끔하게 만들 수 있다. (다만 하나의 브랜치에서 작업한 것처럼 보이게 된다!) 이렇게 어떤 방법으로든 스무스하게 merge가 되면 좋겠지만… 그렇지 못한 경우는 늘상 발생한다. main 브랜치에서 파생한 feat1 브랜치에서 작업 후 main 브랜치를 베이스로 PR을 열어놓은 사이, main 브랜치에서 파생한 또다른 브랜치인 feature2의 작업 내역이 먼저 PR merge됐다면 어떨까? (자동 merge가 불가능하다는 회색 버튼이 뜬다 - 사진을 추가해야할 것이다) 이때 github 상에서 conflict을 해결해줄 수도 있지만, 그러면 새로운 merge commit이 생기는 만큼(확실한가?) 다른 방식을 생각해보게 될 것이다. 이때 git rebase가 다시 한번 등장한다. (다음 시간에…) 🎸 기타git aliasgit에서 사용할 명령어를 별칭으로 기록해두는 거~ (작성중) .gitignoregit이 관리할 필요가 없는 파일(ex. 로그 파일, 환경변수 파일)들은 .gitignore 파일에 작성하여 git의 관리 대상에서 제외시켜줄 수 있다. 리액트 프로젝트의 경우 용량이 큰 node_modules 폴더와 빌드 아웃풋인 dist 폴더를 .gitignore로 제외시켜주는 것이 일반적이다. 123node_modules/dist/.env git stash워킹 디렉토리의 내용을 잠시 올려두는 거~ (작성중) cherrypick특정 브랜치에서 작업을 하던 도중, 다른 브랜치에서 특정 커밋만을 가져올 수 있다. 12git checkout feat1git log feat1 브랜치의 ...번 커밋을 feature2 브랜치로 가져오고 싶을 때 cherrypick 명령어를 사용한다. 12git checkout feature2git cherry-pick `...` git tag태그로 프로젝트 히스토리에 버전을 명시해주는 거~ (작성중) Refhttps://git-scm.com/docshttps://git-scm.com/book/ko/v2/https://kyounghwan01.github.io/blog/etc/git/git-reset-revert/이-작업을-하는-이유https://im-developer.tistory.com/182","link":"/2022/01/31/git-commands-everything/"},{"title":"자바스크립트 함수형 프로그래밍과 파이프","text":"배열에서의 함수형 프로그래밍 | reduce | pipe SBA 인사이트 스쿨에서 진행했던 마플 유인동님의 ‘모던 자바스크립트 라이브코딩’ 강의를 가벼운 마음으로 듣다가, 굉장히 매력적이면서 탐구정신이 묻어나오는 코딩 스타일에 깊은 감명을 받아 정리해보았다. 저녁 먹느라 강의의 중반부를 놓쳤는데, 아쉽게도 해당 강의는 다시 제공하지 않아서 2년 전 녹화하신 비슷한 강의와 기타 여러 자료들을 참고했다. 개인적으로 매력을 느꼈던 Kent C Dodds. 선생님의 Inversion of Control과도 연계해서 생각해볼 수 있을 것 같다. 해당 글에 대한 내맘대로 이해한 글은 여기에 정리해두었다. 명령형으로 작성하기숫자값들로 구성된 어떤 배열(list)의 원소 중 ‘홀수’만을 찾아서 그 값들의 ‘제곱’을 모두 더한 값을 구하려고 한다. 이때 배열의 모든 원소를 순회하지 않고, 특정 길이(length)만큼 돌며 반환하고자 한다. 위 요구사항을 직관적으로는 아래와 같이 작성하게 될 것이다. 1234567891011function f(list, length) { let i = 0; let acc = 0; for (const a of list) { if (a % 2) { acc = acc + a * a; if (++i === length) break; } } console.log(acc);} 실행시켜보면, 기대한 값을 출력한다. 1234567function main() { f([1, 2, 3, 4, 5], 1); // 1 (1) f([1, 2, 3, 4, 5], 2); // 10 (1 + 3 * 3) f([1, 2, 3, 4, 5], 3); // 35 (1 + 3 * 3 + 5 * 5)}main(); 위 코드에서 아쉬운 점은, 명령형으로 작성된 부분이 많다는 것이다. i라는 임의의 변수의 값을 0으로 초기화한 후, 강제로 1씩 늘려주고 있다.123let i = 0;// ... if (++i === length) break; for문을 돌며 홀수 필터링을 직접 수식으로 작성해주고 있다.1234if (a % 2) { acc = acc + a * a; if (++i === length) break;} JavaScript의 제너레이터를 이용하여 코드를 조금씩 고쳐보자. 제너레이터로 작성하기 🤔 제너레이터(generator)란?ES6에서 도입된 문법으로, 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수.제너레이터 함수는 제너레이터 객체를 반환하여, next 메서드 호출을 통해 그 시점의 값을 반환한다.제너레이터 함수는 function* 키워드로 선언하며, 하나 이상의 yield 표현식을 포함한다. 1234567891011function *filter(f, iter) { for (const a of iter) { if (f(a)) yield a; }}function *map(f, iter) { for (const a of iter) { yield f(a); }} 홀수만 걸러내기 위한 목적의 filter 함수를 분리하고, 이터러블을 돌며 각 원소를 특정한 방식으로 연산한 값들을 하나씩 반환해줄 map 함수를 작성하였다. 각각은 asterisk(*)을 붙인 제너레이터 함수로 작성하였으며, 이에 따라 값을 yield로 반환하게 된다. 🤔 이터러블(iterable)이란?Symbol.iterator를 프로퍼티로 갖고 있는 객체로, 순회 가능한 데이터 컬렉션(자료구조)을 의미한다.for...of문 또는 배열 디스트럭쳐링 할당의 대상으로 사용할 수 있다. 이터러블에서 특정 길이만큼만 순회하게끔 도와주는 take 함수는 제너레이터가 아닌 일반 함수로 작성한다. 명령형으로 작성한 모든 세부 구현 코드는 이곳에 집어넣는 것이다. 1234567function take(length, iter) { let res = []; for (const a of iter) { res.push(a); if (res.length === length) return res; }} 위와 같이 분리한 추상화된 함수들을 이용하여 기존 함수를 다시 작성할 수 있다. filter와 map은 각각 첫 번째 인수로 연산 또는 필터링 조건을 명시한 콜백 함수를 받는다. 1234567function f(list, length) { let acc = 0; for (const a of take(length, map(a =&gt; a * a, filter(a =&gt; a % 2, list)))) { acc = acc + a; } return acc;} console.log와 같은 사이드 이펙트를 만드는 함수도 main 함수로 옮겨준다. 12345function main() { console.log([1, 2, 3, 4, 5], 1); // 1 console.log([1, 2, 3, 4, 5], 2); // 10 console.log([1, 2, 3, 4, 5], 3); // 35} 결과는 동일하지만, 기존의 명령형 코드들을 조금 더 선언적으로 작성할 수 있게 되었다. 어떻게 할 것인지를 세부적으로 모두 작성하는 명령형이 아니라,무엇을 할 것인지만 작성해주고 실제 처리는 추상화된 별도의 함수가 처리하는 프로그래밍 방식을 선언형 프로그래밍이라고 한다. 함수가 하는 일들을 각각 분리했다는 점에서 함수형 프로그래밍과도 같은 맥락으로 이해할 수 있다. reduce 함수 직접 만들어보기그런데 여전히 for문 안에서 acc = acc + a를 직접 실행해주고 있는 것이 아쉽다. 초기값이 있고, 이 초기값을 가지고 이후에 나올 값들을 덧붙여 연산을 수행할 수 있게끔 JavaScript에서는 reduce 메서드를 제공한다. 직접 reduce를 만들어 축약해보자. 1234567891011121314function reduce(f, acc, iter) { for (const a of iter) { acc = f(acc, a); } return acc;}const add = (a, b) =&gt; a + b;const f = (list, length) =&gt; reduce(add, 0, take(length, map(a =&gt; a * a, filter(a =&gt; a % 2, list)))); 함수(f)와 초기값(acc), 그리고 순회할 대상인 iter를 인자로 받는 reduce 함수를 정의하고, 인자로 받은 두 값을 더한 값을 반환하는 add 함수를 정의했다. 그리고 add 함수를 reduce 함수에서 수행할 콜백으로, 기존에 작성한 take, map, filter가 반환한 배열을 reduce 함수의 세 번째 인자로 넣어주었다. 읽는 흐름은 오른쪽부터 시작하면 된다. 주어진 list로 홀수만 filter한 배열의 각 원소값들에 대해, map을 이용하여 제곱 연산을 수행하고, take를 통해 length만큼 반환한 값들을, reduce 함수의 add 함수를 이용해 하나씩 더해준다. (이때 초기값은 0) 함수를 다른 함수의 인자로 넘길 수 있는, JavaScript 함수의 일급 객체의 특성을 이용하여 원하는 시점에 원하는 함수를 넘겨주는 것이다. 이는 코드를 값처럼 다루는 메타 프로그래밍이라고도 한다. main 함수를 수행하면 결과는 역시 똑같다. 12345function main() { console.log(f([1, 2, 3, 4, 5], 1)); // 1 console.log(f([1, 2, 3, 4, 5], 2)); // 10 console.log(f([1, 2, 3, 4, 5], 3)); // 35} reduce를 유연하게 만들기지금 reduce 함수는 고정된 세 개의 인자(f, acc, iter)를 받고 있다. 하지만 초기값인 acc 값을 넘겨주고 싶지 않을 수도 있다. 실제로 JavaScript 배열 내장 메서드인 reduce 역시 초기값은 optional이다. 1arr.reduce(callback[, initialValue]) 인자로 acc 값이 들어오지 않았을 경우를 대비하여 코드를 수정해 보자. 12345678910function reduce(f, acc, iter) { if (arguments.length === 2) { iter = acc[Symbol.iterator](); acc = iter.next().value; } for (const a of iter) { acc = f(acc, a); } return acc;} 함수의 arguments 길이가 2, 즉 acc 값이 없다면 함수 바디에서는 세 번째 인수로 들어온 iter 값을 acc라고 생각하게 될 것이다. 이때 acc에 Symbol.iterator를 구현하여 iter를 순회 가능하도록 만들고, iter의 첫 번째 값(iter.next().value)을 초기값(acc)으로 지정해준다. acc 값을 지정해주지 않는다면 0부터 연산한 값을, acc 값을 지정한다면 acc부터 연산한 값을 반환하게 된다. 12reduce(add, [1, 2, 3]); // 6reduce(add, 10, [1, 2, 3]); // 16 이렇게 탄탄해진(?) reduce 함수를 가지고 기존 함수를 또 만져보자. reduce 함수에 정해지지 않은 개수의 인자를 넘겨줄 수 있는 pipe 함수를 정의한다. 1const pipe = (...args) =&gt; reduce((res, f) =&gt; f(res), args); pipe 함수를 이용하여 우리의 f 함수를 새롭게 작성할 수 있다. 1234567const f = (list, length) =&gt; pipe( list, list =&gt; filter(a =&gt; a % 2, list), list =&gt; map(a =&gt; a * a, list), list =&gt; take(length, list), list =&gt; reduce(add, 0, list)); 원본 배열인 list부터 시작하여 순서대로 다음 콜백함수(filter, map…)들을 수행해준다. 이때 pipe 함수에서 호출하는 reduce는 함수는 acc가 가리키는 원본 배열에 연산을 수행한 값을 다시 돌려주기 때문에, 전체 그림에서는 현재 콜백함수의 반환값이 되는 배열을 다음 콜백함수의 인자로 계속해서 넘겨주게 된다. 이와 같은 코딩 방식을 LISP(리스프) 라고 부르기도 한다. LISP는 “List Processing”(리스트 프로세싱)의 줄임말로, 코드 그 자체로 하나의 리스트를 의미한다. currying 활용하기아직도 끝나지 않았다! 일급 객체인 JavaScript 함수의 특성을 사용하여, currying으로 함수를 구현해보자. currying은 함수를 리턴하는 함수의 특징을 살려서 구현한 개념으로, 필요한 시점에 인자를 순차적으로 전달하여 호출할 수 있는 방식을 의미한다. 여기서는 인자의 개수를 정해놓지 않고, rest parameter를 사용하여 원하는 만큼 인자를 받을 수 있는 currying 함수를 구현할 것이다. 아래 예제를 살펴보자. currying 함수가 반환하는 함수의 인자에서 rest.length가 0보다 크다면(존재한다면) f를 다시 한번 호출하고, 그렇지 않다면 rest를 인자로 하는 f 함수를 리턴한다. 1234const curry = f =&gt; (a, ...rest) =&gt; rest.length ? f(a, ...rest) : (...rest) =&gt; f(a, ...rest);const add = curry((a, b) =&gt; a + b);add(10)(5); // 15 이제 위에서 사용한 filter, map 등의 함수들을 모두 curry로 감싸보자. 123456789101112131415161718192021222324252627282930const filter = curry(function *(f, iter) { for (const a of iter) { if (f(a)) yield a; }});const map = curry(function *(f, iter) { for (const a of iter) { yield f(a); }});const take = curry(function(length, iter) { let res = []; for (const a of iter) { res.push(a); if (res.length === length) return res; }});const reduce = curry(function(f, acc, iter) { if (arguments.length === 2) { iter = acc[Symbol.iterator](); acc = iter.next().value; } for (const a of iter) { acc = f(acc, a); } return acc;}); 이제 f 함수를 훨씬 더 간단하게 작성할 수 있다. list를 각 함수의 두 번째 인자로 넘겨주는 것이 아니라, currying 함수가 리턴하는 함수의 인자로 넘겨주는 방식이다. 1234567const f = (list, length) =&gt; pipe( list, list =&gt; filter(a =&gt; a % 2)(list), list =&gt; map(a =&gt; a * a)(list), list =&gt; take(length)(list), list =&gt; reduce(add)(list)); list =&gt; filter(a =&gt; a % 2)(list)는 list를 받아서, filter가 반환하는 함수에 list를 그대로 전달한다. 이 말은 곧 각 콜백함수를 아래와 같이 작성할 수도 있다는 뜻이다. 각 콜백함수에 list 인자를 명시적으로 넘기는 대신, 콜백함수를 호출하여 전달해주면 curry에 의해 새로운 함수를 리턴하게 되므로 같은 방식으로 동작한다. 12345678const f = (list, length) =&gt; pipe( list, filter(a =&gt; a % 2), map(a =&gt; a * a), take(length), reduce(add) ); 위 코드의 특징은, 지연 평가된다는 것이다. pipe 함수의 첫 번째 인자인 list 배열의 모든 원소에 대해 filter, map, take, reduce가 각각 실행되는 것이 아니다. 즉 첫 번째 콜백함수인 filter에서 걸러진 값은 map으로 넘어가지 않고, 이때는 list의 다음 원소에 대하여 다시 처음부터 filter를 실행하게 된다. 이는 next를 호출할 때까지는 평가되지 않는 제너레이터 함수의 특징 덕분이다. 따라서 위 코드는 가장 처음의 명령형 코드와 시간복잡도가 일치한다. 2차원 배열 순회하기그런데 지금까지 우리 곁에 있어준 main 함수에 [1, 2, 3, 4, 5]와 같은 쏘 심플한 배열 말고, 2차원 배열을 넘겨주면 어떨까? 123456const arr = [ [1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]; 우선은 arr를 펼쳐보자. 1234567891011const flat = function *(iter) { for (const a of iter) { if (a &amp;&amp; a[Symbol.iterator]) { for (const b of a) { yield b; } } else { yield a; } }}; 여기서 중첩 for문을 조금 더 스타일리쉬하게(!) 바꿀 수도 있다. 123456789const flat = function *(iter) { for (const a of iter) { if (a &amp;&amp; a[Symbol.iterator]) { yield* a; // 여기를 바꿨다. } else { yield a; } }}; 잘 풀어지는지 확인해보자. 1[...flat(arr)]; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] if문으로 중첩된 배열을 풀어주고 있기 때문에, 어떤 모양의 배열이든지 풀어줄 수 있다. 123456const arr = [ [1, 2], 3, 4, 5, [6, 7, 8], 9, 10]; 1[...flat(arr)]; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 굳! 이제 이 함수를 아까 만들어두었던 pipe 함수로 다시 호출해보자. 이때 flat은 인자로 iter만 받으면 되기 때문에, 인자를 연속적으로 넣어주기 위해 작성했던 curry는 필요없다. 그리고 한번에 실행결과를 확인하기 위해 마지막 인자에는 console.log도 넣어줬다. 12345678pipe(arr, flat, filter(a =&gt; a % 2), map(a =&gt; a * a), take(3), reduce(add), console.log); // 35 (1 + 9 + 25) 원하는 값이 잘 나오는 것을 확인할 수 있다! 😎 파이프라인 프로그래밍지금까지 사용한 pipe, 즉 파이프 함수는 실제 현실에서의 파이프(배관)에서 아이디어를 가져왔다.Whatis에서는 pipe를 다음과 같이 정의하고 있다. 🔗 파이프는 단방향 통신을 위한 용도로 사용된다. 하나의 파이프는 그 이전 파이프에서 전달된 결과를 파라미터로 삼아 또 다른 결과를 내놓는다. 파이프를 이해하기 위해서는 순수 함수를 이해해야 한다. 순수 함수는 다음을 준수해야 한다. 같은 입력 값에선 같은 반환 값을 보장한다. 함수 외부 스코프의 그 어떠한 변수의 값도 바꾸지 않는다. 한 파이프가 반환하는 값은 그 다음 파이프의 입력 값으로 전달되기 때문에, 각 상황에서 같은 값을 반환해야 하는 것이다. 지금까지 JavaScript Array prototype의 reduce 함수를 직접 구현하여 하나의 배열 input에 대해 여러 개의 함수를 순차적으로 실행하도록 했다. 위에서 작성한 reduce 함수와 pipe 함수를 다시 살펴보자. 12345678910function reduce(f, acc, iter) { if (arguments.length === 2) { iter = acc[Symbol.iterator](); acc = iter.next().value; } for (const a of iter) { acc = f(acc, a); } return acc;} 1const pipe = (...args) =&gt; reduce((res, f) =&gt; f(res), args); 그리고 사용부에서는 아래와 같이 호출해주고 있다. 12345678pipe(arr, flat, filter(a =&gt; a % 2), map(a =&gt; a * a), take(3), reduce(add), console.log); // 35 (1 + 9 + 25) 하지만 첫 번째 인자로 연산을 수행할 list를, 나머지 인자들에는 콜백 함수들을 넣어주는 방식은 뭔가 부족하다. 클로저를 이용하여 list를 다른 방식으로 받아보도록 바꿔보자. 초기값(list)과 함수를 명시적으로 분리하기 위해 args라고 선언해줬던 변수는 조금 더 확실하게 funcs로 네이밍을 바꿔주었다. 😮 주의할 점! 여기서는 위에서 직접 만들었던 reduce 대신, JavaScript Array.prototype의 내장 메서드인 reduce를 사용했다. 우리가 만들었던 reduce는 초기값이 없어도 되는데, 여기서는 초기값을 특정한 방식으로 반드시 넣어주는 경우를 고려했기 때문이다. 1const pipe = (...funcs) =&gt; v =&gt; funcs.reduce((res, func) =&gt; func(res), v); 이제 파이프는 v라는 값을 받는 또 다른 함수를 반환하는 형태로 바뀌었다. 새롭게 반환된 함수가 v를 받을 때까지 파이프는 reduce를 실행하지 않는다. 지연 평가가 이루어지고 있는 것이다. 새로운 pipe 코드를 실행해보자. arr를 pipe의 첫 번째 인자로 넣는 대신, 클로저를 활용하여 pipe가 반환한 함수의 인자로 넣어주었다. 123456789101112131415const arr = [ [1, 2], 3, 4, 5, [6, 7, 8], 9, 10];pipe( flat, filter(a =&gt; a % 2), map(a =&gt; a * a), take(3), reduce(add), console.log)(arr); // 35 원하는 값이 잘 나오는 것을 확인할 수 있다! 생각작년에 잠시 인턴을 하면서 사용했던 RxJS에서 처음 접했던 Functional Programming, 그리고 그 API에 있었던 pipe가 와닿지 않았었는데 하나하나 단계를 밟아가보니 이제 조금 이해가 된다. (물론 처음부터 혼자 다시 하라 그러면 어려울 것이다.) 제너레이터와 이터러블, 그리고 클로저까지 JavaScript만으로 할 수 있는 기능들을 조합하여 사용하는 사람이 편리한 코드, 선언적으로 작성할 수 있는 코드가 탄생했다. 항상 만드는 사람이 고생스럽더라도, 사용하는 사람이 직관적으로 편리하게 쓸 수 있는 코드를 고민했었는데 이렇게 또 한 걸음 앞으로 나간 것 같다. FxTS도 공부해봐야겠다.. 허허 🙃 Refhttps://www.youtube.com/watch?v=4sO0aWTd3ychttps://medium.com/오늘의-프로그래밍/함수형-프로그래밍-pipe-c80dc7b389dehttps://ko.wikipedia.org/wiki/리스프","link":"/2021/12/03/js-functional-programming/"},{"title":"Docker로 MySQL 띄워 NestJS + TypeORM과 연결하기","text":"투머치 제목 이 얼마나 거창한 제목인가… 사내 웹프론트그룹에서 하고 있는 어떠한 비밀(?..) 프로젝트에서, 막내라는 이유로 그룹장을 하고 있당. 최종적으로 만들고 싶은 플랫폼의 프로토타이핑을 하고, 각자의 꿈을 펼쳐보기로… 그렇게 무모하게 Nest.js가 뭔지도 잘 모른채, 그저 fancy하다는 이유로 첫 삽을 파보았다. NestJS Nest (NestJS) is a framework for building efficient, scalable Node.js server-side applications 라고 한다. 효율적이고, 확장 가능한 Node.js 기반의 서버사이드 앱을 만들기 위한 프레임워크다. 뭐든 자기 앱이 제일 개쩌니까~! 딱히 웅장하진 않은 재미없고 딱딱한 소개를 하고 있다. 조금 trendy하다고 느낀 건, 기본으로 TypeScript를 지원한다는 사실이다. 아아… 타입스크립트 없이는 살지 못해… 이 NestJS의 구조는 크게 Controller, Provider, Module로 나뉜다. ✔️ Controller 클라이언트에서 들어오는 요청을 처리하고 응답을 반환하는 역할을 수행한다. 나는 TechStack을 만들고 싶으므로 아래와 같이 야심차게 시작해본다. 123456789// tech-stacks.controller.tsimport { Controller, Get } from '@nestjs/common';@Controller('tech-stacks')export class TechStacksController { @Get() findAll(): string { return 'Hello, techStacks' } 컨트롤러는 엔드포인트 라우팅(routing) 메커니즘을 통해 각 컨트롤러가 받을 수 있는 요청을 분류한다. 그래서 컨트롤러를 사용 목적에 따라 잘 구분하면 구조적이고 모듈화된 소프트웨어를 작성할 수 있다고 한다. 직접 컨트롤러 파일을 만들지 않고도 아래 명령어로 fancy하게 자동으로 파일을 만들 수 있다. MZ세대 취향저격 1nest g controller [name] 난 분명 techStacks 로 CLI를 돌렸는데 자동으로 tech-stacks 이름으로 파일이 생성됐다. 저기 컨벤션인가보다. 컨트롤러만 단독으로 만드는 대신 CRUD 보일러플레이트 코드를 한번에 생성할 수도 있다고 한다. 아아… 이 얼마나 멋진… 1nest g resource [name] ✔️ Provider Nest의 핵심 개념으로, 여러 소스들로 프로바이더를 구현할 수 있다. 이를테면 service, repository, factory, helper, 등등… (하나만 해라 제발) 프로바이더는 의존성으로 주입될 수 있는 데이터 가공 함수들을 모아둔 객체다. 수없이 되뇌었던 그 이름..! IoC! 의존성을 이렇게 분리하다니. 역시 fancy한 프레임워크다. 사실 다른 프레임워크에서는 어떻게 하고 있는지 잘 모른다. 12345678910111213141516// tech-stacks.service.tsimport { Injectable } from '@nestjs/common';import { TechStack } from './interfaces/techStack.interface';@Injectable()export class TechStacksService { private readonly techStacks: TechStack[] = []; create(techStacks: TechStack) { this.techStacks.push(TechStack); } findAll(): TechStack[] { return this.techStacks; }} 앱이 제공하고자 하는 핵심 기능, 즉 비즈니스 로직을 수행하는 역할을 하는 것이 프로바이더이다. 컨트롤러가 이 역할을 수행할 수도 있겠지만 소프트웨어 구조상 분리해 두는 것이 단일 책임 원칙(SRP, Single Responsibility Principle)에 더 부합하기 때문이라고 한다. IoC, SRP 이런 말 써줘야 또 있어보인다. ✔️ Module 일반적으로 모듈이라고 하면 조그만 클래스나 함수처럼 한가지 일만 수행하는 소프트웨어 컴포넌트가 아니라, 여러 컴포넌트를 조합하여 작성한 좀 더 큰 작업을 수행하는 단위를 말한다. Nest에서 모듈은 앱의 구조 설계를 위한 metadata를 제공한다. metadata라고만 말하고 있으니 도통 무슨 소린지 알 수가 없다. 그냥 앱의 루트 모듈이 있고, 하위에 도메인별로 모듈을 나눴다고 생각하면 될 듯하다. 12345678910111213// app.module.tsimport { Module } from '@nestjs/common';import { TechStacksController } from './tech-stacks/tech-stacks.controller';import { AppController } from './app.controller';import { AppService } from './app.service';import { TechStacksService } from './tech-stacks/tech-stacks.service';@Module({ imports: [], controllers: [AppController, TechStacksController], providers: [AppService, TechStacksService],})export class AppModule {} 귀차나서 Nest가 기본으로 만들어준 app.module 파일에 TechStack 도메인의 아이들도 같이 욱여넣어줬다. yarn 으로 로컬 서버를 실행하고 3000번 포트로 접속하면, Hello, techStacks 텍스트가 썰렁하게 등장한다! (포스팅을 쓰는 지금 시점에서는 코드가 많이 바뀐 상태이므로 그냥 그랬을 것이라고 이해하자.) 그렇게 별 문제없이 아주 야심차게 시작하는 듯 했으나..! TypeORM을 연결하려면 실제 DB가 있어야 한다..! MongoDB도 잠깐 해봤고, MySQL도 해보긴 했다. 프로토타이핑을 하는 가벼운(?) 단계에서 선택 기준은 그저 ‘소스가 얼마나 많은가’. 역시 MySQL로 ㄱㄱ 그렇게 Nest에 MySQL을 등에 업은 TypeORM 연결을 위해 검색에 나섰는데, 아마 첫 번째 검색 결과가 화근이었을까. docker로 하고 있는 게 아니겠는가..! 분명 모두가 docker를 사용하고 있는 것 같았는데, 지금 다시 검색해보니 꼭 그렇지만은 않은 것 같다. 하지만… 며칠 전의 나는 docker를 꼭 해야한다고 생각했고… 그렇게 TypeORM, MySQL을 뒤로 한 채 docker로 가보았다. -이제 꼬리물기 끝- Docker도커는 컨테이너 기반의 오픈소스 가상화 플랫폼이다. 컨테이너 안에는 다양한 프로그램, 실행 환경을 ‘컨테이너’라는 개념으로 추상화하고 클라우드, PC 등 어디서든 실행할 수 있다. 자세한 설명이나 등장 배경은 이미 다른 검색 결과에 많으니 생략한다. 도커 설치부터 애를 먹었다. 도커를 자동으로 설치해주는 아래 커맨드 1sudo wget -qO- https://get.docker.com/ | sh 를 입력하면 wget: command not found 에러가 뜨고, 그래서 wget을 설치해주려고 하면 yum을 사용하란다. 1yum install wget 커맨드를 입력하면 yum: command not found 잠시 숨을 고르고 yum도 설치하라는 대로 해준다. 1sudo apt-get install yum 결과는 apt-get: command not found (아마도) homebrew로 간신히 도커를 설치하고, mysql 실행을 위해 mysql image를 pull해준다. 아니?! 이게 대체 무슨 소리냐 docker hub(registry): 앱스토어 역할이다. 필요한 프로그램을 다운로드받을 수 있는 곳이다. (마치 npm에 여러 패키지가 등록되어 있고, 개발자가 필요한 패키지를 npm install로 설치하는 것과 같다.) image: docker hub의 프로그램(ex. apache, mysql)을 컴퓨터에 다운로드받은 것이다. container: 다운받은 image를 실행하는 것이다. image는 여러 개의 container를 가질 수 있다. docker hub에서 image를 다운 받는 과정을 pull, image를 실행시키는 행위를 run 이라고 한다. https://hub.docker.com/에서 원하는 이미지를 다운로드받을 수 있다. 1docker pull mysql 다운로드 받은 image를 확인하려면 아래 명령어를 입력한다. 1docker images mysql이 잘 받아진 것 같다 ^^ 어느 단계에서인지 까먹었으나, 아래와 같은 에러가 뜨는 경우가 있다. 🚨 no matching manifest for linux/arm64/v8 in the manifest list entries 회사에서 준 최고 빠른 M1 Mac은 정말 사랑스럽고 손이 많이 가는 친구다. 뭐 하나 설치하려 해도 낯선 에러가 떠서 검색해보면, M1 칩 이슈라고 한다^^… 에러 메시지를 검색해서 나온 블로그가 작년에 우테코를 같이 했던 백엔드 크루(지만 서로 모르는…)의 글이었다. docker-compose.yml 파일을 만들어 다음과 같이 작성해준다. 123456789101112131415version: '3'services: local-db: platform: linux/x86_64 # m1 mac 이슈 image: library/mysql:5.7 container_name: local-db restart: always ports: - 3306:3306 environment: MYSQL_ROOT_PASSWORD: secret TZ: Asia/Seoul volumes: - ./db/mysql/data:/var/lib/mysql - ./db/mysql/init:/docker-entrypoint-initdb. 그리고 compose 명령어를 입력해준다 1docker-compose up -d 이제 mysql 컨테이너를 만들어준다. 1docker run --name [container name] -e MYSQL_ROOT_PASSWORD=&lt;password&gt; -d -p 3306:3306 mysql 3306:3306은, 각각 host의 포트와 container의 포트를 가리킨다. host의 3306번 포트와 docker container의 3306번 포트를 연결하라는 의미다. 처음에 무지성으로 쓰다가, 위대하신 이고잉 선생님의 강의를 듣고 이해 완. (영광스러운 캡쳐도 떠 두었다.) 이를 port forwarding이라고 한다. 포워딩 별거 없네 그런데 계속 아래와 같은 에러가 뜨는 게 아니겠어.. 1🚨 Ports are not available: listen tcp 0.0.0.0:3306: bind: address already in use 이미 mysql용 3306번 포트를 차지하고 있는 프로세스를 찾아서 sudo kill -9 [process_number] 를 입력해줘도 계속해서 끈질기게 포트를 차지해버리는 누군가… 거의 반나절을 고민한 끝에 찾아냈다. 🤯🤯🤯 후… 도커의 개념을 제대로 이해하지 못한 채로 이상한 데서 헤매고 있었다. 로컬에서 돌아가고 있던 MySQL 서버를 꺼준 후 다시 실행하면, 짜잔! (갑자기 나타난 docker desktop) 개발자를 안심시키는 초록불과 함께 mysql-local 이름으로 지정한 mysql container가 돌아가는 것을 볼 수 있다. docker run 명령어는, docker create + docker start + docker attach 명령을 합친 것이라고 한다. create와 start 는 알겠고, attach까지 알아보기엔 힘이 달렸다. 도커로 실행중인 프로세스를 보기 위해 docker ps 명령어를 입력한다. 아마 process status의 약자였던 것 같다. 진정한 별다줄의 세계는 프로그래밍 세계에서 탄생한 것이 아닐까, 생각한다. 현재 실행중인 프로세스 뿐 아니라 전체 프로세스를 확인하기 위해서는 docker ps -a 를 입력하면 된다. (-a는 누가 봐도 all 임을 짐작할 수 있다. 아님 말고) 컨테이너가 하나밖에 없어서 썰렁하다. 새 컨테이너를 만들긴 귀찮으니 잠시 mysql-local 컨테이너를 꺼준 후 뭐가 나오는지 봐준다. 1docker stop mysql-local 아까와는 달리 STATUS가 Exited로 표기된 것을 알 수 있다. 이제 보여주기식 실행이 끝났으니 다시 실행시킨다. docker start mysql-local을 하면 될 것 같았으나, 안 된다. 1년차 개발자의 짬을 믿고 docker restart mysql-local 을 입력해준다. 성공. ✌️ 이제 이상한 짓은 그만두고 도커 실행 명령어를 입력한다. 1docker exec -it mysql-local bash 아니, 아까는 run 하라며 갑자기 exec이 웬말이냐?? docker run은 도커 컨테이너를 생성하고 실행까지 한번에 해주는 명령어다. 반면 docker exec는 실행중인 컨테이너에만 실행할 수 있는 명령어다. 일반적인 컨테이너 실행 명령어인 run과 달리 컨테이너 상태를 디버깅하기 위한 용도로 주로 사용한다. docker exec에는 주로 뒤에 여러 commands를 붙여서 실행한다. ex) docker exec mysql-test pwd 여기서는 bash에서 interactive shell을 열 목적으로 뒤에 -it [container_name] bash 옵션을 줄줄이 붙여줬다. 아무튼 그렇게 실행해준다. -i : interactive shell -t: terminal 여기서 사용한 -it 는 -i와 -t를 합친 것으로, 터미널 입력을 위한 옵션을 뜻한다. 이밖에도 자주 사용되는 docker CLI option들은 다음과 같다. 옵션 설명 -d detached mode; 백그라운드 모드 -p 호스트와 컨테이너의 포트를 연결(포워딩) -v 호스트와 컨테이너의 디렉토리를 연결(마운트) -e 컨테이너 내에서 사용할 환경변수 설정 -name 컨테이너 이름 설정 -rm 프로세스 종료시 컨테이너 자동 제거 -link 컨테이너 연결 [컨테이너명:별칭] docker는 아무리 찾아봐도 이해가 되지 않았는데, 이고잉 선생님의 도커 입문 수업을 듣고 갈증이 싹 가셨다. MySQLMySQL을 실행하려면 물론 MySQL을 다운받아야 한다. 그냥 공식 홈페이지에서 직접 다운 받았다. 그리고 명령어 공부하기 귀찮아서 구이…구이(GUI)를 찾다가 workbench도 다운 받았다. (근데 딱히 편한 건 모르겠다^^ 이쁘지도 않다.) docker exec으로 실행한 shell에 아래 명령어를 입력하여 mysql 서버를 실행한다 1mysql -u root -p -u root : -p : p는 password의 약자다. -p [password] 와 같은 식으로 바로 입력해줄 수도 있다. 패스워드를 생략하고 -p 만 사용하면 아래와 같은 패스워드 입력창이 뜬다. 패스워드까지 입력하면, ta-da! 🎉 mysql 서버가 실행되었다. 그치만 난 쿼리를 해본지 오래됐으므로 workbench로 간다. UI는 정말 못생겼지만, 맥도날드 키오스크에서 헤매고 계실 우리 어머니 세대의 심정을 헤아려가며 찾다보면 어떻게든 테이블과 데이터를 만들 수 있다. 우여곡절을 거친 신입 개발자는 이제 뭘 클릭하는 데 거침없다. 우당탕탕 만들었기 때문에 어떻게 만들었는지 설명하진 못한다. 적당히 techtree 라는 이름의 테이블을 생성하고, name, desc, image, url, type, id 라는 필드(column이라고 해야될 듯 하다.)를 만들어주었다. 그리고 데이터도 2개 심어주었는데, 워크벤치 껐다가 다시 켜니 이전에 심어둔 데이터를 어디서 확인하는지 도통 모르겠다 ㅡㅡ 내 데이터 내놔라 👊 그래서 이건 그냥 shell에서 확인했다. desc는 한글로 썼다고 저렇게 표시해주냐 ㅡㅡ 성공한 사람이 되어서 한글을 전세계 제1언어가 되게 하리라. 물론 거짓말이다. 그냥 아무도 모르게 조용히 살고 싶다. 그럼 이제 TypeORM으로 가보자고 TypeORMORM이란 ‘Object Relational Mapping’의 약자로, 객체-관계 매핑을 의미한다. 풀어서 설명하면, 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다. 객체 지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용하기 때문에 객체 모델과 관계형 모델 간에 불일치가 존재한다. ORM을 사용하면 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결할 수 있다. 이런 멋드러지는 소리들은 이제 그만하고, NestJS에 TypeORM을 연결해보자. 우선 ormconfig.json 파일을 만든다. (딴소리지만, ORM 대문자로 썼을 때는 꽤나 있어보이는데 orm 소문자로 쓰니까 정말 없어보인다.) 이 config 파일의 옵션들을 앱과 연결시키기 위해 app.module.ts 파일에서 아래와 같이 갖은 방법을 사용했는데, 123456TypeOrmModule.forRootAsync({ useFactory: async () =&gt; Object.assign(await getConnectionOptions(), { autoLoadEntities: true, }),}); 뭘 해도 deprecated된 메서드(getConnectionOptions() 등) 라고 하며 줄이 좍좍 그어졌다 ㅡㅡ 알고 보니 루트 디렉토리에 ormconfig.json 파일이 있다면 TypeOrmModule.forRoot()에 옵션 객체를 전달하지 않아도 된다고 한다. 그니까 그냥 아래처럼 쓰면 된다. 12345@Module({ imports: [TypeOrmModule.forRoot(), TechStackModule], controllers: [...], providers: [...]}) fancy하다고 칭찬했던 Nest는 어서 공식문서를 개편하지 않는다면 죽음을 면치 못하리라. 😡 엔티티를 작성해준다. 123456789101112131415161718192021222324// techstack.entity.tsimport { Column, Entity, PrimaryGeneratedColumn, Unique } from 'typeorm';@Entity({ name: 'techstack' })@Unique(['id'])export class TechStackEntity { @PrimaryGeneratedColumn() id: number; @Column({ type: 'varchar', length: 45 }) name: string; @Column({ type: 'varchar', length: 45 }) desc: string; @Column({ type: 'varchar', length: 90, nullable: true }) image: string; @Column({ type: 'varchar', length: 45, nullable: true }) url: string; @Column({ type: 'varchar', length: 45, nullable: true }) type: string;} 완전 성의없이 MySQL 테이블 형태 그대로 갖다 적었다. PrimaryGeneratedColumn() 데코레이터는, 이름에서도 알 수 있듯이 새로운 데이터가 추가될 때 해당 필드의 값을 자동으로 1씩 증가시켜 할당해준다. 정말 사랑스러운 녀석… dto가 대체 뭔진 모르겠지만 (물론 Data Transfer Object의 약자라고 한다.) 그냥 인터페이스처럼 만들면 되나보다. 다른 소스들에서 그렇게 하라길래 대충 CreateTechStackDto라고 이름 지어놓고 Create가 아닌 곳에서도 여기저기 갖다 쓰고 있다. 12345678// techstack.dto.tsexport class CreateTechStackDto { name: string; desc: string; image?: string; url?: string; type?: string;} id는 위에서 PrimaryGeneratedColumn() 데코레이터가 알아서 지어준다길래 여기서는 뺐다. ㅎㅎ 이제 지쳤으므로 급전개가 이루어질 것이다. Nest의 프로바이더 역할을 했던 service 파일에, 위에서 생성한 TechStackEntity 를 집어넣는다. 이때 InjectRepository 데코레이터를 사용한다. repository가 바로 db 역할을 하는 것이다! 그리고 메서드들도 수정해준다. 코드는 아래와 같다. 12345678910111213141516171819202122232425262728293031323334// tech-stacks.service.tsimport { Injectable } from '@nestjs/common';import { InjectRepository } from '@nestjs/typeorm';import { TechStackEntity } from 'src/tech-stacks/entity/techstack.entity';import { Repository } from 'typeorm';import { CreateTechStackDto } from './dto/techstack.dto';@Injectable()export class TechStacksService { constructor( @InjectRepository(TechStackEntity) private techstacksRepository: Repository&lt;TechStackEntity&gt;, ) {} findAll(): Promise&lt;CreateTechStackDto[]&gt; { return this.techstacksRepository.find(); } findOne(id: number): Promise&lt;CreateTechStackDto&gt; { return this.techstacksRepository.findOne({ where: { id } }); } async createTechStack(item: CreateTechStackDto): Promise&lt;void&gt; { await this.saveTechStack(item); } private async saveTechStack(item: CreateTechStackDto) { const techStack = new TechStackEntity(); techStack.name = item.name; techStack.desc = item.desc; await this.techstacksRepository.save(techStack); }} Nest가 제공하는 Repository ****하나로 find(), findOne(), save() 등의 연산을 자동으로 할 수 있다니… 정말 경이롭지 않을 수 없다. controller 파일에 임시로 심어뒀던 메서드들도 다 갖다 치우고, 새로 단장한 service의 코드를 갖다 쓰는 방식으로 바꿔준다. 123456789101112131415161718192021222324// tech-stacks.controller.tsimport { Body, Controller, Get, Param, Post } from '@nestjs/common';import { CreateTechStackDto } from './dto/techstack.dto';import { TechStacksService } from './tech-stacks.service';@Controller('tech-stacks')export class TechStacksController { constructor(private techStackService: TechStacksService) {} @Get() async findAll(): Promise&lt;CreateTechStackDto[]&gt; { return this.techStackService.findAll(); } @Get('/:id') async findOne(@Param('id') techId: number): Promise&lt;CreateTechStackDto&gt; { return this.techStackService.findOne(techId); } @Post() async create(@Body() techStack: CreateTechStackDto) { return this.techStackService.createTechStack(techStack); }} 사실 꼭 Promise 함수로 써야 하는지는 모르겠다. Repository의 내장 메서드들이 Promise를 쓰게 되어있나? 🤔 아아 … 궁금해하지만 말고 찾아보면 될 일. Repository.d.ts에 기재된 타입 시그니처는 대략 다음과 같다. 1234/** * Finds entities that match given find options. */find(options?: FindManyOptions&lt;Entity&gt;): Promise&lt;Entity[]&gt;; 그래, Promise로 쓰란다. 여담이지만, 소스코드를 공개하며 해당 파일명을 알려줄 때는 디렉토리 위치까지 알려줬음 좋겠다. 그게 모두 정답은 아니겠지만… 나도 내 멋대로 했기 때문에 파일명만 공개하기로 😇 이제 마지막으로, 위대한 Nest가 제공한다는 기본 모듈 분리의 원칙에 따라 tech-stacks.module.ts 파일을 생성하고, 코드를 작성해준다. 123456789101112import { Module } from '@nestjs/common';import { TypeOrmModule } from '@nestjs/typeorm';import { TechStackEntity } from './entity/techstack.entity';import { TechStacksController } from './tech-stacks.controller';import { TechStacksService } from './tech-stacks.service';@Module({ imports: [TypeOrmModule.forFeature([TechStackEntity])], providers: [TechStacksService], controllers: [TechStacksController],})export class TechStackModule {} TypeOrmModule.forFeature()는 누가 봐도, TypeOrmModule.forRoot()의 하위 모듈들을 만들기 위한 코드같으므로 설명은 생략한다. (피곤해서 그런 건 아니다) 자 이제 yarn start 로 서버를 실행시켜주면…! 두둥탁 🥁 인생은 원래 뜻대로 되는 일이 별로 없다. 게다가 저 마지막 줄에 TechStacksController (?) 물음표는 정말 사람 킹받게 한다. 여기저기 수소문한 끝에, 앱의 root가 되는 app.module.ts에서 중복으로 TechStack의 물건들을 갖다 써서 그런다고 한다. 12345678910111213import { Module } from '@nestjs/common';import { TypeOrmModule } from '@nestjs/typeorm';import { TechStacksController } from './tech-stacks/tech-stacks.controller';import { TechStackModule } from './tech-stacks/tech-stacks.module';import { TechStacksService } from './tech-stacks/tech-stacks.service';@Module({ imports: [TypeOrmModule.forRoot(), TechStackModule], // ➕ TechStackModule 추가 controllers: [], // ➖ TechStacksService 제거 providers: [], // ➖ TechStacksController 제거})export class AppModule {} 성공 🤩 마음의 평화가 찾아왔다. 이제 브라우저에서 localhost:3000으로 접속하면 아까 mysql로 봤던 데이터를 확인할 수 있다. 포스트맨에서도 물론 잘 나온다규 아까 만든 Repository.create() 메서드로 데이터 추가도 할 수 있다. 후후… 이제 끝! 이 아니고 프론트 만들러 가자 Ref https://wikidocs.net/book/7059 https://gmlwjd9405.github.io/2019/02/01/orm.html https://www.youtube.com/watch?v=Ps8HDIAyPD0&amp;list=PLuHgQVnccGMDeMJsGq2O-55Ymtx0IdKWf https://zinirun.github.io/2020/08/15/how-to-use-docker/ https://www.lainyzine.com/ko/article/docker-exec-executing-command-to-running-container/ https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html https://www.hanumoka.net/2018/04/29/docker-20180429-docker-install-mysql/","link":"/2022/05/12/nest-typeorm/"},{"title":"객체지향의 사실과 오해 - 2장","text":"이상한 나라의 객체 가림막 막대 실험 사람은 아기 때부터 뚜렷한 경계를 가지고 함께 행동하는 물체를 하나의 개념으로 인지한다. 물체가 여러 부분으로 구성돼 있더라도 함께 움직일 경우 그 물체를 하나의 유기적인 단위로 인식한다. 객체지향과 인지 능력인간은 본능적으로 세상을 독립적이고 식별 가능한 객체의 집합으로 바라본다. 객체지향은 세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적인 인지 능력에 기반을 두고 있다. 인간의 인지 능력은 물리적인 한계를 넘어 개념적으로 경계 지을 수 있는 추상적인 사물까지도 객체로 인식할 수 있게 한다. 객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 어떤 것이다. 객체지향 패러다임은 소프트웨어의 세계 역시 다양한 소프트웨어 객체들이 모여 이뤄져 있다는 믿음에서 출발한다. 객체지향 패러다임의 목적은 현실 세계를 기반으로 새로운 세계를 창조하는 것이다. 객체, 그리고 이상한 나라이상한 나라의 앨리스동화 속 앨리스는 작은 문을 통과하기 위해 다양한 아이템을 활용하여 자신의 키를 늘였다 줄였다 한다. 앨리스 객체앨리스는 작은 문을 통과하기에 적당한 상태로 자신의 키를 계속해서 변화시킨다. 따라서 특정 시점의 앨리스의 상태란 특정 시점에서의 앨리스의 키를 의미한다. 엘리스의 특별한 행동에 따라 앨리스의 상태(키)가 변하게 된다. 앨리스의 상태를 결정하는 것은 행동이지만 행동의 결과를 결정하는 것은 상태다. 앨리스가 하는 행동에 따라 현재의 키에서 더 커지거나 작아질 수 있으므로, 앨리스가 한 행동의 결과는 앨리스의 상태에 의존적이다. 앨리스가 성공적으로 문을 통과할 수 있는지 여부는 전적으로 앨리스의 키가 얼마인가에 달렸다. 문을 통과한다는 생동의 결과는 앨리스의 위치라는 상태를 이용해 쉽게 설명할 수 있다. 앨리스가 문을 통과했다면 앨리스의 위치는 아름다운 정원으로, 통과하지 못했다면 여전히 천장이 낮은 긴 통로 안에 있을 것이다. 어떤 행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 영향을 받는다. 앨리스는 문을 통과하기 전에 먼저 키를 작게 줄이기 위해 음료나 케이크를 먹어야 한다. 행동 간의 순서가 중요하다. 이렇게 앨리스의 상태가 변경되더라도 앨리스는 앨리스다. 앨리스는 상태 변경과 무관하게 유일한 존재로 식별 가능하다. 앨리스의 특징을 요약하면 다음과 같다. 앨리스는 상태를 가지며 상태는 변경 가능하다. 앨리스의 상태를 변경시키는 것은 앨리스의 행동이다. 앨리스는 어떤 상태에 있더라도 유일하게 식별 가능하다. 객체, 그리고 소프트웨어 나라하나의 개별적인 실체로 식별 가능한 물리적인 또는 개념적인 사물은 어떤 것이라도 객체가 될 수 있다. 객체는 상태(state), 행동(behavior), 식별자(identity) 를 지닌 실체로 볼 수 있다. 상태✔️ 왜 상태가 필요한가 객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다. 어떤 행동의 결과는 과거에 어떤 행동들이 일어났었느냐에 의존한다. 이상한 나라의 앨리스가 문을 통과한다는 행동의 결과를 예상할 수 있는 한 가지 방법은 앨리스가 과거에 케이크나 버섯을 먹었던 적이 있는지 살펴보는 것이다. 그러나 일반적으로 과거 행동의 이력을 통해 현재 행동의 결과를 판단하는 방식은 어렵다. 여기서 행동의 과정과 결과를 단순하게 기술하기 위한 ‘상태’ 라는 개념이 등장한다. 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다. 따라서 현재를 기반으로 객체의 행동 방식을 이해할 수 있다. ✔️ 상태와 프로퍼티 세상에 존재하는 모든 것들이 객체인 것은 아니다. 숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓과 같은 단순한 값들은 객체가 아니다. 단순한 값들은 그 자체로 독립적인 의미를 가지기보다는 다른 객체의 특성, 즉 상태를 표현하기 위해 사용된다. 단순한 값이 아니라 객체를 사용해 다른 객체의 상태를 표현할 수도 있다. 앨리스가 음료를 들고 있는지 여부는 앨리스라는 객체가 음료라는 객체와 연결돼있는지 여부로 표현할 수 있다. 앨리스의 상태는 키와 위치라는 단순한 값과 음료라는 객체의 조합으로 표현할 수 있게 된다. 객체와 객체 사이의 의미 있는 연결을 ‘링크’ 라고 한다. 객체와 객체 사이에는 링크가 존재해야만 요청(메시지)을 주고받을 수 있다. 링크는 객체가 다른 객체를 참조할 수 있다는 것을 의미하며, 이것은 일반적으로 한 객체가 다른 객체의 식별자를 알고 있는 것으로 표현된다. 링크와 달리 객체를 구성하는 단순한 값은 ‘속성’ 이라고 한다. 객체의 프로퍼티는 단순한 값인 속성과 다른 객체를 가리키는 링크라는 두 가지 종류의 조합으로 표현된다. 객체는 자율적인 존재다. 객체지향의 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없다. 자율적인 객체는 스스로 자신의 상태를 책임져야 한다. 이때 등장하는 ‘행동’은 다른 객체로 하여금 간접적으로 객체의 상태를 변경하게끔 해준다. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다. 행동✔️ 상태와 행동 객체의 상태를 변경하는 것은 객체의 자발적인 행동뿐이다. 객체가 취하는 행동은 객체 자신의 상태를 변경시키며, 이때 부수 효과(side effect) 를 초래한다. 객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다. 음료를 마신 후의 앨리스의 키는 음료를 마시기 전의 앨리스의 키보다 작아져야 한다. 상태와 행동 사이에는 다음 관계가 성립한다. 객체의 행동은 상태에 영향을 받는다 객체의 행동은 상태를 변경시킨다 앨리스가 문을 통과하는 행동은 과거의 행동을 돌아볼 필요 없이 앨리스의 ‘키’와 ‘위치’라는 두 가지 상태를 이용해 간단하게 서술할 수 있다. 앨리스의 키가 40cm 이하라면 문을 통과할 수 있다 문을 통과한 후에 앨리스의 위치는 아름다운 정원으로 바뀌어야 한다 ✔️ 협력과 행동 객체는 섬이 아니며, 자신의 책임을 완수하기 위해 다른 객체와 적극적으로 상호작용한다. 객체는 외부에서 수신한 메시지에 따라 적절히 행동하면서 협력에 참여하고, 그 결과 자신의 상태를 변경한다. 객체는 자기 자신의 상태뿐 아니라 다른 객체의 상태 변경을 유발할 수 있다. 앨리스가 음료를 마시면 앨리스 자신의 키가 작아지는 동시에 앨리스가 먹은 양만큼 음료의 양이 줄어야 한다. 따라서 객체의 행동에는 다음 두 가지 부수효과가 따른다. 객체 자신의 상태 변경 행동 내에서 협력하는 다른 객체에 대한 메시지 전송 ✔️ 상태 캡슐화 객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다. 앨리스가 음료를 마시면 앨리스 자신의 상태(키)를 변경함과 동시에 자신이 먹은 양만큼 음료의 양을 줄여달라고 메시지를 전송한다. 메시지를 수신한 음료는 스스로 양이 줄어들 것인지를 결정한다. 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다. 객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태를 변경할지 여부는 객체 스스로 결정한다. 메시지 송신자는 간섭할 수 없다. 캡슐화는 객체의 자율성을 높이다. 자율적인 객체는 스스로 판단하고 스스로 결정하며, 객체들 사이 협력은 더욱 유연하고 간결해진다. ✔️ 식별자 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다. 값의 상태는 불변 상태를 가지며, 값이 같은지 여부는 상태가 같은지를 이용해 판단한다. 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성이라고 한다. 반면 객체는 시간에 따라 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다. 객체는 가변 상태를 가진다. 타입이 같은 두 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체로 다뤄진다. 식별자를 기반으로 객체가 같은지는 판단할 수 있는 성질을 동일성(identical) 이라고 한다. 상태가 가변적인 두 객체의 동일성을 판단하기 위해서는 상태 변경에 독립적인 별도의 식별자를 이용할 수밖에 없다. 객체지향의 세계는 상태가 변하지 않는 값과 상태가 변하는 객체들이 서로 균형을 맞추며 조화를 이루는 사회다. 기계로서의 객체일반적으로 객체의 상태를 조회하는 작업을 쿼리(query) 라고 하고 객체의 상태를 변경하는 작업을 명령(command) 이라고 한다. 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다. 사용자는 명령을 통해서만 상태를 변경할 수 있고 조회(쿼리)를 통해서만 상태를 조회할 수 있다. 즉 객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 행동뿐이다. 이 점은 객체의 캡슐화를 강조한다. 객체의 상태와 행동은 하나의 단위로 캡슐화된다. 기계 은유에서 두 기계는 외부에 동일한 행동을 제공하고 상태 역시 동일하지만, 우리는 두 기계를 구분된 별개의 객체로 인식한다. 이것은 객체가 상태와 무관하게 구분 가능한 식별자를 가진다는 것을 의미한다. 앨리스 객체와 음료 객체를 기계 은유의 관점에서 표현한다면, 앨리스 기계의 ‘음료를 마시다’ 버튼을 눌렀을 때 앨리스 기계는 링크를 통해 연결된 음료 기계에게 ‘마셔지다’라는 버튼이 눌려지도록 요청을 전송한다. 즉, 링크를 통해 연결된 두 객체가 메시지 전송을 통해 협력하고 있는 것이다. 행동이 상태를 결정한다객체의 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태가 캡슐화되지 못하고 공용 인터페이스에 노출되버릴 확률이 높아진다. 객체를 협력자가 아닌 고립된 섬으로 만든다. 상태를 먼저 고려한 객체는 협력에 적합하지 못하다. 객체의 재사용성이 저하된다. 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나오기 때문이다. 따라서 상태가 아니라 행동에 초점을 맞춰 객체를 생성해야 한다. 객체는 다른 객체와 협력하기 위해 존재한다. 협력의 문맥에 맞는 적절한 행동을 수행하는 객체를 발견하거나 창조해야 한다. 객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는 데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택하는 방식으로 수행된다. 협력 안에서 객체의 행동은 결국 객체의 책임이며, 응집도 높고 재사용 가능한 객체를 만들 수 있어야 한다. 🙋‍♀️ 행동이 상태를 결정한다. 은유와 객체✔️ 두 번째 도시전설 객체지향을 현실 세계의 모방이라고 보는 관점은 객체지향 분석/설계란 현실 세계에 존재하는 다양한 객체를 모방한 후 필요한 부분만 취해 소프트웨어 객체로 구현하는 과정이라고 설명한다. 이 관점은 객체지향을 현실 세계의 추상화라고도 하는데, 여기서 추상화란 실제 사물에서 자신이 원하는 특성만 취하여 핵심만 표현하는 행위를 말한다. 그러나 객체지향 세계는 현실 세계의 단순한 모방이 아니다. ✔️ 의인화 현실 세계의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은, 소프트웨어의 객체는 행동을 스스로 수행할 수 있다는 것이다. 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화라고 부른다. 객체지향 세계의 거리는 현실 속의 객체보다 더 많은 특징과 능력을 보유한 객체들로 넘쳐난다. ✔️ 은유 현실 세계와 객체지향 세계 사이의 관계는 은유(metaphor) 에 기반한다. 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다. 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다. ✔️ 이상한 나라를 창조하라 객체지향 설계자로서 우리의 목적은 현실을 모방하는 것이 아니며, 단지 이상한 나라를 창조하기만 하면 된다! 🤓 DISCUSSION “행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 영향을 받는다”고 한다. 그러나 이전상태가 무엇이든 간에 절대적으로 상태값을 변경시키는 경우는 어떨까? 예를들어 사과를 먹으면 키가 100cm가 된다면? 행동의 성공여부 = 결과 이므로, 결과는 이전에 어떤 행동이 발생했는지에 따라 영향이 있을 것이다. 어쨌든 상태의 변화는 자신의 의지로 하는 것이다. 결과는 절대값 100cm지만, 그 행동을 수행할지 여부는 이전 상태값을 기준으로 판단할 수 있다. 상황을 객체가 판단해야 한다. 결과가 절대값이 된다는 건 캡슐화에 위배되는 것일 수도 있다. 상태는 외부에서 알면 안 된다. “상태가 객체 내부에 깔끔히 캡슐화되지 못하고 공용 인터페이스에 노출될 수 있다”는 것은 무슨 의미일까? 외부에서 상태를 직접 변경시키는 것은 좋지 않다. 속마음으로만 갖고 있는 상태들을 가정해보자. 어떤 객체의 속마음이 여러 다른 객체나 컨트롤러에 의해서 인터페이스에 노출되는 경우가 있다. (ex. class의 getter 또는 observer 등) 캡슐화가 보장되지 않을 수도 있기 때문에, 행동 단위로 상태를 결정하거나 가져오는 방법이 필요하다 객체지향은 객체들 간의 상호작용으로 이뤄져 있는데, 객체의 상태부터 정의한다면 실수할 수도 있다. “객체의 행동이 객체의 책임을 의미한다”는 것은 무슨 의미일까? 객체의 책임은 객체의 역할이다. 객체의 역할은 행동들의 집합이다. 객체의 책임은 자신의 상태를 바꾸는 것이다. 그 과정에서 사이드 이펙트를 일으킬 수 있다. 따라서 객체는 상태를 변경하는 것에 책임을 가지고, 중요하게 관리해야 한다. 객체의 행동이란 결국 외부와의 약속(인터페이스)다. 상태가 바뀔 때 다른 상태가 같이 바뀌거나 기존 상태에 영향을 받는데, 이걸 무시하고 바뀌는 것을 방지하는 책임이 있다.","link":"/2022/02/12/oop-true-and-false-2/"},{"title":"객체지향의 사실과 오해 - 5장","text":"5장: 책임과 메시지 존 달리와 밥 라타네는 실험을 통해 ‘책임감 분산’이라는 현상을 발견했다. 사건에 대한 목격자가 많으면 많을수록 개인이 느끼는 책임감은 적어진다. 집단적 위기 상황에서 명확한 책임을 가진 권위자가 없을 때, 대부분의 사람들은 자신에게 명확한 책임이 없는 경우에는 발작 환자를 도와주는 일을 타인의 책임으로 간주해버린다. 그에 반해 이를 보고할 책임이 명확하게 주어진 경우에는 신속하게 위기 상황을 해결하려고 노력한다. 이 이야기에서 훌륭한 객체지향의 세계는 명확하게 정의된 역할과 책임을 지닌 객체들이 상호 협력하는 세계라는 사실을 이끌어낼 수 있다. 자율적인 책임설계의 품질을 좌우하는 책임객체지향 공동체를 구성하는 기본 단위는 ‘자율적’인 객체다. 자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체, 그 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체를 의미한다. 적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력체를 낳는다. 이는 전체 애플리케이션의 품질을 결정한다. 자신의 의지에 따라 증언할 수 있는 자유객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다. 앨리스의 재판 이야기에서, 모자 장수가 재판이라는 협력에 참여하기 위해서는 왕의 요청을 적절하게 처리한 후 응답해야 한다. 모자 장수는 증언 방식과 증언 자료를 스스로의 의지와 판단에 따라 자유롭게 선택할 수 있다. 왕의 입장에서 모자 장수가 어떤 방법으로 증언하는지는 중요하지 않다. 만약 왕이 모자 장수가 증언하기 위해 선택할 수 있는 자유의 범위를 지나치게 제한한다면, 모자장수가 다양한 매체를 통해 증언할 수 있는 가능성 자체를 박탈하게 된다. 이때 모자 장수는 자율적으로 책임을 수행할 수 없다. 객체지향 세계에서 객체가 자율적이기 위해서는 객체에게 할당되는 책임의 수준 역시 자율적이어야 한다. 너무 추상적인 책임책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다. 어떤 책임이 자율적인지를 판단하는 기준은 문맥에 따라 다르다. 성급한 일반화의 오류를 피하고 현재의 문맥에 가장 적합한 책임을 선택할 수 있는 안목을 길러야 한다. ‘어떻게’가 아니라 ‘무엇’을자율적인 책임의 특징은 객체가 ‘어떻게(how)’ 해야 하는가가 아니라 ‘무엇(what)’을 해야 하는가를 설명한다는 것이다. 책임을 자극하는 메시지객체가 자신에게 할당된 책임을 수행하도록 만드는 것은 외부에서 전달되는 요청 뿐이다. 이 요청을 메시지라고 부르며, 메시지는 객체로 하여금 자신의 책임 즉 행동을 수행하게 만드는 유일한 방법이다. 메시지와 메서드메시지하나의 객체는 메시지를 전송함으로써 다른 객체에 접근한다. 왕과 모자 장수 사이의 협력에서 왕은 모자 장수에게 ‘증언하라’라는 메시지를 전송한다. 협력의 다른 축에서 하얀 토끼는 ‘증인석에 입장하라’라는 메시지를 전송한다. ‘증언하라’라는 부분은 메시지 이름(message name) 이라고 한다. 메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 인자(argument) 를 통해 추가 정보를 제공할 수 있다. 메시지는 메시지 이름과 인자의 두 부분으로 구성된다 1증언하라(어제, 왕국) 메시지 전송은 수신자와 메시지(메시지 이름과 인자의 조합)의 조합이다. 수신자, 메시지 이름, 인자의 순서대로 나열하면 메시지 전송이 된다. 1모자장수, 증언하라(어제, 왕국) 객체가 메시지를 수신할 수 있다는 것은 객체가 메시지에 해당하는 책임을 수행할 수 있다는 것을 의미한다. 객체가 수신할 수 있는 메시지의 모양은 객체가 수행할 책임의 모양을 결정한다. 모자 장수는 ‘증인석에 입장하라’와 ‘증언하라’라는 메시지를 수신했을 때 이를 처리하는 방법을 자유롭게 선택할 수 있다. 모자 장수가 메시지를 변경하지만 않는다면 책임을 수행하는 방법을 변경하더라도 왕은 그 사실을 알 수 없다. 이것은 객체의 외부와 내부가 메시지를 기준으로 분리된다는 것을 의미한다. 메서드모자 장수가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 메서드라고 한다. 객체가 메시지를 수신한 후 메시지를 처리할 수 있다고 판단되면 책임을 다하기 위해 메시지를 처리할 방법인 메서드를 선택한다. 다형성다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 다형성은 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수 있다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행한다. 다형성은 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 하며, 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다. 이를 통해 설계를 유연하고 재사용 가능하게 만들 수 있다. 다형성은 수신자의 종류를 캡슐화하여, 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. 즉 다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다. 유연하고 확장 가능하고 재사용성이 높은 협력의 의미송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다. 첫째, 협력이 유연해진다. 송신자는 수신자가 메시지를 이해한다면 누구라도 상관하지 않으므로, 수신자를 다른 타입의 객체로 대체하여 유연하게 협력을 변경할 수 있다. 둘째, 협력이 수행되는 방식을 확장할 수 있다. 송신자에게 아무런 영향도 미치지 않고서도 수신자를 교체할 수 있기 때문에 협력의 세부적인 수행 방식을 쉽게 수정할 수 있다. 셋째, 협력이 수행되는 방식을 재사용할 수 있다. 협력에 영향을 미치지 않고서도 다양한 객체들이 수신자의 자리를 대체할 수 있기 때문에 다양한 문맥에서 협력을 재사용할 수 있다. 송신자와 수신자를 약하게 연결하는 메시지메시지는 송신자와 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만든다. 메시지를 따라라객체지향의 핵심, 메시지객체지향 애플리케이션의 핵심은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다. 객체지향 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의되며, 실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 객체다. 클래스를 정의하는 것보다 객체들의 속성과 행위를 식별하는 것이 먼저다. 진정한 객체지향 패러다임으로의 도약은 개별적인 객체가 아니라 메시지를 주고받는 객체들 사이의 커뮤니케이션에 초점을 맞출 때 일어난다. 객체 자체에 초점을 맞추고, 메시지가 아니라 데이터를 중심으로 객체를 설계하는 방식은 객체의 내부 구조를 객체 정의의 일부로 만들기 때문에 객체의 자율성을 저해한다. 객체의 자율성을 보장하기 위해 객체 내부 구조는 감춰져야 한다. 데이터가 아닌 객체의 행위를 고려하기 위해서는 객체를 독립된 단위가 아니라 협력이라는 문맥 안에서 생각해야 한다. 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성해야 한다. 객체지향 설계의 중심에는 메시지가 위치한다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다. 책임-주도 설계 다시 살펴보기객체지향 설계는 적절한 책임을 적절한 객체에게 할당하면서 메시지를 기반으로 협력하는 객체들의 관계를 발견하는 과정이다. 이를 책임-주도 설계라고 한다. 책임-주도 설계 방법에서 역할, 책임, 협력을 식별하는 것은 애플리케이션이 수행하는 기능을 시스템의 책임으로 보는 것에서 시작된다. 객체가 책임을 완수하기 위해 다른 객체의 도움이 필요하다고 판단되면 도움을 요청하기 위해 어떤 메시지가 필요한지 결정한다. 메시지를 결정한 후에는 메시지를 수신하기에 적합한 객체를 선택한다. 수신자는 송신자가 메시지를 보내면서 기대한 바를 충족시켜야 한다. 즉 메시지가 수신자의 책임을 결정한다. What/Who 사이클책임-주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것이다. 이 과정을 흔히 What/Who 사이클이라고 한다. 협력이라는 문맥 안에서 필요한 메시지를 먼저 결정한 후에 메시지를 수신하기에 적합한 객체를 선택한다. 그리고 수신된 메시지가 객체의 책임을 결정한다. 책임이 먼저 오고 객체가 책임을 따른다. 결과적으로 시스템이 수행해야 하는 행위는 협력하는 객체들의 책임으로 분배된다. 즉 수신 가능한 메시지가 모여 객체의 인터페이스를 구성한다. 묻지 말고 시켜라메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 한다. 이를 묻지 말고 시켜라(Tell, Don’t Ask) 스타일 또는 데메테르 법칙(Law of Demeter) 이라고 한다. 메시지 중심의 설계는 메시지 수신자의 캡슐화를 증진시킨다. 또한 송신자가 수신자의 내부 상태를 미리 알 수 없기 때문에 송신자와 수신자가 느슨하게 결합된다. 송신자는 수신자가 어떤 객체인지는 모르지만 자신이 전송한 메시지를 잘 처리할 것이라는 것을 믿고 메시지를 전송할 수밖에 없다. ‘묻지 말고 시켜라’ 스타일은 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 주기 때문에 설계를 유연하게 만든다. 이 스타일은 메시지가 ‘어떻게’ 해야하는지를 지시하는 것이 아니라 ‘무엇을’ 해야하는지를 요청하는 것이다. 메시지를 믿어라메시지를 전송하는 객체의 관점에서 자신이 전송하는 메시지를 수신할 수 있다면 협력하는 객체의 종류가 무엇인지는 중요하지 않다. 또 메시지를 이해할 수 있다면 다양한 타입의 객체로 협력 대상을 자유롭게 교체할 수 있기 때문에 설계가 좀 더 유연해진다. 메시지를 믿어라. 그러면 자율적인 책임은 저절로 따라올 것이다. 객체 인터페이스인터페이스일반적으로 인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다. 인터페이스는 다음과 같은 세 가지 특징을 지닌다. 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다. 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용할 수 있다. 협력에 참여하는 객체는 인터페이스를 통해 다른 객체와 상호작용하며, 객체의 인터페이스만 알면 객체의 내부 구조나 작동 방식을 몰라도 객체와 상호작용 할 수 있다. 또한 인터페이스만 유지된다면 객체의 내부 구조나 작동 방식을 변경하거나 다른 객체로 대체한다고 하더라도 인터페이스 사용자에게 영향을 미치지 않는다. 메시지가 인터페이스를 결정한다객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성된다 공용 인터페이스실제로 인터페이스는 외부에서 접근 가능한 공용 인터페이스와 내부에서만 접근할 수 있는 사적인 인터페이스로 구분된다. 각각은 메시지 송신자가 다른 객체인지 아니면 객체 자신인지에 따라 다르다. 왕과 모자 장수 사이에는 ‘증언하라’라는 메시지를 송/수신할 수 있는 인터페이스가 존재한다. 하얀 토끼와 모자 장수 사이에는 ‘증인석에 입장하라’라는 메시지를 수신할 수 있는 인터페이스가 존재한다. 객체가 협력에 참여하기 위해 수행하는 메시지가 객체의 공용 인터페이스를 암시한다. 먼저 메시지를 결정하고 이 메시지를 수행할 객체를 나중에 결정하기 때문에 메시지가 수신자의 인터페이스를 결정할 수밖에 없다. 책임, 메시지, 그리고 인터페이스 협력에 참여하는 객체의 책임은 자율적이어야 한다 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 채워지며, 객체가 메시지를 수신했을 때 적절한 객체의 책임이 수행된다. 이 책임 수행 방법을 메서드라고 하며, 메시지와 메서드의 구분을 통해 다형성이 탄생한다. 인터페이스는 객체가 다른 객체와 협력하기 위한 접점으로, 객체가 어떤 메시지를 수신할 수 있느냐가 어떤 책임을 수행할 수 있느냐와 어떤 인터페이스를 가질 것인지를 결정한다. 메시지로 구성된 공용 인터페이스는 객체의 외부와 내부를 명확하게 분리한다. 인터페이스와 구현의 분리객체 관점에서 생각하는 방법 좀 더 추상적인 인터페이스 - 지나치게 상세한 수준의 메시지는 객체의 자율성을 저해한다. 추상적인 인터페이스를 제공하여 수신자의 자율성을 보장하는 것이 좋다. 최소 인터페이스 - 외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말자. 최소 인터페이스는 메시지를 먼저 결정하고 객체를 나중에 선택하는 책임-주도 설계 방법을 따를 때 달성할 수 있다. 인터페이스와 구현 간에 차이가 있다는 점을 인식 - 객체의 외부와 내부를 명확하게 분리하는 것이 중요하다. 구현구현(implementation) 은 객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 것으로, 객체의 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다. 객체는 상태와 행동을 가진다. 상태를 어떻게 표현할 것인가는 객체의 구현에 해당한다. 행동은 메시지 처리 방법을 가리키는 것으로, 메서드라고 부른다. 메서드를 구성하는 코드 자체는 객체의 구현 부분에 포함된다. 객체의 외부와 내부를 분리하는 것은 결국 객체의 공용 인터페이스와 구현을 명확하게 분리하라는 것이다. 인터페이스와 구현의 분리 원칙훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 소프트웨어는 항상 변경된다. 객체의 모든 것이 외부에 공개돼 있다면 변경에 의한 파급효과가 어마어마할 것이다. 소프트웨어의 변경 시 안전 지대는 객체의 내부인 구현이고, 위험 지대는 객체의 외부인 공용 인터페이스다. 변경에 대한 안전 지대를 만드는 것는 객체를 자율적인 존재를 만드는 데도 기여한다. 캡슐화객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 캡슐화라고 한다. 정보 은닉이라고 부르기도 한다. 상태와 행위의 캡슐화객체는 상태와 행위를 한데 묶은 후 외부에서 반드시 접근해야만 하는 행위만 골라 공용 인터페이스를 통해 노출한다. 프로그래밍 관점에서 상태를 주로 데이터로 구현되고 행동은 프로세스로 구현된다. 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안으로 함께 묶어 놓음으로써 객체의 자율성을 보장한다. 사적인 비밀의 캡슐화객체는 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 막기 위해 의사소통 가능한 특별한 경로만 외부에 노출한다. 이런 고정된 경로를 공용 인터페이스라고 한다. 객체는 공용 인터페이스를 경계로 최대한의 자율성을 보장받을 수 있다.객체를 자율적인 존재로 바라보는 것은 결국 객체의 내부와 외부를 엄격하게 분리한다는 것을 의미한다. 객체는 자신의 의지에 따라 변경하고 조작할 수 있는 비밀을 가지고 있는 부분인 내부와, 외부의 객체가 의지하고 접근할 수 있는 공용 인터페이스를 가리키는 외부로 구성된다. 책임의 자율성이 협력의 품질을 결정한다객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 되며, 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정한다. 그 이유는 다음과 같다. 첫째, 자율적인 책임은 협력을 단순하게 만든다. 자율적인 책임은 의도를 명확하게 표현함으로써 협력을 단순하고 이해하기 쉽게 만든다. 책임이 적절하게 추상화되는 것이다. 둘째, 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다. 책임이 자율적이기 때문에 왕과 모자 장수 사이에 약속된 ‘증언하다’라는 책임만 완수할 수 있으면 어떤 방법을 선택할지는 전적으로 모자 장수의 권한이다. 요청하는 객체가 몰라도 되는 사적인 부분이 객체 내부로 캡슐화되기 때문에 인터페이스와 구현이 분리된다. 셋째, 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다. 변경의 파급효과가 객체 내부로 캡슐화되기 때문에 두 객체 간의 결합도가 낮아진다. 넷째, 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다. 왕의 입장에서 ‘증언하라’라는 책임을 수행할 수 있다면 모자 장수가 아닌 어떤 사람이 요청을 수신하더라도 재판을 진행하는 데 문제가 없다. 책임이 자율적일수록 설계가 유연해지고 재사용성이 높아진다. 다섯째, 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다. 모자 장수는 자신의 의지를 기반으로 책임을 완수할 수 있을 정도로 충분히 자율적이다. 책임이 자율적일수록 객체의 응집도를 높은 상태로 유지하기가 쉬워진다. 즉 책임이 자율적일수록 적절하게 ‘추상화’되며, ‘응집도’가 높아지고, ‘결합도’가 낮아지며, ‘캡슐화’가 증진되고, ‘인터페이스와 구현이 명확히 분리’되며, 설계의 ‘유연성’과 ‘재사용성’이 향상된다. 👂 Discussion🤔 모자장수 외부의 객체 (ex. 왕)는 어떤 기준으로 모자장수에게 ‘증언하라’고 시키는 것일까? 모자장수의 공용 인터페이스를 보고 확인한다. 특정 인터페이스를 갖고 있는지 확인하는 과정은, 특정 클래스를 상속받았는지, 또는 필요한 메서드가 있는지 등을 확인할 수 있다. 메시지를 받은 객체가 관련 정보가 없다면, 다른 객체에게 메시지를 또 요청할 수 있다. 인터페이스는 설계 시점에는 모르는 것이다. ‘증언하라’는 메시지를 보내고 싶다면, 그 메시지를 받는 모자장수나 앨리스는 ‘증언하라’에 대한 인터페이스를 구현했을 것이고, 하얀 토끼는 ‘증언하라’ 인터페이스를 만들어두지 않았을 것이다. 모든 것은 “메시지”로부터 출발해야 한다. 왕-재판장-증인 이라는 역할이 있고, 증인이 되기 위해서는 필요한 인터페이스를 가지고 있어야 한다. 그 사실을 알고 있기 때문에 왕이 호출을 한 것일 것이다. 약속한 리턴값이 올 것이라고 믿고, 묻지 말고 시키자! 🤔 ‘어떻게’ → ‘무엇을’로 관점을 전환할 경우, 책임의 처리에 필요한 것을 외부에서 찾게 되어 협력이 더욱 복잡해지는데, 그럼 객체의 의존성이 높아지는 게 아닌가? 추상적인 인터페이스를 만들어야한다는 것은 협력을 고려하면서도 외부 의존성을 낮추는 것이다. 그래서 너무 구체적이지도 너무 추상적이지도 않게, 추상화의 정도를 적절하게 해야 한다. 🤔 객체의 응집도란? ‘응집도’란 ‘하나의 프로그램을 구성하는 각각의 모듈이 그 고유의 기능을 잘 처리할 수 있는지를 나타내는 정도’라고 하는데, 책임이 자율적일수록 외부에서 강제하는 부분이 줄어드니까 (수신자) 객체가 자기가 필요한 데이터들만 가지고 일을 알아서 잘 처리한다는 뜻이다. 제너럴리스트가 아닌 스페셜리스트 Ref https://velog.io/@ljinsk3/%EC%A2%8B%EC%9D%80-%EC%84%A4%EA%B3%84%EB%9E%80-feat.-%EA%B2%B0%ED%95%A9%EB%8F%84-%EC%9D%91%EC%A7%91%EB%8F%84","link":"/2022/03/05/oop-true-and-false-5/"},{"title":"리팩터링 12장","text":"상속 다루기 12.1 메서드 올리기메서드 올리기를 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다. 그러나 메서드 올리기 리팩터링을 적용하려면 선행 단계를 거쳐야 할 때가 많다. 메서드 올리기를 적용하기에 가장 이상하고 복잡한 상황은 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다. 두 메서드의 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기를 고려해보자. 절차 똑같이 동작하는 메서드인지 면밀히 살펴본다. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다. 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다. 정적 검사를 수행한다. 서브클래스 중 하나의 메서드를 제거한다. 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다. 예시12345678910// before// Employee 클래스(Party를 상속함)...get annualCost() { return this.monthlyCost * 12;}// Department 클래스(Party를 상속함)...get totalAnnualCost() { return this.monthlyCost * 12; } 12345// after// Party 클래스...get annualCost() { return this.monthlyCost * 12; } 12.2 필드 올리기서브클래스의 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자. 이렇게 하면 데이터 중복 선언을 없앨 수 있고, 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다. 절차 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다. 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다. 슈퍼클래스에 새로운 필드를 생성한다. 서브클래스의 필드들을 제거한다. 테스트한다. 12.3 생성자 본문 옮기기생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른 식으로 접근해야 한다. 절차 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다. 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 옮긴다. 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다. 예시123456789101112131415161718192021// beforeclass Party {}class Employee extends Party { constructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; } // ...}class Department extends Party { constructor(name, staff) { super(); this._name = name; this._staff = staff; } // ...} 1234567891011121314151617181920212223// afterclass Party { constructor(name) { this._name = name; }}class Employee extends Party { constructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; } // ...}class Department extends Party { constructor(name, staff) { super(name); this._staff = staff; } // ...} 12.4 메서드 내리기특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스(들)에 추가하는 편이 깔끔하다. 절차 대상 메서드를 모든 서브클래스에 복사한다. 슈퍼클래스에서 그 메서드를 제거한다. 이 메서드를 사용하지 않는 모든 서브클래스에서 제거한다. 12.5 필드 내리기서브클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스(들)로 옮긴다. 절차 대상 필드를 모든 서브클래스에 정의한다. 슈퍼클래스에서 그 필드를 제거한다. 이 필드를 사용하지 않는 모든 서브클래스에서 제거한다. 12.6 타입 코드를 서브클래스로 바꾸기타입 코드는 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다. 타입 코드는 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다. 또 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 유용하다. 절차 타입 코드 필드를 자가 캡슐화한다. 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다. 타입 코드 게터 메서드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택 로직을 만든다. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다. 타입 코드 필드를 제거한다. 타입 코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용한다. 예시: 직접 상속할 때1234567891011121314151617// before// Employee 클래스...constructor(name, type) { this.validateType(type); this._name = name; this._type = type;}validateType(arg) { if (![&quot;engineer&quot;, &quot;manager&quot;, &quot;salesperson&quot;].includes(arg)) { throw new Error(`${arg}라는 직원 유형은 없습니다.`); }}toString() { return `${this._name} (${this._type})`;} 123456789101112131415161718192021222324252627// after// Employee 클래스...constructor(name) { this._name = name;}class Engineer extends Employee { get type() { return &quot;engineer&quot;; }}class Salesperson extends Employee { get type() { return &quot;salesperson&quot;; }}class Manager extends Employee { get type() { return &quot;manager&quot;; }}function createEmployee(name, type) { switch (type) { case &quot;engineer&quot;: return new Engineer(name); case &quot;salesperson&quot;: return new Salesperson(name); case &quot;manager&quot;: return new Manager(name); default: throw new Error(`${type}라는 직원 유형은 없습니다.`); } return new Employee(name, type);} 12.7 서브클래스 제거하기서브클래싱은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다. 하지만 더 이상 쓰이지 않는 서브클래스는 제거하는 것이 좋다. 절차 서브클래스의 생성자를 팩터리 함수로 바꾼다. 서브클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼클래스로 옮긴다. 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 맏는다. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다. 서브클래스를 지운다. 예시1234567891011121314151617// beforeclass Person { constructor(name) { this._name = name; } get name() { return this._name; } get genderCode() { return &quot;X&quot;; } // ...}class Male extends Person { get genderCode() { return &quot;M&quot;; }}class Female extends Person { get genderCode() { return &quot;F&quot;; }} 서브클래스가 하는 일이 이게 다라면 굳이 존재할 이유가 없다. 서브클래스 만들기를 캡슐화하는 방법은 바로 생성자를 팩터리 함수로 바꾸기다. 123456789101112131415161718192021222324252627282930313233class Person { constructor(name, genderCode) { this._name = name; this._genderCode = genderCode; } get name() { return this._name; } get genderCode() { return this._genderCode; } // ... get isMale() { return &quot;M&quot; === this._genderCode };}class Male extends Person { get genderCode() { return &quot;M&quot;; }}class Female extends Person { get genderCode() { return &quot;F&quot;; }}function createPerson(aRecord) { switch (aRecord.gender) { case 'M': return new Male(aRecord.name, &quot;M&quot;); case 'F': return new Female(aRecord.name, &quot;F&quot;); default: return new Person(aRecord.name, &quot;X&quot;); }}function loadFromInput(data) { return data.map(aRecord =&gt; createPerson(aRecord));}// 클라이언트...const numberOfMales = people.filter(p =&gt; p.isMale).length; 12.8 슈퍼클래스 추출하기비슷한 일을 수행하는 두 클래스가 보이면 상속 메커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다. 절차 빈 슈퍼클래스를 마든다. 원래의 클래스들이 새 클래스를 사속하도록 한다. 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 차례로 적용하여 공통 원소를 슈퍼클래스로 옮긴다. 서브클래스에 남은 메서드들을 검토한다. 공통되는 부분이 있다면 함수로 추출한 다음 메서드 올리기를 적용한다. 원래 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다. 예시12345678910111213141516171819202122232425262728293031323334353637383940// beforeclass Employee { constructor(name, id, monthlyCost) { this._id = id; this._name = name; this._monthlyCost = monthlyCost; } get monthlyCost() { return this._monthlyCost; } get name() { return this._name; } get id() { return this._id; } get annualCost() { return this.monthlyCost * 12; }}class Department { constructor(name, staff) { this._name = name; this._staff = staff; } get staff() { return this._staff.slice(); } get name() { return this._name; } get totalMonthlyCost() { return this.staff .map(e =&gt; e.monthlyCost) .reduce((sum, cost) =&gt; sum + cost); } get headCount() { return this.staff.length; } get totalAnnualCost() { return this.totalMonthlyCost * 12; }} 123456789101112131415161718192021222324252627282930313233343536373839404142// afterclass Party { constructor(name, id, monthlyCost) { this._name = name; } get name() { return this._name; } get annualCost() { return this.monthlyCost * 12; }}class Employee extends Party { constructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; } get monthlyCost() { return this._monthlyCost; } get id() { return this._id; }}class Department extends Party { constructor(name, staff) { super(name); this._staff = staff; } get staff() { return this._staff.slice(); } get monthlyCost() { return this.staff .map(e =&gt; e.monthlyCost) .reduce((sum, cost) =&gt; sum + cost); } get headCount() { return this.staff.length; }} 12.9 계층 합치기클래스 계층구조가 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져 더는 독립적으로 존재해야 할 이유가 사라진다면, 그 둘을 하나로 합쳐야 할 시점이다. 절차 두 클래스 중 제거할 것을 고른다. 필드 올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 적용하여 모든 요소를 하나의 클래스로 옮긴다. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다. 빈 클래스를 제거한다. 12.10 서브클래스를 위임으로 바꾸기상속은 한 번만 쓸 수 있는 카드라는, 가장 명확한 단점이 있다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼을 수밖에 없다. 또 상속은 클래스들의 관계를 아주 긴밀하게 결합한다. 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기가 쉽다. 위임은 이 두 문제를 모두 해결해준다. 위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의할 수 있다. 즉, 상속보다 결합도가 훨씬 약하다. 절차 생성자를 호출하는 곳이 많다면 생성자를 팩터리 함수로 바꾼다. 위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조도 필요하다. 위임을 저장할 필드를 슈퍼클래스에 추가한다. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다. 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른다. 함수 옮기기를 적용해 위임 클래스로 옮긴다. 원래 메서드에서 위임하는 코드는 지우지 않는다. 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다. 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야 한다. 호추하는 외부 코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거한다. 서브클래스의 모든 메서드가 옮겨질 때까지 5~7 과정을 반복한다. 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정한다. 서브클래스를 삭제한다. 예시1234567891011121314151617181920212223242526272829303132333435363738// before// Booking 클래스...class Booking { constructor(show, date) { this._show = show; this._date = date; } get hasTalkback() { return this._show.hasOwnProperty('talkback') &amp;&amp; !this.isPeakDay; } get basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return result; }}// PremiumBooking 클래스(Booking을 상속함)...class PremiumBooking extends Booking { constructor(show, date, extras) { super(show, date); this._extras = extras; } get hasTalkback() { return this._show.hasOwnProperty('talkback'); } get basePrice() { return Math.round(super.basePrice + this._extras.premiumFee); } get hasDinner() { return this._extras.hasOwnProperty('dinner') &amp;&amp; !this.isPeakDay; }} 위 예제에는 상속이 잘 들어맞지만, 현실은 이만큼 완벽하지만은 않다. 슈퍼클래스에는 서브클래스에 의해 완성되는, 즉 서브클래스 없이는 불완전한 어떤 구조가 존재할 수 있다. 상속은 한 번만 사용할 수 있는 도구다. 따라서 상속을 사용해야 할 다른 이유가 생긴다면, 그리고 그 이유가 프리미엄 예약 서브클래스보다 가치가 크다고 생각된다면 프리미엄 예약을 (상속이 아닌) 다른 방식으로 표현해야 할 것이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// after// Booking 클래스...class Booking { constructor(show, date) { this._show = show; this._date = date; } get hasTalkback() { return (this._premiumDelegate) ? this._premiumDelegete.hasTalkback : this._show.hasOwnProperty('talkback') &amp;&amp; !this.isPeakDay; } get basePrice() { let result = this._show.price; if (this.isPeakDay) result += Math.round(result * 0.15); return (this._premiumDelegate) ? this._premiumDelegate.extendBasePrice(result); : result; } get hasDinner() { return (this._premiumDelegate) ? this._premiumDelegate.hasDinner : undefined; } _bePremium(extras) { this._premiumDelegate = new PremiumBookingDelegate(this, extras); }}function createBooking(show, date) { return new Booking(show, date);}function createPremiumBooking(show, date, extras) { const result = new Booking(show, date, extras); result._bePremium(extras); return result;}// 클라이언트(일반 예약)...aBooking = createBooking(show, date);// 클라이언트(프리미엄 예약)...aBooking = createPremiumBooking(show, date, extras);class PremiumBookingDelegate { constructor(hostBooking, extras) { this._host = hostBooking; this._extras = extras; } get hasTalkback() { return this._host._show.hasOwnProperty('talkback'); } get basePrice() { return Math.round(this._host._privateBasePrice + this._extras.premiumFee); } extendBasePrice(base) { return Math.round(base + this._extras.premiumFee); } get hasDinner() { return this._extras.hasOwnProperty('dinner') &amp;&amp; !this.isPeakDay; }} 12.11 슈퍼클래스를 위임으로 바꾸기제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다. 즉 슈퍼클래스가 사용되는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야 한다. 서브클래스 방식 모델링이 합리적일 때라도 슈퍼클래스를 위임으로 바꾸기도 한다. 슈퍼/서브클래스는 강하게 결합된 관계라서 슈퍼클래스를 수정하면 서브클래스가 망가지기 쉽기 때문이다. 절차 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다. 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다. 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다. 서로 관련된 함수끼리 그룹으로 묶어 진행한다. 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드되었다면 상속 관계를 끊는다. 예시12345678910111213141516171819202122232425262728// beforeclass CatalogItem { constructor(id, title, tags) { this._id = id; this._title = title; this._tags = tags; } get id() { return this._id; } get title() { return this._title; } hasTag(arg) { return this._tags.includes(arg); }}class Scroll extends CatalogItem { constructor(id, title, tags, dateLastCleaned) { super(id, title, tags); this._lastCleaned = dateLastCleaned; } needsCleaning(targetDate) { const threshold = this.hasTag(&quot;revered&quot;) ? 700 : 1500; return this.daysSinceLastCleaning(targetDate) &gt; threshold; } daysSinceLastCleaning(targetDate) { return this._lastCleaned.until(targetDate, ChronoUnit.DAYS); }} 12345678910111213141516171819202122232425262728// after class CatalogItem { constructor(id, title, tags) { this._id = id; this._title = title; this._tags = tags; } get id() { return this._catalogItem._id; } get title() { return this._catalogItem._title; } hasTag(aString) { return this._catalogItem.hasTag(aString); }}class Scroll { constructor(id, title, tags, dateLastCleaned) { this._catalogItem = new CatalogItem(id, title, tags); this._lastCleaned = dateLastCleaned; } needsCleaning(targetDate) { const threshold = this.hasTag(&quot;revered&quot;) ? 700 : 1500; return this.daysSinceLastCleaning(targetDate) &gt; threshold; } daysSinceLastCleaning(targetDate) { return this._lastCleaned.until(targetDate, ChronoUnit.DAYS); }}","link":"/2022/05/27/refactoring-12/"},{"title":"2021년 회고","text":"한 해 돌아보기 개발자로서 가장 많이 성장한 한 해였고, 그 어느 때보다 좋은 사람들을 많이 만났고, 넘칠 만한 사랑과 도움을 받았다. 우아한테크코스2월부터 11월까지, 우아한테크코스 3기 프론트엔드 과정에 참여했다. 한 크루의 블로그에서 불펌했다 ㅎㅎ 작년 연말, 많은 스타트업의 인턴을 떨어지고 우테코마저도 크게 기대를 하고 있진 않은 터였다. (사실 뭐하는 건지 잘 모르기도 했다.) 그렇게 애매하게 시작했는데, 올 한 해는 우테코밖에 없었다. 이제 4기가 활동하겠네. 버려진 3기… 매일 데일리 미팅을 하며 코치님, 크루들과 실없거나 진지한 이야기들을 나눴다. 코로나로 인해 대부분은 줌으로 진행했지만, 하루의 시작을 30분이라도 사람들과 가벼운 이야기를 주고받으며 열어간다는 것 자체가 MBTI E인 나에게는 큰 힘이었다. Lv1과 Lv2에서는 자바스크립트와 리액트로 총 8개의 미션을 수행했다. 페어 프로그래밍을 진행하며 여러 크루들을 만났고, 내가 그동안 얼마나 내멋대로 코딩했는지(..), 얼마나 잘 모르고 있었는지 크게 충격을 받으며 배웠던 기간이었다. 무던한 성격으로 내 뜻에 많이 맞춰준 크루도 있었고, 서로 잘 맞지 않아 수도 없이 부딪혀가며 때론 목소리가 높아졌던 크루도 있었다. 뭐가 됐든, 모든 크루들에게 아낌없이 배웠다. 요런 미션들을 했다고 한다... 각 미션마다 현업자 분들께 귀중한 코드리뷰도 받았다. 단순히 코드 스타일 뿐 아니라 큰 그림에서 데이터를 주고 받는 방식, 프론트엔드 설계를 비롯하여 현업에서 자주 쓰이는 컨벤션과 실용적인 자바스크립트 문법들을 배울 수 있었다. 더 중요한 건, 질문하는 방법을 배웠다는 사실이다. 지금와서 그때 PR에 남겼던 리뷰들을 보면 참 부끄럽고 죄송하다. 뭐가 문젠지도, 내가 무슨 생각으로 그 코드를 작성했는지도 모른 채 “아무튼 뭐가 맞는 방식인가요?” 따위의 질문들만 남겼다니… 차근차근 내가 공부하면 좋을 토픽들을 던져주셨던 리뷰어님들께 감사하다. Lv3에서는 백엔드 크루들과 함께 팀 프로젝트를 진행했다. 이건 밑에서 설명할 것이다. Lv4에서는 팀 프로젝트를 이어가며 각종 잔잔바리 미션들도 진행했다. 프론트엔드 성능/마크업/웹접근성/AWS 배포/UI Library 만들기 미션을 진행하며 정말… 큰 자괴감을 느꼈다. 나는 정말 아무것도 몰랐구나. 개발자 되려면 한참 멀었구나. (아니면 역시 개발자는 그만둬야 할까) 크루들과 상호 코드리뷰를 주고받으며 역시 한 발짝 한 발짝 크게 성장하고 있는 기분을 느꼈다. Lv5에서는 사실 취업을 준비하느라 많은 것들을 하지 못했고, 사회적 거리두기는 더욱 심해졌고, 당연히 울적했던 날들의 연속이었다. 가장 최근임에도 불구하고 뭐가 뭔지 기억도 잘 안 난다 🤷‍♀️ 어? 그런 게 있었어? 없던 걸로 치자. 똥같은 대한민국의 취업난 각 레벨이 끝날 때마다 글쓰기 미션을 통해 내가 어떤 마음으로 개발을 시작했고, 어떻게 공부하고 있으며, 어떤 개발자가 되고 싶은지 스스로를 돌이켜봤다. 공돌이인 크루들도 많은데 다들 글도 정말 멋있게 잘 쓴다. 다른 크루들의 소중한 이야기들도 읽어보고, 내 생각도 정리하면서 각 단계를 좋게 마무리할 수 있었다. 한번은 포비의 따뜻한 피드백도 받았다. 우히히 그리고 수 차례 모의면접을 진행하면서, 내가 어쩌면 외면하고 있었던 나의 얕디 얕은 지식들을(..) 낱낱이 부검당했다. 처음엔 정말 식은땀이 날 정도로 긴장하고 두려웠는데, 그런 순간들을 대비하기 위해 부단히 연습하면서 점점 면접에 익숙해질 수 있었다. 소중한, 꼭 필요했던 연습 기회들이었다. 하지만 그 무엇보다 값진 건, 코치님들과 크루들과의 추억이다. 사실 3년 전부터 슬럼프를 겪은 이후에는 새로운 사람을 만나는 게 조금 두려웠고, 깊게 친해지지도 못했었다. 우테코도 사람에 대한 큰 기대를 하지 않고 시작했었다. 그런데 정말 이상하리만큼 서로에게 하나라도 더 주고 싶어하는 크루들과, 사소한 이야기 고민이라도 진지하고 따뜻하게 들어주는 코치님들이 있었기 때문에 너무 행복했다. 한 사람도 밉거나 서운한 사람 없이 고마움만 가득하다. 못 본지 오래됐는데, 눈물날 것 같자나 😭 완전 신난 우테코 3기 크루들 우아한테크코스 기간 동안 만들어왔던 히스토리는 🍀 여기에 정리해두었다. 놀토 프로젝트우테코 Lv3를 시작하고 백엔드 아마찌가 제안했던 ‘놀러오세요 토이프로젝트’ 팀에 배정되어 팀 프로젝트를 진행했다. 야심차게 화이팅을 외치며 시작하자마자 사회적 거리두기 4단계가 시행되어 모든 협업을 줌으로 진행해서 아쉬움이 많이 남는다. 허접한 실력으로 만들어봤던 우리 팀 노션 페이지 그래도 팀원들이 모두 둥글둥글하고 자기 할일을 열심히 하는 사람들이라, 큰 충돌이나 갈등 없이 4개월을 알차게 진행할 수 있었다. 하루도 지켜지지 않는 칼퇴를 울부짖으면서도 웃는 얼굴로 힘차게 팀을 이끌어나간 조엘, 항상 뭔가 공부해와서 팀원들에게 이것저것 알려주는 차분한 우리팀의 신 찰리, 조용하지만 우리 팀의 작업의 많은 의문점을 던지며 프로젝트를 더욱 견고하게 만들어나가게 도와줬던 포모, 밝은 웃음소리와 하나하나 섬세한 자세로 팀원들의 질문들에 적극적으로 설명해주던 아마찌까지 모두 최고의 팀원들이었다. 오랜 작업에 정신줄을 놔버린 우리 팀원들 특히 프론트엔드 페어였던 미키에게 많이 고맙다. 백엔드 넷이 할 동안 프론트는 단 둘이서 정말 산전수전(?)을 많이 겪었다. 미키가 아니었더라면 혼자서는 상상도 하지 못했을 작업과 기술적 도전들을 이뤄낼 수 있었다. 처음부터 스타일이 잘 맞았던 건 아니라 조금씩 엇나가거나 감정이 상할 뻔한 적도 있지만, 회고의 시간을 통해 각자 생각을 솔직하게 털어놓으면서 서로 한 발짝 성장할 수 있는 계기가 되었다. 체력도 약해서 종종 뻗어버리는 내게 항상 응원해주고, 나를 위해서 진정성 있는 조언도 해줬던 미키 덕에 개발자로서 큰 도약을 할 수 있었다. 우리 놀토 팀원들이 아니었다면 언제 또 이렇게 굉장한 서비스를 만들어볼 수 있을까 싶다. 기본서 읽기모던 자바스크립트 딥다이브, 코어 자바스크립트, 그림으로 배우는 HTTP Network Basic, 이펙티브 타입스크립트, 그리고 UI/UX 책 두 권(사용자를 유혹하는 UX의 기술, 도날드 노먼의 UX 디자인 특강)을 읽었다. 사실 부끄럽지만 작년까지 책은 거의 읽은 적이 없다. 프로그래밍은 책으로 공부하는 게 아니라는 알 수 없는 자신감(..) 때문이 아니었을까. 물론 직접 코드를 쳐가면서 공부해가야하는 건 맞지만, 자바스크립트를 하는 프론트엔드 개발자가 되고 싶으면 이론부터 제대로 학습하고 가는 게 맞는 건데 바보같았다. 나열한 책들을 한 번만 읽지는 않았다. 못해도 2번 이상 완독했다. 혼자 꾸준히 읽으면서 가장 크게 달라진 점은, 궁금한 게 많아졌다는 것이다. 이전에는 아는 것도 없어서 궁금한 것도 없고, 코드가 돌아가면 ‘그냥 그런가보다’ 하고 끝내기 일쑤였다. 공부를 하면 할수록 아는 게 많아지니, 궁금한 게 늘어난다. 그 궁금증에 목말라 또 여기저기 찾아보거나 크루들에게 물어보러 다닌다. 공부에 재미를 붙이게 된 것만으로도 큰 자산이다. 스터디우아한테크코스 크루들과 함께 하브루타 스터디, UX 스터디, 모던 자바스크립트 딥다이브 스터디, 인터뷰스낵 스터디에 참여했다. 대부분 내가 정말 좋아하는 언니(💙)이자 스터디의 여왕이자 하루를 48시간으로 쪼개 쓰는 크루가 스터디를 도맡아 진행해줬다. 스터디를 하면서는 크루들의 생각을 들을 수 있었다는 게 가장 좋았다. 같은 토픽, 같은 문법에 대해서도 서로가 생각하는 방식이나 코드 스타일, 동작 원리에 대한 이해나 사용 경험 등 굉장히 다양한 이야기들이 나오기 마련이다. 좁디좁은 내 생각을 널리 확장해주는 데 정말 큰 도움을 받았고, 또 그냥 코시국에 줌으로 잡담을 나누면서 요즘 사는 이야기, 공부하고 있는 것들을 들을 수 있어서 잔잔히 재밌었다. 그밖에도 알고리즘 문제풀이, 타입스크립트 이펙티브 읽기 인증 스터디에도 참여했다. 뭔가 다같이 모여서 적극적으로 진행하진 않았지만, ‘챌린저스’라는 앱을 사용하여 기간 동안 꾸준히 인증하는 방식으로 진행했다. 꾸준한 건 뭐든 자신있기 때문에, 모두 착실하게 해왔거나 지금도 하고 있다. 글또글또는 2년 전인가 처음 알게 됐다. 매일 글만 쓰는 문과생으로 글 쓰는 것엔 자신 있었지만, 뭣도 모르는 내가 개발자로서 글을 쓸 수 있을지 의문이었다. 언젠간 들어가서 글을 써야지! 다짐했었다. 오랫동안 잊고 있다가, 우테코 코치님이 알려주셔서 다시 생각이 났다. 감사하게도 글또 멤버로 합류하게 되었고, 이 포스팅을 마지막으로 한번도 패스권을 쓰지 않고 6기 활동을 마무리했다. 사실 대량의 글을 빠르게 양산해내는 건 자신 있었지만, 지난 시간 동안 글의 퀄리티는 크게 생각하지 않고 써왔었다. 글또에서 이미 현업에 계신 수많은 멋진 개발자 분들, 그리고 유명한 개발 블로그를 운영하고 계시는 네임드(!) 분들과 함께하며 조금이나마 신경 써서 블로그 포스팅을 하기 시작했다. 첫 개발자로서 일을 시작하게 되면 무지 바쁘겠지만, 어떻게든 다음 기수도 같이 계속 해나가보고 싶다. 아무리 바쁘더라도 시간은 만들어지니까. 글을 쓰던 안 쓰던 바쁜 건 똑같을 테니까. 나를 위한 시간을 가져야 더 여유도 가질 수 있는 법이다. 취업취업하기 전까지 19개 회사에서 탈락 메일을 받았다. 사실 그중 절반은 경력직 채용에 지원한 것이긴 하다. 20번째에 우아한형제들 취업에 성공하고, 진행중이었던 두 군데의 전형은 포기했다. 그중 한 군데는 최종면접을 앞두고 있던 상태라 조금 아쉽기도 했지만, 몸도 안 좋았고 많이 지쳐있었다. 개발자들이 모두 꿈꾼다는 네카라쿠배당토에 모두 지원했었다. 서류부터 탈락한 곳, 코딩테스트에서 떨어진 곳, 면접에서 떨어진 곳 등 다양하다. 10대 때는 무서울 것 없이 탄탄대로였다가, 대학에 진학한 후 나름 많은 실패를 겪어봤다고 생각했다. 그리고 지난 수 년 간 충분히 힘들었다고 생각했다. 청년층이 왜 그렇게 취업에 피눈물을 흘리는지 몸소 느끼게 됐다. 안 그래도 낮았던 자존감이 정말 지하 끝까지 바닥나는 것을 경험할 수 있다. 어느 순간부터는 아무렇지도 않게 됐다. 또 떨어지겠지, 뭐. 나를 원하는 곳은 없어. 내가 생각해도 누가 나를 뽑겠어. 다 포기하면서 기계적으로 다시 지원서를 내고, 간간히 크루를 만나고. 온전히 내 힘으로 한 취업이라고 생각하진 않는다. 누가 운칠기삼이라고 했던가. 취업은 운9기1 정도인 것 같다. 마지막까지 가서 지칠대로 지쳐버린 나를 겨우 살려준 취업이었다. 취준하면서 이런 것도 만들었다고 한다... 건강대부분의 사람들이 신년계획을 세워놓고 실패하는 건 ‘의지’가 부족해서라고 하지만, 내게 가장 부족한 건 ‘건강’이었다. 올해도 역시 건강만큼은 챙기자고 다짐했지만, 세상 일은 정말 뜻대로 되지 않더라… 운동은 정말 꾸준히 했다. 바빠도 좀 사람답게 살아보자고 유튜브 틀어놓고 주 2회씩 근력과 유산소 운동을 했다. 하고나면 개운하긴 했다. 앉아있을 때도 덜 힘든 것 같고? 그런데도 별로 몸이 개운치 않아 병원에 갔고, 병원에서는 런닝을 하라고 했고, 그리하여 처음 나선 20분 런닝에서 기어이 무릎을 다쳤다. 의사선생님이 운동하는 직업이냐고 물었다. 🤦‍♀️ 두 달이 지난 지금도 20분 이상 걸으면 무릎이 엄청 아프다. 다시 병원에 가야겠다… 그리고 모종의 이유로 수술을 받게 됐다. 12월에 받았어야 했는데, 여러 사정으로 1월에 받게 됐다. 정말 예상치도 못한 병이라 참 울적하다. 그보다 더 울적한 건, 연말을 열흘 앞두고 코로나에 걸렸다는 사실이다. 밖에서 놀다 걸린 것도 아니고, 직장 동료에게 옮은 아버지한테 집 안에서 옮아서 걸렸다. 취업하고 고작 이틀 놀았는데, 크리스마스와 연말 제주도 여행과 수많은 친구들과의 약속과 수술까지 모두 취소하게 됐다. 지금은 열흘 간의 치료와 격리기간을 끝내고 조용히 호캉스 중이다. 사실 최악이긴 했다. 워낙 나가서 사람 만나고 노는 것 좋아하는 사람인데, 취업 직후에 크리스마스와 연말까지 혼자 아픈 채로 보낸다니. 게다가 몇 달 간 바쁘디 바빴던 남자친구도 딱 그 기간 동안 회사 전체 휴가였다. 그치만 모든 일에 감사하기로 했다. (확실한지?) 가장 황금같은 시간을 처음으로 혼자 보내면서, 그동안 인간관계에 목맸던 스스로를 돌아봤다. 열흘이 지나고 격리해제된 이후에는 내 두 눈으로 세상을 보고, 두 귀로 길거리의 소리를 듣고, 두 다리로 (아직 무릎은 아프지만..) 걸을 수 있고, 먹고 싶은 것 사먹을 수 있는 환경에 감사하게 됐다. 힘들고 답답하기만 했던 시간, 그 기분들을 두고두고 가져갈 필요는 없으니까. 주어진 오늘과 내일을 어떻게 더 재미있게 살 수 있을지 고민할 시간도 부족하다. 코로나 집콕일기그렇게 코로나 걸려서 열흘 간 갇혀있는 동안 앱을 만들었다. React Native를 한번 해보고 싶어서 간단히 다른 앱을 구상 중이었는데, 간지를 추구하는 개발자답게 “코로나 격리된 동안 열 받아서 혼자 앱 만든 개발자” 가 하고 싶었다. 진짜 어이없다. 열흘간 만들었지만, 사실 그중 사흘은 몸져누워있었기 때문에 사실상 일주일만에 만들었다.(라고 해야 더 간지나 보인다). 그리고 서버는 아직 없다. 앱 배포도 심사 받아야 한다는데, 진짜 귀찮다. 코로나 완치자에게 그럴 여유는 없다. 아냐 입사 전까지 다시 해볼 것. 캡쳐는 피그마지만 진짜 만들었다. 아무도 안 궁금하겠지만 코드는 🍀 여기에서 확인할 수 있다. 그리고 2022년사실 신년계획같은 건 세우지 않는 편이다. 매일같이 내일 당장 불의의 사고로 죽을지도 모른다고 생각하는(..) 극단적인 사고방식의 소유자라, 내일의 계획도 대강만 세워두고 오늘 하루 지금 이 시간이나 정신 똑바로 차리고 살자는 주의다. (하지만 MBTI는 J다.) 그리고 이미 1월 2일이기도 하다. 그리고 “성실”, “부지런함”, “뭔가 이루기” 그런 건 나와 맞지 않는다. 조금 재수없지만, 그런거 다짐하지 않아도 성실하게 살아지는 훌륭한 한국형 주입식 교육의 산물 그 자체다. 작년 계획은 “내려놓기”였다. 너무 열심히 살지 말고, 좀 내려놓기. 그리고 어느 정도 지킨 것 같다. 브랜딩을 하는 친구 회사의 제품에서 올해 나를 표현할 수 있는 형용상 키워드를 골라봤다. 한 개만 고르기엔 아쉬우니까 두 개. “유쾌하다” 와 “단단하다” 를 골랐다. 뭘 이루려는 생각 따위는 없다. 새해 들을 첫 곡으로 우주소녀의 “이루리”같은 건 듣지 않는다. 올해는 처진달팽이의 “말하는 대로”를 들었다. 부정적인 생각과 걱정들로 나를 채우는 건 그만두고, 내 자신을 더욱 사랑할 줄 아는 단단한 사람이 되고 싶다. 올해는 임인년, 호랑이의 해라고 한다. 작년까지 나의 해였는데, 나의 해가 이렇게 지다니. 분하다. 무서운 호랑이를 보고도 드는 생각은, 물려죽으면 끝장이겠구나. 그런 생각만 하는 팍팍한 사회초년생 개발자지만, 그런대로 맘에 든다. 아무튼 호랑이는 조심해야 하니까.","link":"/2021/12/31/retrospective-2021/"},{"title":"우아한 타입스크립트 2부","text":"실전 타입스크립트 코드 작성하기 지난 8월 우아한테크세미나 발표 주제였던 우아한 타입스크립트 영상을 보고 정리한 내용이다. 👉 1부 보러가기 1. Conditional Type 활용하기 Item&lt;T&gt; - T에 따라 달라지는 container 1234567891011interface StringContainer { value: string; format(): string; split(): string[];}interface NumberContainer { value: number; nearestPrime: number; rount(): number;} T가 string이면 StringContainer, 아니면 NumberContainer 123456789type Item1&lt;T&gt; = { id: T, container: T extends string ? StringContainer : NumberContainer};const item1 = Item1&lt;string&gt; = { id: 'aaa', container: null; }; T가 string도 number도 아니면 사용 불가 12345678910111213type Item2&lt;T&gt; = { id: T extends string | number ? T : never; container: T extends string ? StringContainer : T extends number ? NumberContainer : never;}; const item2 = Item2&lt;boolean&gt; = { id: true, // 🚨 Type 'boolean' is not assignable to type 'never' container: null; // 🚨 Type 'null' is not assignable to type 'never'}; ArrayFilter&lt;T&gt; - T 에 들어오는 요소들 중에 Array 만 필터링 1234567type ArrayFilter&lt;T&gt; = T extends any[] ? T : never;type StringsOrNumbers = ArrayFilter&lt;string | number | string | number[]&gt;;// 1. string | number | string[] | number[]// 2. never | never | string[] | number[] -&gt; 여기서 never는 사라짐 // 3. string[] | number[] Table or Dino 123456789101112131415161718interface Table { id: string; chairs: string[];}interface Dino { id: number; legs: number;}interface World { getItem&lt;T extends string | number&gt;(id: T): T extends string ? Table : Dino;}let world: World = null as any;const dino = world.getItem(10);const what = world.getItem(true); // 🚨 Argument of type 'boolean' is not assignable to parameter of type 'string | number' Flatten&lt;T&gt; 1234567891011121314151617181920212223type Flatten&lt;T&gt; = T extends any[] ? T[number] : T extends object ? T[keyof T] : T; // 아마 primitive typeconst numbers = [1, 2, 3];type NumbersArrayFlattened = Flatten&lt;typeof numbers&gt;;// 1. number[]// 2. number const person = { name: 'Zig', age: 25};type SomeObjectFlattened = Flatten&lt;typeof person&gt;;// 1. 'name' | 'age'// 2. T['name' | 'age'] -&gt; string | numberconst isMale = false;type SomeBooleanFlattened = Flatten&lt;typeof isMale&gt;;// false infer 1234type UnpackPromise&lt;T&gt; = T extends Promise&lt;infer K&gt;[] ? K : any;const promises = [Promise.resolve('Zig'), Promise.resolve(25)];type Expected = UnpackPromise&lt;typeof promises&gt;; // string | number 함수의 리턴 타입 알아내기 - MyReturnType 123456789101112131415161718function plus1(seed: number): number { return seed + 1;}type MyReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: any) =&gt; infer R ? R : any; // 컴파일타임의 typeof은 타입스크립트 타입을 반환 type Id = MyReturnType&lt;typeof plus1&gt;;lookupEntity(plus1(10));function lookupEntity(id: Id) { // ...} 👩‍🏫 여기서 제네릭은 ‘함수여야 하는’ 제약사항을 의미한다 내장 conditional types(1) 1234567891011121314151617// type Exclude&lt;T, U&gt; = T extends U ? never : T;type Excluded = Exclude&lt;string | number, string&gt;; // number - diff// type Extract&lt;T, U&gt; = T extends U ? T : never;type Extracted = Extract&lt;string | number, string&gt;; // string - filter// Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; (Mapped Type)type Picked = Pick&lt;{ name: string, age: number }, 'name'&gt;;// 타입이 { name: string }// type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;type Omited = Omit&lt;{ name: string, age: number }, 'name'&gt;;// 타입이 { age: number }// type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;type NonNullabled = NonNullable&lt;string | number | null | undefined&gt;;// 타입이 string | number mapped type - keyof 를 사용하는 타입 헬퍼 내장 conditional types(2) 1234567891011121314type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: any) =&gt; infer R ? R : any; type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends ( ...args: infer P) =&gt; any ? P : never;type MyParameters = Parameters&lt;(name: string, age: number) =&gt; void&gt;; // [name: string, age: number] 내장 conditional types(3) 123456789101112131415161718interface Constructor { new (name: string, age: number): string;}type ConstructorParameters&lt; T extends new (...args: any) =&gt; any&gt; = T extends new (...args: infer P) =&gt; any ? P : never;type MyConstructorParameters = ConstructorParameters&lt;Constructor&gt;;// [name: string, age: number] type InstanceType&lt;T extends new (...args: any) =&gt; any&gt; = T extends new ( ...args: any) =&gt; infer R ? R : any;type MyInstanceType = InstanceType&lt;Constructor&gt;; // string → 👩‍🏫 여기서 제네릭은 new 키워드가 있어야 한다는 제약사항! ⇒ 이런 식으로 내장타입을 찾아가면서 공부해야 한다 Function인 프로퍼티 찾기 1234567891011121314151617181920type FunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? K : never;}[keyof T];type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;type NonFunctionPropertyNames&lt;T&gt; = { [K in keyof T]: T[K] extends Function ? never : K;}[keyof T];type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;interface Person { id: number; name: string; hello(message: string): void;}type T1 = FunctionPropertyNames&lt;Person&gt;; // 타입이 'hello'type T2 = NonFunctionPropertyNames&lt;Person&gt;; // 타입이 'id' | 'name'type T3 = FunctionProperties&lt;Person&gt;; // 타입이 '{ hello: (message: string) =&gt; void; }'type T4 = NonFunctionProperties&lt;Person&gt;; // 타입이 '{ id: number; name: string; }' 2. Overloading을 활용하기 자바스크립트는 오버로딩이 불가능 타입스크립트의 오버로딩 이름은 같지만 시그니처가 다른 형태 타입스크립트의 오버로딩에서 로직 구현은 함수 안에서 (런타임에) 알아서 하게 되므로, 타이핑만 명시한다1234567891011121314function shuffle(value: string): string;function shuffle&lt;T&gt;(value: T[]): T[];function shuffle(value: string | any[]): string | any[] { if (typeof value === 'string') { return value.split('').sort(() =&gt; Math.random() - 0.5).join(''); } return value.sort(() =&gt; Math.random() - 0.5);}shuffle('Hello, Zig!');shuffle(['Hello', 'Zig', 'long', 'time', 'no', 'see']);shuffle([1, 2, 3, 4, 5]); → 함수 호출 시 IDE가 시그니처를 알려줌 이때 위 두 개의 시그니처를 모두 허용할 수 있는 형태로 함수 바디를 구현해야 함 클래스의 메서드 오버로딩123456789101112131415161718192021222324class ExportLibraryModal { public openComponentsToLibrary( libraryId: string, componentIds: string[], ): void; public openComponentsToLibrary(componentIds: string[]): void; public openComponentsToLibrary( libraryIdOrComponentIds: string | string[], componentIds?: string[], ): void { if (typeof libraryIdOrComponentIds === 'string') { if (componentIds !== undefined) { // 첫 번째 시그니처 libraryIdOrComponentIds; componentIds; } } if (componentIds === undefined) { // 첫 번째 시그니처 libraryIdOrComponentIds; } }} 3. readonly, as const를 남발하기 ReadonlyArray&lt;T&gt;와 as const 1234567891011121314151617181920class Layer { id!: string; name!: string; x: number = 0; y: number = 0; width: number = 0; height: number = 0;}const LAYER_DATA_INITIALIZE_INCLUDE_KEYS: ReadonlyArray&lt;keyof Layer&gt; = [ 'x', 'y', 'width', 'height',];const x = LAYER_DATA_INITIALIZE_INCLUDE_KEYS[0];// 'id' | 'name' | 'x' | 'y' | 'width' | 'height'const LAYER_DATA_INITIALIZE_INCLUDE_KEYS = ['id', 'name'] as const;const id = LAYER_DATA_INITIALIZE_INCLUDE_KEYS[0]; // 'id' ReadonlyArray&lt;T&gt; 123456789101112const weekdays: ReadonlyArray&lt;string&gt; = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',];weekdays[0]; // readonly string[]weekdays[0] = 'Fancyday'; // 🚨 Index signature in type 'readonly string[]' only permits reading as const 123456789101112const weekdays = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',] as const;weekdays[0]; // 'Sunday'weekdays[0] = 'Fancyday'; // 🚨 Cannot assign to '0' because it is a read-only property Mapped Types 1234567891011121314interface IPerson { name: string; age: number;}type ReadonlyPerson = Readonly&lt;IPerson&gt;;const person: ReadonlyPerson = Object.freeze&lt;IPerson&gt;({ name: 'Zig', age: 25,});person.name = 'Sun'; // 🚨person.age = 27; // 🚨 타입도 map을 돌면서 하나하나 readonly로 바꿔줄 수 있다 12345678910111213141516171819202122232425interface IPerson { name: string; age: number;}type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null;};type Stringify&lt;T&gt; = { [P in keyof T]: string;};type PartialNullablePerson = Partial&lt;Nullable&lt;Stringify&lt;IPerson&gt;&gt;&gt;; /*type PartialNullablePerson = { name?: string | null | undefined; age?: string | null | undefined;}*/let pnp: PartialNullablePerson;pnp = { name: 'Zig', age: 25 };pnp = { name: 'Zig' };pnp = { name: undefined, age: null }; 내장된 Mapped Types 1234567891011121314151617181920type Partial&lt;T&gt; = { [P in keyof T]?: T[P];};type Required&lt;T&gt; = { [P in keyof T]-?: T[P];};// 💡 -?: 모든 optional을 제거해줌 type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P];};type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P];};type Record&lt;K extends keyof any, T&gt; = { [P in K]: T;}; Readonly&lt;T&gt; 1234567891011121314151617interface Book { title: string; author: string;}interface IRootState { book: { books: Book[]; loading: boolean; error: Error | null; };} type IReadonlyRootState = Readonly&lt;IRootState&gt;;let state1: IReadonlyRootState = {} as IReadonlyRootState;const book1 = state1.book.books[0]; book1.title = 'new'; // 😮 값이 바뀐다! depth가 깊기 때문 → DeepReadonly&lt;T&gt; 를 사용 123456789101112type DeepReadonly&lt;T&gt; = T extends (infer E)[] ? ReadonlyArray&lt;DeepReadonlyObject&lt;E&gt;&gt; : T extends object ? DeepReadonlyObject&lt;T&gt; : T;type DeepReadonlyObject&lt;T&gt; = { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; };type IDeepReadonlyRootState = DeepReadonly&lt;IRootState&gt;;let state2: IDeepReadonlyRootState = {} as IDeepReadonlyRootState;const book2 = state2.book.books[0];book2.title = 'new'; // 🚨 readonly keyword in return type return값이 배열이나 튜플인 경우 12345678910111213function freturn1(): string[] { return ['readonly'];}const fr1 = freturn1();fr1[0] = 'hello'; // 🤔 가능function freturn2(): readonly string[] { return ['readonly'];}const fr2 = freturn2();fr2[0] = 'hello'; // 🚨 4. optional type보단 Union Type을 사용하기 Result1은 optional type r1의 데이터가 있으면 error는 null이고 loading은 false1234567891011121314151617type Result1&lt;T&gt; = { data?: T; error?: Error; loading: boolean;};declare function getResult1(): Result1&lt;string&gt;;const r1 = getResult1();r1.data; // string | undefinedr1.error; // Error | undefinedr1.loading; // booleanif (r1.data) { r1.error; // Error | undefind (😮 data가 있을 때는 error가 있으면 안되는데) r1.loading; // boolean} Result2는 union type in operator type guard를 활용하여 r2를 제한시키기12345678910111213141516type Result2&lt;T&gt; = | { loading: true } | { data: T; loading: false } | { error: Error; loading : false };declare function getResult2(): Result2&lt;string&gt;;const r2 = getResult2();r2.data; // 🚨 Property 'data' does not exist on type '{ loading: true }'r2.error; // 🚨 Property 'error' does not exist on type '{ loading: true }'r2.loading; // booleanif ('data' in r2) { r2.error; // 🚨 r2.loading; // false } Result3은 union type type guard를 활용하여 r3을 명시적으로 제한시키기123456789101112131415161718type Result3&lt;T&gt; = | { type: 'pending'; loading: true } | { type: 'success'; data: T; loading: false } | { type: 'fail'; error: Error; loading : false };declare function getResult3(): Result3&lt;string&gt;;const r3 = getResult3();if (r3.type === 'success') { r3; // { type: 'success'; data: string; loading: false; }} else if (r3.type === 'pending') { r3; // { type: 'pending'; loading: true; }} else if (r3.type === 'fail') { r3; // { type: 'fail', error: Error; loading: false; }} else { // ...} 5. never 활용하기 Toast는 모두 type을 가지고 type은 enum 중 하나를 가지는 경우123456789101112enum ToastType { AFTER_SAVED, AFTER_PUBLISHED, AFTER_RESTORE,}interface Toast { type: ToastType, createdAt: string,}const toasts: Toast[] = [...]; if와 else if로 이루어진 잘못된 추론1234567891011121314151617// toastNodes1 -&gt; (JSX.Element | undefined)[] // 😮 왜 undefined도 있을까? const toastNodes1 = toasts.map((toast) =&gt; { if (toast.type === ToastType.AFTER_SAVED) { return ( // ... ) } else if (toast.type === ToastType.AFTER_PUBLISHED) { return ( // ... ) } else if (toast.type === ToastType.AFTER_RESTORE) { return ( // ... ) }}); → 무조건 else 구문도 넣어야 한다! (그러면 리턴타입이 JSX.Element[]만 나옴) 🤔 새로운 ToastType이 추가된다면?→ 마지막 else에 never를 검사 123456789101112131415const toastNodes2 = toasts.map((toast) =&gt; { if (toast.type === ToastType.AFTER_SAVED) { // ... } else if (toast.type === ToastType.AFTER_PUBLISHED) { // ... } else if (toast.type === ToastType.AFTER_RESTORE) { // ... } else { return neverExpected(toast.type); }});function neverExpected(value: never): never { throw new Error(`Unexpected value: ${value}`);} → switch와 default never를 통한 처리 123456789101112131415161718const toastNodes3 = toasts.map((toast) =&gt; { switch(toast.type) { case ToastType.AFTER_SAVED: return ( // ... ); case ToastType.AFTER_PUBLISHED: return ( // ... ); case ToastType.AFTER_RESTORE: return ( // ... ); default: return neverExpected(toast.type); }}); 정리infer 키워드는 정말 처음이다. 그 누구도 알려주지 않았었는데 유용하게 활용할 수 있을 듯하다. 그동안 두려움의 대상이었던(!) &lt;T extends K&gt;를 비롯한 그 확장 버전 타입들에 대해서도 도전 정신이 불타오른다.🔥 Pick, Omit 등의 유틸리티 타입 뿐 아니라 ReturnType, ParameterType 등 함수에서 뽑아낼 수 있는 타입들의 실제 구현부를 함께 배울 수 있어서 좋았다. 정리하면서 2번째 다시 훑는 중이지만, 일하면서도 다시 여러번 참고해볼 만한 알차고 멋진 발표였다. 👍","link":"/2021/12/19/woowa-typescript-02/"},{"title":"우테코 3주차 기록","text":"우아한테크코스 3주차 페어 프로그래밍 새로운 페어가 매칭되었다. 데일리 미팅 다른 조 크루다. ‘티케’인데, 자꾸 닉네임을 ‘피케’라고 부르게 되어서 (도대체 왤까 😞) 처음에 미안했다. 새로운 것을 시도하기 망설이거나 코드를 적당히 알고만 넘어가는 나와 달리, 페어는 명쾌하게 답을 알 때까지 공부하고, 함께 토론하고, 탐구하는 것을 좋아한다. 처음엔 조금 어색했지만 분명히 배워야 할 자세다. 헤어지기 전까지 페어의 좋은 습관을 내 학습 방법에도 잘 묻혀 놔야겠다. 페어는 자신이 제안하면서도 정확하게는 몰랐던 점을 밤 늦게까지 공부해서 나에게 설명해 준다. 정말 신뢰 가는 동료라고 생각한다. 페어 따라서 코치들을 조금 더 괴롭혀야겠다…고 생각은 드는데, 아직까지 어색하다! 지난 1년 간 많이 소심이가 된 것 같다. 매일매일 (주말에도) 짬짬이 같이 코딩하고, 회고한다. 매일 회고는 사실 쪼금 귀찮았는데, 다음날만 되어도 전날 한 작업과 새롭게 배운 내용을 금방 까먹는 것을 보니 회고가 필요하겠다. 이끌어준 페어에게 감사하다 😊 코치가 말했던 구조도도 페어가 열심히 그려줬다. 아직은 낯설고 어렵지만 차차 발전해 나가겠지? 로수타잡담(?)이 많았는데, 기억 나는 내용 하나. 우테코 10개월 동안 꼭 배웠으면 좋겠는 것은, 누군가 javascript를 물어봤을 때, 쉬지 않고 계속해서 떠들 내용이 있을 만큼 그 언어에 애정이 있었으면 좋겠다고 하셨다.사실 vanilla js를 잘 알기도 전에 react.js를 시작하여 그냥 대충대충 페이지를 찍어내는 데 급급했었는데, 훌륭한 개발자까진 아니더라도 좋은 개발자가 되기 위해서, 그리고 자신 있게 ‘javascript 개발자’라고말하기 위해서는 누구한테나 정말 필요한 자세인 것 같다. 늘 염두에 두어야겠다. 테코톡DOM &amp; BOM 주제의 첫주차 테코톡을 진행헀다. 첫 주자라 긴장되고 떨렸을 텐데, 생각지 못했던 내용들까지 세심하고 꼼꼼하게 준비하여 테코톡 발표를 진행하셨다. 새롭게 알게 되거나, 헷갈렸던 내용 정리! DOM에서 document 객체는 html 파일마다 한 개씩 새로 생성된다. HTMLCollection getElementsByTagName, getElementsByClassName 사용 시 리턴되는 형태다. 문서 내에 순서대로 정렬된 노드의 컬렉션으로, 유사배열이다. HTML 엘리먼트의 children 프로퍼티에 접근하는 것이다. 배열 구조분해나 Array.from()으로 HTMLCollection으로부터 배열을 생성해서 배열 내장 메서드(.map, .forEach 등)를 사용할 수 있다. HTMLCollection은 배열의 인덱스로 접근할 수 있고, 객체의 속성에 접근하듯이 .[속성명]의 방식으로 접근도 가능하다. NodeList element.childNodes 프로퍼티나 document.querySelectorAll 메서드로 반환되는 노드의 모음이다. Node.childNodes의 NodeList는 라이브 콜렉션으로, DOM의 변경사항을 실시간으로 반영한다. 반면 document.querySelectorAll()의 NodeList는 정적 콜렉션으로, DOM이 변경되어도 collection의 내용에는 영향을 주지 않는다. HTMLCollection과 마찬가지로 유사배열이지만, forEach는 기본적으로 사용할 수 있다. Ref https://devsoyoung.github.io/posts/js-htmlcollection-nodelist + 크롬 개발자 도구에서 javascript 성능을 확인하는 방법을 알았다. 😮 신기 자동차 미션 공통 피드백 리뷰어와의 적극적인 토론 및 리액션하기. 이모지도 리액션이다 👀 class와 instance의 의미 생각해보기. ES6에 class가 도입되어 무조건 class를 쓰기보다는, 객체를 생성할 필요가 없는 경우에는 함수를 쓰는 것도 고려해 보자. 단수/복수 네이밍에 유의하자. 인덱스를 통해 찾는 방법은, 추후에 변경될 여지가 많이 있기 때문에 지양해야 한다. 객체의 데이터는 직접 접근하기보다는 요청하자. getter를 활용해도 좋다. 빠른 실패(early return)를 사용하면 코드를 간결하고 직관적으로 작성할 수 있다. 하나의 함수는 한 가지 기능만 수행하도록 하자. validation에서 alert 메시지를 넣는 것은 함수가 2가지 기능을 하게 된다. 특히 isValid 등 is가 붙은 것은 ‘flag 변수’라고 하는데, flag만 하지 않고 alert까지 하는 것은 좋지 않은 패턴이다. filter, map 등 javascript의 chaining methods를 활용하면 코드가 더욱 간결해지고 가독성이 높아진다. 구조 분해 할당을 많이 활용하자! DOM을 가져올 때도 사용할 수 있다1const [thisBtn, thatBtn, otherBtn] = document.getElementsByTagName('button'); 일반 for문 대신 Array method(forEach 등)를 사용하자. for문에는 인덱싱의 조건 등 실수할 수 있는 여지가 들어가기 때문이다. no-prototype-builtins(eslint) - Object.prototype의 builtin으로 제공되는 메서드를 객체에서 직접 호출하지 않도록 하자. 자동차~로또 미션 공통 피드백 페이지에 접속하면 처음 입력해야 하는 input에 autofocus를 두는 것과 같은, 사용자를 고려한 프로그래밍을 하자. 리뷰어의 피드백에서 한 발자국 더 나아가, 스스로 고민해보고 코드를 작성하는 습관을 들이자. 도메인 로직에 포함할 것과, 포함하지 않을 것을 구분하자. getRandomNumber와 같은 순수함수는 다른 객체에서도 쓸 수 있게 분리하거나, 객체에서만 필요한 것인데, this를 사용할 필요가 없다면 static으로 선언하는 방법도 있다. 잠재우기 말고, 결과를 지연시켜 보여주는 것 javascript로 코드 작성 시 단순한 잠재우기를 하는 경우는 거의 없다. 단순히 지연시키는 동작은 큰 의미가 없다. 강아지한테 밥 주고 “1초 기다려!”하는 명령형 코드에는 문제가 있다. 이벤트를 실행할 때마다 계속 하드코딩을 해야 하며, 강아지가 10마리까지 늘어나면 모두 기다리라고 명령해야 하는 셈이다. (즉 sleep 코드만 늘어나게 된다.) 선언형 코드로 작성하자 😮 휴먼 에러를 줄이기 for문에 변수를 선언하고 돌리는 형태는 너무 많은 작업이 필요하다. → 휴먼에러가 될 수 있다 index만을 순회하는 for loop은 거의 사용할 일이 없다 Array의 메소드를 활용하자 함수에 이벤트 행위를 굳이 적을 필요는 없다. click 이벤트에 대한 콜백함수의 네이밍은, handleRestartButtonClick()보다는 handleRestartButton()과 같은 형태로 쓰는 것이 좋다. 다만 on, handle 등의 prefix가 붙는 것은 좋다. 나중에 click을 할 수도, enter를 칠 수도, 모바일은 touch를 할 수도 있다는 점을 고려하자. 📚 배우기javascript의 Object 객체는 자신만의 속성을 갖고 있으며, 다른 것과 식별이 가능해야 한다. 원시값 역시 객체처럼 취급할 수 있다. 일부에서는 자바스크립트는 모든 것이 객체라고도 한다. 원시값은 call by value이지만, 객체는 call by reference다. 즉 객체는 참조값으로 전달되며, 서로 동일한 참조값을 갖고 있을 때 같은 객체라고 볼 수 있다. 객체의 속성을 참조할 때 해당 객체에 속성이 참조되어 있지 않다면 생성자 함수의 prototype 속성에서 찾는다. 모든 객체는 Object()를 상속 받기 때문에, 프로토타입 체이닝을 통해 거슬러 올라간\u001f Object()의 prototype에서도 속성을 찾을\u001c수 없다면 undefined를 반환한다. 함수는 스코프 체인을 통해 변수를 찾는다. 스코프 체인은 코드가 작성된 위치에 따라 생성된다. 객체의 어떤 속성에 접근하려할 때 그 객체 자체 속성 뿐만 아니라 객체의 프로토타입, 그 프로토타입의 프로토타입 등 프로토타입 체인의 종단에 이를 때까지 그 속성을 탐색하며, 그 종점은 null이다. 함수 안에서 사용하는 this 키워드는 함수를 포함한 객체를 참조한다. 이때 this의 값은 함수가 호출되는 컨텍스트에 따라 결정된다. this는 객체 멤버의 컨텍스트가 바뀌는 경우에도 언제나 정확한 값을 사용하게 해준다. 한 번 작성된 함수는 다른 컨텍스트에서 실행되어도 원래의 스코프에 접근할 수 있으며, 이를 이용하여 클로저를 작성할 수 있다. 👉 javascript는 클래스 기반이 아닌, 프로토타입을 가진 객체 기반의 언어👉 프로토타입 - 객체지향 언어가 아닌 javascript가 객체지향과 비슷한 특징들을 가질 수 있게 해준다. DOM object를 가져오기 위해 사용했던 document.querySelector('div')와 같은 코드도, Document 객체의 인스턴스가 가진 메소드를 활용한 것이다.웹페이지가 로딩될 때 Document 인스턴스가 만들어지고, 전체 웹 페이지 구조와 컨텐츠 그리고 URL같은 기능들을 제공하는 document가 호출되는 것이다.그동안 사용해왔던 다른 내장 객체/API(Array, Math 등등)들도 마찬가지! 😮 - Prototype &amp; Mixin ES2015부터 class 키워드를 지원하기 시작했으나, syntactic sugar일 뿐이며 javascript는 여전히 프로토타입 기반의 언어다. javascript에 “메소드”라는건 없다. 하지만 javascript는 객체의 속성으로 함수를 지정할 수 있고 속성 값을 사용하듯 쓸 수 있다. javascript에서 함수는 속성을 가질 수 있다. 모든 함수에는 prototype이라는 특수한 속성이 있다. 1234function doSomething(){}doSomething.prototype.foo = &quot;bar&quot;; // add a property onto the prototypevar doSomeInstancing = new doSomething();console.log(doSomeInstancing); 12doSomeInstancing.prop = &quot;some value&quot;; // add a property onto the objectconsole.log(doSomeInstancing); 12345console.log(doSomeInstancing.foo); // barconsole.log(doSomeInstancing.prop); // some valueconsole.log(doSomething.foo); // undefinedconsole.log(doSomething.prototype.foo); // barconsole.log(doSomething.prop); // undefined javascript 함수는 prototype 프로퍼티를 가지고 있다.new 연산자를 통해 생성한 인스턴스는 __proto__라는 프로퍼티를 갖고 있으며, 이는 constructor의 prototype을 참조한다. 이때__proto__는 생략이 가능하도록 구현되어 있다. 이때 prototype은 객체 인스턴스가 갖고 있는 것이 아니라, Object 즉 객체 그 자체가 갖고 있는 속성이다.즉 doSomething.prototype은 가능하지만, doSomeInstancing.prototype은 불가능하다.여기서 doSomeInstancing은 __proto__를 타고 올라가 doSomething의 foo 속성에 접근할 수 있다.인스턴스의 __proto__는 생략할 수 있기 때문에, doSomeInstancing을 통해 doSomething의 prototype 속성에 접근하려면, 단순하게 그 속성값을 작성해주면 된다. (여기서는 foo)프로토타입 체이닝을 통해 자동으로 거슬러 올라가 찾아주기 때문이다. 😯 이때 prototype에 정의한 모든 것은 모든 인스턴스가 효과적으로 공유한다는 뜻이며, 심지어 프로토타입의 일부를 나중에 변경하다고 해도 이미 생성되어 있는 인스턴스는 필요한 경우 그 변경 사항에 접근할 수 있다. 또한 doSomething의 인스턴스인 doSomeInstancing에서 생성한 속성 prop은 doSomething에서는 찾을 수 없다. 12345678910function Graph() { this.vertexes = []; this.edges = [];}Graph.prototype = { addVertex: function(v){ this.vertexes.push(v); }}; console.log(g)의 실행 결과는 다음과 같다. g는 vertexes 와 edges를 속성으로 가지는 객체이며, g.addVertex()를 실행하면, 프로토타입 체이닝을 통해 Graph의 addVertex()를 호출할 수 있다. ES5에는 Object.create()라는 방식도 도입되었다고 하지만, 여기선 패스!대신 ES6에서 등장한 class를 통해 객체를 생성할 수 있다. Mixin은 javascript에는 없는 클래스 복사 기능을 흉내 낸 것이다. Mixin은 특정 행동을 실행해주는 메서드를 제공하는데 단독으로 쓰이지 않고, 다른 객체에 행동을 더해주는 용도로 사용된다. 123456789101112131415161718192021222324// mixinlet someMixin = { greets() { alert(`Hello ${this.name}`); }, study() { alert(`${this.name} is now studying`); } play() { alert(`${this.name} is playing drum`); }};// create objectclass Person { constructor(name) { this.name = name; }}// copy methodObject.assign(Person.prototype, someMixin);new Person(&quot;Zig&quot;).play(); // Zig is playing drum Refhttps://developer.mdozilla.org/ko/docs/Learn/JavaScript/Objects/Basicshttps://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Object-oriented_JShttps://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chainhttps://ko.javascript.info/mixins - DOM 조작과 reflowDocumentFragment를 사용하여 DOM 조각을 새롭게 생성하는 것이, 기존의 createElement보다 성능이 좋다. append를 하더라도 reflow가 발생하지 않기 때문이다.DocumentFragment는 DOM tree에 영향을 미치지 않는다. (따라서 reflow가 발생할 때에도 document에 영향을 미치지 않는다!) 위 내용을 공부하며 innerText와 innerHTML에 더해 textContent라는 것도 알게 되었다.innerText는 사람이 읽을 수 있는 요소만 가리키며, innerHTML은 말 그대로 html을 가져온다. Node 인터페이스에서 사용되는 textContent는 노드의 모든 자식을 주어진 문자열로 이루어진 하나의 텍스트 노드로 대치한다. Refhttps://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragmenthttps://developer.mozilla.org/ko/docs/Web/API/Node/textContenthttps://gist.github.com/paulirish/5d52fb081b3570c81e3ahttps://csstriggers.com/https://developers.google.com/speed/docs/insights/browser-reflow?csw=1https://johnresig.com/blog/dom-documentfragments/https://medium.com/@maddydeep28/dom-creation-and-manipulation-tips-and-tricks-df4707ede27c - isNaN vs Number.isNaNisNaN은 값이 Number 타입이 아니거나 Number 타입으로 변환될 수 없을 때 true를 리턴한다. (값을 먼저 Number로 형변환한다) 123isNaN = function(value) { Number.isNaN(Number(value));} Number.isNaN은 값이 NaN 타입인지 확인한다. 기존부터 존재한 isNaN의 조금 더 엄격한 버전이다.😯 NaN 값은 산술 연산이 정의되지 않은 결과 또는 표현할 수 없는 결과를 도출하면 생성된다. 123456789isNaN('zigsong') // trueisNaN(NaN) // trueisNaN(undefined) // trueisNaN('zig'/'song') // trueNumber.isNaN('zigsong') // falseNumber.isNaN(NaN) // trueNumber.isNaN(undefined) // falseNumber.isNaN('zig'/'song') // true 따라서 Number.isNaN의 인자에 Number.parseInt 등으로 감싼 NaN 타입을 넣어주면, true를 리턴하게 된다. 1Number.isNaN(Number.parseInt('zigsong')) // true Refhttps://stackoverflow.com/questions/33164725/confusion-between-isnan-and-number-isnan-in-javascripthttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN 기타CustomEvent 새로운 CustomEvent를 생성하고, dispatch를 할 수 있다. model과 view, controller의 역할을 명확히 구분할 수 있는 방법이다. Ref https://developer.mozilla.org/ko/docs/Web/API/CustomEvent/CustomEvent checked type checkbox인 input의 checked T/F값은 $element.checked로 가져올 수 있다. getter, setter class 내부에서 getter를 설정하여 프로퍼티를 가져오는 코드를 명시할 수 있다. #private 2019년에 나온 ES7부터, javascript class에 #(해시) prefix를 붙여 private 메소드 또는 프로퍼티를 선언할 수 있다. form event 처리 html form에서의 click과 enter 모두 submit이라는 이벤트 하나로 묶을 수 있다. 그동안 eventListener에 아무 생각 없이 click만 주구장창 써왔던 나 자신 반성하자😬 html attribute input 태그에 required, min, max 값 등을 넣어 자체적으로 제공되는 validation을 활용할 수 있다. $element.toggleAttribute라는 내장 메소드를 활용하여 해당 DOM 객체의 속성을 넣었다 뺐다할 수 있다. 😮 semantic html div를 남발하지 말고, section 등의 태그가 필요하진 않은지 생각하자. 🤔 생각해보기YAGNI 발음은 마치 ‘야근이’…같지만 신선한 개념이다. ‘You aren’t gonna need it’이란 뜻으로, 프로그래머가 필요하다고 간주할 때까지 기능을 추가하지 않는 것이 좋다는 익스트림 프로그래밍(XP)의 원칙이다. Ref https://ko.wikipedia.org/wiki/YAGNI 디자인 패턴을 사용하는 이유 패턴만을 생각하고 있으면 패턴에 종속되어 버리는 경우가 있다. 이는 패턴을 위해서, 끼워 맞추기 형태로 문제를 해결하는 것이다. 프레임워크나 디자인 패턴보다는, 주어진 문제를 해결하는 것이 중요하다. EX (Extreme Programming) 아무도 유지보수하지 않는 패턴을 작성하는 것을 지양하자. 설레발 주도 개발(Hype Driven Development - HDD)은 당신의 프로젝트에 다양한 방법으로 영향을 끼친다. 레거시를 위한 레거시에 종속되는 경우룰 방지하자. Why you should not modify a JavaScript object prototype built-in Objects prototypes을 변경하지 말자123Array.prototype.insert = function(index, item) { this.splice(index, 0, item)} 라이브러리가 제공하는 자체 메소드와 충돌이 날 위험이 있고, 추후에 위와 같이 customize한 메소드의 동작을 변경해야 할 때 유지보수가 힘들어진다. 필요한 함수는 따로 분리하여, import해서 사용하자 Ref https://flaviocopes.com/javascript-why-not-modify-object-prototype/ 2021 우아한 형제들 경력 개발자 인터뷰Ref https://woowabros.github.io/interview/2021/02/16/2021-interview.html etc 뭔가 html, css를 많이 다룬 한 주였다. 그런 것까지 프론트엔드 개발자가 하나하나 다 뜯어봐야 하나 😞 했었는데, css도 잘하는 백엔드 개발자가 있다면?! 생각이 바뀌었다. FE library가 어느 정도 정비되고 있다. 준비해주신 분들, 관리자를 하겠다고 나선 분들 모두 대단하다. 좋은 정보들을 주고 받기 위해 나도 신경써서 다음 관리자로 지원해봐야겠다. 😄 학습 로그를 작성하는 방법을 배웠다. 또 할 일이 늘어난 것 같아 쪼금 벅차지만 지속적인 공부와 스스로의 발전을 위해서, (그리고 추후의 포트폴리오를 위해서) 필요한 일인 것 같다.지금 진행하고 있는 미션의 모든 단계가 끝나면 작성해 봐야겠다. 지식 산업, 특히 프로그래밍에 끝은 없다. 정해진 기간 내에 결과를 낼 수 있어야 한다. 질이 나쁜 코드라도, 일단은 동작하도록 만드는 것이 중요하다. 리팩토링과 클린 코드는 그 이후에 진행하자.처음에 100% 만족하지 않더라도 일단 동작하는 코드로 데드라인까지 보내고, 그 후에 차차 개선해 나가면 된다. 회고는 감정적인 소통과, 학습(반성)을 통한 개선이 모두 이루어지는 것이 좋다. 또 페어에게 좋은 말만 해주기보다는 좋았던 점, 잘못된 부분이 적절히 섞인다면 서로의 성장에 더욱 도움이 될 것이다. 코치 준이 알려준 4mat 학습선호도 설문을 해봤다. what/why/how/if인가? 4가지로 나뉜다고 하는데, 생각보다 극단적으로 답을 잘 고를 수 있었다 😬 뭐든 극단적인 사람… 내 결과가 궁금하다! 주말에 한 크루가 같이 놀자고 연락을 줬다. 친구 졸업식(..은 아니고 사진 촬영)에 갔다가 노느라고 아쉽게 참여하지 못했지만 😢 담에 약속 잡고 또 놀았으면 좋겠다! 😎 마무리사실 너무너무 정신없고 바쁘게 지나갔던 한 주다. 어째 매주 이럴 것 같지만! 쉴 틈 없이 작업하는 와중에도 토이 프로젝트와 스터디, 친구들을 모두 포기하지 못하는 사람… 😑또 머리하면서 코딩했다. 근데 잠 좀 일찍 자자. 아무튼 유튜브는 전보다 덜 보는 것 같은데, 매일 늦게 자니 얼굴하고 몸이 구려졌다 😬 하루에 당충전도 너무 많이 하고…오래, 멀리 가기 위해서 몸 정신 다 신경 써서 챙겨야 할 듯하다.","link":"/2021/02/20/woowa-week-03/"},{"title":"우테코 4주차 기록","text":"우아한테크코스 4주차 페어 프로그래밍 1단계를 마무리하고 2단계를 진행했다. View를 더욱 세부적으로 나누고 CustomEvent를 적용하여 view와 controller의 역할을 구분하였다. view에서 event가 발생하면 dispatchEvent를 통해 controller에서 기능을 수행하도록 했다. 페어의 리드를 따라 처음 시도해 본 패턴인데, 쓰다보니 익숙해지며 괜찮은 방식이라고 느꼈다. 다만 코치님들의 말씀대로, 설계를 하기 전에 해당 패턴을 왜 사용했는지, 장점은 무엇인지, 만드는 과제에 적합한 패턴인지, 내가 잘 알고 있는지 등에 대해 진지하게 생각해보지 못한 것 같다. 좋아 보여서 시도해보는 것은 좋지만, 왜 쓰는지를 알고 보다 꼼꼼한 검토 후에 설계를 시작하는 것이 좋을 것 같다. 웹 접근성에 대한 고민을 많이 했다. 페어가 aria 태그를 알려주었고, section과 h1 제목 태그 등을 적절한 상황에서 올바르게 작성하는 semantic html 작성에 대한 고민을 시작하게 되었다. 페어가 알려준 WAVE라는 크롬 익스텐션도 꽤나 유용하다! 혼자라면 절대 생각하지 못했을 부분들을 많이 고민하고 알려줘서 고마운 마음이다. cypress가 조금씩 익숙해져가는 것 같다. 필요할 때 사용되는 메소드를 찾는 것이 재미있다. reduce나 addEventListener의 콜백 함수 처리 등, javascript의 기본적인 메서드 사용 방식을 계속해서 헷갈리고 있다는 점을 느꼈다. 오래 작업하다보니 지친 탓일 수도 있지만, 전반적으로 언어에 대한 기본기가 탄탄하지 않은 것 같다. 시간 내서 반드시 차근차근 살펴봐야겠다. 페어와 같이 하다보니 메소드를 controller에 넣을지, utils에 넣을지 고민하는 등 혼자 했으면 그냥 기계적으로 했을 작업들을 시작하기 전에 한 번 더 생각해볼 수 있어서 좋다. 나는 손가락은 빠르지만 사실 머리는 비어 있다! 코딩하는 기계. 품질은 보장 못함 😬 vscode가 우리 파일 dirty하다고 했다 😂 페어는 중간중간에 나를 많이 칭찬해준다! 나는 항상 페어와 다른 크루들 보면서 대단하다고 느끼는데, 부끄럽지 않게 나도 많이 배우고 성장해야겠다. 같이 밤늦게까지 작업하며 헛소리도 가끔 하고 점점 정신을 잃어가는 동료애를 학교 팀플 이후에 처음 느끼고 있는 것 같아 재미있다(?) 내가 아무래도 혼자 코딩하던 습관이 짙게 배어 있어서 페어를 배려하지 못한 부분들이 있었던 것 같다. 어디선가 해답이나 소스를 찾으면 무조건 일단 돌려보고 생각하는 습관 때문에 페어에게 생각할 시간을 충분히 주지 못한 것 같다. 페어와 함께 하는 프로그래밍에서 상대방과 맞춰가려는 연습을 더 해야겠다. 그래도 페어가 조금 굳어있던 자신 때문에 불편했을까봐 먼저 이야기 꺼내주어서 고마웠다! 서로 오해한 채로 있는 것보다 바로바로 자기 생각을 공유하는 게 훨씬 좋은 것 같다. 포수타 알고리즘 공부에 대한 질문이 있었다. 나는 알고리즘 스터디를 오래 진행했음에도 불구 상당히… 약하다 😭 알고리즘이 프로그래밍계의 토익이 되고 있다는 말씀을 해주셨다.알고리즘을 빠삭하게 마스터하지 못하더라도, 다른 프로그래밍 역량들로 자신을 채워나가는 것도 좋은 방법이다. 들어가고자 하는 회사에 나를 뽐낼 수 있도록! 😎 등교와 관련한 간단한 이야기들을 전달하고, 백엔드 강의 때 있었던 캡틴의 훈화 말씀(?)을 공유했다. 페어를 기다리는 것도 연습이다. 이는 학습의 기본이며, 협업에서 필요하다. 컨디션이 좋아 코드를 거침없이 써내려나갈 때 페어를 기다려주지 못한 스스로를 반성하게 되었다. 사실 지금도 많이 벅차고 여유가 없지만, 알아서 여유 시간을 만들면서 번아웃이 오지 않게끔 조절하고 있다. 한번 너무 쎈 번아웃을 맞아서 엉망진창이 된 적이 있기에 주의하고 있다.그래도 어떻게 하면 지치지 않으면서 학습을 지속할 수 있을까?에 대한 캡틴의 이야기에 귀기울여 보았다. 주변에서 정보와 지식들은 물밀듯이 밀려오고, 남들이 하는 것 다 좋아보이고 다 해야될 것 같은 기분이 든다. 무언가에 쫓기고, 조급한 마음. 이에 휘둘리게 되면 번아웃의 지름길로 향하는 것이다.나도 또 그럴 뻔 했다. 우테코에 토이 프로젝트 2개, 스터디까지 하고 있으면서(취미로 드럼과 운동까지 😵) 크루의 스터디 모임에 또 참여해야만 할 것 같은 마음이 들었다.이제 당분간은 일을 벌이지 않기로 다짐했으면서 또 흔들렸다. 그래도 용감하게 포기했다. 정말 용감한 선택이었다. 마침 캡틴의 메시지가 그런 내 선택을 지지해주는 것 같았다. 의식에 매여 있는 당신의 인생 일부를 반복으로 만들어진 습관에 맡긴 뒤, 그렇게 얻은 여유를 정말 중요한 일(기계처럼 반복해선 안 되는 일)에 투입해야 한다. 위 메시지가 엄청 와닿는다. 공부를 습관처럼 해온지 십수년도 넘었는데, 그로 인해 얻은 여유를 내가 좋아하는 드럼과 운동, 뛰어놀기에 쏟고 있다. (물론 코딩도 좋아하는 편이다 🙃) 주변에 휘둘리지 않는 똘끼를 가지자! 나 자신을 믿어보자! 테코톡javascript에서 제일 헷갈리는 개념 중 하나인 this를 주제로 테코톡을 진행했다. 내용도 좋았지만, 발표를 너무 재밌게 잘 준비해주셔서 집중력 있게 들을 수 있었다.발표 자료를 그렇게 센스 있게 만드는 연습을 좀 해야겠다 😵 자바스크립트 엔진은 모든 실행 가능한 코드(전역, 함수, eval 코드 등)를 평가하여 실행 문맥(렉시컬 환경 컴포넌트, 디스 바인딩 컴포넌트 등)을 만든다. 이 실행 문맥에 this에 대한 정보가 담긴다. 전역 실행 문맥에서 함수가 실행되면, 함수 실행 문맥으로 넘어가는 타이밍에서 this가 결정되는 것이다. This Binding 규칙들은 아래와 같다. 1. 기본 Binding 함수를 단독실행하게 되면 this는 기본적으로 전역 객체(window)에 binding된다. 하지만 use strict를 사용하면 binding될 객체가 존재하지 않기 때문에 this는 undefined다. node 환경에서 전역 코드 상 this는 빈 객체가 나온다. 이는 module의 export와 같은 객체다. 2. 암시적 Binding ‘.’이 가리키는 object에 binding된다. 이때 this를 사용한 함수를 callback으로 넘기면 this를 잃어버린다! 😵 callback으로 함수를 넘기면 기존 함수의 참조값만 전달하여 this binding을 실행하지 않기 때문이다. 3. 명시적 Binding call, apply, bind 등의 메서드를 통해서 명시적으로 this binding이 가능하다. call(context, arg1, arg2...) - 인수를 하나하나 전달 apply(context, args) - 인수를 유사배열 형태로 전달 func.bind(context, arg1, arg2)과 같은 형태로 주로 사용해왔다. hard binding - 항상 같은 객체로 binding하는 방법 4. new 키워드로 Binding 생성자 함수로서의 역할 수행 실제 내부 로직은 다음과 같다. 1234567{ obj = {}; this = obj; this.name = 'zig' // obj: { name: 'zig' }; return this;} new binding &gt; 명시적 binding &gt; 암시적 binding &gt; 기본 binding 순서로 binding이 이루어진다. ES6부터 등장한 arrow function을 사용하면 이 어지러운 this binding을 피할 수 있다.arrow function은, 상위 실행 문맥을 유지할 수 있다. 선언될 당시의 상위 스코프에서 이루어진 this binding을 참조하기 때문에 this를 잃어버리지 않을 수 있다! 언제 봐도 헷갈리는 this, 아마 수 개월은 더 싸워봐야 헷갈리지 않고 쓸 수 있을 것 같다.react를 개발하는 동안에는 그냥 arrow function만 썼는데, this에 대한 개념을 명확히 알고 필요에 따라 자신 있게 쓸 수 있는 개발자가 되어야겠다. 👨‍🏫 강의서로의 성장을 위한 피드백 기록하고 공유하자 미션을 회고하고, 설계에 대한 토론을 나누어보자 - 함께 자라기고독한 전문가👤 ? 신뢰가 깨진 상황에서는 어떤 행동이라도 악의적으로 느낄 수 있다 아무리 뛰어난 기술적 실천법을 갖고 있다 하더라도, 사회적 자본과 사회적 기술, 신뢰감 없이는 적용하기 어렵다. 노벨과학상의 산실 벨 연구소의 뛰어난 연구자에 대한 연구에 따르면 뛰어난 연구자는 타인의 도움을 받으며, 타인과 인터랙션에 시간을 더 쏟는다 인간은 컴퓨터가 아니기 때문에, 논리적인 질문을 한다고 해서 논리적인 답변을 하지는 않는다질문 받은 사람은 논리적인 답변을 해야 한다는 압박감 때문에, 가짜 답변을 하는 경우가 많다. 그러면 실수를 점점 더 감추게 되고, 나중에 실수가 커져서 더 좋은 아웃풋이 나올 수 없다페어 프로그래밍 전후로 회고 시간을 가지고, 서로의 감정을 이야기하는 것이 필요하다. 이때 너무 논리에만 빠지지 않게 주의하자 심리적 안정감 - 내 생각이나 의견, 질문, 걱정, 혹은 실수가 드러났을 때 처벌받거나 놀림받지 않을 것이라는 믿음 페어의 발목을 잡고, 때로는 페어를 기다려라. 그것이 함께 성장하기 위한 길! 😎 깜짝 퀴즈틀렸거나 헷갈렸던 문제들 위주로 정리Q. 다음 중 자바스크립트 Array의 내장 메서드가 아닌 것은? 1reverse/ fill/ reduceRight/ has reverse와 fill은 알고 있었고, has는 Set에 있는 것이기 때문에 아닐 것이라고 생각했다.정답이었던 reduceRight은 사실 처음 들어봤다. 😵말 그대로 reduce에 대한 누적을 오른쪽부터 실행한다. Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight Q. 아래 코드 실행 시 console에는 무엇이 찍힐까요? 123456function Pokemon(name) { this.name = name;}const pikachu = Pokemon('pikachu');console.log(pikachu.name); 뭐라 답했는지 기억도 안 난다 😑 암튼 에러가 뜬다. 1Uncaught TypeError: Cannot read property 'name' of undefined new 키워드 없이 실행했기 때문에, pikachu는 undefined가 된다. Q. 아래 코드 실행시 출력되는 값은? 123(function(name) { console.log(`I am ${name}`);})('pikachu'); “I am pikachu”가 출력된다. Q. 아래의 코드를 실행하면 어떻게 출력될까요 12345678910111213const pokemon = { name: '피카츄', owner: { zig: { ownername: 'zig', play() { console.log(`${this.ownername}: ${this.name} 네 차례야`); } } }}pokemon.owner.zig.play(); “zig: undefined 네 차례야”가 출력된다. “zig: 피카츄 네 차례야”를 출력하고 싶다면, 12345678910111213141516const pokemon = { name: '피카츄', getName() { return this.name; }, owner: { zig: { ownername: 'zig', play() { console.log(`${this.ownername}: ${pokemon.getName()} 네 차례야`); } } }}pokemon.owner.zig.play(); 로또 미션 공통 피드백 - 1 다른 크루들의 PR 리뷰에도 참여해보자 DOM 조작 최적화에 대해 끊임없이 고민과 실험을 해보자 JSDOC을 활용하자 tag에 id 대신 data 속성을 사용해보자 class는 스타일을 위한 것이므로 class로 여러 개를 가져와서 조작할 경우 추후 깨지기 쉽다 id는 document에 정말 딱 한 개만! 필요할 때 사용한다 불필요하거나 의미를 알기 어려운 return은 지양하자 객체에의 접근은 일관성 있게 NodeList는 array는 아니지만 기본적으로 forEach를 사용할 수 있다 EOL을 지키자 로또 미션 공통 피드백 - 2 웹 표준을 지켜 html을 수정해보자cf) 많은 사이트들의 제목은 h1 태그를 사용한다. 검색 노출을 늘리기 위한 SEO를 고려한 방식이라고 한다. javascript가 기본적으로 제공하는 API를 잘 활용해보자 validator를 계속 쌓아가면 효율적이다 함수의 네이밍을 명확히 하자 지옥의 분기😵를 피하자 123456789101112// 😵if (count === 6) { rankCount[0]++;} else if (count === 5 &amp;&amp; numbers.has(bonusNumber)) { rankCount[1]++;} else if (count === 5) { rankCount[2]++;} else if (count === 4) { rankCount[3]++;} else if (count === 3) { rankCount[4]++;} Object literal로 작성하는 것도 좋은 방법이다. 이때 key에 undefined 값이 들어올 수도 있으므로 필요에 따라 적절한 디폴트 값을 부여해야 한다. 실수는 예방하는 것이 아니라 관리하는 것이다. 자신이 자주 하게 되는 실수들은 체크리스트를 만들어 잘 관리하자 Refhttps://github.com/validatorjs/validator.jshttps://github.com/ansman/validate.js 📚 배우기Execution Context &amp; Scope &amp; ClosureExecution Context자바스크립트는 함수를 실행할 때, 실행 컨텍스트(execution context)를 생성한다. Scope스코프란 현재 접근할 수 있는 변수들의 범위를 의미한다.ES5까지는 오직 함수에 의해서만 스코프가 생성되었으나, ES6에서부터는 블록에 의해서도 스코프 경계가 발생하게 함으로써 구분이 명확해졌다. 🤔 Scope ChainScope Chain을 따라 스코프를 형성하면서 현재 호출된 함수가 선언될 당시의 Lexical Environment를 참조한다.선언한다는 행위는, 콜 택 상에서 어떤 실행 컨텍스트가 활성화된 상태를 가리킨다. 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문이다. Closure클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는데, 이를 Lexical Scope(정적 스코프)라고 한다. 12345678function init() { const name = &quot;zig&quot;; function displayName() { // inner function인 displayName은 클로저이다. console.log(name); // outer function인 init 함수에 선언된 name을 기억한다. } displayName(); }init(); 아래 코드는 위와 동일하게 작동한다. 12345678910function makeFunc() { const name = &quot;zig&quot;; function displayName() { console.log(name); } return displayName;}var myFunc = makeFunc();myFunc(); 자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성하기 때문에 makeFunc 내부에서 displayName이 리턴될 때 name 변수를 가지고 있다.name은 클로저가 생성된 시점의 유효 범위 내에 있는 지역 변수이며,displayName의 인스턴스는 변수 name이 있는 어휘적 환경에 대한 참조를 유지하기 때문이다. 클로저를 활용하여 프라이빗 메소드를 흉내낼 수도 있다. 이렇게 클로저를 사용하는 것을 모듈 패턴이라고 하는데 ES6부터는 본격적으로 모듈을 지원함으로써 더욱 사용이 간편해졌다.아래는 ES5 환경에서 모듈 패턴을 사용하는 코드이다. 12345678910111213141516const $ = (function($element) { const element = $element; // show, hide가 공유하는 private property function controlDisplay(attr) { // show hide가 공유하는 private method element.style.display = attr; } return { show: function() { controlDisplay(block); }, hide: function() { controlDisplay(none); }, };})(); 그러나 함수 내에서 함수를 불필요하게 작성하는 것은 때로는 코드를 더럽힐 수 있다. 특히 생성자가 호출될 때마다 메서드가 다시 할당되기 때문에, 성능적인 문제도 발생한다.자바스크립트의 prototype을 사용하여 클로저를 다른 방식으로 작성할 수 있다. 12345678910 function Person(name, greet) { this.name = name this.greet = greet } Person.prototype.getName = function() { return this.name; }; Person.prototype.greets = function() { return this.greet;}; 이처럼 클로저는 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하여 상태를 안전하게 변경하고 유지하기 위해 사용할 수 있다. + 클로저는 메모리를 계속 차지하므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리해줄 필요가 있다. Refhttps://developer.mozilla.org/ko/docs/Glossary/Scopehttps://developer.mozilla.org/ko/docs/Web/JavaScript/Closures – Module &amp; State Management모듈은 특정 기능을 하는 하나의 코드 묶음 단위이다. 모듈이 모여 하나의 큰 프로그램이 되며, 모듈은 또 다른 모듈의 일부로서 기능할 수 있다.🤓 자바스크립트 파일들 간에 export, import를 할 수 있는 것은 모듈 덕분! 모듈은 ES6에서부터 지원하기 시작했다. 모듈은 파일 단위의 구성을 기본으로 한다. 하지만 간단한 메서드 형태인 모듈들인 경우 한 개의 파일에서 관리하기도 한다. 모듈의 변수, 함수, 클래스 등은 export 키워드로 노출하고 import로 다른 모듈, 페이지에서 가져와서 사용한다. 모듈은 순환 참조를 할 수 없다. 모듈 시스템은 항상 트리 구조로 맨 위에 처음 실행되는 루트 페이지/모듈이 있으며 한 방향으로만 참조할 수 있다. 모듈의 이름은 중복될 수 없다. 따라서 가져오는(import) 시점에 이름을 재정의해 충돌을 피할 수 있다.1import { View as WonderfulView } from '/wonderfulView.js'; 상태는 어플리케이션의 데이터를 가리키며, 앱의 흐름에서 이 상태를 잘 관리해줘야 한다. 상태 값의 변화를 예측 가능한 범위에서 통제하기 위해서는 일관되게 READ하는 로직과, 최소한의 Write를 하는 로직을 고민해서 설계해야 한다. Refhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Moduleshttps://css-tricks.com/build-a-state-management-system-with-vanilla-javascript/ - 나만의 라이브러리javascript prototype을 이용, 함수를 확장하여 나만의 라이브러리로 사용할 수 있다. 아래는 한 크루의 코드를 참고하여 직접 간단하게 만들어 본 코드 12345678910111213141516171819202122232425262728293031const $ = (() =&gt; { const constructor = function (selector) { this.$element = document.querySelector(selector); } constructor.prototype.method = function () {} constructor.prototype.init = function () { console.log(this.$element); return this; } constructor.prototype.show = function () { this.$element.style.display = 'block'; return this; } constructor.prototype.hide = function () { this.$element.style.display = 'none'; return this; } const instantiate = function (selector) { return new constructor(selector); } return instantiate;})(); 위와 같이 즉시실행함수(IIFE)로 정의하면, 사용 시 new 키워드를 붙이지 않고 사용할 수 있다.또 각 메서드마다 this를 리턴하여 메서드 체이닝이 가능하게끔 만들었다. 123456// someView.jsconst priceInput = $('#price-input');const winningsModal = $('#winnings-modal');priceInput.show().init();winningsModal.hide(); 다른 크루의 pr에 달린 리뷰도 같은 접근법을 사용한다. 1234567891011121314151617181920function $(selector) { const element = document.querySelector(selector) return { show() { element.style.display = 'block' }, hide() { }, get innerHTML() { }, set innerHTML(v) { }, addEventListener(eventName, cb) { } }} 조금 더 노력하면(?) 현재 어플리케이션에서 필요한 validator도 커스텀 라이브러리로 만들어볼 수 있다. Refhttps://velog.io/@mkitigy/DOM-custom-DOM-library-만들기https://github.com/woowacourse/javascript-racingcar/pull/48#discussion_r577554316https://github.com/ansman/validate.js 기타&lt;input type=“reset” /&gt; 모든 폼(form) 요소의 값을 초깃값으로 되돌리는 리셋 버튼 기능을 수행한다. 😮 (몰랐다!) removeEventListeneraddEventListener가 있듯이 특정 시점에 event를 지워주는 removeEventListener도 있다.특정 dom에 이벤트가 처음 딱 한 번만 실행되도록 하기 위해서 넣어봤다가, 이번에는 적절한 방식이 아닌 듯하여 사용하진 않았다. css로 라이언 그리기https://zinee-world.tistory.com/425https://zinee-world.tistory.com/426 git cherry-pick다른 브랜치의 커밋들을 가져올 수 있다. 알고는 있었는데 직접 써본 것은 처음!한 크루의 블로그를 참고하였다.커밋을 하나씩 가져오는 것도 가능하지만, 특정 범위의 커밋을 모조리 가져오는 것도 가능하다. 커밋 a부터 커밋 b까지 가져오고 싶다면 아래와 같이 입력한다. 1git cherry-pick a^..b git rebase vs pullrebase를 했더니 지난 커밋들이 모두 그대로 산 채로 딸려와 PR에 같이 올라갔다 😑. 원상태로 돌아가 upstream을 pull해서 이전 단계의 머지 커밋만 딱 가져오고, 그 이후에 새로운 커밋들만 차곡차곡 쌓아나가 보자 javascript에서는 null도 object콘솔을 찍으면 아래와 같이 나온다! 😮 1console.log(typeof null); // &quot;object&quot; MDN에 따르면 하위호환 유지를 위해 null의 타입이 null이 아니라고 하는데, 무슨 말일까? 🤔 우선 undefined는 데이터 타입이자 값을 나타낸다.const name와 같이 변수를 선언하면 변수에 undefined라는 ‘값’을 할당한다. null은 명시적으로 값이 없음을 나타내기 위해 사용한다.Number 타입의 초기값이 0이고, String 타입의 초기값이 “”이듯 null은 어떤 Object 타입의 값을 할당받을 변수를 초기화해주는 값이다. 🙄 그런데 이게 자바스크립트의 초기 버그라는 의견도 있다. 알 수 없는 자스의 세계 Ref https://webclub.tistory.com/1 javascript는 1급 객체? 🤔프로그래밍 언어에서 type을 전달, 반환 및 할당할 수 있는 경우 해당 type을 1급 객체로 간주한다고 한다. 1급 객체가 되기 위해서는 다음 조건을 충족해야 한다. 변수나 데이터 구조에 담을 수 있다. 파라미터로 전달할 수 있다. 리턴값으로 사용할 수 있다. javascript에서는 const 키워드로 함수를 할당할 수 있으며, 123const funcA = function() { // ... }; method 방식을 이용할 수도 있다. 1234567const student = { name: 'zig', grade: 4, print: function() { console.log(this.name + ': ' + this.grade); }} 함수를 전달할 수도 있으며, 12345function printStudent() { console.log('student working');}$('form').on('submit', printStudent)$('button').on('click', printStudent) 마지막으로 함수를 반환할 수도 있다. 이건 위의 클로저를 참조! 이 모든 것은 javascript의 function은 prototype을 통해 object를 상속 받고 있기 때문이다. 즉, javascript의 function 또한 object라는 점을 이용하여 함수를 각양각색으로 활용할 수 있다.고차함수(HoF, Higher order Function)을 만들 수 있는 것도 장점이다! Refhttps://soeunlee.medium.com/javascript에서-왜-함수가-1급-객체일까요-cc6bd2a9ecachttp://junil-hwang.com/blog/javascript-1급함수/ Array.push 대신 Array.map 사용하기 javascript Array 내장 메서드를 잘 활용하자 👍 aria-role ARIA(Accessible Rich Internet Applications)는, 웹 접근성을 높이기 위한 W3C 명세이다. HTML 요소에 role 또는 aria-* 속성을 추가하여 콘텐츠의 ‘역할(roles), 상태(states), 속성(properties)’ 정보를 보조기기에 제공한다. Ref https://github.com/lezhin/accessibility/tree/master/aria 🤔 생각해보기HOW형 인간 학습심리테스트 검사 결과 HOW/ WHY/ WHAT/ IF 4가지 유형 중 프론트엔드 최고의 지독한 HOW형이 나왔다. 극단적인 파이 모양… 사실 너무나 잘 알고 있었다. 😬지난 한 달 간 나를 거쳐간 두 명의 페어 모두 WHY형이라 왠지 더 미안하다 😭 효율갑에 무조건 빨리빨리, 상처 잘 받지도 않아서 내가 너무 딱딱하게 말하진 않나 늘 생각하고 반성하긴 했는데아무튼 참 오래토록 변하지도 않고 선명한 성격이다. 성격이 스스로 그렇게 맘에 안 들진 않지만, 의식적으로라도 부드러워지도록 노력해야겠다. 익스텐션 구경하기 auto rename tag better Comment bracket pair colorizer code spell checker color highlight(컬러코드를 미리보기) git indicators htmltagwrap indent-rainbow markdown preview Enhanced output colorizer polacode(코드를 이쁘게 캡쳐) Todo Tree version lens wakaTime(코드 짜는 시간을 분석, 메일이 옴) GIPHY(익스텐션x 화면 녹화해주는 프로그램, 움짤로 만들어줌) Bool 변수 이름짓기 is 용법/ 조동사 용법/ has 용법/ 동사원형 용법으로 나눌 수 있다. 동사원형 용법은 3인칭 단수로 쓰는 점에 유의하자. 주어 역할을 하는 인스턴스가 3인칭 단수이기 때문이기도 하며, 스위프트 API 디자인 가이드와의 일관성을 지키기 위해서도 필요하다.Ref https://soojin.ro/blog/naming-boolean-variables POJORef https://masteringjs.io/tutorials/fundamentals/pojo flexbox 가지고 놀기Ref https://d2.naver.com/helloworld/8540176 웹 접근성 진단 도구 NULIRef https://nuli.navercorp.com/education/tools 좋은 코드란?Ref https://jbee.io/etc/what-is-good-code/ wanted events 저명한(!) 프론트엔드 개발자 분들과 어깨를 나란히 하는 우리 코치님도 강연하시는! Ref https://www.wanted.co.kr/events/livetalk20 또 코테 😣 Ref https://www.wanted.co.kr/events/scofe2021 😎 마무리우테코를 시작한지 벌써 한 달이나 지났다. 다음주부터는 백/프론트 격일 등교를 시작한다. 정신이 없는 건지 어쩐지도 모르겠다. 페어와 더욱 솔직한 이야기들을 할 수 있어서 좋다. 홍수같이 쏟아드는 정보들 정신 차리고 따라잡자! 😵","link":"/2021/02/27/woowa-week-04/"},{"title":"우테코 6주차 기록","text":"우아한테크코스 6주차 페어 프로그래밍진득하게 오래했던 3단계 유튜브 미션을 마무리하고 페어 회고를 진행했다. [심바 to 지그] 역시 가장 큰 내용은 무척 재밌었다는 것이었다. 때론 산만하기도 했지만, 페어와 합이 잘 맞았던 것 같다. 하지만 모든 크루들이 그런 것은 아니기 때문에 항상 신경 쓰기! 그렇게 시끄럽게 떠들다보면 다시 자기 할 일로 돌아오지 못해서 케어가 필요한 친구들도 있는데, 나는 내 일을 제어도 잘 해서 그럴 걱정은 없다고 말해줬다. 심바는 왠지 나이 차이 많이 나는 사촌오빠같은 느낌이다 😗 페어도 나도, 앞뒤가 다른 사람이다. 입게으름뱅이. 말로는 열심히 안 한다고, 게으르다고 하지만 사실 누구보다 부지런하고 열심이다 😂 학습 속도도 빠르고, 기억력도 좋다고 했다. 다만 기억력이 관계형은 아닌 것 같다고 🤣 무슨 말인지 알 것 같다. [지그 to 심바] 페어하는 과정 내내 많이 신났어서 텐션을 감추지 못하고 시끄러워져버렸는데 티키타카를 아주 잘 받아주는 고마운 페어였다. 다른 크루들과 놀고 싶어서 여기저기 쏘다니는 나를 잘 데려다 앉혀놓고 코딩을 시켜서 어느 정도 제정신을 유지할 수 있었다. 솔직히 나라면 대충 하고 넘겼을 기능들을 꼼꼼하게 물고 가져와서 같이 고민해볼 수 있었다. CSS에도 관심이 많아서 같이 배울 수 있었다. 실력이 비슷한 것 같고, 설계나 구조 등에 있어서 둘 다 새롭게 배우려는 의지가 커서 함께 처음부터 맨땅에 헤딩하듯 삽질해가면서 작업을 할 수 있었다. 드라이버 네비게이터를 따로 분리하지 않고 정말 동시코딩을 하는 진정한 의미의(?) 페어 프로그래밍이었다 🙃 포수타 갈수록 점점 집중 안하는 포수타 😵 프론트/백 등교일자 변경 건의안은 기각되었다 😭 글쓰기 교육 이번주부터 본격 글쓰기 과제가 시작되었다. 첫 글쓰기 주제는 우테코 한달 회고 🤓 테코톡요즘 아주 흥미롭게 여겨졌던, javascript의 event loop를 주제로 테코톡을 진행했다.3가지만 잘 기억하기! 코드가 쌓이는 call stack(LIFO) 비동기 함수(DOM, AJAX, timeout 등)의 처리를 기다리는 web api web api에서 넘어온 비동기적으로 실행된 콜백함수를 보관하는 callback queue call stack이 비면 callback queue의 동작을 call stack으로 옮겨주는 event loop 👩‍🏫 이 모든 것은 자바스크립트는 call stack이 1개인 single thread 언어이기 때문에 발생한다. https://velog.io/@thms200/Event-Loop-이벤트-루프 👨‍🏫 강의유튜브 미션 공통 피드백 - 1사용성 고려하기모달이 열린 상태에서 dimmed 영역 클릭시 모달이 닫히는 기능이나, 시스템 상으로 에러가 발생했을 때 사용자에게 메시지로 알려주는 등의 기능을 작성할 수 있다.또 사용자의 행동을 예측하거나 분석하여 상황에 맞게끔 코드를 작성하는 습관을 들이자. 객체의 불변성 지키기객체의 불변성을 지켜주지 않으면, 원치 않게 다른 곳에서 데이터가 변경될 수 있는 side effect의 가능성이 있다. 또 데이터의 변경 사항을 추적하기 어려워진다. 그러면 야근 당첨! 😎 원본 객체에 변경이 가해지는 것을 주의하자! input 태그의 사용성input 태그에 사용할 수 있는 속성들을 참고하자. 다른 html 태그들도 많은 기본 속성들을 제공한다! submit 이벤트 핸들러에서 값 찾기 HTMLFormElement.elements['elementName']는 많이 사용하는 방법 중 하나 target.currentTarget으로 이벤트를 바인드한 타겟도 불러올 수 있다. 계층구조를 넘나드는 것은 위험하다. 부모의 조상의 조상까지 거슬러 올라간다면..😵 closest를 사용하자. (다만, 일부 브라우저에서는 지원이 안 된다.) URLSearchParams 브라우저 API URL을 하나의 객체처럼 다루는 방법 아래처럼 사용했다. 1234567891011121314const searchParams = new URLSearchParams({ type: 'video', part: 'snippet', maxResults: VALUE.CLIPS_PER_SCROLL, q: keyword,});if (pageToken) { searchParams.set('pageToken', pageToken);}const requestURL = SEARCH_URL + searchParams;return await httpRequest(requestURL); localStorage 사용 시 고려사항 localStorage의 키값들을 상수로 관리하자. localStorage에 저장하려는 값을 직렬화(JSON.stringify)할 수 없는 경우(undefined, function, Symbol, cyclic object)를 대비해서 가드문을 추가하자. JSON을 다룰 때 순환참조(cyclic object) 문제를 잘 기억하자 localStorage에 값이 없을때 디폴트값을 지정하자. localStorage는 동기식으로 작동하기 때문에 키 하나에 너무 큰 객체나 값을 담지 말자. localStorage의 용량을 고려해야 한다. array보다는 key값을 넣어서 object로 저장한다면 탐색 시간이 줄어들 수 있다. - 유튜브 미션 공통 피드백 - 2srcdoc&lt;iframe&gt;에 srcdoc 속성을 사용해보자. &lt;iframe&gt; 태그의 srcdoc 속성은 &lt;iframe&gt; 요소에 보일 웹 페이지의 HTML 코드를 명시한다. (src보다 우선됨) http request API와 브라우저 API 호출 12345fetch(url).then(response =&gt; { if (!response.ok) { alert('잘못된 요청입니다.'); // 브라우저 API }}) http request api 안에서 바로 브라우저 api를 호출하지 말자. api는 api의 역할만 해야 하는데, 에러 화면에 대한 처리 등은 못하고 무조건 alert만 하게 되는 문제가 발생한다.😮 코드의 재사용성을 고민하자! 초기화와 생성자 class 내에 constructor가 없고 init만 있는 것은 조금 어색할 수도 있다. 생성자 내에서 init 메소드를 호출하는 등의 방식으로 변경하거나, 별도의 초기화 전용 함수도 고려해보자. try-catch try-catch 문에는 finally 를 쓰자! || 연산자로 default value를 리턴하는 방식도 좋다. 함수 파라미터의 기본값 함수의 인자에 기본값을 반드시 줘야하는 컨벤션도 있을 것이고, try-catch를 사용해야할 수도 있다. 내가 만든 함수를 사용하는 사람이 실수한다면, 그 실수할 여지를 준 사람의 잘못이다. querySelector의 의미 querySelector를 사용하면 인자에 div &gt; .className과 같은 방식으로 nested된 요소를 선택할 수 있다. getElementsByClassName으로는 불가하다. data-XXX 로 관리할 데이터에 대한 고민 사실 DOM에는 data- 없어도 아무 이름이나 주입이 가능하다. 즉 data-video-id=&quot;XXX&quot; 대신 video-id=&quot;XXX&quot;도 가능하다. 😮 앱의 ‘상태’를 DOM에 위임하는 것은, 나중에 상태가 바뀔 때 위험 디자인 패턴 주화입마라는 말을 처음 들어봤다. 무협지에서 쓰는 말이라고 하는데, 심리적인 원인 등으로 인해 몸속의 기가 뒤틀려 통제할 수 없는 상태를 가리킨다고 한다. 나와 크루들의 현 상황에 적절한 표현인 것 같기도 하다 🤣 일단 스스로 사고할 수 있는 힘을 기르자. 정해진 MVC 패턴에 너무 고통 받지 말고 가이드라인 없이 많은 것들을 시도해 보자. 그리고 프로젝트에 맞는 패턴들을 생각해서 활용하자. MVC 패턴을 정해놓고 쓰지는 말자는 뜻! - 자동차 경주게임 셀프 코드 리뷰부끄럽긴 하지만, 아주 좋은 기회였다. 분명히 한 달 뒤에 보면 또 부끄럽겠지 😂셀프 리뷰를 마치고 느낀 점은 크게 두 가지. 리뷰어님의 코멘트 하나하나를 그저 수정하기에 급급하기보다는, 어떤 부분을 지적하거나 수정을 요청하셨는지를 조금 더 시간을 가지고 고민하고 직접 찾아보는 시간을 가져야겠다. 다른 크루들의 PR을 많이 보지 않았다면 수정사항을 찾기 어려웠을 것 같은데, 매주 강의를 비롯하여 크루들의 PR에서도 많이 배울 수 있는 만큼 미션 완료 후 다양한 방식으로 다시 코드를 검토하고 시도해봐야겠다. - loading &amp; Skeleton UI여태까지 spinner가 좋은 줄 알고 그것만 사용했는데, 다양한 서비스 특히 무한 스크롤이 발생하는 페이스북이나 유튜브 등에서는 생각해 보면 skeleton UI를 이용하여 사용자가 콘텐츠 로드를 기다릴 수 있게끔 만들어 놓았따.이러한 loading UI를 사용하는 이유는, UX적인 관점에서 사용자는 콘텐츠가 페이지에 로드되는 동안 계속 참여해야 이탈률이 낮아지기 때문이다. 기존의 빙글빙글 돌아가기만 하는 spinner보다는, 실제 로드될 컨텐츠의 모양과 유사한skeleton UI를 사용하면 사용자들이 컨텐츠가 곧 로드될 것이라고 기대하여 사이트에 머물게 된다. 즉 사용자가 콘텐츠 로드하는 시간동안 목표로 향해 나아가고 있다는 것을 알려준다. Refhttps://www.smashingmagazine.com/2020/04/skeleton-screens-react/https://blog.logrocket.com/improve-ux-in-react-apps-by-showing-skeleton-ui/ - lazy loadinglazy loading은 가능한 한 길게 미루어 웹페이지에서 보여줄 콘텐츠들이 실제로 화면에 보일 때까지 미룬 후 로딩하는 기술이다.고화질의 사진이나 유튜브의 iframe과 같은 무거운 컨텐츠들을 로드할 때, 한 번에 모든 것을 로드할 때까지 기다린다면 사용자 경험이 좋지 못할 것이다.또한 lazy loading은 웹 성능과 디바이스 내 리소스 활용도 증가, 그리고 연관된 비용을 줄이는 데 도움을 줄 수 있다. lazy loading을 구현하는 방법 중 하나는 이미지 로딩을 사전에 막는 것이다.일반적으로 이미지는 src 속성을 이용하여 이미지를 로드한다. 그런데 이 방식은 HTML 내 모든 img 태그가 src 속성을 가지기만 한다면, 이미지를 무조건 로드한다는 치명적인 단점이 있다.그래서 src 속성 대신 다른 속성에 이미지 URL을 넣는 방식으로 lazy loading을 이용할 수 있다.예를 들어 태그에 data-src라는 속성에 이미지 URL을 지정한다면, 초기에 html 태그가 웹페이지에 그려질 때는 이미지가 로드되지 않는다. 12&lt;img data-src=&quot;https://ik.imagekit.io/demo/default-image.jpg&quot; /&gt; 하지만 이렇게만 작성하면 실제 이미지가 로드되지 않기 때문에 해당 이미지를 언제 로딩할 것인지 알려줘야 한다.이를 위해서 해당 이미지(현재는 placeholder 상태)가 뷰포트에 들어왔는지(사용자가 보는 페이지에 들어왔는지) 확인해야 한다. javacript의 scroll, resize, orientationChange(디바이스 화면 방향 변경을 감지) 이벤트나 IntersectionObserver API를 이용하여이미지가 로딩될 시점을 설정할 수 있다. Native Lazy Loading최신 브라우저에는 아래처럼 img나 iframe에 loading=&quot;lazy&quot; 속성을 넣어, 뷰포트에 해당 컨텐츠가 보일 때 loading시켜줄 수 있다. 12&lt;img src=&quot;image.jpg&quot; alt=&quot;...&quot; loading=&quot;lazy&quot;&gt;&lt;iframe src=&quot;video-player.html&quot; title=&quot;...&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt; Refhttps://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_APIhttps://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loadinghttps://helloinyong.tistory.com/297 - debounce, throttlescroll 이벤트와 같이 약간의 동작에도 addEventListener에서 실행되는 콜백 함수가 계속해서 호출되는 문제를 막기 위해 debounce와 throttle을 사용한다. debounce이벤트를 그룹화하여 특정 시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술이다. 즉, 순차적 호출을 하나로 ‘그룹화’한다. 그래서 연속적으로 호출되는 함수 중 마지막 함수(또는 제일 처음)만 호출할 수 있다. throttlethrottle 이벤트를 일정한 주기마다 발생하도록 하는 기술이다. throttle이 걸린 이벤트는 설정한 시간 동안 최대 한 번만 발생하게 된다. 즉 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 해 준다. 미션에서는 아래와 같이 throttle을 사용하여 무한 스크롤 이벤트 구현 과정에 지연을 발생시켰다. 12345678910111213export default function throttle(callback, delay) { let ticking; return function () { if (ticking) return; ticking = setTimeout(() =&gt; { ticking = null; callback.apply(this, arguments); }, delay); };} 🤓 debounce는 이벤트가 끝날 시점에 한 번, throttle은 정해진 시간 주기마다 한 번! Ref https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor/Throttling - CSS: Grid Layoutgrid는 부모-자식, 그리고 column-row의 2차원 관계만 신경 쓰면 어렵지 않게 사용할 수 있다! 12345.wrapper { display: grid; grid-template-columns: 200px 200px 200px; grid-template-rows: 50px 50px;} css는 항상 내용이 방대하기 때문에 링크로 대체 🙄 Refhttps://studiomeal.com/archives/533https://code.tutsplus.com/ko/tutorials/introduction-to-css-grid-layout-with-examples--cms-25392 📚 배우기DOMContentLoadedDOMContentLoaded 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생한다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다. DOM Element가 그려지기 전에 자바스크립트에서 DOM에 접근했을때에 오류가 발생하거나, 자바스크립트를 파싱하고 실행하는 동안 다른 작업들이 블로킹 상태가 되기 때문에일반적으로 자바스크립트 파일을 body 태그 끝에서 부르는 이유와도 관련이 있다. 123456const App = () =&gt; { init() { ... }}window.addEventListener('DOMContentLoaded', App); Ref https://developer.mozilla.org/ko/docs/Web/API/Window/DOMContentLoaded_event vanilla js로 상태관리 구축하기 모든 구독(subscribe)을 돌며 해당 페이로드로 콜백을 발생시키는 Pub/Sub 패턴 중심 객체인 store 만들기 store 객체가 모든 변화를 추적하기 위해 위해 Proxy 사용 proxy는 객체가 데이터를 요청할 때마다 모니터링 get 트랩을 추가하면 객체가 데이터를 요청할 때마다 모니터링 set 트랩으로 객체에 대한 변경을 감시 기초 컴포넌트와, 이를 상속 받는 각 컴포넌트들을 구현 Ref https://devtimothy.tistory.com/86 cyclic objectJSON에서 객체 참조를 할 때 발생한다. (이때 JSON.stringfiy는 실패하므로, localStorage의 값을 관리할 때 주의할 것! 😮) 12const circularReference = { otherData: 123 };circularReference.myself = circularReference; Ref https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value 객체 리터럴 프로퍼티123456789101112131415161718192021222324const BREAD = { CROISSANT: 'croissant', BAGUETTE: 'baguette'}const TASTE = { // []로 object의 key 접근 [BREAD.CROISSANT]: 'great'}console.log(TASTE) // { croissant: 'great' }; ``` 위와 같이 한 객체의 프로퍼티를 다른 객체의 key로 사용할 때 대괄호([])를 사용해야 하는 이유를 몰라서 헤맸었다. 알고 보니 별 건 아니었음 🙄 JavaScript 객체의 프로퍼티 키는 동적으로 생성할 수 있는데(=computed property), ES5에서는 프로퍼티 키를 동적으로 생성하려면 객체 리터럴 외부에서 대괄호([]) 표기법을 사용해야 한다. ```javascriptconst prefix = 'intro';const langs = [html, css, javascript];var obj = {};obj[prefix + '-' + langs[0]] = 'HTML';obj[prefix + '-' + langs[1]] = 'CSS';obj[prefix + '-' + langs[2]] = 'JAVASCRIPT'; ES6에서는 객체 리터럴 내부에서도 프로퍼티 키를 동적으로 생성할 수 있다. 123456const obj = { [prefix + '-' + langs[0]]: 'HTML', [prefix + '-' + langs[1]]: 'CSS', [prefix + '-' + langs[2]]:'JAVASCRIPT',} Ref https://poiemaweb.com/es6-enhanced-object-property observer pattern이번 미션을 수행하면서 적용했던 observer pattern 🤓 앱의 state를 담아두는 Store를 만들고, Store의 값을 받아와야 하는 observer(미션에서는 controller)들은 Store를 구독(register 또는 subscribe)한다. Store의 값이 변하면 Store에 register된 observer들에게 상태변화를 notify하고 상태 변화를 감지한 observer들에서 업데이트된 Store의 값을 가지고 동작을 수행한다. Ref https://medium.com/@yeon22/design-pattern-observer-pattern-이란-ef4b74303359 event delegation기존 DOM에 있는 element가 아닌, 동적으로 생성된 새로운 element에도 event를 attach하기 위해서는 그때그때 loop를 돌며 addEventListener를 달아주는 방법도 있지만,element의 상위 DOM에 event를 위임하여 해당 DOM의 내부에 새로 생성될 element들에 event를 붙여줄 수 있다. 이를 event delegation(이벤트 위임)이라고 한다. 그러나 아래 코드에서도 볼 수 있듯, 상위 DOM에서 이벤트가 발생할 때 해당 요소가 우리가 찾는 요소인지를 파악하기 위해 event의 target을 한 번 확인해줘야 하는 문제가 발생한다.이때문에 event delegation이 기존의 모든 새로운 element에 addEventListener를 붙여주는 것보다 성능이 좋지 않다고 생각할 수 있다. 1234document.addEventListener('click', function (event) { if (!event.target.matches('.sandwich')) return; console.log(event.target);}, false); 하지만 event delegation을 사용하는 것이 성능이 더욱 좋다. event listener를 만들 때마다 브라우저의 메모리를 사용하게 된다. 여러 개의 이벤트를 다는 것보다, 하나의 이벤트를 생성해 놓고 이를 추적하는 것이 훨씬 효율적이다. 만약 한 개의 element에만 event를 달고자 한다면 직접 다는 것이 좋다. 그러나 여러 개의 element에 event를 달고자 한다면, event delegation을 사용하는 것이 바람직하다 🤓 Refhttps://gomakethings.com/why-is-javascript-event-delegation-better-than-attaching-events-to-each-element/ encodeURIComponentencodeURIComponent() 함수는 URI의 특정한 문자를 UTF-8로 인코딩해 이스케이프 문자로 나타낸다. encodeURI와는 인코딩 대상과 방식에 차이가 있다. 12345678const set1 = &quot;;,/?:@&amp;=+$&quot;; // Reserved Charactersconst set2 = &quot;ABC abc 123&quot;; // Alphanumeric Characters + Spaceconsole.log(encodeURI(set1)); // ;,/?:@&amp;=+$console.log(encodeURI(set2)); // ABC%20abc%20123 (the space gets encoded as %20)console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24console.log(encodeURIComponent(set2)); // ABC%20abc%20123 (the space gets encoded as %20) Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent 기타만다오, 우아한형제들 웹 프론트엔드 신입 개발자 파일럿 프로젝트 개발기https://woowabros.github.io/woowabros/2021/03/08/mandao.html API key 서버에서 가져오기한 크루가 모두를 위해 만들었다. netlify로 배포할 수 있다. 대단쓰 😮https://github.com/bigsaigon333/hide-api-key-with-serverless-functions CypressWrapper 사용하기https://github.com/woowacourse/javascript-racingcar/pull/20#discussion_r574992460 코드 의존성을 파악해주는 도구https://github.com/sverweij/dependency-cruiser 우아한형제들 개발자 채용https://www.youtube.com/watch?v=vcL81FAYgys&amp;feature=youtu.be 프론트 캡틴이 등장하는 우아한형제들 면접https://www.youtube.com/watch?v=JBS3H3PzI58&amp;feature=youtu.be 🤔 생각해보기디자인 패턴은 언제 공부하는 게 좋을까? 🤔많은 크루들이 디자인 패턴 때문에 고민하는 것을 보고, 캡틴이 보내준 메시지결론은, 일단 패턴 신경쓰지 말고 개발을 시작하자!패턴에는 정해진 답도 없고, 처음부터 하나의 패턴만 고집하는 것은 좋지 않다.https://okky.kr/article/133477 😎 마무리무야-호이제는 바쁜지도 모르겠다. 학교도 개강해 버렸다 😵 그리고 다른 사이드 프로젝트들은 결국 던져졌다. 코치님께 뭐 질문하려다가 한 시간 면담을 해버렸다. 지금처럼 즐기자! 🤓","link":"/2021/03/13/woowa-week-06/"},{"title":"우테코 7주차 기록","text":"우아한테크코스 7주차 페어 프로그래밍 1단계 마지막 페어는 서니! 서로의 대학 동기가 될 뻔한 아주 꼬여버린 재밌는 스토리가 있었다. 페어는 집중력과 몰입력이 대단하다. 나는 산만하다. 민폐 끼치지 않도록 조심 또 조심… 페어는 NFP고 나는 STJ인데, 서로 성격이 반대다. 나는 구질구질하고, 페어는 쿨하다. 이중전공으로 CS를 배워서 그런지 확실히 내가 생각지 못했던 성능 상의 부분들, 쓰레드 문제(모름)를 잘 알고 있는 것 같다. 멋있었다! 또 css 변태다. tab을 이용했을 시 웹 접근성을 고려하는 모습이 멋져서 반해버렸다. 조금 느린 내가 계속 똑같은 내용 물어보고, 다시 짚어가면서 설명하는 동안에도 차분히 기다려 주면서 하나하나 친절하게 설명해주는 고마운 친구다. 머리에 과부하 걸린 내가 이리저리 돌아다니는 동안에도 페어는 이 사람 저 사람 찾아다니며 막히는 부분들을 해결하고 있다. 왠지 미안하다 😵 20분씩 알람 맞춰놓고 하니까 타임어택 기분도 들고 재미있다! 페어는 밥을 잘 안 먹는 것 같다 😂 내가 밥 먹고 산책하고 오는 동안에도 혼자 공부, 아침에 등교하면서도 혼자 공부, 저녁엔 과외까지 간다. (운동 틈틈이 하고, 밥 잘 먹고, 아프지 않았으면 좋겠다!) 로수타충격적이게도 하나도 듣지 못했다. 하지만 크루들과 잘 놀았으니 더욱 만족스럽다 😎 원래 선생님 말씀 안 듣고 친구들과 수다 떠는 게 더 오래 기억에 남는 법이라며… 아, 스위치를 달라고 들어온 아드님이 너무나 귀여웠다 🤓 테코톡이번 주 주제는 이름만 들어도 어려운 Scope &amp; Closure😵 개인적으로 여러번 정리해봤기 때문에 PASS 👨‍🏫 강의유튜브 미션 공통 피드백 - 3CSS 변태들 다크모드, snackbar 효과, 버튼의 hover event 등 다들 어디서 그렇게 시간이 나는지 대단하게 구현해 놓은 멋진 크루들 Cache API 호출 결과를 cache에 저장해 두고 다음에 다시 사용하게끔 만든다. 물론 정말 만들어진 cache를 이용하는 것은 아니고, class를 커스터마이징하여 만들었다. WeakMap을 이용하여 cache 기능을 구현한 크루들도 있었다. Ref 크루의 PR 브라우저 기능 커스터마이징 alert, confirm 등 브라우저에서 기본으로 제공하는 창들을 커스터마이징한 modal로 만들어 보자. 훨씬 더 예쁘고 와닿는 웹사이트 탄생! 얕은 복사 array.filter는 사본을 반환해주기 때문에 원본 배열에 지장이 가지 않는다. [...someArr].filter로 하지 않고 someArr.filter로 사용해도 문제 없다. 삼항 연산자와 값식문 123456789101112let isWatched; // bool type variablelet videoWatchedCount;// 1번function setVideoWatchedCount() { isWatching ? videoWatchedCount -= 1 : videoWatchedCount += 1;}// 2번function setVideoWatchedCount() { isWatching ? (videoWatchedCount -= 1) : (videoWatchedCount += 1);} 위의 코드에서 1번은 실행되지 않을 것이고, 2번만 의도대로 작동할 것이다 JavaScript ES6에서 괄호()의 의미는 ‘즉시 실행’이다. 삼항연산자를 사용할 때, 내용에 ‘값’을 할당하는 것이 아닌 ‘문’을 바로 쓰는 것이 좋을까? 🤔 **값(value)**이란 프로그램이 조작할 수 있는 표현으로, 문자열, 문자, 숫자 등 어떤 데이터 형식도 가질 수 있다. 12343 // 숫자 타입의 값 'zig' // 문자타입의 값null // 빈 값true // '참'을 의미하는 값 **식(expression)**이란 값을 결정짓기 위해 평가될 수 있는 구문으로, 상수, 변수, 함수, 연산자들의 조합으로 이루어진다.‘식’은 평가를 통해 또다른 ‘값’을 생성해내지만, 어떠한 사이드 이펙트를 발생시키지는 않는다. 1232 + 3 // 5로 평가되는 연산식 4 ≠ 4 // false라는 값으로 평가되는 관계식 y + 6 // 변수도 값으로 평가되므로 역시 식 **문(statement)**은 수행할 액션의 구문 단위로, 데이터에 어떤 액션을 취할 것인지를 결정한다. 하지만 값을 만들지는 않는다.세미콜론을 만나면 ‘문’이라고 할 수 있다. 123456789const a = 1; // 선언문b = a + 5; // 할당문function play(){} // 함수 선언문play(car); // 함수 호출return; // 리턴 호출for (let i = 0; i &lt; limit; i++) // 반복문if (x &gt; 5) // 조건문 Refhttps://365kim.tistory.com/85https://www.bsidesoft.com/4074https://www.bsidesoft.com/760 SPA🙋‍♀️ SPA, Single Page Application(싱글 페이지 어플리케이션)이요! 라고 자신만만하게 외칠 수 있지만… 정작 뭐가 뭔지는 전혀 모르고 써왔다 🤦‍♀️ 전통적인 웹은 여러 페이지로 구성되어, 페이지를 리로딩할 때마다 서버로부터 모든 리소스를 다시 받아 렌더링을 했다. 그러나 웹에서 보여주는 정보가 많아지면서, 전통적인 방식은 당연히 성능상으로 뒤처질 수밖에 없었다. 이를 해소하기 위해 뷰 렌더링을 브라우저 단에서만 하는 방식이 도입되었고,이를 적용시킨 것이 React와 같은 웹 프레임워크! (사실 React는 프레임워크가 아닌 라이브러리지만) SSR, 서버-사이드 렌더링은 서버에서 사용자에게 보여줄 페이지를 모두 구성하여 보내주는 방식이다.모든 데이터가 매핑된 페이지를 클라이언트에 빠르게 보여줄 수 있으며, SEO(검색 엔진 최적화)에도 유리하다. 😮 왜 SEO에 적합할까?- HTML에 모든 컨텐츠가 저장되어 있기 때문이다! CSR, 클라이언트-사이드 렌더링은 서버에서 최초 한번만 전체 페이지를 로딩하여 보내준다.서버는 요청한 API에 대해 JSON data로 응답하고, 클라이언트 단에서는 JavaScript가 html을 그려준다. CSR 방식에도 단점은 존재한다. 우선 JavaScript를 실행하지 않는 일반 크롤러에선 페이지의 정보를 제대로 받아가지 못할 수 있어, 검색엔진에서 페이지가 검색결과에서 잘 나타나지 않을 수도 있다.또 JavaScript가 실행될 때까지 페이지가 비어있기 때문에, 자바스크립트 파일이 아직 캐싱되지 않은 사용자는 아주 짧은 시간동안 빈 페이지가 나타날 수 있다. Refhttps://velog.io/@ksh4820/SPA-CSR과-SSR-SEOhttps://d2.naver.com/helloworld/7804182 Routing어플리케이션에서 routing은 어떤 화면(view)에서 다른 화면으로 전환하는 내비게이션을 관리하기 위한 기능을 의미한다. 브라우저가 화면을 전환하는 경우는 다음과 같다. 브라우저의 주소창에 URL을 입력하면 해당 페이지로 이동한다. 웹페이지의 링크를 클릭하면 해당 페이지로 이동한다. 브라우저의 뒤로 가기 또는 앞으로 가기 버튼을 클릭하면 사용자가 방문한 웹페이지의 기록(history)의 뒤 또는 앞으로 이동한다. 전통적인 link 방식 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;about.html&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;contact.html&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;a href&gt;를 클릭하면 href의 리소스가 url의 path에 추가되고 서버에 해당 리소스를 요청한다. 이때 서버는 html로 화면을 표시하는데 필요한 완전한 리소스를 클라이언트에 응답한다. 이를 서버 렌더링이라 한다. 브라우저는 서버가 응답한 html을 수신하고 렌더링한다. 이 과정에서 새로고침이 발생한다. AJAX전통적인 링크 이동 방식은 페이지를 이동할 때마다 전체 HTML과 CSS, JavaScript를 매번 다운로드해야 하므로 속도 저하의 요인이 된다. 이를 보완하기 위해 등장한 것이 AJAX(Asynchronous JavaScript and XML)이다. AJAX는 JavaScript를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 최초에 서버로부터 웹페이지가 반환되면 그 이후에는 데이터를 주고받으며 화면을 갱신한다. 12345678910111213141516const root = document.querySelector(&quot;.container&quot;);const navigation = document.getElementById(&quot;navigation&quot;);const routes = { home: &quot;/data/home.json&quot;, about: &quot;/data/about.json&quot;, contact: &quot;/data/abocontactut.html&quot;,};const render = async (id) =&gt; { const url = routes[id]; const res = await fetch(url); const { title, content } = await res.json(); root.innerHTML = `&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`;};... &lt;a&gt; 태그에 href 속성 대신 AJAX을 사용하여 서버에 필요한 리소스를 요청(fetch)한 후 응답받은 데이터를 이용하여 JavaScript로 html을 그려낸다. 이를 통해 불필요한 리소스 중복 요청을 방지할 수 있으며, 페이지 전체를 전부 로드하는 대신 갱신이 필요한 일부만 로드하므로 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다. 하지만 이 방식은 URL을 변경시키지 않으므로 해당 페이지의 주소가 변경되지 않는다. 이는 브라우저의 뒤로가기, 앞으로가기 등의 history를 관리할 수 없음을 의미한다. 또한 주소가 변경되지 않기에 새로고침을 클릭하면 언제나 첫페이지가 다시 로딩된다. 따라서 이 또한 SEO에 취약한 구조이다. HashHash는 AJAX에서 history를 관리할 수 있게끔 보완한 방식으로, URI의 anchor를 사용한다. 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; hash는 리소스를 새로 요청하는 것이 아니라, 앵커(anchor)로 웹페이지 내부를 이동한다. 그래서 hash 방식은 서버에 새로운 요청을 보내지 않고, 갱신되지 않지만 페이지마다 고유의 논리적 URL이 존재하므로 history를 관리할 수 있다.uri의 hash가 변경되면 hashchange 이벤트가 발생하여 hash의 변경을 감지한다. 이때 추가적인 AJAX 요청을 할 수 있다. hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다. 일반적으로 hash 방식을 사용할 때 #!을 사용하기도 하는데 이를 해시뱅(Hash-bang)이라고 부른다. 또 다른 문제는 SEO 이슈이다. 검색엔진은 웹사이트의 콘텐츠를 수집하기 위해 보통 JavaScript를 실행시키지 않기 때문에 hash 방식으로 만들어진 사이트의 콘텐츠를 수집하기 어렵다. PJAX이를 보완한 방식이 HTML5의 Histroy API인 pushState와 popstate 이벤트를 사용한 PJAX 방식이다. 1234567&lt;nav&gt; &lt;ul id=&quot;navigation&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/Contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;a&gt; 태그의 href 속성에 path를 사용하여, 클릭 시 해당 링크의 path가 추가된 URI를 서버로 요청한다. PJAX 방식은 이 과정에서 내비게이션 클릭 이벤트를 캐치하고 preventDefault를 사용하여 서버요청을 방지한다. 이후 href 어트리뷰트에 path를 사용하여 AJAX 요청을 한다. 이때 AJAX 요청 자체는 주소창의 URL을 변경시키지 않아 history 관리가 불가능하다. 여기서 pushState 메서드를 사용하여 주소창의 URL을 변경하고 URL을 history entry로 추가할 수 있다. 12345678910111213141516171819202122232425const routes = { &quot;/&quot;: &quot;/data/home.json&quot;, &quot;/service&quot;: &quot;/data/service.json&quot;, &quot;/about&quot;: &quot;/data/about.html&quot;,};const render = async (path) =&gt; { const url = routes[path]; const res = await fetch(url); const { title, content } = await res.json(); root.innerHTML = `&lt;h1&gt;${title}&lt;/h1&gt;&lt;p&gt;${content}&lt;/p&gt;`;};window.addEventListener(&quot;popstate&quot;, (e) =&gt; { render(e.state.path);});navigation.addEventListener(&quot;click&quot;, (e) =&gt; { if (!e.target.matches(&quot;#navigation &gt; li &gt; a&quot;)) return; e.preventDefault(); const path = e.target.getAttribute(&quot;href&quot;); history.pushState({ path }, null, path); render(path);}); Refhttps://developer.mozilla.org/ko/docs/Web/API/Historyhttps://developer.mozilla.org/ko/docs/Web/API/History_APIhttps://tutorialzine.com/2015/02/single-page-app-without-a-frameworkhttps://css-tricks.com/using-the-html5-history-api/https://tyle.io/blog/52 📚 배우기IntersectionObserver를 사용한 의 lazy loading123456789&lt;iframe width=&quot;100%&quot; height=&quot;118&quot; data-src=&quot;https://www.youtube.com/embed/${video.id}?enablejsapi=1&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowscriptaccess=&quot;always&quot; allowfullscreen&gt;&lt;/iframe&gt; 위와 같이 &lt;iframe&gt; 태그에 src 속성 대신 data-src 속성을 부여한 후, InterSectionObserver를 사용하여 lazy loading을 구현할 수 있다. 12345678910111213141516171819export default function lazyLoading() { const options = { threshold: 1.0 }; const callback = (entries, observer) =&gt; { entries.forEach((entry) =&gt; { if (entry.isIntersecting) { entry.target.src = entry.target.dataset.src; observer.unobserve(entry.target); } }); }; const observer = new IntersectionObserver(callback, options); observer.observe(document.querySelector('#modal-videos')); const modalClips = document.querySelectorAll('#modal-videos iframe'); modalClips.forEach((clip) =&gt; { observer.observe(clip); });} 지정한 root 화면 (여기서는 #modal-videos)에 1% (option의 threshold) 이상 &lt;iframe&gt;이 교차되면,해당 &lt;iframe&gt;의 data-src 속성에 숨어서 기능하지 않덛 url이 &lt;iframe&gt;의 src 속성에 들어가서, 해당 영상의 썸네일이 로드된다. Ref https://velog.io/@syj9484/React-Intersection-Observer-API를-이용한-lazy-loading - babel-preset-envwebpack 빌드 시스템에서 사용하는 babel은, babel-preset-env와 함께 설정해주는 경우가 많다.babel은 JavaScript의 최신 문법을 ES5의 문법으로 바꿔주는 역할을 하지만, babel 단독으로는 아무런 역할을 하지 못한다.preset과 plugin을 추가해야 babel이 제대로 작동할 수 있다. 그래서 babel이 사용할 dependency를 알려주는 .babelrc 파일을 생성하고, 사용하고 싶은 ES6의 문법들을 모두 npm 패키지으로 설치 후 plugin에 설정해줘야 한다.arrow function을 사용하기 위해 @babel/plugin-transform-arrow-functions을 설치하고, .babelrc에 아래처럼 적어줘야 하는 것이다. 1234// .babelrc{ plugins: ['@babel/plugin-transform-arrow-functions']} 이러한 번거로움을 줄이기 위해 탄생한 것이 preset이다. preset은 plugin들을 포함한 번들 파일을 포함한다.npm 설치와 babel 설정을 한번만 하면 plugin들이 자동적으로 설치된다. 아래 목록과 같은 공식 babel preset이 있으며, airbnb preset 등 비공식 preset들도 존재한다. @babel/preset-env @babel/preset-flow @babel/preset-react @babel/preset-typescript npm으로 preset 패키지 설치 후, .babelrc에 적어주면 된다. 1npm install --save-dev @babel/preset-env 123{ presets: ['@babel/preset-env']} Ref https://velog.io/@pop8682/번역-왜-babel-preset이-필요하고-왜-필요한가-yhk03drm7q babel-polyfill**polyfill은 기본적으로 하위 브라우저를 지원하는 서비스 개발에 사용된다.babel-polyfill은 ES6+에서 새롭게 추가된 Promise, WeakMap과 같은 내장객체나 Array.from, Object.assign과 같은 정적 메소드를 구형 브라우저에서도 작동할 수 있도록 변환해주는 도구다.쉽게 말해 ES6+에서 새롭게 추가된 객체나 메소드들을 구형 브라우저에도 작동할 수 있도록 변환해준다. babel이 ES6+의 문법을 구형 브라우저에서도 작동할 수 있도록 변환해주는 것이라면, babel-polyfill은 ES6+에서 새롭게 추가된 객체들을 구형 브라우저에서도 작동할 수 있도록 변환해주는 것이다.그러나 babel 7.4.0부터는 babel-polyfill을 직접 사용하므로 이젠 따로 설치할 필요가 없어졌다. (현재 babel-polyfill은 deprecated되었다.) Refhttps://okchangwon.tistory.com/3https://medium.com/@larkbless/babel-babel-polyfill-왜-같이-사용할까-b5f806ae64a1 Webpack Handbook KRRef https://joshua1988.github.io/webpack-guide/ JS Deep-dive WebpackRef https://poiemaweb.com/sass-webpack HTML Collection vs NodeList (크루 블로그)Ref https://yung-developer.tistory.com/79 - Web Server vs WAS웹 사이트의 flow는 사용자의 동작에 따라 클라이언트가 서버로 Request를 보내고, 다시 Response를 받아 사용자에게 보여주는 흐름이다. 웹 서버는 웹 페이지, 사이트 또는 앱을 저장하는 프로그램으로, 클라이언트에서 요청한 HTTP를 확인 후 데이터를 처리하여 페이지에 필요한 HTML, CSS, JavaScript 등을 다시 클라이언트에 보내준다.대표적인 웹 서버의 종류에는 아파치 웹 서버(Apache Web Server), GWS, IIS 등이 있다. WAS(Web Application Server)는 서버로 들어오는 수많은 요청들을 관리하는 역할을 한다. 많은 요청을 처리하기 위해 서버를 돕는 역할로,사용자 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어를 일컫는다. 아파치 톰캣(Apache Tomcat), 레진(Resin), 제이런(JRun) 등이 있다. Ref https://swimjiy.github.io/2019-11-03-How-Web-Works 기타Object.freeze객체의 불변성을 위해 사용한다.크루들이 상수들을 정의해둔 파일 등에서 많이 사용하는 것을 봤는데, 상수 객체의 변수들은 변경될 위험이 없을 것 같은데 일일히 freeze시켜주는 이유가 궁금했다. 1234567export const VALUE = Object.freeze({ KEYWORD_COUNT: 3, CLIPS_PER_SCROLL: 10, THROTTLE_TIME: 1000, MAX_SAVED_COUNT: 100, SNACKBAR_TIME: 3000,}); 물론 팀마다 스타일은 다를 수 있기 때문에 합의해서 사용하면 되지만,언제든지 휴먼 에러가 발생할 수 있는 여지를 줄여주는 것이 좋을 것 같다 🙂 Object.freeze는 객체 내부의 객체의 변경은 막을 수 없기 때문에, 재귀적으로 deep Freeze를 구현해줘야 하는 경우도 있다.아래는 MDN 문서의 deep freeze 예제다. 12345678910111213function deepFreeze(object) { // 객체에 정의된 속성명을 추출 var propNames = Object.getOwnPropertyNames(object); // 스스로를 동결하기 전에 속성을 동결 for (let name of propNames) { let value = object[name]; object[name] = value &amp;&amp; typeof value === &quot;object&quot; ? deepFreeze(value) : value; } return Object.freeze(object);} 🤔 생각해보기use strict를 쓰는 이유잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고, 그 환경에서 개발을 함으로써 발생 가능한 문제를 미리 예방한다. JavaScript의 strict mode는 코드의 동작 환경을 다음과 같이 제한한다. 기존에는 조용히 무시되던 에러들을 throwing한다. JavaScript 엔진의 최적화 작업을 어렵게 만드는 실수들을 바로잡는다. 가끔씩 strict mode의 코드는 sloppy mode의 동일한 코드보다 더 빨리 작동하도록 만들어진다. strict mode는 ECMAScript의 차기 버전들에서 정의될 문법을 금지한다. ‘use strict’는 스크립트 최상단에 선언할 수 있지만, 이처럼 전역에 선언하는 방식은 권장되지 않는다. 1234567// 전역에 strict mode의 적용하는 것은 바람직하지 않다!'use strict';function foo() { x = 10; // ReferenceError: x is not defined}foo(); 전역에 선언한 strict mode는 스크립트 단위로 적용되어, strict mode 스크립트와 non-strict mode 스크립트 간 충돌을 발생시킬 위험이 있다. 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; 'use strict'; &lt;/script&gt; &lt;script&gt; x = 1; // 에러가 발생하지 않는다. console.log(x); // 1 &lt;/script&gt; &lt;script&gt; 'use strict'; y = 1; // ReferenceError: y is not defined console.log(y); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 함수 레벨에서 strict mode를 적용하는 것이 일반적이다. 1234567// 함수 단위로 strict mode 적용function foo() { 'use strict'; x = 10; // ReferenceError: x is not defined}foo(); ES6의 module 개념을 사용하면 기본적으로 엄격 모드가 적용된다. 1234function strict() { // 모듈은 기본적으로 strict mode이다. }export default strict; 😎 strict mode가 제한하는 환경들은 직접 사용하며 알아보자 Refhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_modehttps://ko.javascript.info/strict-modehttps://poiemaweb.com/js-strict-mode Naver TOAST - 기술 글쓰기로 시작하는 건강한 개발 문화 글을 쓰게 되면서 얻는 이점은, 온전히 내 지식으로 쌓이게 된다는 점 글도 잘 쓰면 말도 잘하게 된다. Ref https://ui.toast.com/weekly-pick/ko_20210315 클라이언트의 사용자 중심 예외처리(Jbee)환경 에러 언제 어떻게 발생할 지 알고 있는, 예상 가능한 에러 (Expected Error) 언제 어떻게 발생할 지 알지 못하는, 예측할 수 없는 에러 (Unexpected Error) 사용자 에러 사용자가 에러 상황을 이해해서 해결 가능한 에러 (애플리케이션을 계속 사용할 수 있도록 도와줄 수 있는 에러) 사용자에게 상황을 말해줘도 사용자가 해결 불가능한 에러 (사용자에게 아무런 도움이 되지 않는 에러) 에러 다루기 예상 가능한 에러와 예상할 수 없는 에러를 판단할 기준 마련하기 에러 전파를 막기 위한 장치 만들기 에러 모니터링을 위한 도구 사용하기 Ref https://jbee.io/react/error-declarative-handling-2/ 😎 마무리이제 아주 미루는 게 습관이 됐구만!어차피 다 제때 못하니까 나도 같이 밀려나는 것 같다. 하지만 살인적인 스케줄인 것만은 분명하다.드럼학원도 그만두고, 방학 때 놀러갈 계획도 포기 😞운동은 살기 위해 계속 하고 있다 술자리에서도 드디어 정신줄을 놔버리고, 아주 좋다창🖼을 열어~","link":"/2021/03/20/woowa-week-07/"},{"title":"우테코 8주차 기록","text":"우아한테크코스 8주차 벌써 8주차, 2달이 지났다. lv1이 끝나간다. 다음 레벨부터는 글 제목을 ‘회고’ 대신 ‘이야기’로 해보면 어떨까 생각이 든다. ‘회고’라고 하니까, 미션마다 주어지는 회고 같아서. 😬 페어 프로그래밍 확실히 매일 5분씩이라도 그날의 회고를 남겨놓는 게 좋다. 오늘 뭘 배우고 적용했는지, 무슨 문제로 토론하거나 삽질했는지, 그날의 기분은 어땠는지 돌이켜볼 수 있다. 1단계 이후 대공사를 마무리했다. 다행히도 큰 문제없이 머지되었다. API 상의 이슈가 많아 크루들, 코치들과 많은 이야기를 나누었다. 백엔드와 소통하다보니 정말 현업하는 것 같은 느낌도 살짝 든다. (아님) 정규표현식, 웹 접근성 등 서니의 변태스러운(!) 집착들을 배웠다. 서로 조금 지치거나 생각할 시간이 필요할 때 말을 잘 하지 못해 불편했던 부분들이 있었는데, 회고 시간을 가지면서 발전적으로 함께 이야기를 나눌 수 있었다. 서니와 닭발에 소주 먹으러 가자는 이야기를 했다. 포수타 레벨 3,4에서 진행하는 서비스 개발은 기업협력 서비스가 될 수도 있다고 한다! 😮 그때쯤이면 내 실력이 얼만큼 향상됐을지, 어떤 서비스를 만들고 있을지 궁금하다. 방학이 다가오니 lv1에서 미뤘던 부분들을 잘 마무리하자! 테코톡이번주 주제는 유조의 Callback!무시무시하고 인상 깊은 발표자료를 준비했다. callback 함수의 문제는, 중첩 시 가독성이 매우 떨어지는 callback 지옥을 경험하게 된다는 것이다. 😱 123456789101112131415161718192021222324252627setTimeout((name) =&gt; { let names = ''; if (!name) { throw new Error('이름을 찾을 수 없습니다.'); } else { names += name; console.log(names); } setTimeout((name) =&gt; { if (!name) { throw new Error('이름을 찾을 수 없습니다.'); } else { names += name; console.log(names); } setTimeout((name) =&gt; { if (!name) { throw new Error('이름을 찾을 수 없습니다.'); } else { names += name; console.log(names); } }, 500) }, 400)}, 500) Promise는 callback 지옥에서 개발자를 구원해준다.비동기 작업이 넘어올 때, resolve와 reject를 통해 각각 성공/실패한 경우를 처리한다. async-await은 ES6에 추가된 Promise의 syntactic sugar이다.함수 앞에 async를 명시하여 비동기 함수의 실행을 기다릴 수 있다. 123456789101112const delay = (ms) =&gt; { return new Promise((resolve) =&gt; setTimeout(resolve, ms));}const doSomething = async () =&gt; { await delay(1000); console.log('우아한'); await delay(1000); console.log('테크코스');}doSomething(); 👨‍🏫 강의지하철 노선도 미션 공통 피드백 - 1명확한 계층 분리어떤 크루의 멋진 코드 😮 12345678910111213141516const accessToken = { value: '', init() { // ... }, set(newAccessToken, keepLogin = false) { // ... }, clear() { this.value = ''; // ... }, get() { return this.value; },}; HoC를 이용한 네비게이션 보디가드바닐라로 리액트 컴포넌트를 잘 구현했던 크루의 코드다. 로그인의 여부에 따라서 갈 수 있는 경로를 구분해 준다.과연 여기서 authenticatedRoute와 unauthenticatedRoute는 어떤 식으로 작성된 코드일 지 생각해보자 🤔 (생각보다 복잡하지 않다!) 123456789101112const routeHandler = { '/': () =&gt; authenticatedRoute(mountStations), '/login': () =&gt; unauthenticatedRoute(mountLogin), '/signup': () =&gt; unauthenticatedRoute(mountSignup), '/search': () =&gt; authenticatedRoute(mountSearch), '/sections': () =&gt; authenticatedRoute(mountSections), '/stations': () =&gt; authenticatedRoute(mountStations), '/map': () =&gt; authenticatedRoute(mountMap), '/lines': () =&gt; authenticatedRoute(mountLines),}; - 셀프 리뷰 - 행운의 로또이번에도 한 달 전 진행한 미션에 대한 셀프 리뷰를 진행했다. 내가 생각했을 때 바보 같지만 나눠보고 싶은 질문 하나의 블록 내부에서 변수를 먼저 모두 선언하고 아래에 함수들을 정의하는 게 좋을지, 아니면 변수와 함수 선언이 조금 번갈아가며 나오더라도 의미상으로 관련 있는 코드들끼리 묶는 게 좋을지? 🤔그때는 몰랐지만 지금은 알 수 있는 것 HTMLFormElement.elements를 사용하여 폼 컨트롤이 되는 대상들의 목록을 쉽게 가져올 수 있다. 하나의 form 안에 있는 여러 input의 값을 가져오는 데에 유용하다. model에 너무 많은 역할을 부여하지 말자그때도 몰랐고 아직도 잘 모르겠는 것 createElement를 사용해도 될까? 속성들까지 붙이기엔 코드가 조금 과해지는 것 같기도 하다. innerHTML은 XSS 공격 등에 취약하다는데, JavaScript로 만드는 DOM 요소를 어떻게 붙여 넣는 것이 가장 좋은 방식일까? 웹 접근성을 충분히, 진지하게 고민하진 않은 것 같다 😅반복되고 있는 실수 및 습관이 있다면? id와 class를 기준 없이 생각나는 대로 사용하고 있다 반복적으로 특정 부분을 실수하기보다는, 많은 내용들을 별 생각 없이 가져다 쓰는 것이 큰 문제 😞기존에 작성하던 방식에서 코드를 단순히 가져와서 사용한 경우는 없는지 CustomEvent에 대한 근본적인 이해 없이 이전 단계들에서 페어가 만들어 준 class를 기계적으로 상속 받아 사용하고 있었다.확실하게 말할 수 있는 발전한 1가지 다른 미션을 진행하며 혼자 CustomEvent를 찾아보면서, 사용하는 패턴과 방식을 익혀 조금 더 자연스럽게 쓸 수 있게 되었다 함수의 목적과 의도가 잘 드러나게끔, 하나의 함수는 하나의 일만 하게끔 작성하는 습관을 조금이나마 들인 것 같다.다시 로또 미션 코드를 작성한다면 어떻게 작성할 것인가? 코드를 읽는 사람이 별도 설명 없이 코드만 보고 알아차릴 수 있게끔 작성하기 사용자의 입장에서 프로세스가 진행되는 논리 단계에 따라 코드를 작성하기 view는 여러 개 인데 controller를 하나만 쓰다보니 파일이 방대해졌다. 설계를 잘 잡고, controller도 역할 별로 분리시킨다면 더욱 깔끔해질 것이다. SMART한 페어와의 회고창의성부정적인 분위기가 우리의 창의력 수준을 떨어뜨릴 수 있고 긍정적인 감정 상태가 창의력을 촉진해 문제 해결에 도움이 된다. 창의성이 가장 필요할 때 창의성 발휘가 좀처럼 잘 되지 않는, “창의성의 아이러니 제2법칙” 터널 비전부정적인 감정이 들면 눈의 창문이 더욱 좁아진다. 이런 식으로 악순환이 될 것이다.프로그래머나 테스터라면 이런 경험이 매우 친근할 것이다. 화면에 에러가 뜬다. 호흡이 가빠지고 머리로 열이 오르기 시작한다. 왜 안 되지? 이상하네. 다시 한 번 해본다. 또 안 된다. 머리 부하가 높아진다. 한참을 헤매다가 원인을 찾아냈다. 욕이 절로 나온다. 너무도 뻔한 실수였다. 수십 번 훑어본 소스 코드에, 그리고 구글 검색까지 해본 에러 메시지에 분명히 원인이 드러나 있는데 무슨 숨은 그림 찾기도 아니고 도무지 눈에 보이지 않았다. 1. 다른 사람 활용하기내가 찾지 못하는 물건을 엄마는 항상 잘 찾는다. 다른 사람에게 부탁하자. 내 방을 잘 모르는 사람일수록 더욱 좋다. 그 사람은 나와 다르다. 나와 다른 부분에 주목한다. 시야각이 확장된다. 이를 인지적 유연성이라고 한다. 코딩하다 삽질을 30분 이상 하고 있는 것 같으면, “🙋‍♀️삽질!”하고 외쳐 주변 개발자들에게 도움을 구하자. 2. 마법의 주문스스로에게 전하는 마법의 주문, “Hm… That’s interesting! 😲” 3. 기분 전환오늘 저녁 맥주 한잔? 🍻 4. 자신의 반응을 선택하기현재 스트레스 수준과 감정 상태를 인지하고 스스로를 돌아본다. ‘아, 내가 지금 당황하고 있구나. 머리에 열이 나네. 얼마 동안 삽질했구나. 어떻게 해야 할까?’ “당신은 자신에게 일어나는 사건(event)을 통제할 수는 없습니다. 하지만 그 사건에 대한 자신의 반응(reaction)을 통제할 수 있습니다.” SMART 회고 Specific, 구체적이고 Measurable, 측정할 수 있고 Achievable, 달성 가능하며 Relevant, 적절하고 Timely, 시기 적절한 논리에 대한 환상인간은 컴퓨터가 아니기 때문에, 논리적인 질문을 한다고 논리적인 답변을 하지 않는다.논리적으로 질문을 하면, 압박감 속에 논리적인 답변을 하고자 가짜 답변을 지어내는 경우가 많다. 저 사람이 어떤 감정 상태일까? 를 먼저 생각하라. Webpack &amp; Module BundlerES6 이후로 JavaScript에서는 모듈 시스템이 공식적으로 제공되고 있다. Webpack은 프론트엔드 프레임워크에서 많이 사용되는 Module Bundler로,의존 관계를 가지고 있는 JavaScript, CSS, 이미지 등의 리소스들을 하나(또는 여러 개)의 파일로 번들링해 준다. Webpack은 아래와 같은 문제를 해결해준다. JavaScript 스코프여러 개의 자바스크립트 파일에서 선언된 변수와 함수들의 스코프는 전역적으로 설정된다. 어디서나 접근할 수 있기 때문에, 변수의 충돌이나 로딩 순서 등에 취약하다는 단점이 있다. Webpack은 이를 모듈이라는 단위로 관리할 수 있게 도와준다. 브라우저별 HTTP 요청 숫자의 제약브라우저에서 한번에 서버로 보낼 수 있는 HTTP 요청 숫자는 제약되어 있다. 보통 크롬의 경우 한 번에 6개의 요청을 할 수 있는데 webpack을 통해 번들링하면 요청해야 하는 파일의 수 또한 적어지므로 성능이 개선된다. Dynamic Import &amp; Lazy LoadingSPA의 단점은, 초기에 필요하지 않은 페이지에 대한 스크립트들도 불러온다는 것이다.하지만 웹팩을 통한 모듈 번들링을 이용하면 필요한 페이지에 따른 스크립트 모듈을 동적으로 불러오는 것이 가능하다.목적별로 여러 entry를 설정하여, 특정 페이지 렌더링을 위한 코드로 분리하는 것이다. 1234567// webpack.config.jsmodule.exports = { entry: { home: 'home.js', about: 'about.js', }}; 웹 개발 작업 자동화지금은 live-server와 같은 도구를 이용하여 브라우저에서 새로고침을 하지 않아도 손쉽게 변경된 코드 내용을 확인할 수 있지만, 이전에는 브라우저에서의 새로고침이 반복적으로 필요했다. 또한 웹 서비스를 개발하고 웹 서버에 배포할 때는 HTML, CSS, JS 및 이미지 압축, CSS 전처리기 변환 등의 작업이 추가적으로 필요했다.webpack만의 종속성 관리는 위와 같은 작업들을 자동으로 수행해 준다. 파일들의 압축과 전처리를 위해 loader를 사용할 수 있다. 현재 프로젝트에서 사용 중인 webpack의 설정 내용은 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require('path');const webpack = require('webpack');// HTML 파일의 생성을 도와준다. const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { entry: './src/js/index.js', output: { publicPath: '', filename: 'subway.bundle.js', // 번들링된 결과물의 파일 이름 path: path.resolve(__dirname, './dist'), // 번들링된 결과물을 저장하는 디렉토리 }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: ['babel-loader'], }, { test: /\\.css$/, use: ['style-loader', 'css-loader'], }, { test: /\\.(png|svg|jpg|jpeg|gif)$/i, type: 'asset/resource', }, ], }, devServer: { port: 8080, hot: true, contentBase: '/dist/', historyApiFallback: true, }, plugins: [ new webpack.ProgressPlugin(), new webpack.HotModuleReplacementPlugin(), // 생성된 html 파일에 자동으로 번들링된 javascript 파일을 &lt;script&gt; 태그로 넣어준다. new HtmlWebpackPlugin({ filename: 'index.html', template: './index.html' }), ],}; Refhttps://webpack.js.org/https://medium.com/@chullino/웹팩-3-4-js모듈화-역사-돌아보기-1-9df997f82002https://pks2974.medium.com/dynamic-import-로웹페이지-성능-올리기-caf62cc8c375https://webpack.js.org/guides/lazy-loading/ Login with JWT(Json Web Token)유저 인증을 할 때, 세션을 사용하여 모든 기록을 서버에 저장하는 방식은 서버에 무리가 갈 수 있다.또한 서버를 확장하는 것이 어려워진다는 단점이 있다. 이러한 문제를 해결하기 위해 탄생한 것이 토큰이다. 토큰 기반 시스템은 stateless, 즉 상태를 갖고 있지 않다. 유저의 인증 정보를 서버나 세션에 담아두지 않고, 서버에 데이터를 요청할 때마다 토큰을 함께 전달한다.토큰을 사용함으로써 유저는 처음 로그인한 서버 외에도 다른 서버들에 자유롭게 요청을 보낼 수 있으며, 이로 인해 서버의 분산이 이루어져 서버의 확장이 용이해진다. 오늘날 많이 사용되는 토큰은 JWT이다. JWT는 필요한 모든 정보를 자체적으로 갖고 있다. 따라서 별도의 데이터베이스 없이도 해당 토큰의 유효성을 검증할 수 있다. JWT를 이용한 Authentication은 아래와 같은 흐름으로 이루어진다. 사용자가 로그인을 한다. 서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한다. 그리고 기타 정보와 함께 Payload에 넣는다. 이때 JWT 토큰의 유효기간을 설정한다. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급한다. 클라이언트는 Access Token을 받아 저장한다. (쿠키, 세션 등) 클라이언트는 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인한다. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다. 이때 5번 과정에서 Access Token을 Auth 헤더에 실어 보낼 때, Bearer Authentication 방법을 사용한다. 12Authorization: &lt;type&gt; &lt;credentials&gt;Authorization: Bearer &lt;access-token&gt; 인증 타입은 bearer 이외에도 Basic, Digest, HOBA, Mutual 등이 있다. Ref https://velopert.com/2350 📚 배우기 태그HTML의 &lt;main&gt; 태그는 문서 &lt;body&gt;의 주요 콘텐츠를 나타내며, 문서의 핵심 주제나 앱의 핵심 기능에 직접적으로 연결됐거나 확장하는 콘텐츠로 이루어진다.문서에 하나 이상의 &lt;main&gt; 요소가 존재해선 안 된다! 😮 또 &lt;main&gt;은 문서 영역을 구분 짓는 용도로 사용되기 때문에 &lt;article&gt;, &lt;aside&gt;, &lt;footer&gt;, &lt;header&gt;, &lt;nav&gt; 요소의 자손 요소가 되어서는 안 된다. Refhttps://developer.mozilla.org/ko/docs/Web/HTML/Element/mainhttp://www.tcpschool.com/html-tags/main MiniCssExtractPluginwebpack에서 css 파일들을 묶어 별도로 추출하기 위해 사용하는 플러그인이다. JS 파일의 에 포함된 css를 별도의 파일로 추출해준다. css-loader와 함께 사용하는 것이 권장된다. 1234567891011121314// webpack.config.jsconst MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { plugins: [new MiniCssExtractPlugin()], module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], }, ], },}; Refhttps://webpack.js.org/plugins/mini-css-extract-plugin/https://joshua1988.github.io/webpack-guide/tutorials/code-splitting.html#실습-절차 input pattern&lt;input&gt; 태그에 pattern이라는 속성이 있다! 😮&lt;input&gt; 요소의 값을 검사할 때 사용될 정규 표현식을 지정해 준다. Custom Validations페어와 3시간 여를 삽질했음에도 불구 아주 신났던(왜 그랬을까🤔?) Custom Validity 만들기 요소의 validityState를 받아서, 유효하지 않은 원인에 따라 서로 다르게 setCustomValidity를 해줄 수 있다.경고창을 띄우고 싶은 시점에 reportValidity를 호출해주면 된다. 미션에서는 아래와 같이 작성했다. 12345678910111213141516171819setInputValidity() { const validityState = this.$stationNameInput.validity; if (validityState.valueMissing) { this.$stationNameInput.setCustomValidity('역 이름을 입력해 주세요.🙀'); } else if (validityState.tooShort) { this.$stationNameInput.setCustomValidity('2글자 이상 입력해 주세요.👾'); } else if (validityState.patternMismatch) { this.$stationNameInput.setCustomValidity('공백, 특수문자를 제외한 한글을 입력해 주세요.🤓'); } else { this.$stationNameInput.setCustomValidity(''); }}async handleNameSubmit(event) { event.preventDefault(); this.$stationNameInput.reportValidity(); await this.addStation(event);} 화면에는 아래처럼 보인다. Refhttps://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement/setCustomValidityhttps://developer.mozilla.org/en-US/docs/Web/API/ValidityState invalid eventJavaScript DOM event에 invalid라는 것이 있다.위에서 사용한 Custom Validation의 연장선에서 살펴볼 수 있다.폼 제출 시 input의 요소가 정의한 기준((min, max, pattern 등의 속성)에서 invalid한 값을 가질 때 발생한다. Ref https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/invalid_event Custom PromisePromise 다시 공부하기 😵 Promise 개념 짚고 가기 ⬇️https://www.freecodecamp.org/news/how-to-write-a-javascript-promise-4ed8d44292b8/ Promise chaining 대신 async-await을 사용하자! ⬇️https://blog.logrocket.com/promise-chaining-is-dead-long-live-async-await-445897870abc/https://blog.patricktriest.com/what-is-async-await-why-should-you-care/ 비동기 함수의 return과 await, return await이 헷갈린다면 ⬇️https://flaviocopes.com/how-to-return-result-asynchronous-function/https://jakearchibald.com/2017/await-vs-return-vs-return-await/ generator와 async 함수 비교 ⬇️https://hackernoon.com/async-await-generators-promises-51f1a6ceede2 Custom Promise 만들기 (어려운 편 😵) ⬇️https://p-iknow.netlify.app/js/custom-promise 기타gh-pages: dist directory만 deploy하기Ref https://velog.io/@bigsaigon333/gh-pages-dist-디렉토리만-deploy-하기 효과적인 피드백 “덜 가르치고 더 많은 피드백을 제공하라! (Teach less and provide more feedback!)” 피드백을 어떻게 ‘주느냐’보다 어떻게 ‘받아들이는가’가 중요하다. Ref https://21erick.org/column/5251/ 정규표현식 사이트정규표현식 마스터 서니가 알려준 정규표현식을 만들어주는 사이트Ref https://regexr.com/ 😎 마무리글쓰기 미션 제출 주간이라 그런지, 크루들의 글이 빠른 속도로 리젠(!)되고 있다.아직 힘든 걸까, 아니면 그냥 그때 많이 무너진 마음이 아직까지 말랑해진 채로 위태롭게 유지되고 있는 걸까.일주일 내내 이야기 나누는 프론트 크루들 뿐 아니라 백엔드 크루들의 글까지.전혀 슬픈 내용도 아닌데 읽으면서 많이 울었다. 그냥 다른 사람들이 나랑 비슷한 걱정과 고민들을 하며 보냈을 불안한 나날들을 떠올리면 눈물이 난다. 언제쯤 그칠까 🤷‍♀️그렇지만 이런 나 그대로도 나쁘지 않은 것 같다.크루들과 더 많은 시간을 보내며 더 깊은 이야기들을 나눠보고 싶다.","link":"/2021/03/27/woowa-week-08/"},{"title":"우테코 11주차 이야기","text":"우아한테크코스 11주차 webpack으로 React 프로젝트 시작하기 | React setState의 비동기성 | React 이모저모 페어 프로그래밍브랜과 일주일이라는 짧은 시간 동안 페어를 진행했다. 전공자라는 메리트도 있겠지만, 무엇보다도 공식문서를 잘 확인하는 습관이 멋진 페어다. 대충 구글링하여 스택오버플로우나 블로그에서 필요한 정보만 쏙쏙 베껴왔던 지난날의 모습들을 반성한다. 브랜 덕분에 처음으로 CRA 없이 React App을 처음부터 만들어 보았다. 중간중간에 내가 잘 따라오고 있는지 한번씩 질문도 해준 덕에 잊지 않고 정리할 수 있었다. 다만 브랜도 나만큼 타이핑이 빠를 뿐 아니라 생각하는 시간과 그것을 코드로 옮기는 시간도 아주 빠르다. 종종 벅찬 기분이 들었다! 그래도 중간중간에 말을 하면서 어느 정도 해소가 되었다. 그리고 “깔끔하다”, “좋다” 등의 긍정적인 피드백을 남발하여(?) 점점 신빙성이 떨어지긴 했지만 페어에게 자신감을 주고 우리 코드에 확신을 가지게끔 도와줬던 것 같다. 브랜은 내게 낯선 것을 겁내지 말고 시도했으면 좋겠다고 했다. 고작 몇 개월 아마추어스러운 React를 다뤘다고 코드 스타일이 조금 남아 있어서, 처음 보는 방식들을 낯설어 하고 내 코드 스타일이 일반적인 패턴이라고 생각하는 면이 없잖아 있었다. 소신 있게 코드를 적용하고, 틀리면 지적 받을 수 있는 용기를 가지자. 공부하기JavaScript Web Worker싱글 스레드 언어인 JavaScript는 한번에 하나의 일 밖에 수행하지 못한다. 그러나 JavaScript가 동작하는 브라우저는 싱글 스레드가 아니다. 따라서 스크립트 연산을 웹 어플리케이션의 메인 스레드와 분리된 별도의 백그라운드 스레드에서 작동시키기 위한 기술이 필요한데, JavaScript에서는 Web Worker를 사용한다. worker는 Worker() 객체를 만들어서 사용한다. worker로 생성한 파일은 현재 window와는 다른 전역 맥락에서 동작하는 워커 스레드에서 작동한다.워커 스레드는 사용자 인터페이스(UI)를 방해하지 않고 작업을 수행한다. 워커와 메인 스레드 간의 데이터 교환은 메시지 시스템을 사용한다. postMessage()로 데이터를 전송하고, onMessage()로 데이터를 수신한다. 이때 데이터는 공유가 아닌 복제를 통해 전달된다. 1234567891011&lt;body&gt;&lt;!-- contents --&gt;&lt;/body&gt;&lt;script&gt; if(window.Worker) { const worker = new Worker('worker.js'); worker.onmessage = (event) =&gt; { console.log(event.data); // 'done' worker.terminate(); }; }&lt;/script&gt; main thread에서 new Worker('worker.js') 로 worker thread를 만든다. main thread에서 worker.onmessage 에 worker의 메시지를 전달받기 위한 이벤트 핸들러를 등록한다. worker thread에서 worker.js의 작업을 처리한 후 postMessage()로 데이터를 main thread의 worker.onmessage에 전달한다. 만약 더이상 worker thread가 필요 없거나 작업을 종료해야 한다면 worker.terminate()를 호출한다. 부모-자식 간에만 소통하는 DedicatedWorker와, 다른 worker와 작업을 공유할 수 있는 SharedWorker로 구분된다. Dedicated Worker 는 Worker를 처음에 생성한 스크립트만 액세스 할 수 있는 반면, Shared Worker는 복수의 스크립트에서 액세스할 수 있다. Refhttps://pks2974.medium.com/web-worker-간단-정리하기-4ec90055aa4dhttps://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API - webpack으로 React App 시작하기CRA(create-react-app)을 사용하는 대신, webpack을 이용해 필요한 모듈들과 React 패키지를 직접 설치하여 React App을 만들어 보자. (이번 미션에서 페어 브랜이 많이 도와줬다!) 1. yarn init으로 package.json 설치 2. react와 react-dom 패키지 설치 1yarn add react react-dom 👾 react와 react-dom 패키지의 차이react는 React 자체를 제공하는 라이브러리, react-dom은 React와 브라우저 DOM을 연결해주는 역할을 한다. 3. babel 세팅 1yarn add babel-loader @babel/core @babel/preset-react @babel/preset-env -D babel-loader: JavaScript 파일을 babel preset/plugin과 webpack을 사용하여 ES5로 컴파일해주는 plugin @babel/core: ES6 문법을 ES5로 바꿔준다. @babel/preset-react: react의 JSX를 JavaScript로 바꿔준다. @babel/preset-env: ES6의 모든 문법들 뿐 아니라 브라우저에 맞춰서 컴파일해준다. babel이 갖고 있는 여러 plugin들을 모아둔 것.\u001c 4. webpack 설정 1yarn add webpack webpack-dev-server webpack-cli html-webpack-plugin -D webpack-cli: build 스크립트를 통해 webpack 커맨드를 사용할 수 있게 해준다. webpack-dev-server: webpack에서 제공하는 development mode용 서버 html-webpack-plugin fileName: dist 파일에서 생성해주는 파일. 디폴트는 index.html이다. template: webpack 번들링 결과로 나온 html 파일들 중 script를 심어줘야 할 파일 여기에 더해 style-loader와 css-loader를 추가해준다.style-loader는 css를 DOM에 주입시키는 역할,css-loader는 css 파일들을 읽어 html의 &lt;style&gt;에 넣어주는 역할을 한다.이때 webpack의 설정은 오른쪽부터 적용되기 때문에, css-loader를 style-loader 이후에 배치한다. 👾 만약 style 태그 대신 css파일로 만들고 싶은 경우 MiniCssExtractPlugin을 사용한다. 아래와 같이 webpack.config.js 파일을 세팅했다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { mode: 'development', entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', corejs: '3.10', }, ], '@babel/preset-react', ], plugins: ['babel-plugin-styled-components'], }, }, }, { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ], }, devServer: { contentBase: path.join(__dirname, 'dist'), port: 9000, hot: true, }, plugins: [new HtmlWebpackPlugin({ template: './index.html' })],}; Refhttps://velog.io/@pop8682/번역-React-webpack-설정-처음부터-해보기https://www.zerocho.com/category/Webpack/post/58ac2d6f2e437800181c1657 알아보기yarn ejectCRA(Create-React-App)로 만든 React App에서 yarn eject를 실행하면 숨겨진 모든 설정 파일들을 밖으로 추출해 준다. config와 scripts 뿐만 아니라 babel과 관련된 세팅들까지 확인할 수 있다. package.json에서 babel plugin 등을 추가적으로 세팅할 수도 있다. 👾 주의! yarn eject로 한번 뜯어놓은 앱은 다시 돌이킬 수 없다. - &lt;noscript&gt;&lt;noscript&gt; 태그는 클라이언트 사이드 스크립트(client-side scripts)를 사용하지 않도록 설정했거나, 스크립트를 지원하지 않는 브라우저를 위한 별도의 콘텐츠를 정의할 때 사용한다. Refhttp://www.tcpschool.com/html-tags/noscript - &lt;script defer&gt;1&lt;script src=&quot;index.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; &lt;script&gt; 태그의 defer 속성은 페이지가 모두 로드된 후에 해당 외부 스크립트가 실행됨을 명시한다. 일반적으로 &lt;script&gt;는 html의 &lt;head&gt; 안에 작성한다. &lt;script&gt;를 &lt;head&gt;에 작성하면 css 등 외부로부터 불러오는 리소스 파일을 한 군데에서 관리할 수 있는 장점이 있다. 그런데 브라우저는 html 마크업을 파싱하여 DOM 트리를 구성하고 페이지를 렌더링한다. html 파싱하는 동안 브라우저는 &lt;script&gt;를 만날 때마다 파싱을 중지하고 스크립트를 로드하고 실행한다. 이 과정에서 렌더링이 지연되기 때문에, html 파싱이 끝난 후 &lt;script&gt;를 로드하기 위해 html 파일의 가장 아래, &lt;body&gt;가 닫히기 전에 작성해주기도 한다. &lt;script&gt;는 기본적으로 다운로드와 실행이 순차적으로 진행되지만, defer 속성을 추가하면 브라우저가 &lt;script defer&gt;를 만났을 때 다운로드를 시작하지만, html 파싱을 막지 않고 &lt;/html&gt;을 만났을 때 실행된단. 즉 DOMContentLoaded 이벤트 이전에 실행되는 것이다. webpack의 번들링 결과 생성된 dist/index.html의 &lt;script&gt;에서 defer 속성을 확인할 수 있다. 123&lt;head&gt; &lt;script defer src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; Refhttps://webdir.tistory.com/322https://kimlog.me/js/2019-10-05-script/ package.json에 contributor 명시하기1234567891011// package.json&quot;contributors&quot;: [ { &quot;name&quot;: &quot;zigsong&quot;, &quot;email&quot;: &quot;wldms5764@gmail.com&quot; }, { &quot;name&quot;: &quot;somebody&quot;, &quot;email&quot;: &quot;somebody@naver.com&quot; }], 위와 같이 명시해주면,별다른 설정 없이 상대방이 한 commit에 내 이름도 함께 올라간다. github의 commit 주인(?)에도 두 명 모두 귀엽게 올라가 있다. Tailwind CSStailwind는 직역시 ‘순풍’이라는 뜻이다. 왜 이런 이름을 채택했을까? 모르겠다. Tailwind CSS는 Bootstrap 등과 비슷하게, 미리 정해진 class명을 태그의 class 속성에 넣어주기만 하면 CSS를 입혀주는 방식이다. 123&lt;button class=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded&quot;&gt; Click Me!&lt;/button&gt; Utility-First 컨셉이라고 하는데, html 코드의 태그에 스타일을 정의할 수 있기 때문에 별도의 CSS 파일을 관리할 필요가 없다는 장점이 있다.또 class명을 따로 짓지 않아도 돼서 BEM, OOCSS 사용 시의 불편함도 해결할 수 있다.이와 유사하게 평소 써왔던 styled-component의 어려움은 매번 컴포넌트를 새로 만들어야 한다는 점이었는데, tailwind CSS는 그런 고민을 없애준다. 현재 github과 nuxt.js 공식 사이트 등에서 Tailwind CSS를 사용하고 있다. Refhttps://tailwindcss.com/docshttps://wonny.space/writing/dev/hello-tailwind-css reset CSS브라우저마다 기본으로 제공되는 HTML tag들의 padding, display 등의 스타일 속성을 모두 초기화해준다.reset.css에 내용을 작성 후 import 하면 반영된다. Ref https://meyerweb.com/eric/tools/css/reset/ 질문하기Virtual DOMQ. 우리는 JavaScript만으로 앱을 구성할 때 명령형으로 작성했을까요? 선언형으로 작성했을까요?명령형 프로그래밍은 ‘어떻게(HOW)’, 선언형 프로그래밍은 ‘무엇(WHAT)’ 에 중점을 두고 있다. 집에서 루터회관에 간다고 했을 때, 명령형 방식은“집에서 나온다. ➡️ 9호선을 탑승한다. ➡️ 종합운동장 역에서 2호선으로 환승한다. ➡️ 잠실역에서 내린다 ➡️ … “로 이루어질 것이다. 반면 선언형 방식은 “루터회관은 잠실역 8번 출구 근처에 위치해 있다.”라고 할 것이다. 선언형 프로그래밍의 경우 함수 실행 시 동일한 인자 입력에 대해 사이드 이펙트 없이 항상 같은 값을 반환 받는다는 보장이 있다. 데이터 중심의 순수함수로 작성되는 것이다. 이 때문에 코드의 가독성과 재사용성을 높일 수 있다는 장점이 있다. 그동안의 JavaScript 앱은 많은 경우 명령형의 방식으로 작성해왔다.예를 들어, 로또 당첨 결과를 가지고 모달을 띄워주는 함수가 있을 때 다음과 같이 필요한 rankCounts와 earningRate 정보를 받아 화면에 모달을 표시해준다. 12345openModal(rankCounts, earningRate) { this.$modal.classList.add('open'); this.showRanks(rankCounts); this.showEarningRate(earningRate);} 하지만 선언형 방식으로 작성한 경우도 있다. 다음 코드는 수동 로또를 생성해서 현재 앱의 lottos 배열에 직접 값을 담아주고 있다. 123createManualLottos(manualTickets) { this.lottos = manualTickets.map(manualNumbers =&gt; new Lotto(manualNumbers));} 또 React에서 주로 사용되는 JSX 문법은 선언형 프로그래밍을 가능하게 해준다. html과 같은 형태의 코드를 통해 결과물을 바로 확인할 수 있는 것이다. 아래 예시는 버튼을 클릭했을 때, openModal 함수가 실행되어야 함을 알려준다. 1&lt;button onClick={this.openModal}&gt; Q. React 이전의 SPA 라이브러리들은 무엇이 있었을까요?jQuery, Backbone, Vue.js, Angular, Ember 등 Q. React 탄생 배경은 어떻게 될까요?Backbone, AngularJS가 생태계를 장악하던 시절, SPA 제작을 위한 보다 구조화된 방식의 프레임워크가 필요해졌다. ComponentUI를 구성하는 개별 뷰 단위인 Component는 앱에서 각 부분들의 재사용성을 크게 향상시켜준다. JSX 123456class MyComponent extends React.Component { render() { return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;; }}ReactDOM.render(&lt;HelloMessage name=&quot;zig&quot; /&gt;, root); 위와 같이 작성한 JSX 코드는 babel 컴파일 과정을 거쳐 다음과 같이 변환된다. 123456789101112class MyComponent extends React.Component { render() { return React.createElement( &quot;div&quot;, null, &quot;Hello &quot;, this.props.name ); }}ReactDOM.render(React.createElement(MyComponent, { name: &quot;zig&quot; }), root); html 코드를 통해 선언적으로 작성한 뷰 단의 코드를 통해 최종 결과물에 직관적으로 도달할 수 있다. 덕분에 코드는 더욱 예측 가능해지고, 협업과 유지보수에도 크게 도움이 되었다. React는 이러한 Component, JSX 등의 매력적인 feature와 함께 Virtual DOM이라는 강력한 무기를 가지고 탄생하였다. 컴포넌트가 render하는 return값을 가지고 현재 브라우저에 띄워진 DOM과 비교하여, 서로 다른 부분만을 다시 그려내는 것이다. 이를 통해 브라우저가 DOM을 해석하고 렌더링하는 비싼 작업을 Virtual DOM을 통해 미리 최적화시키고 컴포넌트 단위로 묶어서 관리할 수 있게 되었다. Virtual DOM은 단순한 DOM 조작 도구가 아니라, 컴포넌트 단위로 움직이는 선언적인 프로그래밍을 위해 동작한다. DOM 조작은 react-dom 라이브러리에 맡기고, 화면이 어떻게 보여져야 하는지만 이벤트와 데이터의 흐름을 통해 조작하면 된다. 이로 인해 데이터의 흐름 방향과 요소들 간의 연관성을 파악하기가 수월해졌다. Refhttps://boxfoxs.tistory.com/430https://2020.stateofjs.com/en-US/technologies/front-end-frameworks/https://medium.com/@RianCommunity/https://medium.com/@RianCommunity/react의-탄생배경과-특징-4190d47a28f JSXQ. #root를 미리 선언해놓는 이유는 무엇일까요?React 앱의 entry인 index.js에는 항상 아래 코드가 존재한다. 1ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); html 파일의 정해진 지점에 React DOM을 삽입하기 위한 목적이다. 일반적으로 html 파일의 body 태그 내부에 그려진다. 123&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt; React DOM에 의해 관리되는 모든 것이 이 요소 안에 들어가므로 이것을 root DOM 노드라고 부른다. Refhttps://www.w3schools.com/react/react_render.asphttps://reactjs-kr.firebaseapp.com/docs/rendering-elements.html#dom에서-요소-렌더링하기 Q. import 방법도 다른 것 같네요Q. React는 들어본 것 같은데 react-dom은 무엇일까요?ReactDOM은 React와 실제 DOM을 연결해주는 다리로, root DOM 노드 안에 들어가는 엘리먼트를 모두 관리하는 역할을 한다. ReactDOM의 render 메소드는 React 엘리먼트를 container DOM에 렌더링하고 컴포넌트에 대한 참조를 반환한다. 1ReactDOM.render(&lt;App /&gt;, document.getElementById('root'); Refhttps://ko.reactjs.org/docs/react-dom.htmlhttps://ko.reactjs.org/docs/rendering-elements.html Q. render가 하는 일은 무엇일까요?컴포넌트의 render 메소드는 virtual DOM을 생성한다. 이때 업데이트 이후의 상태를 기존 화면의 DOM과 비교하여 달라진 부분만 렌더링해준다. Q. JSX와 표현식은 같은 걸까요?JSX는 표현식이다. 컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식된다. 표현식이기 때문에 변수에 할당할 수 있으며, 1const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;; if문 안에 사용할 수 있고, 123456function getGreeting(user) { if (user) { return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;; } return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;} 함수의 반환값으로 사용된다. 12345function MyComponent() { return ( &lt;h1&gt;Hello, {props.name} &lt;/h1&gt; );} JSX 내부에서는 문을 사용할 수 없다. 123456789101112// wrongfunction MyComponent() { return ( { if (props.name) { &lt;h1&gt;Hello, {props.name} &lt;/h1&gt; } else { &lt;h1&gt;Hello, world} &lt;/h1&gt; } } );} 삼항연산자는 표현식으로 사용 가능하기 때문에 JSX 내부에서 사용할 수 있다. 123456789// goodfunction MyComponent() { return ( { props.name ? &lt;h1&gt;Hello, {props.name}&lt;/h1&gt; : &lt;h1&gt;Hello, world &lt;/h1&gt; } );} Q. JSX와 React.createElement() 는 무슨 관계일까요?JSX는 객체를 표현한다. 아래 두 예시는 동일하다. 12345const element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, world! &lt;/h1&gt;); 12345const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!'); JSX는 컴파일 후 React.createElement()의 결과로 생성된 element와 같은 형태로 바뀐다. Q. document.createElement()와 다른 점은 무엇일까요?브라우저에서 제공하는 createElement()와 React에서 제공하는 createElement()는 받는 인자와 작성 방식이 서로 다르다. 1document.createElement(tagName[, options]); 123456React.createElement(component, props, ...children);ReactDOM.render( React.createElement(Hello, {toWhat: 'World'}, null), document.getElementById('root')); Class StateQ. 상태를 직접 변경하지 않고 굳이 setState()를 사용하는 이유가 무엇일까요?직접 state를 수정하면 컴포넌트가 리렌더링되지 않는다. 오로지 setState()만이 상태를 올바르게 업데이트하고 컴포넌트를 리렌더할 수 있다. Q. setState()는 비동기적으로 작동할까요?React는 성능을 위해 여러 setState() 호출을 단일 업데이트로 한꺼번에 처리한다.setState()의 인자로 객체가 들어오면 상태가 즉시 업데이트되지 않을 수 있다. 1234// Wrongthis.setState({ counter: this.state.counter + this.props.increment,}); 상태의 동기적인 업데이트를 위해 객체보다는 함수를 인자로 사용하는 다른 형태의 setState()를 사용할 수 있다. 1234// Correctthis.setState((state, props) =&gt; ({ counter: state.counter + props.increment})); Q. 불변성을 지켜야 하는 이유는 무엇일까요?의도하지 않은 특정 객체가 변경되면 참조하고 있던 객체에서도 변경이 일어난다. 이 상태를 유지할 경우 side-effect가 발생할 확률과 프로그램의 복잡도가 높아지기 때문에 상태의 불변성을 지키는 것은 중요하다. Handling EventsQ. bind를 사용해야하는 이유는 무엇일까요?12345678910111213141516171819202122class Toggle extends React.Component { constructor(props) { super(props); this.state = { isToggleOn: true }; // constructor에서 binding this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(state =&gt; ({ isToggleOn: !state.isToggleOn })); } render() { return ( &lt;button onClick={this.handleClick}&gt; {this.state.isToggleOn ? 'ON' : 'OFF'} &lt;/button&gt; ); } this binding을 해주지 않고 handleClick을 전달한다면, 함수가 실제 동작할 때 this는 undefined가 된다. (이때 handleClick에서 this를 출력해보면, 콜백이 전달되는 곳인 button 태그가 찍힌다.)class 컴포넌트의 constructor에서의 this binding을 통해 현재 컴포넌트에서 선언한 handleClick이 해당 컴포넌트에 binding되어 있는 메소드임을 명시하여, 콜백으로 올바르게 동작하게끔 할 수 있다. Q. 매번 사용하는 bind를 생략하는 방법이 있을까요? public class field 문법 사용 (실험적인 방법)123456class Toggle extends React.Component { // 이 문법은 `this`가 handleClick 내에서 바인딩되도록 합니다. // 주의: 이 문법은 *실험적인* 문법입니다. handleClick = () =&gt; { console.log('this is:', this); } 위와 같이 사용하면 handleClick은 Toggle 클래스의 prototype이 아닌 Toggle 인스턴스의 메소드로 선언된다. 따라서 프로그램에서 사용되는 시점에서의 문맥 상 this를 참조할 수 있다. 콜백에 화살표 함수 사용하기화살표 함수로 콜백을 전달하면, this는 해당 메소드가 바인딩된 컴포넌트를 가리키게 된다. 12345678910111213class Toggle extends React.Component { //... render() { // 이 문법은 `this`가 handleClick 내에서 바인딩되도록 합니다. return ( &lt;button onClick={() =&gt; this.handleClick()}&gt; Click me &lt;/button&gt; ); }} Q. JSX 내부에 이벤트 핸들러로 콜백 함수를 전달하는 것과 함수를 전달해서 사용하는 것은 어떤 차이가 있을까요?위에서 설명한 내용 Ref https://ko.reactjs.org/docs/handling-events.html KeyQ. 왜 리스트의 key값으로 index를 사용하는 것은 안티 패턴일까요?1234todos.map((todo, index) =&gt; ( &lt;Todo {...todo} key={index} /&gt; ));} 위와 같이 리스트의 key값으로 index를 사용할 경우, 리스트에 새로운 아이템이 추가되거나 삭제되었을 때 react가 방금 수정된 index의 아이템에 매칭되는 컴포넌트를 올바르게 찾지 못할 수 있다. 리스트의 재배열이 일어나지 않는다면 key값을 index로 사용해도 문제가 없겠지만, 가능한 변하지 않는, 영구적이고 고유한 값을 key값으로 사용하는 것이 좋다. Q. 데이터에 고유한 id 값이 없다면 어떻게 key 값을 설정하는 게 좋을까요?그러나 데이터 자체에 고유한 id값이 없다면 무엇을 key값으로 사용해야할지 고민이 될 것이다.이럴 때는 nanoid나 nanoid 등 잘 만들어진 id 부여 모듈을 사용해볼 수 있다. Ref https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318 RefQ. Ref를 사용해야 하는 케이스는 무엇이 있을까요?React 공식문서에 기재된 Ref를 사용해야 하는 케이스에는 다음의 경우들이 있다. 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때 애니메이션을 직접적으로 실행시킬 때 서드 파티 DOM 라이브러리를 React와 같이 사용할 때Q. Ref를 남용하면 안되는 이유는 무엇일까요? React는 props를 통해서만 컴포넌트 간의 소통이 가능하도록 한다. 그러나 ref를 사용하면 다른 컴포넌트들에 직접적으로 접근할 수 있다. ref는 데이터의 동기화를 보장하지 않고 데이터의 캡슐화는 실패한다. 데이터의 변경이 의도한 방식과 다르게 동작하여 state는 업데이트되지 않아 컴포넌트의 리렌더링이 발생하지 않는 상황이 발생할 수 있다. 또 React는 상태 주도(state-driven) 개발을 지향하며, 상태를 갖는 컴포넌트들 간의 관계로 구성된다. ref를 사용하는 것은 이벤트 주도(event-driven) 개발이 되어, React 컴포넌트들에서 상태를 관리하기가 어려워진다. state와 props를 사용하여 컴포넌트 간의 관계를 유지하자. props chain이 복잡해졌을 때는 redux 등의 상태 관리 도구를 사용해볼 수도 있다. Refhttps://ko.reactjs.org/docs/refs-and-the-dom.html#gatsby-focus-wrapperhttps://blog.logrocket.com/why-you-should-use-refs-sparingly-in-production/ Lifecycle Function Component 기타잘 정리된 이력서보다 중요한 것작년 내내 면접을 보러다닐 일이 많았는데, 대부분은 잘 보지 못했던 것 같다.아무래도 지식 수준이 많이 떨어졌기 때문에 😞 앞으로 제출할 이력서와 보러 다니게 될 면접을 준비하며 생각해볼 만한 이야기들이다. 1. 지원동기를 명확히 하자지원하는 회사의 그 팀에서 정말 하고 싶은 일이 있다는 것을 명확히 밝히자. 확실한 이유가 있다면 회사에서도 더욱 눈여겨볼 것이다. 그리고 동기부여는 누가 주입시켜주는 것이 아니라는 사실. 2. 함께 일하기혼자서 일하는 회사는 없다. 많은 사람들과 커뮤니케이션하고 일했던 경험을 보여주자. 3. 퍼포먼스를 기재하기과정만큼 중요한 것이 결과이다. 인턴이든, 외주든 그동안 수동적으로 일해온 것이 대부분이었기에 어떤 일을 했고, 그래서 어떤 퍼포먼스를 냈는지는 자신 있게 말하지 못했던 것 같다. 지원하는 회사에 나와 비슷한 수많은 사람들이 있는데 내가 떨어져서 억울하다면, 나 자신이 과연 더욱 나은 성과를 낼 수 있는 사람인지 돌이켜보자. 4. 어려움 경험하기어려움을 일부러 경험할 수는 없겠지만, 프로덕트를 개발하다 장애를 맞딱뜨리는 등의 상황을 잘 헤쳐나간 경험이 있다면 좋은 이야기가 될 것이다. 5. 본인에 대해 잘 이해하기지원하는 회사의 팀과 나의 지향점이 맞는지를 판단할 수 있어야 한다. 팀이 일하는 방식과 목표가 나와 같은 방향인지 확인하고 어필하자. Ref https://minieetea.com/2021/04/archives/6193 마무리Lv2가 시작되었다! 짧았던 방학은 순식간에 지나가버리고 이제는 React로 시작해야 한다.Lv1도 순식간이었는데, 이만큼의 시간을 보내고 나면 더 이상 수업과 페어 프로그래밍이 없다니 아쉽기도 하다. 아쉬워지기 전에 Lv2의 하루하루도 소중하고 알차게 보내기로 다짐!","link":"/2021/04/17/woowa-week-11/"},{"title":"우테코 15주차 기록","text":"우아한테크코스 15주차 useCallback과 useMemo | React의 Router | Redux Middlware 페어 프로그래밍redux thunk를 본격적으로 사용하기 시작했다. api 호출을 위해 액션을 3개씩 만드는 것에서 다들 불편함과 답답함을 느끼게 되는 것 같다. redux toolkit 등 redux action을 관리해주는 도구의 필요성을 느끼고 있다. 처음부터 좋아보여 쓰는 것이 아니라, 필요에 의한 도구의 도입! 좋은 깨달음인 것 같다. TypeScript도 중간중간 막혔다. 유일하게 TS를 해본 멤버인 내가 많이 기여했어야 했는데, 나도 다 까먹어서 계속 헤맨 것 같아 미안하다. 그래도 체프와 유조가 여기저기서 잘 찾아다 줘서 AnyScript 없이 잘 쓸 수 있었다. 일단 any는 eslint가 욕한다. 쓸 수 없다. Immer도 쓰게 되었다. 상태가 깊어지면서 불변성을 유지하며 업데이트를 하기 어려웠는데, 모든 리듀서에 Immer를 쓰는 것이 옳은 방식인지는 잘 모르겠다. 긴 미션에 다들 조금씩 지쳐가는 게 보였다. 물론 나도… 그리고 자꾸 힘 빠지면 시니컬하게 말하는 습관이 있는 것 같은데, 내가 들어도 가끔 기분 나쁘게 들린다. 페어들은 아니라고 해줬지만, 반성하고 고쳐야겠다. snackbar 때문에 거의 이틀을 날리고 라이브러리를 사용했다. 주화입마에 빠지게 된 걸까? 이것저것 해보다가 PR을 조금 늦게 냈다. 주말에 모여서 맥주 한잔 했다. 내가 너무 졸려서 많은 얘기를 나누진 못했지만, 좋은 페어들과 값진 시간을 보냈다. 자꾸 ‘나는 바보야’를 외치는 체프와, 이상한 드립을 고수하는 유조와 함께 즐거운 페어를 한 것 같다! 마지막 날 회고 때, 유조가 적어준 말이 인상 깊다. “페어가 1명 늘어났지만 배운 것은 3배는 늘어난 것 같다.” 나도 마찬가지! 테코톡 - 브라우저 렌더링(정리 중)페어였던 체프가 발표한 브라우저 렌더링지난 주에 내 차례에서도 살짝 다뤘기 때문에 어느 정도 알고 있다 생각했는데, 생각보다 모르는 내용이 많다. 특히 Performance에서 이것저것 체크해볼 수 있는 건 정말 멋지다.아래는 발표 후 체프가 올려준 자료 Ref https://d2.naver.com/helloworld/59361 공부하기useCallback, useMemouseCallback메모이제이션된 콜백을 반환한다. 두 번째 인자로 들어가는 콜백의 의존성이 변경되었을 때만 콜백 함수가 새로 생성된다. (기본적으로는 컴포넌트가 리렌더링될 때마다 함수가 새로 만들어진다.) 123456const memoizedCallback = useCallback( () =&gt; { doSomething(a, b); }, [a, b],); 123456789101112const getProducts = useCallback(async () =&gt; { setLoading(true); try { const response = await api.get('/products'); setProducts(response.data); } catch (error) { enqueueSnackbar(MESSAGE.GET_PRODUCTS_FAILURE); } setLoading(false);}, [enqueueSnackbar]); enqueueSnackbar가 변경될 때마다 getProducts가 재생성되고, 그때마다 useEffect 내의 호출을 통해 api 요청을 다시 보낸다.사실상 enqueueSnackbar는 변경되지 않기 때문에 getProducts는 한번만 생성되고 호출도 한번만 발생하지만, eslint의 deps 규칙에 의해 의존성 배열에 추가되었다. useMemo메모이제이션된 값을 반환한다. 의존성이 변경되었을 때만 값을 다시 계산한다.미션은 아니지만, 학교 수업 팀플에서 웹을 제작하는 중에 useMemo를 사용할 상황에 마주했다. 12345678910111213141516171819const Home = () =&gt; { const [selectedLength, setSelectedLength] = useState&lt;number&gt;(0); const shuffledCorps = useMemo(() =&gt; _.shuffle(corporations), []); const handleSelectCard = () =&gt; { setSelectedLength(selectedLength + 1); }; return ( &lt;Styled.Root&gt; &lt;Styled.GridContainer&gt; {shuffledCorps.map((corp) =&gt; ( &lt;TarotCard key={corp.id} corp={corp} onClickCard={handleSelectCard} /&gt; ))} &lt;/Styled.GridContainer&gt; &lt;/Styled.Root&gt; );}; TarotCard를 클릭할 때마다 useState로 선언한 selectedLength가 변경되어 shuffle을 새로하고 있었다.컴포넌트가 마운트될 때 shuffle을 한 번만 실행시켜주기 위해 useMemo를 사용했다. Ref https://ko.reactjs.org/docs/hooks-reference.html - React의 Router많이 사용하는 BrowserRouter, HashRouter, MemoryRouter 모두 Router의 하위 항목들이다. BrowswerRouter는 HTML5의 history API (pushState, replaceState, popstate)를 이용한다. 이전 브라우저들을 지원하지 않는다.특정 path에서 새로고침 시 경로를 찾지 못해 404 에러가 발생한다. React에서 Redirection을 설정해 줘도 인지하지 못하는 것이다. HashRouter는 URL의 hash 조각을 이용한다. 그래서 주소에 해쉬(#)가 붙으며, 검색 엔진이 읽지 못한다.location.key나 location.state를 지원하지 않는다는 점에 유의하자. 이전 브라우저들을 지원하며, 공식 문서에서는 BrowserRouter를 사용할 것을 권장하고 있다. MemoryRouter는 URL의 history를 메모리에 저장한다. (페이지의 주소창과 관련이 없다) 테스트나 non-browser 환경(React Native) 등에서 사용한다. 미션에서는 스토리북 설정에서 사용했다. 123import { MemoryRouter } from 'react-router-dom';addDecorator((story) =&gt; &lt;MemoryRouter initialEntries={['/']}&gt;{story()}&lt;/MemoryRouter&gt;); Refhttps://reactrouter.com/web/guides/quick-starthttps://medium.com/@daniel.hramkov/browserrouter-vs-hashrouter-e8bf1c3824cehttps://ui.dev/build-your-own-react-router-v4/ - redux에서 middleware가 필요한 이유Dan이 StackOverflow에 직접 답을 남기기도 하는구나 신기하다.다른 무엇보다도, redux의 action creator가 순수함수여야 한다는 원칙은 사실 틀렸다는 것이 가장 충격적이었다. Dan의 답변은, So it is just easier from the maintenance point of view to extract action creators into separate functions. 그냥 action creator들을 더 작은 조각으로 분리시키기 위함이었다! 일종의 syntax sugar인 셈이다. middleware가 없이 action을 생성했다면, redux action을 사용하는 컴포넌트에서는 다음과 같이 작성해야 한다. 1234567891011121314// action creatorfunction loadData(dispatch, userId) { // needs to dispatch, so it is first argument return fetch(`http://data.com/${userId}`) .then(res =&gt; res.json()) .then( data =&gt; dispatch({ type: 'LOAD_DATA_SUCCESS', data }), err =&gt; dispatch({ type: 'LOAD_DATA_FAILURE', err }) );}// componentcomponentWillMount() { loadData(this.props.dispatch, this.props.userId); // don't forget to pass dispatch} 컴포넌트에서 해당 함수가 async인지 여부를 알고 있어야 하는 것이다.그러나 middleware를 거쳐 action을 작성한다면, 일반적인 방식의 dispatch 호출이 가능하다. 1234567891011121314// action creatorfunction loadData(userId) { return dispatch =&gt; fetch(`http://data.com/${userId}`) // Redux Thunk handles these .then(res =&gt; res.json()) .then( data =&gt; dispatch({ type: 'LOAD_DATA_SUCCESS', data }), err =&gt; dispatch({ type: 'LOAD_DATA_FAILURE', err }) );}// componentcomponentWillMount() { this.props.dispatch(loadData(this.props.userId)); // dispatch like you usually do} 지난 2년 간 낚였던 redux의 3대 원칙… Dan의 마지막 답변. Action creators were never required to be pure functions. 😐 Refhttps://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux redux로 전역 상태 관리하기 &amp; normalize 다루기Refhttps://jbee.io/react/react-2-redux-architecture/https://jbee.io/react/react-redux-normalize/ 알아보기heroku로 json server 배포하기페어 체프가 도와줬다! Heroku에 가입한다. 새로운 앱을 만든다.[heroku 사이트] 화면의 'Create a new app'을 클릭하거나 터미널에 아래와 같이 입력한다. 12heroku loginheroku create [app-name] json server 사용을 위한 파일을 추가한다.3-1. 프로젝트 루트 디렉토리에 server 폴더 생성3-2. db.json 생성3-3. server.js 생성 후 아래 코드 입력12345678910const jsonServer = require('json-server');const server = jsonServer.create();const router = jsonServer.router('db.json');const middlewares = jsonServer.defaults();const port = process.env.PORT || 3000;server.use(middlewares);server.use(router);server.listen(port); 3-4. package.json에 아래 코드 입력 1234567891011121314151617{ &quot;name&quot;: &quot;json-server-deploy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Simple json database to deploy to the host of your choice&quot;, &quot;main&quot;: &quot;server.js&quot;, &quot;scripts&quot;: { &quot;start&quot;: &quot;node server.js&quot; }, &quot;keywords&quot;: [ &quot;json-server,heroku, node, REST API&quot; ], &quot;author&quot;: &quot;Jesper Orb&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;json-server&quot;: &quot;^0.16.2&quot; }} 3-5. yarn 설치 1yarn install 코드 출처 3-6. gitignore에 node_modules 추가 heroku에 배포하기git add, git commit 후 heroku 서버에 push해주면 끝!1git push heroku master 👾 heroku로 배포한 도메인에 몇 시간 동안 접속 요청이 없는 경우, 앱이 수면 상태로 전환되어 초기 접속이 느력진다. 이때 수면 상태로 전환되는 것을 방지하기 위해 계속 request를 보내줄 수 있는 서비스가 있다. 이름도 귀여운 아래 사이트에 도메인을 등록하면 된다.👉 https://kaffeine.herokuapp.com/ Refhttps://velog.io/@jjunyjjuny/Node.js-프로젝트-배포하기-Heroku - styled-component에서 css 객체 사용하기아래와 같이 import하여 객체 프로퍼티 값으로 활용할 수 있다. 123456789101112131415161718import styled, { css } from 'styled-components';const buttonStyle = { small: css` width: ...; height: ...; ` large: css` width: ...; height: ...; `}const CartButton = styled.button` // ... ${({ type }) =&gt; buttonStyle[type]};` - a11y웹 접근성을 의미한다. ‘accessibility’의 줄임말이다. - currying &amp; partial application모두 함수형 프로그래밍의 기법이다. Partial Application여러 개의 인자를 받는 함수가 있을 때 일부의 인자를 고정한 함수를 만드는 기법이다. 12345678910111213const add = function(a, b) { return a + b;}function partial(fn, x) { return function(y) { return fn(x, y); }}const add10 = partial(add, 10);add10(20); // 30 partial에 의해 만들어진 partial 함수에 고정되지 않은 나머지 인자를 전달해서 add 함수를 호출한다. bind 함수를 쓰면 더 깔끔하다. 12const add10 = add.bind(null, 10);add10(20); // 30 CurryingPartial Application처럼 인자를 미리 고정할 수 있지만 하나씩만 고정한다. 또한 모든 인자를 받을 때까지 계속 함수를 생성한다. 12345678910function addThree(x) { return function(y) { return function(z) { return x + y + z; } }}// 인자를 하나씩 세 번 받아야 호출된다.addThree(1)(2)(3); // 6 curry는 함수 조합의 경우 등에 유용하게 사용될 수 있다. Refhttps://blog.rhostem.com/posts/2017-04-20-curry-and-partial-applicationhttps://www.zerocho.com/category/JavaScript/post/579236d08241b6f43951af18 - propTypes vs TypeScript Typescript: 정적인 타입 체크PropTypes: 런타임 타입 체크 TypeScript를 쓸 때는 PropTypes가 필요 없다. PropTypes는 pure JS로 개발할 때 사용한다. 👾 Flow라는 것도 있다. JavaScript 코드를 위한 정적 타입 체커로, 페이스북에서 개발했다. 모듈로 설치해서 사용한다. 1yarn add --dev flow-bin 다음 명령어를 통해 실행시킨다. 1yarn run flow init @flow를 주석으로 작성하여, 코드 작성 시 타입을 명시해줄 수 있다. 1234567// @flowfunction concat(a: string, b: string) { return a + b;}concat(&quot;A&quot;, &quot;B&quot;); // Works!concat(1, 2); // Error!` 첫 번째 링크는 크루 차얀의 블로그Refhttps://chayan.oopy.io/a5278e0d-99b5-4cf9-96cc-4f3317f5bc00https://davemn.com/2020-07/typescript-vs-proptypeshttps://ko.reactjs.org/docs/static-type-checking.htmlhttps://flow.org/en/docs/types/ - VFC, FC‘VFC(Void Function Component)’ 타입은 prop으로 children을 받지 않음을 명시한다. 그러나 임시적으로 react에서 제공하고 있는 타입이라 사용하지 않는 것이 좋다. @types/react 18 version에서 deprecated될 버전이다. ‘FC(Function Component)’ 역시 사용하지 않는 것이 좋다. (Ref) - CSS-in-JS vs CSS-in-CSSCSS-in-JS👍 장점 Global namespace: class명이 build time에 유니크한 해시값으로 변경되기 때문에 별도의 명명 규칙이 필요하지 않다. Dependencies: CSS가 컴포넌트 단위로 추상화되기 때문에 CSS 파일(모듈)간에 의존성을 신경 쓰지 않아도 된다. Dead Code Elimination: 컴포넌트와 CSS가 동일한 구조로 관리되므로 수정 및 삭제가 용이하다. Minification: 네임스페이스 충돌을 막기위해 BEM 같은 방법론을 사용하면 class명이 길어질 수 있지만, CSS-in-JS는 짧은 길이의 유니크한 클래스를 자동으로 생성한다. Sharing Constants: CSS 코드를 JS에 작성하므로 컴포넌트의 상태에 따른 동적 코딩이 가능하다. Non-deterministic Resolution: CSS가 컴포넌트 스코프에서만 적용되기 때문에 우선순위에 따른 문제가 발생하지 않는다. Isolation: CSS가 JS와 결합해 있기 때문에 상속에 관한 문제를 신경 쓰지 않아도 된다. 👎 단점 번들 크기가 커진다. 인터랙션이 늦다. 성능에 초점을 맞춘다면 CSS-in-CSS를, 개발 생산성에 초점을 맞춘다면 CSS-in-JS를 사용하는 것이 좋다. Refhttps://blueshw.github.io/2020/09/14/why-css-in-css/https://blueshw.github.io/2020/09/27/css-in-js-vs-css-modules/ 질문하기Middlware Clousure와 Currying의 차이는 무엇일까요? Currying을 실생활에 적용한 적이 있다면 Middleware말고 어디에 또 있을까요? Redux에서 Middleware가 필요한 이유는 무엇이며 비동기 처리를 Middleware로 해야할 이유는 무엇일까요? Front-end TDDRefhttps://ui.toast.com/fe-guide/ko_TESThttps://ui.toast.com/weekly-pick/ko_20181226https://ui.toast.com/weekly-pick/ko_20190116 기타TTFBTime To First Byte의 약자로, HTTP 요청을 했을 때, 처음 byte(정보)가 브라우저에 도달해서 이 정보가 브라우저에서 프로세싱이 시작되는 시간을 측정해 이 시간을 TTFB라고 한다. 브라우저의 성능에 따라 TTFB는 달라지며, 브라우저가 아닌 TTFB를 측정해주는 웹 서비스를 사용해서 확인해야 한다. TTFB는 서버의 성능속도를 보여주는 척도로 사용될 수 있다.또 TTFB가 좋게 나올수록 구글의 SEO 랭킹이 높아지기 때문에, 고려해야 할 부분이기도 하다. Refhttps://hackya.com/kr/ttfb-에-대한-개념탑재를-해봅시다/ 스토리북 배포하기Refhttps://storybook.js.org/tutorials/intro-to-storybook/react/ko/deploy/ Under the hood - ReactRefhttps://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/ Redux ToolkitRefhttps://jbee.io/react/introduce-redux-starter-kit/ 마무리스승의날 파티도 있었고, 코치 없는 코치의 생일 파티도 했다. 5월은 정말 화려보스…Lv2도 끝나가고 날씨도 덥고, 비가 오면서 조금씩 처지는 기분이다. 아, 배달의민족 COO 한명수님의 말랑특강은 정말 유익하고(?) 충격적이었다…나중에 다시봐야겠다. 캡틴 포비의 나태해지고 있다는 말에 상처 받은 크루들이 있는 것 같다. 아무 생각도 들지 않는 나는 뭘까 🤔거의 그냥 되는대로 살고 있는 것 같다. 큰 부담도 없고, 별 생각도 없다. 해탈한 걸까","link":"/2021/05/15/woowa-week-15/"},{"title":"우테코 30주차 기록","text":"놀토 UI 개편 | 성능 베이스캠프 놀토 프로젝트UI 전면 개편 &amp; 반응형 만들기카드형 UI를 전면 개편하면서 각 페이지의 반응형 대응을 본격적으로 시작하고 있다. 아기자기 귀엽고 특색 있는 UI도 좋지만, 사용자에게 보다 콘텐츠를 깔끔하게, 적절한 개수를 보여줄 수 있는 UI가 필요한 것 같다. 지난번 UT들에서도 ‘한 번에 더 많은 피드를 볼 수 있으면 좋겠다’라는 의견이 많이 나오기도 했고. 카드 UI는 레진코믹스를 많이 참고했다. 이미지를 보다 확실하게 크게 보여주고, 하나의 열에 보여주는 컨텐츠의 개수를 늘렸다. 그리고 shadow를 없애 보다 플랫하게, 깔끔하게 가기로 했다. 카드 좌측 상단의 flag도 레진코믹스를 거의 따라했다(ㅎ) &lt;레진코믹스 메인페이지&gt; &lt;개편 중인 놀토 페이지&gt; 반응형 작업은 디바이스의 break points 별로 딱딱 요소의 크기나 폰트 사이즈를 변경하는 대신, 뷰포트의 크기에 맞춰서 스무스하게 조절될 수 있도록 rem이나 px 대신 % 단위를 사용하고 있다. 모바일에서도 쉽게 사용할 수 있을 정도의 UI가 완성되면 Lv4가 끝나기 전 PWA에도 도전해보고 싶다. 아직까지도 고생 중인 부분은 헤더다. 위에서 언급한 레진코믹스 외에도 에어비앤비, 오늘의집, 네이버웹툰 등의 페이지를 참조하고 있는데, 작디 작은 모바일 화면에서 무엇을 삭제할지, Navigation 메뉴들의 배치는 어떻게 할지 감이 잡히질 않는다. 페어와 오래오래 고민하고 토론한 끝에 우선은 한 차례 의사결정이 된 듯하다. 개발 후 모양이 나와봐야 알겠지만, 완벽하진 않더라도 사용자가 한 눈에 봤을 때 이해할 수 있는 UI를 제작하고 싶다. 페이지네이션 api인피니티 스크롤 구현을 위해 백엔드와 페이지네이션 api를 논의했다. 유튜브의 search api를 참고하여, 필수적으로 필요한 results와 pageToken이 있으면 된다고 생각했다. results는 한 번에 가져올 컨텐츠의 개수를, pageToken은 다음에 불러올 page의 고유한 식별자를 가리킨다. 여기에 추가적으로 다음 페이지의 존재 여부를 확인하는 hasNextPage 정도의 필드가 응답에 있어야 하지 않을까? 생각했다. 그런데 까다롭게 고려해야 할 부분이 있었다. 무한 스크롤 도중 최신 피드가 추가된다면? 피드는 최신순으로 가져와야 하기 때문에, 늦게 생성된 id의 피드부터 불러온다. 총 10개의 피드가 있다고 가정해 보자. 0번째 페이지를 불러오며 10/9/8번 피드(최신순)를 가져온다. 다음 스크롤에서 1번째 페이지를 불러오며 7/6/5번 피드를 가져온다. (2번째 페이지를 불러오기 전에) 11번 피드가 추가된다. 0번째 페이지에는 11/10/9번 피드가, 1번째 페이지에는 8/7/6번 피드가, 2번째 페이지에는 5/4/3번 피드가 포함된다. 즉 앞서 불러온 5번 피드는 11번 피드의 추가로 인해 중복으로 불러와지는 문제가 발생한다. 피드의 추가 뿐 아니라 삭제 시에도 문제가 발생한다. 5개의 피드를 가져오는 도중 그 5개에 포함된 피드를 삭제한다면, 5개의 피드를 요청했음에도 4개의 피드만 불러와지는 경우가 발생할 수 있다. 따라서 동적으로 페이지네이션 조건을 적용해야 한다. 놀토 팀에서는 아래와 같이 api를 구성했다. 1/feeds/recent/nextFeedId=7&amp;countPerPage=5 nextFeedId 파라미터를 사용하여 현재 시점 기준으로 다음 순서의 피드부터 가져오게끔 했다. countPerPage는 상기한 유튜브 api의 results와 같다. 응답은 아래와 같다. 12345678910{ feeds: [ { id : 7, ...} { id : 6, ...}, { id : 5, ...}, { id : 4, ...}, { id : 3, ...}, ], nextFeedId: 8 // 또는 null} api 요청 시 countPerPage값을 통해 한번에 불러올 피드의 개수를 지정하고, 서버에서 피드의 배열과 함께 받은 nextFeedId를 다시 전송하여 해당 id보다 작은 id를 가진 피드들을 추가적으로 불러온다. 이때 중간에서 어떤 피드가 삭제되어도 (설령 그게 nextFeedId에 해당하는 피드라 할지라도) nextFeedId보다 id가 ‘작은’ 피드들만 불러오면 되기 때문에 문제없이 피드를 순서대로 받아올 수 있다. 현재 상태에서 가장 마지막 페이지, 즉 nextFeedId가 없을 때에는 null을 반환하여 클라이언트에서 더 이상 요청을 보내지 않도록 한다. 👾 새로운 피드가 추가되었을 때 가장 최신 피드를 즉시 불러올 방법은 없지만, 놀토는 피드의 실시간 업데이트가 중요한 SNS와 같은 플랫폼이 아니기 때문에 반영하지 않았다. Refhttps://wbluke.tistory.com/18https://jojoldu.tistory.com/528 프론트엔드로딩 성능 개선 강의공원의 섬세하고 친절한 프론트엔드 로딩 성능 개선 강의가 있었다. 간만에 모르는 개념들이 와르르르 쏟아지다보니 정신이 없었지만 다시 잘 주워 담는 중이다. ✅ 요청 다이어트 Network 탭의 워터폴 차트에서 다운로드 시간을 줄여보자. 놀토의 bundle.js 파일 로드 시간도 꽤나 오래 걸리고 있다. (아직 성능 개선 전이므로^^) TTFB(Time To First Byte)는 서버의 문제! ✅ 소스코드 압축 minify &amp; uglify는 webpack에서 자동으로 해준다. CSS-in-JS도 babel transpile 과정에서 minify된다. brotli, gzip 등의 압축 방식이 있다. 브라우저는 압축된 상태로 받은 리소스를 다시 압축 해제해서 사용한다. ✅ 이미지 &amp; 폰트 해상도 조절을 위해 image resize를 활용하자. srcset을 활용해 각 디바이스별로 충분한 크기의 이미지를 사용하자. 이미지의 포맷 변경과 압축, 메타 정보(EXIF)를 제거하여 더욱 용량을 줄일 수 있다. 이미지 포맷들 중 png, webp, jpeg, gif의 특징을 잘 알고 비교하여 사용하자. progressive jpeg도 좋은 방법! 애초에 이미지를 불러오지 않고, svg나 css 등 코드로 해결할 수 있는 부분은 없는지 생각해 보자. subset을 활용하여 한글 폰트에 대응하자 font-display 속성을 활용 웹폰트 로드 여부에 관계없이 항상 텍스트가 보이게 하려면 swap, fallback, optional (fallback, optional은 100ms의 매우 짧은 시간 동안만 텍스트가 로딩되지 않는다.) 값을 사용하자. ✅ 브라우저의 호스트 당 최대 Connection 수 제한 Domain Sharding에 대해서 알아보자. Domain sharding은 리소스를 여러 개의 서브 도메인으로 나눠서 다운받는 방법이다. 브라우저는 더 많은 리소스를 한번에 더 많이 받을 수 있으며, page load time을 향상시킬 수 있다. 하지만 각 도메인과의 연결을 생성할 때마다 비용이 발생한다는 문제가 있다. HTTP2는 multiplexing 기능을 지원하기 때문에, Domian sharding을 사용할 필요가 없다. HTTP/2는 뭔가 다르다! 뭐가 다를까? 손너잘의 테코톡을 통해 확인해보자. Server push를 통해 서버에게 맡기는 방법도 있다. 클라이언트가 요청하지 않은 JS, CSS, font, 이미지 파일 등과 같이 필요하게 될 특정 파일들을 서버에서 단일 HTTP 요청 응답 시 함께 전송할 수 있다. ✅ 요청 수 줄이기 tree-shaking dynamic import React.lazy, Suspense lazy loading &amp; IntersectionObserver route별 code splitting 이미지는 sprite를 사용하거나 css, svg 코드로 대체하자. ✅ 미리 가져오기 preload 미리 리소스를 받아와서 브라우저에 캐시해 둔다. 브라우저에 명시적으로 우선순위를 지정해준다. onload 핸들러가 필요하다. 폰트나 LCP에 영향을 미치는 요소에 적용하면 좋다. prefetch 브라우저에게 미래에 필요할 수 있는 전체 페이지, 혹은 특정 리소스(script, css 등)를 미리 다운로드 받아두라고 알려준다. 렌더링이 다 끝난 이후라 블로킹이 되지는 않는다. 페이징된 목록에서 다음 페이지의 컨텐츠 등을 불러올 때 사용할 수 있다. 웹팩에서는 chunk로 다 나누고 불러오는 과정으로 설정 preconnect 브라우저에게 서버와 연결만 미리 맺어두고 있으라고 알려준다. defer와 async defer는 HTML 파싱이 끝날 때까지 스크립트 실행을 지연한다. HTML 파싱이 모두 끝난 후, DOMContentLoaded 이전에 실행된다. async는 DOMContentLoaded나 다른 스크립트들과는 독립적으로 동작한다. 스크립트를 다운 받는 동안에 HTML 파싱을 차단하지는 않지만, 스크립트가 실행되는 동안에는 HTML 파싱이 중단된다. ✅ 캐시 메모리 캐시 vs 디스크 캐시 메모리 캐시는 RAM에 저장하여 휘발된다. 작지만 속도가 빠르다. 디스크 캐시는 CPU에 저장되므로 영구적으로 보존된다. Cache-Control no-store: 캐시 불가능. 매번 서버에서 새로 받아와야 한다. no-cache: 캐시 가능하긴 하지만 origin 서버에 매번 캐시 유효성 검증 요청을 보낸다. must-revalidate: 캐시는 사용하기 이전에 기존 리소스의 상태를 반드시 확인해야 하며 만료된 리소스는 사용되어서는 안된다. 조건부 요청 Last-Modified → If-Modified-Since로 확인 ETag → If-None-Match로 확인 유효 기간 설정 max-age Expires ✅ CDN Cache-Control public: 중간 프록시(ex. CDN)에도 캐시를 저장할 수 있다. private: 최종 끝단의 클라이언트에만 캐시가 가능하다. 리소스 업데이트를 반영하기 위해 정적 리소스에 고유한 값(ex. bundle의 chunk hash)을 사용하거나 cache busting, caching purge 등을 알아보자. 공부하기img onError&lt;img&gt; 태그에 onError 속성이 있었다! img 태그에 사용한 이미지의 링크가 존재하지 않아 엑박이 뜨는 경우 사용한다. 12345678return ( &lt;img src={feedDetail.thumbnailUrl} onError={(event: SyntheticEvent&lt;HTMLImageElement&gt;) =&gt; { event.currentTarget.src = DEFAULT_IMG.FEED; }} /&gt;) CSS의 background-image로 쓰고 싶다면 url을 2개 넣어주면 된다. 두 번째 url에 이미지 에러 시 들어갈 디폴트 url 주소가 들어간다. styled-components 사용 시 아래와 같이 작성한다. 12345const FeedContainer = styled(Card)&lt;{ imageUrl: string }&gt;` background-image: url(${({ imageUrl }) =&gt; imageUrl}), url(${DEFAULT_IMG.FEED}); background-size: cover; cursor: pointer;` transition maxHeight요소의 height를 스무스하게 늘렸다 줄였다 할 수 있도록 transition을 줘야 하는데, 그게 요소의 자식 컨텐츠의 양에 따라 height가 변하는 상황이라면? 요소의 height를 fit-content로 주면 되겠지만, transition을 사용하기 위해서는 height에 px등의 단위로 고정값을 줘야 한다. 즉 fit-content를 사용한 요소는 transition이 먹지 않는다! 이때 max-height 값을 사용할 수 있다. max-height를 넉넉히 계산해서 먹이면, 마치 자식 컨텐츠의 크기에 따라서 부모 요소의 height가 움직이는 것처럼 보인다. 123456789101112131415161718const SubCommentWrapper = styled.div&lt;{ $isFold: boolean; isReplyFormVisible: boolean; replyCount: number;&gt;` // ... transition: max-height ${({ $isFold }) =&gt; ($isFold ? '0.35s ease' : '0.85s ease')}; max-height: ${({ $isFold, isReplyFormVisible, replyCount }) =&gt; { if ($isFold) return 0; let height = 0; if (isReplyFormVisible) height += 30; return `${replyCount * 50 + height}rem`; }};`; 답글의 개수와 각 답글의 줄 수에 따라서 height가 부드럽게 조절되는 것을 볼 수 있다. Generic function in TypeScriptTypeScript로 함수를 작성할 때 제네릭을 사용하는 방식을 알아보자. 아래와 같은 type alias가 있을 때, 제네릭 타입 T에 string과 같은 특정한 타입을 넣어 함수를 만들 수 있다. 12type ComparatorType&lt;T&gt; = (a: T, b: T) =&gt; number;const comparator: ComparatorType&lt;string&gt; = (a, b) =&gt; a.length - b.length; 이번엔 type alias문에서 제네릭 선언부의 위치를 함수 매개변수 바로 앞으로 옮겨보자. 1type ComparatorFunction = &lt;T&gt;(a: T, b: T) =&gt; number; 이 상태만으로는 에러가 발생하지 않는다. 하지만 위 타입을 사용해서 똑같이 실제 함수 선언을 작성하면 에러가 발생한다. 12const comparator: ComparatorFunction&lt;string&gt; = (a, b) =&gt; a.length - b.length;// type 'ComparatorFunction' is not generic 왜일까? 🤔 두 번째 type alias에서는 제네릭 함수 타입의 ‘값’ 이 제네릭이기 때문이다. 이는 미래에 선언할 서로 다른 구체적인 함수 타입들의 모든 집합과도 같다. 제네릭 함수 타입에서, 타입 파라미터는 함수 파라미터 앞에 &lt;&gt;로 묶어서 작성한다. 제네릭 함수의 타입 자체는 제네릭이 아니다. 따라서 위에서 Comparator 자체에는 타입 파라미터가 없으므로, Comparator&lt;string&gt;과 같이 사용할 수 없다. 함수를 호출할 때 비로소 타입을 명시해줘야 한다. 12declare const comparatorFunc: ComparatorFunction;const comparator = comparatorFunc&lt;string&gt;('apple', 'banana'); 아래 두 type alias의 차이점을 정리해 보자. 12type ComparatorType&lt;T&gt; = (a: T, b: T) =&gt; number;type ComparatorFunction = &lt;T&gt;(a: T, b: T) =&gt; number; 첫 번째 type alias는 구체적인 함수의 선언을 가리킬 제네릭 타입이고, 두 번째 type alias는 제네릭 함수를 가리키는 특정한 타입이다. Refhttps://stackoverflow.com/questions/58770087/generic-function-type-aliashttps://www.typescriptlang.org/docs/handbook/2/generics.html useEffect 내부에서 async를 지양하는 이유미션의 코드 중에 아래와 같은 코드가 있었다. useEffect 안에서 바로 async 함수를 사용하여 api 호출을 하고, cleanup 함수를 통해 컴포넌트 언마운트 시 loading 상태를 다시 바꿔준다. 12345678910useEffect(async () =&gt; { if (loading) { const gifs = await fetchTrendingGifs(); setGifList(gifs); setLoading(false); } return () =&gt; setLoading(true);}, []); 그러나 이 코드에서 cleanup 함수 즉 return문은 실행되지 않는다!async 함수는 항상 Promise를 리턴하기 때문에 Promise가 fulfilled 상태가 되기 전까지는 값을 반환할 수 없기 때문이다. 따라서 useEffect 안에서 async 함수를 곧바로 사용하는 것은 지양해야 한다. 위 코드는 아래와 같이 바꿀 수 있다. async 함수를 별도로 분리한 후 호출하는 방식이다. 1234567891011121314const loadTrendingGifs = async () =&gt; { if (loading) { const gifs = await fetchTrendingGifs(); setGifList(gifs); setLoading(false); }}useEffect(() =&gt; { loadTrendingGifs(); return () =&gt; setLoading(true);}, []); Ref https://dev.to/danialdezfouli/what-s-wrong-with-the-async-function-in-useeffect-4jne 기타프론트엔드 성능 최적화 - 자원 다운로드 우선순위 설정prefetch, preload, preconnect 등의 속성을 지정하여 자원 다운로드의 우선순위를 앞당기거나, 미리 외부 도메인과의 연결을 생성할 수 있다. 이미지나 웹 폰트를 미리, 병렬적으로 다운로드하여 사용자 경험을 개선할 수 있다. Ref https://codingmoondoll.tistory.com/entry/프론트엔드-성능-최적화-6-자원-다운로드-우선순위-설정 웹 서비스 캐시 똑똑하게 다루기\bCache-Control 헤더를 통해 캐시의 생명 주기를 관리할 수 있다. Cache-Control의 구체적인 값으로는 max-age, Expires 등을 설정한다. 리소스의 유효 기간이 지나기 전이라면, 서버에 요청을 보내지 않고 메모리 캐시에서 자원을 가져오며 이는 네트워크 탭의 ‘from memory cache’ 항목을 통해 확인할 수 있다. 캐시의 유효 기간이 지났다면 서버에 재검증 요청을 보내는데, 이때 If-None-Match, If-Modified-Since 요청 헤더를 사용한다. 브라우저 캐시가 유효하다면 서버는 HTTP 본문을 포함하지 않는 ‘304 Not Modified’ 응답을 내려준다. no-cache 값은 캐시는 저장하지만 사용할 때마다 서버에 재검증 요청을 보내는 것을, no-store 값은 절대로 캐시를 저장하지 않음을 의미한다. 캐시를 없애는 방법으로는 CDN invalidation을 사용할 수 있는데, CDN 캐시를 삭제한다고 해서 브라우저 캐시가 삭제되지는 않는다. CDN과 같은 주간 서버가 특정 리소스를 캐시할 수 있는지 여부는 Cache-Control 헤더 값의 public과 private로 구분한다. 이때 중간 서버에서만 적용되는 max-age 값은 s-maxage 값으료 표기한다. Ref https://toss.tech/article/smart-web-service-cache GIF 사용을 멈춰주세요!gif는 각 프레임의 모든 픽셀에 대한 정보를 무손실 압축 데이터로 담고 있다. 또한 gif는 GPU에서 디코딩하지 못하기 때문에 CPU 사용량이 증가한다. 비디오 포맷들은 기본적으로 손실 압축을 사용하며, 다양한 최적화 기술들이 들어가 있다. H.264와 같은 비디오 포맷들은 대부분의 플랫폼에서 호환이 잘 된다. → gif 대신 mp4 등의 비디오 확장자를 사용하자! WebP/WebM을 사용할 수도 있지만, 낮은 보급률과 플랫폼 지원, 하드웨어 가속 디코딩에 대한 지원 부족 등의 문제가 있다. Ref https://medium.com/vingle-tech-blog/stop-using-gif-as-animation-3c6d223fd35a 실전 UI/UX - 무인양품앱 UI/UX 컨설팅Ref https://brunch.co.kr/@fbrudtjr1/16 New Suspense SSR Architecture in React 18Ref https://github.com/reactwg/react-18/discussions/37 웹 접근성 이해 (부스트코스)Ref https://www.boostcourse.org/web201 자바스크립트 함수 파헤치기Refhttps://meetup.toast.com/posts/118https://meetup.toast.com/posts/123https://meetup.toast.com/posts/129 TypeScript, any 쓸거면 버려라 class와 interface의 찰떡 조합 무엇이 TS를 TS답게 하는가 infer 매직: 중복 정의 없이 파생된 값에 추적성 부여하기 Ref https://github.com/NAVER-FEPlatform/FEDevtalk/blob/master/18_fedevtalk.md 웹 성능 핵심개념 - Critical Rendering Path크루 하루의 정리글. 레이아웃을 다시 그리는 비용을 줄이기 위해 레이아웃의 ‘스코프’를 제한할 수 있다. CSS로 레이아웃 바운더리를 만들어 전체 문서를 reflow시키는 대신 특정 스코프만 reflow시킨다. Ref https://365kim.tistory.com/152 마무리T사의 신입 채용 때문에 우테코 전반이 시끌시끌하다. 최종까지 간 크루도, 중간에 떨어진 크루들도 모두 이런저런 생각이 들 것 같다. 다같이 싱숭생숭해질 수도 있는 이 시기에, 모두 축하할 크루들은 축하해주고 남은 크루들은 실패했다는 생각보다는 다시 끈끈하게 서로를 붙잡고 목표를 향해 정진해야 할 때인 듯하다. 팀 프로젝트와 개인 공부의 밸런스도 잘 잡아야 할텐데, 둘 다 자꾸 욕심은 생기고 부담감은 가중되는 게 사실이다. 아직도 어른스럽지 못한 순간들이나 지레 긴장하여 당황하는 모습을 보이곤 하는데, 그럴 때마다 이야기 들어주고 차분하게 도와주는 페어 미키에게 많이 고맙다. 곤이, 크리스에게도! 감동크루 사연은 왜 매주 받지 않는 걸까? 아무튼, 내 기분이 주변을 힘들게 하지 않도록 더욱 단단해지자. 여태까지 놀았던 것도 아니고, 앞으로도 후회없이 공부하자! 거의 두 달 만에 번개(?)로 놀토 팀원들을 오프라인에서 만났다. 2명씩 찢어져서 서로 가벼운 인사 정도밖에 하지 못했지만, 모니터 속 가상의 인물들만 보다가 오랜만에 서로 잘 살아있음을 확인하니 기분이 색달랐다. 미키랑 밥도 먹으면서 이런저런 사는 이야기… 마지막은 모두 지쳐도 오늘 하루는 다시 빠이팅해보자는 우리 팀원들의 귀여운 그림 실력","link":"/2021/09/04/woowa-week-30/"},{"title":"우테코 37주차 기록","text":"마지막 QA | 마지막 데모데이 놀토 프로젝트놀토 프로젝트가 드디어 막을 내렸다. 며칠 동안 자잘한 (대부분은 UI) 버그들도 고치고, cookie도 수정하고, 구조 도식화도 하고, 거의 팀원들과 떠들기만 하고, 배포를 시도할 때마다 꼬여버리는 github도 겨우 해결했다. 아! 갈수록 난장판이 되어갔던 노션도 정리했다. 게더타운으로 진행된 데모데이는 생각보다도 훨씬 재밌고 바빴고 알찼다. 데모데이 전날 밤 우리 팀 부스를 화려하게 꾸미다가 혼나고 (…) 다같이 캐릭터 모자를 맞춰쓰고 열심히 뽈뽈 돌아다녔다. 초반 호객행위를 해서인지 많은 분들이 우리 부스에 와주셨고, 리뷰어님들도 많이 놀러와주셨다. 모두 아낌없는 칭찬과 조언을 해주셔서 더욱 자신감과 힘을 얻을 수 있었다. 마지막으로 온라인 회식을 했다. 직접 만나고 싶었으나 한 팀원의 격리 때문에 😂 줌이 너무나도 익숙해져서인지 오디오가 쉴틈없이 이야기를 주고 받았다. 거의 술도 안먹었으면서. 정말 주제없는 이야기들을 주고받으며 많이 웃고, 또 팀원들의 숨겨진 스토리들을 들으며 서로 더 친밀해진 기분이다. 온라인으로 무려 4시간이나 떠들었다. 그동안 함께 해온 미키, 조엘, 아마찌, 포모, 찰리 그리고 항상 든든한 지원군이었던 코치 구구 정말 고마웠어요 ❤️ 우테코 3기중에 제일 귀여웠던 놀토 팀은 영원할거야 프론트엔드 공부자바스크립트 반응형🍀 여기서 읽기 자바스크립트 Proxy🍀 여기서 읽기 npm은 어떻게 동작할까🍀 여기서 읽기 공부하기구글 SEO 기본 가이드✅ Google이 내 콘텐츠를 찾을 수 있도록 돕기 sitemap을 제출한다. sitemap은 사이트에 있는 파일로서 새 페이지나 변경된 페이지가 있을 때 이를 검색엔진에 알려준다. robots.txt를 사용하여 원치 않는 크롤링을 차단한다. ✅ Google 및 사용자가 내 콘텐츠를 이해할 수 있도록 돕기 Google이 사용자와 같은 방식으로 내 페이지를 인식하도록 한다. Googlebot이 웹사이트에서 사용하는 자바스크립트, CSS, 이미지 파일에 항상 액세스할 수 있도록 허용한다. &lt;title&gt; 요소를 사용하여 고유하고 정확한 페이지 제목을 만든다. &lt;title&gt;은 간단하지만 설명이 담겨 있어야 하며, 각 페이지에 고유한 &lt;title&gt; 요소 텍스트가 있는 것이 좋다. 메타 설명 태그를 사용하여 페이지 내용을 요약하여 제공한다. 설명 메타 태그는 Google 검색 결과에서 페이지의 스니펫으로 사용할 수 있다. ✅ Google 검색결과에 사이트가 표시되는 방식 관리하기 페이지의 구조화된 데이터를 수정하여 Google 검색결과에서 여러 특별한 기능들을 사용해보자. ✅ 사이트 계층 구조 구성하기 검색엔진의 URL 사용 방식을 이해하자. 콘텐츠별로 고유한 URL을 사용하는 것이 좋다. 웹사이트 탐색 기능을 사용하여 방문자가 원하는 콘텐츠를 빨리 찾을 수 있도록 할 수 있다. breadcrumb 등의 UI로 탐색경로의 목록을 사용하거나, 사용자가 사용할 간단한 탐색 페이지를 만들 수 있다. 단순한 URL을 사용하여 콘텐츠 정보를 전달해야 한다. ✅ 콘텐츠 최적화하기 사이트를 재미있고 유용하게 만들어 자연스러운 입소문을 타게 한다(!) 독자가 무엇을 원하는지 이해하고 적절한 콘텐츠를 제공한다. Google Search Console은 인기 검색어를 제공한다. 사용자 신뢰를 구축하는 웹사이트를 만들고, 전문성과 권위를 명확히 드러낸다. 또 주제에 관해 적절한 양의 콘텐츠를 제공하는 것이 좋다. 주의를 분산시키는 광고를 표시하는 것은 지양하며, 사용자와 검색엔진이 탐색하기 쉽도록 링크를 현명하게 사용한다. ✅ 이미지 최적화하기 HTML 이미지를 사용한다. &lt;img&gt; 또는 &lt;picture&gt; 요소 등의 시멘틱 마크업을 사용하면 크롤러가 이미지를 찾고 처리할 수 있다. 이미지에는 alt 속성을 사용해야 한다. 이미지 사이트맵을 사용하여 검색엔진의 탐색을 도울 수 있다. 표준 이미지 형식을 사용한다. ✅ 사이트를 모바일 친화적으로 만들기 모바일 전략을 선택하자. 반응형 웹 디자인, 동적 게재, 별도 URL 등을 구현할 수 있다. 색인이 정확하게 생성될 수 있도록 모바일 사이트를 구성한다. 웹사이트를 홍보하자. 소셜 미디어 사이트를 이해하고, 검색 실적 및 사용자 행동을 분석한다. 또 사이트 사용자의 행동을 분석한다. Refhttps://developers.google.com/search/docs/beginner/seo-starter-guide?hl=kohttps://imweb.me/faq?mode=view&amp;category=29&amp;category2=35&amp;idx=15573 git tag 달기배포할 때마다 매번 찾아봤던 git tag 달기. 우리는 yarn을 사용하기 때문에 package.json의 버전과 맞춰서 sematic versioning을 진행했다. 일반적으로 git tag를 다는 명령어는 아래와 같지만, 1git tag -a v3.0.1 -m &quot;nolto version 3.0.1&quot; yarn을 이용해서 package의 버전을 업데이트할 수 있다. 1yarn version 원하는 버전을 입력하면, package.json의 version 항목과 함께 git tag도 새롭게 반영된 것을 확인할 수 있다. 사파리 모바일의 video playsinline 속성애증의 사파리 모바일 🤯 메인 페이지의 다른 페이지로 이동했다가, 다시 돌아오면 메인 페이지에 로드되는 &lt;video&gt; 태그의 mp4 확장자 파일들이 모두 자동으로 전체화면으로 실행된다. 아래처럼… 이렇게 정신사나울 수가 없다. 알고 보니 사파리 모바일에서는 모든 &lt;video&gt; 태그를 기본적으로 전체화면으로 실행한다고 한다. (대체 왜?) 그래서 &lt;video&gt; 태그에 playsinline 속성을 넣어줘야 하고, 문제는 다행히 해결되었다. nginx gzip 설정프론트엔드를 SSR 서버로 운영하게 되면서 더 이상 정적 호스팅을 위한 cloudfront를 사용할 필요가 없게 되고, 그리하여 cloudfront의 기본 gzip 옵션을 사용할 수 없게 되었다. gzip을 이용하지 않으면 자바스크립트 번들 파일의 크기가 전혀 줄어들지 않은 채로 브라우저에 렌더링되기 때문에, 방법을 찾아야 했다. 현재 서버로 사용중인 express에서도 gzip을 설정할 수 있지만, express 공식 문서에서는 만약 nginx를 사용한다면 nginx에서 gzip을 설정하라고 권고하고 있다. 기본적으로 nginx 역시 cloudfront와 같은 캐시 프록시 역할을 하므로, nginx에서 파일 압축을 수행하는 것이 맞다는 생각이 들었다. 또 express 서버에 파일 압축 업무를 추가하는 건 부담이 될 수도 있으니까? 사용중인 ssh에 접속하여 nginx 설정 파일을 수정해주면 된다. 1vim /etc/nginx/nginx.conf 그리고 gzip과 관련된 설정들을 추가한다. 직접 작성하려고 했는데, 주석처리가 되어있어서 필요한 부분들의 주석을 풀어줬다. 1234567### Gzip Settings##gzip on; gzip_proxied any; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; gzip, gzip_proxied, gzip_type 설정을 만져줬다. gzip: on으로 gzip 설정을 켜준다. gzip_proxied: proxy나 캐시 서버에서 요청할 경우 동작 여부를 설정한다. any로 지정하면 항상 압축하게 된다. gzip_type: text/javascript도 gzip 대상 파일로 설정한다. Refhttps://expressjs.com/ko/advanced/best-practice-performance.htmlhttp://nginx.org/en/docs/http/ngx_http_gzip_module.html#gzip_typeshttps://www.lesstif.com/system-admin/nginx-gzip-59343019.html SSL이 도대체 뭔가요?SSL은 Secure Sockets Layer의 약자로, 인터넷으로 통신을 할 때 보안 통신을 하기 위한 전자 파일이다. SSL 인증서를 서버에 설치하여 SSL 프로토콜을 이용한 보안 통신을 할 수 있다. 최근에는 TLS라는 용어가 더 많이 사용되고 있다. TLS는 Transport Layer Security의 약자로 SSL 3.0 기반의 표준화된 인증 방식이다. 요즘은 SSL보다는 TLS 방식을 더 권장하고 있다. VeriSign이나 Comodo, 그리고 AWS까지 유료 SSL인증서를 발급해주는 기관도 있고, Let’s Encrypt와 같이 무료 인증서를 발급해주는 곳도 있다. 유료와 무료 SSL 인증서 간에 기술적인 차이점은 없다. 다만 유료 SSL 인증서의 경우 인증서를 사용한 사이트에 인증 관련 문제가 생겼을 시 유료 인증서 발급 기관에서는 일정 부분을 배상하게 된다. 무료 인증서의 경우 이러한 배상 체계가 존재하지 않는다. Ref https://devlog.jwgo.kr/2019/04/12/what-is-ssl/ scrollIntoView모든 페이지의 하단에 footer를 추가하니 마이페이지에 스크롤이 생겼고, 그로 인해 새로운 문제를 발견했다. 아래처럼 scrollIntoView를 통해 부드러운 swipe 효과를 내고 있었는데, 1selectedTab.current.scrollIntoView(); 수평 방향의 스크롤이 발생함과 동시에 수직 방향으로는 화면의 아래쪽으로 쑥 꺼져버리는 것이었다! scrollIntoView의 속성을 잘 몰라서 발생한 문제였다. scrollIntoView의 block 옵션은 요소가 스크롤 가능한 조상에서부터 수직 방향으로 어떻게 정렬될지 결정하는 옵션이다. { block: 'start' } - 요소는 조상 요소의 최상단에 위치한다. { block: 'center' } - 요소는 조상 요소의 중간에 위치한다. { block: 'end' } - 요소는 조상 요소의 최하단에 위치한다. { block: 'nearest' } 요소가 조상 요소보다 아래 있다면, 요소는 조상 요소의 최상단에 위치한다. 요소가 조상 요소보다 위에 있다면, 요소는 조상 요소의 최하단에 위치한다. 요소가 이미 보이는 상태라면, 그 자리에 있는다. 기본값이 start로 설정되어 있었기 때문에, 스크롤 가능한 영역에서 수직 방향으로 최상단에 재정렬되어 화면은 아래쪽으로 밀려난 것이었다. 요소가 이미 보이는 상태기 때문에, 수직 방향으로 가만히 있게끔 { block: 'nearest' }를 걸어주었다. 1selectedTab.current.scrollIntoView({ block: 'nearest' }); 문제 해결! Ref https://stackoverflow.com/questions/48634459/scrollintoview-block-vs-inline FE Conf - 컴포넌트, 다시 생각하기당근마켓 원지혁님의 FE Conf 발표영상이다. 컴포넌트의 의존성에 기반하여 React 컴포넌트를 분리하는 하나의 관점을 설명한다. ✅ 비슷한 관심사끼리 함께 두기비슷한 관심사라면 가까운 곳에 둠으로써 코드의 사용성을 높인다. 대표적으로 하나의 컴포넌트에서 사용하는 스타일(styled-components 등)과 로직(custom hooks)는 컴포넌트 파일에 내재하거나, 동일한 폴더 내에 다른 파일에서 관리할 수 있다. ✅ 데이터를 ID 기반으로 정리하기특정 interface를 가지고 있는 모델 인스턴스 데이터를 다른 컴포넌트에 통째로 넘겨주는 것이 아니라, 필요한 데이터의 id만 넘겨준다. Global ID(또는 Node ID)는 도메인 내에서 유일성을 갖는 ID 체계로, API 요청 시 Global ID를 전달하여 데이터를 가져올 수 있다. 이러한 방식을 GOI(Global Objet Identification)이라고 부른다. 12345678910111213interface Props { articleId: string;}const Something: React.ExoticComponent&lt;Props&gt; = (props) =&gt; { const article = useNode({ on: 'Article' }, props.articleId); return ( &lt;div&gt; &lt;h1&gt;{article.title}&lt;/h1&gt; &lt;/div&gt; );} useNode와 같은 컨셉은 GraphQL과 Relay에서 차용했다고 한다. ✅ 이름 짓기 - 의존한다면 그대로 드러낸다.아래와 같은 interface보다는, 12345678interface Props { leftImageThumnailUrl: string; title: string; title2: string; caption: string; rightDotColor: string; rightcaption: string;} 다음 interface가 모델 간의 연결 정보를 더욱 명확하게 드러내고 있다. 1234567891011interface Props { user: { name: string; nickname: string; totalFollowerCount: number; lastActivityAt: Date; image: { thumbnailUrl: string; } }} 그러나 이 경우 props로 데이터를 넘겨주는 상위 컴포넌트가 항상 정확하게 타이핑을 해서 데이터를 보내줘야 한다는 문제가 있다. 이때 다시 한번 전역 ID를 통해 필요한 객체의 레퍼런스만 받아와 의존성이 느슨한, 재사용 가능한 컴포넌트를 만들 수 있다. 4. ✅ 모델 기준으로 컴포넌트 분리하기얼핏 보면 거의 비슷한 두 컴포넌트가 있다. 이럴 때 기존에 있던 컴포넌트를 재사용할지, 아니면 복사해서 새 컴포넌트로 분리할지 고민이 된다. (실제로 엄청 많이 마주한 문제다!) 발표에서는 다음과 같은 기준을 제시한다. 같은 모델을 의존하는 컴포넌트는 재사용,다른 모델을 갖는 컴포넌트는 분리하자. 이를 위해 리모트 데이터 스키마(API 데이터)를 주의깊게 관찰해야 한다. 마지막으로 인상 깊었던 조언! “질문이 정답보다 중요하다”“관점이 기술보다 중요하다”그리고, 기술 도입이 성공하기 위해서는 유저 경험에 이르기까지 영향을 미칠 수 있어야 한다. 프론트엔드 개발자로서 가져야 할 좋은 마인드! Ref https://www.youtube.com/watch?v=HYgKBvLr49c 기타자바스크립트로 오징어게임 만들기진짜 광기.. Ref https://dev.to/0shuvo0/i-made-squid-game-with-javascript-10j9 개발자 김민준님 인터뷰모두가 공감하는 말, 좋은 동료들이 최고의 복지다! Ref https://www.youtube.com/watch?v=pf9Rj3GKhBA Apple system-ui를 대체할 폰트, Pretendard데모데이날 리뷰어 발리스타님이 오셔서 추천해주고 가셨다. Apple의 system-ui 폰트들과 Noto Sans의 아쉬운 점들을 보완한, 크로스 플랫폼을 지원하는 폰트다. (윈도우에서도 사용 가능!) Ref https://cactus.tistory.com/306 development mode는 어떻게 동작하는가?Ref https://overreacted.io/how-does-the-development-mode-work/ 언어별로 부동소수점 알려주는 사이트도메인이 진짜 광기… Ref https://0.30000000000000004.com/ A레코드 vs CNAME도메인 네임을 다는 두 가지 대표적인 방법 A레코드 - EC2 등을 이용한 ip 주소에 직접 걸어준다. CNAME - AWS cloudfront를 이용하면 https://d2y0p6hv0hkdrd.cloudfront.net과 같은 랜덤 네임을 자동으로 붙여주는데, 그에 CNAME으로 별칭과 같이 이름을 붙여준다. 면접관은 도대체 무슨 생각을 할까?썸네일은 크게 와닿지 않는데, 최근 본 영상들 중에 가장 인상 깊었다. Ref https://www.youtube.com/watch?v=7ye03TMi5SU&amp;t=333s 캡틴 로이드의 ‘잘 정리된 이력서보다 중요한 것’✅ 지원동기가 명확한가“동기”를 어떻게 만들어낼지 판단하게 된다. ‘동기부여’는 누군가 주입하는 것이 아니라, 스스로 하는 것이다. ✅ 어떻게 일하는가혼자서 일하는 회사는 없다. 어떤 규모에서, 어떤 사람들과 함께 일했는지를 밝히자. ✅ 퍼포먼스를 내는가회사는 현재 조직에 없는 사람, 더 나은 성과를 낼 수 있는 사람을 기대한다. 같은 일을 할 때 더 큰 성과를 낼 수 있음을 증명해야 한다. 과정만큼 결과는 중요하고, 퍼포먼스를 ‘내고 싶은 것’과 ‘내왔던 것’은 다르다. ✅ 어려움을 겪었는가어려움의 경험은 스스로 성찰하는가를 알게 하며, 어려움의 경험 이후로 실제로 성장했는지 알게 한다. ✅ 본인에 대해 잘 이해하는가팀과 나의 지향점이 맞는지를 판단하게 한다. 그리고 최근 어디선가 들은 질문, 내가 시니어 개발자라면, 누굴 뽑을 것인가? Ref https://minieetea.com/2021/04/archives/6193 마무리이렇게 레벨 4가 끝났다. 모든 프로젝트, 미션이 끝났다. 그와 동시에 이제 피할 수 없는 시간이 찾아왔다. 위드코로나가 시작되는 다음주부터는 루터에 등교해도 되고, 이제 2주만 있으면 우형 면접이다. 12월까지 이어지는 면접 전형이 너무 길다고 생각했는데, 생각해보면 어쩔 수 없는 결정이었던 것 같다. 결과에 상관없이 우테코가 끝나면 필히 오열할 것이라고 했는데, 데모데이가 끝난 지금 아직 오열하진 않았다. 조금(많이) 뭉클하긴 했다. 어쩜 조와…","link":"/2021/10/27/woowa-week-37/"},{"title":"우테코 Lv1 Lotto PR로그","text":"우테코 Lv1 Lotto PR로그 1️⃣단계 ES6이후로는 함수 Object Contructor 문법은 잘 사용하지 않는다 → function 대신 class로 작성하기 ES5 문법(함수)로도 충분히 구현 가능하겠지만 OOP를 쉽게 구현하기 위해 나온 ES6의 class를 사용하자 상속과 캡슐화 등등을 표현하기 좋고 this 관리도 편하다. Controller가 Model과 View를 멤버로 가지는 동시에, 역할도 알맞게 위임하기 직접 css style을 건드리는 대신, class 이용하기 Ref https://ko.javascript.info/styles-and-classes style보다 CSS 클래스를 수정하는 것을 더 우선시해야 한다. style은 클래스를 ‘다룰 수 없을 때’만 사용해야 한다. DOM이 load됐을 때 App 실행하기 12345const App = () =&gt; { init();};window.addEventListener('DOMContentLoaded', App); 습관적인 (필요 없는) 리턴 주의하기 1234// Badexport const hideElement = (element) =&gt; { return element.classList.add('d-none');}; App에서 controller, view를 연결하는 새로운 방법 12345678910111213141516171819202122export default class App { constructor() { this.$target = $('#app'); this.setup(); } execute() { this.mountComponent(); } setup() { this.gameManager = new GameManager([]); } mountComponent() { this.gameInput = new GameInput({ gameManager: this.gameManager, }); this.gameDisplay = new gameDisplay({ gameManager: this.gameManager }); }} class에서 dom과 event 메소드들 묶기 12345678class GameClass { constructor(props) { this.props = props; this.selectDOM(); this.bindEvent(); }} 🤔 id vs data-*? 페이지의 유일한 엘리먼트라면 id, 비슷한 성격의 것들이라면 data-* class는 스타일을 위한 것이므로 class로 여러 개를 가져와서 조작하는것은 깨지기 쉽다. html에 간략한 섹션 설명 달기 12&lt;!-- purchase amount input form --&gt;&lt;form class=&quot;mt-5&quot; id=&quot;purchase-amount-form&quot; novalidate&gt; novalidate form 태그의 novalidate 속성은 폼 데이터(form data)를 서버로 제출할 때 해당 데이터의 유효성을 검사하지 않음을 명시한다. 타입은 bool 쉴드패턴: 값의 유효성 검사 후 값이 유효하지 않다면 함수의 진행을 중단시켜서(즉시 return) 유효하지 않은 데이터로 로직이 도는것을 막는 코딩 패턴 사용자가 입력한 input값을 검증하는것은 단지 유효성을 검사할 뿐이고 만약 그 값이 유효하지 않다고 한들 그것이 예외가 발생한것은 아니다. ‘예외’는 외부 시스템에 연결해서 응답을 받아야 하는데 외부 시스템이 꺼져있다든지, 파일에 데이터를 쓰려고(write) 하는데 파일이 없는 등 더 이상 처리할 수 없는 ‘에러’가 발생한 상태이거나 throw로 에러를 낸 상태를 가리킨다. 이 때 이 에러를 잡아서(catch) 시스템이 죽지 않도록 처리 하는 것이 익셉션 핸들러의 역할이다.) class private property 사용 1234567891011export class Lotto { #numbers; constructor(numbers) { this.#numbers = numbers; } get numbers() { return [...this.#numbers]; }} 최신 스팩인 #은 물론이고 실무에서 ES6 이상의 스팩을 사용하려면 Babel을 써야 한다. 이는 #도 마찬가지. 크로스 브라우징 생각하면 어차피 ES6는 아무것도 못 쓴다. (const, let 조차도)😂 private vs protected private field는 외부 접근시 Syntax error 를 반환하는 반면, protected field(_ 컨벤션)는 JS 에서는 기능적인 지원은 없지만 내부 클래스 + 유기적으로 상속된 클래스 간에서는 접근이 가능하게끔 약속된 컨벤션의 성격이 강하다. https://github.com/woowacourse/javascript-lotto/pull/11/files#r579574071 private 크로스 브라우징 이슈 Class private field 문법의 경우, 아직 TC39 제안의 Stage 3(후보)에 올라가 있다. (https://github.com/tc39/proposal-class-fields)따라서 아직까지는 ECMAScript의 공식 스펙이 아니며, 크롬이 미리 구현했을 뿐이다. 의존성 주입 의존성 주입은 constructor 내부에서 직접 객체를 생성하여 할당하는게 아니라 외부에서 객체 생성을 한 뒤에 controller를 생성할 때 인자로 주입하여 constructor의 파라미터로 받아서 할당만 하는 방식을 가리킨다. https://github.com/woowacourse/javascript-lotto/pull/15#discussion_r579614957 extra-mile UX - 거스름돈 반환하기 boolean flag 12345678// Boolean 타입이 아닌 truthy, falsy 조건식if (change) {}// Boolean 타입인 조건식if (!!change) {}if (change &gt; 0) {}if (change !== 0) {}if (Boolean(change)) {} 느낌표 두개(!!) 연산자는 확실한 논리결과를 가지기 위해 사용한다. 예를 들어 정의되지 않은 변수 undefined값을 가진 내용의 논리 연산 시에도 확실한 true/false를 가지도록 하는게 목적 대부분의 자바스크립트 스타일가이드와 lint에서 camelCase를 사용을 권장한다. $(document.querySelector)는 DOM tree를 탐색하는 비용이 든다. 한번만 쓰고 말 DOM reference라면 이렇게 inline으로 작성해도 상관없지만, 계속 사용할 DOM reference라면 한번 select 후 저장해두는 것이 좋다. react component형 App 12345678910111213141516class App extends Component { initStates() { this.lottos = new State([]); } mountTemplate() { this.$target.innerHTML = ` ... `; } mountChildComponents() { new PurchaseInput($('#purchase-input-wrapper'), { lottos: this.lottos }); new LottList($('#lotto-view-wrapper'), { lottos: this.lottos }); }} Component를 추상 클래스로 구현하기 12345678910111213141516171819202122232425export default class Component { $target; props; constructor($target, props = {}) { this.$target = $target; this.props = props; this.initStates(); this.render(); this.initEvent(); } render() { this.mountTemplate(); this.mountChildComponents(); } initStates() {} initEvent() {} mountTemplate() {} mountChildComponents() {}} 래퍼 객체 https://medium.com/@yms0214/원시데이터타입-primitive-type-과-래퍼객체-wrapper-object-d8cda814022d 원시타입을 객체화 시켜주는 객체형데이터 타입을 래퍼객체 라고 하며, 그 종류는 Number, String, Boolean이 있다. 테스트 코드 분리하기 기능에 대한 테스트 레이아웃 상황에 대한 테스트 array.fill()에 객체가 들어갈 경우 참조 복사가 발생하여, 값의 변경에 취약하다. https://github.com/woowacourse/javascript-lotto/pull/12/files#r579601082 label과 input &lt;label for=&quot;lotto&quot;&gt;은 &lt;input id=&quot;lotto&quot;&gt;과 짝을 이룬다. &lt;input&gt;태그를 &lt;label&gt; 태그에 자식으로 넣으면 id, for를 사용하지 않아도 연결된다. &lt;label&gt;과 &lt;input&gt;을 연결하면 &lt;label&gt;영역을 선택하여 &lt;input&gt;에 초점을 맞추거나 활성화시킬 수 있음. &lt;label&gt;안에 &lt;a&gt;, &lt;button&gt; 같은 인터랙티브 요소를 배치해선 안 된다. addEventListener의 DOM addEventListener의 익명함수 내 this는 이벤트를 추가한 DOM 요소를 가리킨다. addEventListener의 화살표함수 내 this는 상위 스코프의 this를 가리킨다. classList.replace 메서드의 이름은 내부에 존재하는 로직을 알려주는 방식으로 짓는 것이 아닌 이 메서드를 사용 하는 측(메서드를 호출하는 측)을 위해 오히려 내부 로직을 드러내지 않는식으로 지어야 한다. input의 value를 destructuring으로 가져오기 1const { value } = event.target.elements['purchase']; new App()을 생성하자마자 앱이 실행되는 것은 어색하다. 항상 동적할당은 메모리에 대한 객체를 갖고 있는게 안전하다. (언제 쓸 지 모르기 때문) 123// 생성과 실행 분리const app = new App();app.execute(); visibility display: none : 영역 차지 X / 이벤트 동작 X visibility: hidden : 영역 차지 O / 이벤트 동작 X opacity: 0 : 영역 차지 O / 이벤트 동작 O DocumentFragment 활용하기 12const fragment = document.createDocumentFragment();const childrenFragment = document.createDocumentFragment(); input의 valueAsNumber Number()로 형변환하는 대신 valueAsNumber로 Number 값을 가져오는 방법 css BEM 처음부터 불필요하게 구조나 디자인 패턴을 적용하지 말고, 앱의 규모에 따라서 적절한 구조를 적용해보자 innerHTML, innerText 대신 createElement innerHtml을 이용하여 변경하는 경우 XSS attack에 취약할 수 있다. model은 데이터만 관리하는게 아닌, 데이터를 정제하고 행동을 만들고, 실제 구현체 용도로 사용할 수 있다. array의 reduce 함수는 map과 join으로 대체하기 두 가지 방식12const mapJoinHTML = array.map(element =&gt; `${element.number}번 요소`).join('');const reduceHTML = array.reduce((prev, cur) =&gt; prev + `${element.number}번 요소`, ''); 처음에 보이면 안 되는 요소는 html에 display: 'none'으로 심어두기 처음에 hidden하지 않고 코드에서 hidden 클래스를 추가했다면 화면에 잠깐 보였다가 사라져서 사용자 입장에서는 버그라고 보일 수 있다. 없는 클래스를 삭제하려고 할 때 에러가 발생하지 않는다. https://developer.mozilla.org/ko/docs/Web/API/Element/classList elementClasses는 elementNodeReference의 클래스 속성을 나타내는 DOMTokenList이다. 만약 클래스 속성이 설정되어 있지 않거나 비어있다면 elementClasses.length는 0을 반환한다. closest의 브라우저 지원 이슈 https://developer.mozilla.org/ko/docs/Web/API/Element/closest 새로운 것을 많이 시도한, 조금 어려운 어느 크루의 코드 Reflect https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Reflect Weakmap https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap Proxy 2️⃣단계 자식 컴포넌트에 props로 변수 뿐 아니라 메서드도 넘겨줄 수 있다. 12345678910new WinningNumberForm($('#winning-number-form-wrapper'), { open: this.open, winningNumber: this.winningNumber, tickets: this.tickets,});new ResultModal($('.modal'), { open: this.open, result: this.result, reset: this.reset.bind(this),}); hasOwnProperty로 컴포넌트의 유효성을 체크한다. (abstract 클래스의 메소드를 모두 구현했는지 여부) 123456789101112131415161718192021if (!this.isAllMeothodsImplemented()) this.throwErrorByCase();isAllMeothodsImplemented() { const prototype = this.__proto__; return ( Object.hasOwnProperty.call(prototype, 'initStates') &amp;&amp; Object.hasOwnProperty.call(prototype, 'subscribeStates') &amp;&amp; ... );}throwErrorByCase() { const prototype = this.__proto__; if (!Object.hasOwnProperty.call(prototype, 'initStates')) throw new Error('initStates is not implemented'); if (!Object.hasOwnProperty.call(prototype, 'subscribeStates')) throw new Error('subscribeStates is not implemented'); ...} if절 또는 switch case 대신 object literal을 사용하는 방법 123456const winnerIndex = { [SCORE.FIRST]: 0, [SCORE.SECOND]: ticket.includes(winningNumber.bonus) ? 1 : 2, [SCORE.THIRD]: 2, [SCORE.FOURTH]: 3,}; 테스트는 “주어진 상황에서 예측가능한 상태”를 검증할때 적절한 방식이다. mock data를 활용하여 예측 가능한 값으로 테스트를 해볼 수 있다. 사용성 - esc 키를 눌렀을 때 모달 닫기 1234if (key === 'Escape') { closeModal(); return;} Map 123456789101112const rankCountMap = new Map([ [VALUE.WINNING_RANK.FIRST, 0], [VALUE.WINNING_RANK.SECOND, 0], [VALUE.WINNING_RANK.THIRD, 0], [VALUE.WINNING_RANK.FOURTH, 0], [VALUE.WINNING_RANK.FIFTH, 0], [VALUE.WINNING_RANK.NONE, 0],]);lotto.tickets.forEach(({ winningRank }) =&gt; { rankCountMap.set(winningRank, rankCountMap.get(winningRank) + 1);}); 🤔 왜 Object 놔두고 Map을 쓸까? Map의 순회는 삽입 순서대로 이루어진다. 어떤 값이든 Key로 사용할 수 있다. 바로 순회가 가능하다. 다만 Object로 쓰는 게 나은 경우도 있다! Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map UML - 구조를 다이어그램 등으로 시각화하는 방법은 여러가지 표준들이 존재한다. 각 네모나 화살표, 점선, 화살표 방향(의존) 등이 의미하는 바가 있다. dom selector의 단수/복수를 한번에 처리하는 방법 12345const $ = (selector) =&gt; { const selected = document.querySelectorAll(selector); return selected.length === 1 ? selected[0] : selected;}; error 여부 판단 (하루) 12345678910111213141516const { isError, message, change } = this.validatePurchaseAmount(purchaseAmount);if (isError) { alert(message); clearInputValue(this.$purchaseAmountInput); this.$purchaseAmountInput.focus(); return;}validatePurchaseAmount(purchaseAmount) { if (purchaseAmount % MONETARY_UNIT) { return { isError: true, message: ..., }; } controlled, uncontrolled 컴포넌트 controlled 컴포넌트에서 form data는 컴포넌트에 의해 처리된다. input에서 값이 변경되면, 컴포넌트의 state에 값을 담아 form에서 submit해주는 형식이다. setState를 사용하는 것이 일반적이다. 반면, uncontrolled 컴포넌트에서 form data는 DOM 그 자체에 의해 처리된다. react에서는 ref를 사용하여, 지금 이순간 input에 담긴 값을 form에서 submit해준다. Refhttps://reactjs.org/docs/uncontrolled-components.htmlhttps://reactjs.org/docs/forms.html#controlled-componentshttps://reactjs.org/docs/forms.html#controlled-components html 전체를 아우르는 main 태그 만들기 DOMContentLoaded를 사용하여 초기 HTML 문서를 완전히 불러오고 분석했을 때 앱을 실행하자. 1234document.addEventListener('DOMContentLoaded', () =&gt; { const app = new App($('#app')); app.execute();}); redux 따라하기 action 1234567export const updatePayment = value =&gt; { 'use strict'; return { type: UPDATE_PAYMENT, payload: { payment: value }, };}; reducer 12345678910111213export const payment = (state = 0, { type, payload = {} }) =&gt; { switch (type) { case UPDATE_PAYMENT: if (payload.payment) { return payload.payment; } return state; case RESTART: return 0; default: return state; }}; 리듀서는 순수함수여야 한다. 사이드 이팩트가 없고 넣은게 같다면 나오는 것도 같아야 한다. 다시 말하면 내부에서 random을 호출하는 코드가 존재 하면 안 된다. (직접 호출이 아니라고 하더라도) Object.seal() Object.seal() 메서드는 객체를 밀봉한다. 객체를 밀봉하면 그 객체에는 새로운 속성을 추가할 수 없고(변경은 가능), 현재 존재하는 모든 속성을 설정 불가능 상태로 만들어준다. 하지만 쓰기 가능한 속성(기존에 있던 값)의 값은 밀봉 후에도 변경할 수 있다. 바로 이 점이 Object.freeze()와의 차이라고 할 수 있다. 도메인에 의존적인 상태들(payment, lottos… 등등)과 라이브러리(리덕스 역할의)가 되는 Store를 분리하는 것이 좋다. 그래야 재사용이 가능해진다. singleton pattern 객체를 만들 때, 하나의 생성자로 여러 객체를 만들 수 있다. 하지만 싱글턴은 필요에 의해 단 하나의 객체만을 만들 때 사용한다. prettier의 printWidth는 80 → 120로 변경되는 게 대세! ‘식’ 대신 조건’문’ 사용하기 1!numbers.includes(randomNumber) &amp;&amp; numbers.push(randomNumber); 개발자 각자의 취향 차이라고 볼 수도 있지만, ‘문’이 아닌 ‘식’으로만 써야하는 제약이 있는 상황이 아니라면 123if(!numbers.includes(randomNumber)) { numbers.push(randomNumber); } 이렇게 조건’문’으로 작성된 코드의 가독성이 일반적으로 더 잘 읽힌다. 각 validator에 이름 붙여 return하기 1234567891011121314151617181920export const validator = { purchaseAmount: money =&gt; { if (!(money / UNIT_AMOUNT &gt; 0 &amp;&amp; money % UNIT_AMOUNT === 0)) { return MSG_INVALID_PURCHASE_AMOUNT; } return ''; }, lottoNumbers: numbers =&gt; { if (numbers.length &lt; WINNING_NUMBER_COUNT) { return MSG_BLANK_INPUT; } if (!isRangeOf(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER, numbers)) { return MSG_OUT_RANGED_LOTTO_NUMBERS; } ... return ''; },}; 원하는 form을 선택해서 reset시키기 1document.querySelector('price-form').reset(); Object.hasOwnProperty.call 12345// Object의 hasOwnProperty를 사용하고 'this'를 foo로 명시적 바인딩한 후 호출할 수 있다.({}).hasOwnProperty.call(foo, 'bar'); // true// 같은 목적으로 Object prototype의 `hasOwnProperty`를 사용할 수도 있다.Object.prototype.hasOwnProperty.call(foo, 'bar'); // true Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty private hash(#) prefix 사용하기 1234567891011export class Lotto { #numbers; constructor(numbers) { this.#numbers = numbers; } get numbers() { return this.#numbers; }} memoize 구현하여 cache 기능 따라해보기 😮 1234567891011export function memoize(callback) { const cache = new Map(); return function (arg) { if (!cache.get(arg)) { cache.set(arg, new callback(arg)); } return cache.get(arg); };} 🙄 이 캐시, 어디서 썼나? 바로 아래에서 👇 DOM을 계속해서 select하는 문제 같은 DOM을 조회했을 때 querySelect를 새로 하는 문제는 캐시로 해결할 수 있다. selector key값을 받아서 해당 키값으로 select된 DOM ref를 저장해두고, 다음에 같은 key값을 받았을때 다시 querySelect하는 것이 아닌 캐시에 저장해둔 값을 반환하면 된다. (단, 이러한 방법은 모든 key가 변하지않는 유니크한 DOM ref를 반환한다는 보장이 있어야 안전하다.) Lodash 와 같은 유틸 라이브러리에 포함되어있는 memoize 함수가 비슷한 동작을 한다. ‘단순히 DOM을 조회하는 것이 비용이 클까?’ 라는 질문에는 그럴수도 있고 아닐 수도 있습니다. 비용이 큰지 작은지를 비교하기 위해서는 전제조건이 필요합니다. MDN querySelector 문서를 보면 DOM tree를 depth-first pre-order traversal(깊이 우선 preorder 탐색) 한다고 되어 있다. 즉 querySelector의 성능은 DOM tree의 크기와 어느정도 비례한다는 것이다. 전체 문서의 크기가 굉장히 커서 탐색해야할 노드가 많다면, 성능은 더 나빠진다. 반대로 말하면, 전체 DOM tree가 작음을 보장할 수 있다면 매번 querySelect하더라도 성능 상의 큰 차이를 느끼지 못할 수도 있다. 라이브러리에서 throw error하기 라이브러리 사용자가 라이브러리 제작자가 의도하지 않은 방향으로 사용할 때에는 undefined를 리턴하는것 보다는, 명시적으로 자바스크립트가 에러를 뱉고 동작을 정지할 수 있도록 throw new Error를 하는 것이 좋다. undefined를 리턴할 경우 사용부에서 에러가 나지않으면 이 라이브러리를 잘못 사용했는데도 그 원인이 어디에 있는지 파악하기 어려울 수 있다. 라이브러리는 사용자가 아닌 개발자를 위한 것! this binding이 많이 사용되는 class에서는 bind를 미리 선언하기 12this.onRestart = this.onRestart.bind(this); this.$restartButton.addEventListener('click', this.onRestart); toFixed(Int)로 소수점 자리수 나타내기 단방향 데이터 플로우 (flux 패턴) https://github.com/woowacourse/javascript-lotto/pull/24 dom selector에 기능 붙이기 1234567891011121314151617export function $(selector) { const target = document.querySelector(selector); const $customElement = Object.assign(target, { clearChildren: function () { while (this.hasChildNodes()) { this.removeChild(this.firstChild); } }, disable: function () { this.disabled = true; }, enable: function () { this.disabled = false; } }); return $customElement;}; 브라우저 서포트 검색하기 https://caniuse.com/ 다만, 브라우저 지원률을 https://caniuse.com 에서 확인하면 좋긴 하지만, 사실 현업에서 사용자들의 트러블 슈팅을 하면 IE 미지원이나 모바일 구버전 브라우저의 경우 발목을 잡는 경우들이 꽤나 있다. 그래서 조심해야할 점은 해당 페이지의 지원율과 비즈니스의 사용자가 어떤 디바이스 층으로 나뉘어져 있는지 잘 확인해보는게 중요하다. Object deepfreeze 12345678export const deepFreeze = (target) =&gt; { if (target &amp;&amp; typeof target === 'object' &amp;&amp; !Object.isFrozen(target)) { Object.freeze(target); Object.keys(target).forEach((key) =&gt; deepFreeze(target[key])); } return target;}; WeakMap 사용하여 cache 구현하기 1const cache = new WeakMap(); WeakMap 객체는 키가 약하게 참조되는 키/값 쌍의 컬렉션이다. 키는 객체여야만 하나 값은 임의 값이 될 수 있다. WeakMap 내 키는 약하게 유지된다. 다른 강한 키 참조가 없는 경우, 모든 항목은 가비지 컬렉터에 의해 WeakMap에서 제거된다. Ref https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/WeakMap class나 id보다 dataset이 성능은 느리다? 성능에 대해서는 O(n^2) 급의 느린게 아니라면, 사용을 해도 상관없다. Proxy handler 다루기 덕 타이핑 사용해보기 class로 Presentational과 Container를 만들어서, 상속을 진행한 후 덕 타이핑으로 진행하는 방법도 있다. 클래스 상속이나 인터페이스 구현으로 타입을 구분하는 대신, 덕 타이핑은 객체가 어떤 타입에 걸맞은 변수와 메소드를 지니면 객체를 해당 타입에 속하는 것으로 간주한다 https://ko.wikipedia.org/wiki/덕_타이핑 CypressWrapper 사용 1234567891011121314151617181920212223class CypressWrapper { _getCy(selector) { return cy.get(selector) } type(selector, value) { try { this._getCy(selector).type(value) } catch (err) { new Error(err) } return this } click(selector, params) { try { this._getCy(selector).click(params) } catch (err) { new Error(err) } return this } ...}const cw = new CypressWrapper() reduce로 총합 구하기 123456get profitRate() { const income = Object.values(this.#lottoResult).reduce((acc, cur) =&gt; { return acc + cur.price * cur.count }, 0) return getProfitRate(income, this.#tickets.length * 1000)} cypress should &amp; and 1234cy.wrap(winningNumberInput) .should('have.value', '') .and('be.focused') .type(winningNumbers[index]); class의 메소드들 App Class 내부에서만 쓰이는 Method면 _ prefix를 붙여서 구분하는 편이 좋을다. class 내에서 순서를 constructor - public method - protected - private 순으로 지정하는 것이 좋다. 외부에서 app을 사용할 때 public method만을 사용하므로, 확인할 때 위에 있을 수록 더 쉽게 찾을 수 있기 때문. innerHTML vs innerText vs textContent textContent는 노드의 모든 요소를 반환한다. 그에 비해 innerText는 스타일링을 고려하며, “숨겨진” 요소의 텍스트는 반환하지 않는다. 또한, innerText의 CSS 고려로 인해, innerText 값을 읽으면 최신 계산값을 반영하기 위해 리플로우가 발생한다. (리플로우 계산은 비싸므로 가능하면 피해야 한다.) Internet Explorer 기준, innerText를 수정하면 요소의 모든 자식 노드를 제거하고, 모든 자손 텍스트 노드를 영구히 파괴한다. 이로 인해 해당 텍스트 노드를 이후에 다른 노드는 물론 같은 노드에 삽입하는 것도 불가능하다. Element.innerHTML는 이름 그대로 HTML을 반환한다. 간혹 innerHTML을 사용해 요소의 텍스트를 가져오거나 쓰는 경우가 있지만, HTML로 분석할 필요가 없다는 점에서 textContent의 성능이 더 좋다. 이에 더해, textContent는 XSS 공격 (en-US)의 위험이 없다. 가급적 textContent를 사용하는 것이 좋다. 성능과 보안에 강점이 있고, 결과적으로 해당 노드의 raw text를 얻게 됨으로써 이후 의도한 대로 가공할 수 있기 때문이다. 이 취약점으로 해커가 사용자의 정보(쿠키, 세션 등)를 탈취하거나, 자동으로 비정상적인 기능을 수행하게 할 수 있다. 주로 다른 웹사이트와 정보를 교환하는 식으로 작동하므로 사이트 간 스크립팅이라고 한다. 보통 h와 같은 (heading) 태그를 사용할 때는 이벤트 관점보다는 html상의 위상, 이 element가 heading을 해야하는지 등에 대한 처리가 필요할 때 사용하는 경우가 많다. convention 정의 1234## 📓 Convention- 클래스에서 속성명 앞에 _ 가 붙여진 것은 해당 속성이 protected 속성임을 뜻하며 인스턴스 외부에서 해당 속성을 수정해서는 안됩니다.- 클래스에서 속성명 앞에 # 가 붙여진 것은 해당 속성이 private 속성임을 뜻하며 상속이 수행된 클래스 내부에서도 해당 속성을 사용하려 해서는 안됩니다.- 어떤 인스턴스에 pascal case 표기된 속성이 있다면 해당 속성이 사실 getter 임을 뜻합니다. 이를 조작하려는 시도를 하지 않도록 유의해주십시오. Node.nodeTypeRef https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType javascript는 타입이 느슨하여, parameter가 이상하게 들어올 수 있는 확률이 굉장히 높다. 이에 대비를 잘 해주자 Service layer pattern https://en.wikipedia.org/wiki/Service_layer_pattern 클래스의 메소드보다 변수를 아래로?비유를 하면, 자전거가 굴러가는지, 안 굴러가는지는 내부 상태를 정의한 값으로만은 알 수 없다. 상태만 정의되어있고 move라는 행동이 없다면 굴러가지 않는다. 대규모 프로그래밍을 하게되면, 사실 상태가 의미가 없는 경우가 많다. 해당 클래스를 빠르게 보면서 이 친구는 어떤 역할을 하는 친구인지, 어떤 행동을 하는지만 알면 대략적으로 어느 부분을 수정해야 하는지 확인할 수 있고, 수정해야 하는 메서드를 잘 나눠놓았다면 메서드 단위로 수정을 해주면 된다. 해당 메서드를 수정할 때에는 내부에서 사용되는 상태를 파악하면 되는 것. 결국 상태는 많이 확인을 안하게 된다. 다만 이 전제는 객체지향적으로 메소드나 함수, 클래스를 잘 짜놓았을 경우의 상황이다. 함수 작성 순서 먼저 어떤 행동을 하는 함수인지 정의한다. 해당 함수가 어떤 parameter가 필요한지 정의한다 해당 parameter는 어떠한 예외가 있는지 bad case를 정의하여 return 구문을 작성한다. Ref https://github.com/woowacourse/javascript-racingcar/pull/25#discussion_r576201158","link":"/2021/03/08/wtc-lv1-lotto-pr/"},{"title":"우테코 Lv2 shoppingcart 학습로그","text":"우테코 Lv2 shoppingcart 학습로그 PR-Step1 바로가기 PR-Step2 바로가기 1️⃣ Step1 useCallback메모이제이션된 콜백을 반환한다. useCallback의 콜백의 의존성이 변경되었을 때에만 함수가 변경된다. 123456const memoizedCallback = useCallback( () =&gt; { doSomething(a, b); }, [a, b],); 👾 자식 컴포넌트가 무겁거나 반복될 때 useCallback으로 최적화하기 만약 자식 컴포넌트가 React.memo() 와 같은 API로 최적화되어 있고 그 자식 컴포넌트에게 callback 함수를 props로 넘길 때, 상위 컴포넌트에서 useCallback 으로 함수를 선언하는 것이 유용하다. (함수 컴포넌트에서는 리렌더가 발생할 때마다 그 내부의 메서드들을 재정의한다.) 함수가 매번 재선언되면 하위 컴포넌트는 넘겨 받은 props가 달라졌다고 인식하여 리렌더되기 때문이다. 그러나 자식 컴포넌트를 리렌더링하는 데 큰 퍼포먼스적 이슈가 발생하지 않는다면 useCallback을 사용하지 않는 것이 좋다 (굳이 최적화하는 것이 더 큰 비용을 필요로 하기 때문이다.) 모든 최적화는 복잡성을 증대시킨다. 12345678910111213141516171819202122const ProductsPage = () =&gt; { const getProducts = useCallback(async () =&gt; { setLoading(true); try { const response = await api.get('/products'); setProducts(snakeToCamel(response.data)); } catch (error) { enqueueSnackbar(MESSAGE.GET_PRODUCTS_FAILURE); } setLoading(false); }, [enqueueSnackbar]); useEffect(() =&gt; { getProducts(); }, [getProducts]); return ( // ... )} getProducts는 컴포넌트의 초기 렌더 시에만 호출되도록 의도하였으나, getProducts 메서드 자체가 custom hook의 리턴값이라 useEffect의 deps에 들어간다. 이때 컴포넌트가 리렌더될 때마다 getProducts 메서드가 재정의되어 useEffect가 다시 호출된다는 문제가 발생한다. 따라서 useCallback을 이용하여 getProducts 메서드를 메모이제이션해준다. Refhttps://github.com/woowacourse/react-shopping-cart/pull/21#discussion_r632967515https://dmitripavlutin.com/dont-overuse-react-usecallback/https://leehwarang.github.io/2020/05/02/useMemo&amp;useCallback.html case mapper 함수snake_case로 내려온 api 반환 값을 camelCase로 바꿔주기 위해 사용했다. 소스 출처는 스택오버플로우를 비롯한 여기저기서… 1234567891011121314151617181920212223242526272829303132333435363738// snakeToCamel.ts// '-' 또는 '_' 뒤에 오는 문자열을 CamelCase로 변경 const toCamel = (s: string) =&gt; { return s.replace(/([-_][a-z])/gi, ($1) =&gt; { return $1.toUpperCase().replace('-', '').replace('_', ''); });};// array 타입 체크 const isArray = (a: unknown) =&gt; Array.isArray(a);// object 타입 체크 const isObject = (o: unknown) =&gt; o === Object(o) &amp;&amp; !isArray(o) &amp;&amp; typeof o !== 'function';type NestedObject = Record&lt;string, unknown&gt;;type NestedType = NestedObject | NestedObject[];// api 통신을 통해 받아오는 json 객체가 nested되어있을 경우 재귀적으로 케이스 변환 시행 // eslint-disable-next-line @typescript-eslint/no-explicit-anyconst snakeToCamel = (o: NestedType): any =&gt; { if (isObject(o)) { const n: NestedObject = {}; Object.keys(o as NestedObject).forEach((k) =&gt; { n[toCamel(k)] = snakeToCamel((o as NestedObject)[k] as NestedType); }); return n; } if (isArray(o)) { return (o as NestedObject[]).map((i: unknown) =&gt; snakeToCamel(i as NestedType)); } return o;};export default snakeToCamel; TypeScript interface vs typeinterface는 객체의 추상화를 위해 사용하는 것이라면, type은 타입 그 자체에 포커스가 맞춰져 있다. 교차 타입 및 유니언 타입type은 교차 타입(&amp;)과 유니언 타입(|) 작성이 가능하다. interface는 extends 키워드를 통해 한 개 이상의 타입으로부터 확장할 수 있다. 12345type SuperUser = User &amp; { super: true }// ...interface SuperUser extends User { super: true} 123type Z = A &amp; B &amp; C &amp; D &amp; E// ...interface Z extends A, B, C, D, E {} 123type Z = A | B//...interface IZ extends A | B {} // &lt;- ❌ INVALID SYNTAX, 재선언 (Redeclaratin)type은 재선언이 불가하며, interface는 가능하다. interface를 같은 이름으로 재선언하는 경우 컴파일 타임에 선언적 병합이 이루어져 하나의 interface로 합쳐진다.12345678910111213interface User { name: string}interface User { gender: string}const user: User = { name: 'Ronald', gender: 'male' }type User = { name: string }type User = { gender: string } // ❌ Compilation error// &quot;Duplicate identifier 'User'.&quot; 👾 React에서는 type vs interface ?대다수의 React library에서는 type 대신 interface를 채택하고 있다. 이후 사용자가 프로퍼티를 추가하는 등 interface를 재정의하거나 확장하는 데 있어 interface가 편리하기 때문이다. 그러나 언제나 상황에 따라 알맞는 컨벤션을 선택해야 한다! Refhttps://dev.to/reyronald/typescript-types-or-interfaces-for-react-component-props-1408 dispatch에서 then chaining 사용하기12345678910111213import { Action } from 'redux';import { ThunkDispatch } from 'redux-thunk';import { RootState } from 'modules';const dispatch = useDispatch&lt;ThunkDispatch&lt;RootState, null, Action&gt;&gt;();dispatch(addCartItemRequest(product)) .then(() =&gt; { enqueueSnackbar(MESSAGE.ADDED_CART_ITEM_SUCCESS); }) .catch((error: Error) =&gt; { enqueueSnackbar(error.message); }); thunk middleware를 사용하는 redux action에서 api 요청 이후 success, error 상황에 대한 dispatch 함수를 리턴해주기 때문에 dispatch~then~catch 체이닝이 가능하다. 123456789101112131415161718// actions.tsexport const addCartItemRequest = (product: T.Product) =&gt; async ( dispatch: Dispatch&lt;AddCartItemAction | GetCartItemsAction&gt;) =&gt; { dispatch({ type: ADD_CART_ITEM_REQUEST, productId: product.productId }); try { const response = await api.post('customers/zigsong/carts', { product_id: product.productId }); const { location } = response.headers; const cartId = location.substring(location.lastIndexOf('/') + 1); dispatch({ type: ADD_CART_ITEM_SUCCESS, payload: { cartId, product } }); } catch (error) { dispatch({ type: ADD_CART_ITEM_FAILURE, error }); throw error; }}; Ref https://blog.jscrambler.com/async-dispatch-chaining-with-redux-thunk/ useHistory와 useLocation으로 컴포넌트 간 데이터 주고받기OrderListPage에서 아이템 클릭을 통해 OrderDetailPage로 이동할 때, 현재 클릭한 주문 아이템의 정보를 전달한다. 1234567891011121314151617181920212223242526272829303132// OrderListPage.jsxconst OrderListPage = () =&gt; { const history = useHistory(); const handleClickDetail = useCallback( (order: T.Order) =&gt; { history.push({ pathname: '/order/detail', state: { order }, }); }, [history] ); return ( // ... )}// OrderDetailPage.jsxinterface LocationState { order: T.Order;}const OrderDetailPage = () =&gt; { const location = useLocation&lt;LocationState&gt;(); const { order } = location.state; return ( // ... )} 👾 컴포넌트를 withRouter HoC로 감싸준다면 useHistory를 사용하지 않고 history 객체(BrowserRouter, Switch에 의해 생성된 defaultProps)를 props로 전달받을 수 있다. (history, match, location 값을 반환받는다.) withRouter로 감싼 컴포넌트는 앱의 최상단에 선언되는 Router(BrowserRouter, HashRouter 등)에 포함되어 있어야 하지만, 특정 path를 가리키는 Route 태그로 감싸주지 않아도 된다. 이때 해당 컴포넌트는 가장 가까운 Route path를 찾아 그에 맞는 값을 반환한다. 12345678910import React from 'react';import { withRouter } from 'react-router-dom'; const Home = ({ history }) =&gt; { return ( &lt;div onClick={() =&gt; history.push('/auth')}&gt;Hello!&lt;/div&gt; );};export default withRouter(Home); 이 경우 마찬가지로 useLocation 대신 defaultProps 중 하나인 location을 사용할 수 있다. Refhttps://reactrouter.com/web/api/Hookshttps://velog.io/@yiyb0603/React-Router-dom의-유용한-hooks들) 기타useEffect의 의존성 배열에 들어가는 dispatch123useEffect(() =&gt; { dispatch(getCartItemsRequest());}, [dispatch]); dispatch는 hook이기 때문에 변할 가능성이 있고, callback은 dispatch에 의존성을 가졌기 때문에 dispatch가 바뀌었을 때 callback이 수행되어야 한다. Refhttps://github.com/woowacourse/react-shopping-cart/pull/21#discussion_r634469756 axios customize아래와 같이 특정한 api 요청을 생성한다. 123const api = axios.create({ baseURL: 'https://shopping-cart.techcourse.co.kr/api/',}); axios interceptor를 사용하여 요청/응답 시 처리할 로직을 추가할 수 있다. 12345678910111213141516171819202122232425// 요청 인터셉터 추가axios.interceptors.request.use( function (config) { // 요청을 보내기 전에 수행할 일 // ... return config; }, function (error) { // 오류 요청을 보내기전 수행할 일 // ... return Promise.reject(error); });// 응답 인터셉터 추가axios.interceptors.response.use( function (response) { // 응답 데이터를 가공 // ... return response; }, function (error) { // 오류 응답을 처리 // ... return Promise.reject(error); }); https://이듬.run/axios/guide/interceptors.html CSS 형제 선택자 ~현재 요소 다음에 오는 형제 요소(들)를 선택한다. 123div ~ p { background: grey;} 1234&lt;p&gt;para&lt;/p&gt;&lt;div&gt;my div&lt;/div&gt;&lt;p&gt;change bg&lt;/p&gt; // selected&lt;p&gt;change bg&lt;/p&gt; // selected 👾 + 선택자는 바로 다음에 오는 형제 요소만 선택한다. 123div + p { background: blue;} 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; // selected&lt;p&gt;&lt;/p&gt; // not selected Immer.js리덕스 스토어의 값을 불변성을 유지해주면서 업데이트할 때 편리하게 사용할 수 있다. baseState와 draft, produce 함수 를 사용한다. 👾 redux store 값은 왜 불변성을 유지해야 할까? 데이터의 불변성은 데이터 예측과 데이터 핸들링을 더욱 쉽게 만들어 준다…라고 하기엔 너무 애매하다! redux의 데이터 변경 감지 방식은 얕은 비교(shallow comparison)를 통해 이루어진다. 변경되는 데이터를 단순하고 쉽게 감지하고 다시 렌더링하는 기술을 사용하기 때문에 단순 비교를 통해 좋은 성능을 유지하는 것이다. 이때 redux는 이전 state와 바뀐 state를 구분하는 방법이 참조값이 바뀌었는지 확인하고, 참조값이 바뀌면 state가 바뀌었다고 인식하여 해당 state를 사용하는 컴포넌트에게 리렌더링을 요청한다. 그런데 직접적으로 state를 변경하면 참조값이 변하지 않아 redux는 값이 바뀌었다고 인식하지 않고 리렌더링하지 않을 것이다. redux의 time-travel debugging은 dispatch된 액션들 사이에 왔다갔다 하면서 실제 UI가 어떻게 보여질지를 결정한다. 이렇게 왔다갔다 하기 위해 reducer는 사이드 이펙트가 없는 순수함수여야 한다. reducer가 데이터를 직접 변경한다면, 상태의 전후 전환에서 사이드 이펙트가 발생할 것이다. Refhttps://immerjs.github.io/immer/https://redux.js.org/faq/immutable-datahttps://velog.io/@cyranocoding/redux에-Immutable.js을-끼얹어-상태-관리를-해보자불변성-관리 api 요청 상태 구분하기12345678910111213export enum AsyncStatus { IDLE = 'IDLE', PENDING = 'PENDING', SUCCESS = 'SUCCESS', FAILURE = 'FAILURE',}export type CartState = { cartItems: { data: T.CartItem[]; status: T.AsyncStatus; };}; react-app-rewired👾 블로그 다른 글 참고 RefCRA 앱에서 babel 설정을 도와주는 친구들 2️⃣ Step2 useDispatch &amp; useSelector TypeScript customizeTypeScript외 redux를 사용한다면 store의 상태와 연결지어 useDispatch와 useSelector의 타입을 미리 정의할 수 있다. 1234567891011121314// modules/store.tsimport thunk from 'redux-thunk';import { configureStore } from '@reduxjs/toolkit';import cartSlice from './cartSlice';export const store = configureStore({ reducer: { cartSlice, }, middleware: [thunk],});export type RootState = ReturnType&lt;typeof store.getState&gt;;export type AppDispatch = typeof store.dispatch; useDispatch와 useSelector에 대한 hook을 정의해 준다. 123456// modules/hooks.tsimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';import type { RootState, AppDispatch } from './store';export const useAppDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;();export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector; React 컴포넌트에서 추가적으로 타이핑을 해주지 않아도 된다. 1234567891011// SomeComponent.jsxconst SomeComponent = () =&gt; { // const dispatch = useDispatch&lt;Dispatch&lt;StoreEvent&gt;&gt;(); const dispatch = useAppDispatch(); // const cartItems: CartState['cartItems'] = useSelector((state: RootState) =&gt; state.cartSlice.cartItems); const cartItems: CartState['cartItems'] = useAppSelector((state) =&gt; state.cartSlice.cartItems); return ( // ... )} Refhttps://redux-toolkit.js.org/usage/usage-with-typescripthttps://dev.to/sarimarton/easy-type-safety-with-usedispatch-and-useselector-4fii redix toolkit rejectWithValuethunkAPI의 옵션으로, createAsyncThunk에서 에러 핸들링을 위해 사용한다. 1rejectWithValue(value, [meta]) rejectWithValue는 비동기 요청의 rejected된 응답을 지정된 payload와 meta와 함께 리턴하기 위해 사용된다. rejected되었을 때 실행될 액션의 payload에 값을 전달한다. return 또는 throw할 수 있다. 12345678910111213141516export const getCartItems = createAsyncThunk&lt;{ cartItems: T.CartItem[] }&gt;( 'cartItems/get', async (_, { rejectWithValue }) =&gt; { try { const response = await api.get('customers/zigsong/carts'); return { cartItems: snakeToCamel(response.data) }; } catch (error) { if (!error.response) { throw error; } return rejectWithValue(error.response.data); } }); rejectWithValue로 던져진 에러 객체는 redux toolkit의 slice 객체에서 Promise가 rejected되었을 때 action의 payload 대신 action.error로 접근할 수 있다. 123456789101112131415161718export const cartSlice = createSlice({ name: 'cart', initialState, reducers: { // ... }, extraReducers: { [getCartItems.pending.type]: ({ cartItems }) =&gt; { // ... }, [getCartItems.fulfilled.type]: ({ cartItems }, action: PayloadAction&lt;{ cartItems: T.CartItem[] }&gt;) =&gt; { // ... }, [getCartItems.rejected.type]: ({ cartItems }, action: PayloadAction&lt;{ error: AxiosError }&gt;) =&gt; { cartItems.status = T.AsyncStatus.FAILURE; //👇 action.error로 접근 cartItems.error = action.error.message; }, Refhttps://redux-toolkit.js.org/api/createAsyncThunk#examples 기타Media Query 상수화12345678910111213141516const deviceSizes = { mobile: '480px', tablet: '768px', laptop: '1024px',};const device = { mobile: `screen and (max-width: ${deviceSizes.mobile})`, tablet: `screen and (max-width: ${deviceSizes.tablet})`, laptop: `screen and (max-width: ${deviceSizes.laptop})`,};export const theme: Theme = { // ... device,}; 123456789// styles.tsconst Nav = styled.nav``; border: none; background: none; cursor: pointer; @media ${({ theme }) =&gt; theme.device.tablet} { display: none; }`;","link":"/2021/05/19/wtc-lv2-shoppingcart-log/"},{"title":"우테코 Lv3 - 사용 라이브러리 정리","text":"우테코 Lv3 학습로그 - 사용 라이브러리 정리 axios브라우저와 node.js를 위한, Promise api를 활용하는 http 비동기 통신 라이브러리다. 비슷한 기능을 하는 브라우저 빌트인 도구 fetch api가 있지만, restful API의 기본이 되는 CRUD 요청에 fetch를 사용하는 건 꽤나 불편하다. 1234fetch(url, { method: 'POST', // *GET, POST, PUT, DELETE, etc. body: JSON.stringify(data), // body data type must match &quot;Content-Type&quot; header}) axios로는 간단하게 메서드로 요청 타입을 작성해줄 수 있으며, 데이터 전송 시 JSON.stringify를 해주지 않아도 된다.물론 인라인으로 작성해서 더 깔끔해 보인다. 이게 바로 많은 광고들의 술수? 1axios.post(url, { data: data }) 이밖에도 axios는 여러 편리한 기능들을 가지고 있다. axios fetch 요청 객체에 url이 있다 요청 객체에 url이 없다 써드파티 라이브러리로 설치가 필요 현대 브라우저에 빌트인이라 설치 필요 없음 XSRF 보호를 해준다 별도 보호 없음 data 속성을 사용 body 속성을 사용 data는 object를 포함한다 body는 문자열화 되어있다 status가 200이고 statusText가 ‘OK’이면 성공이다 응답객체가 ok 속성을 포함하면 성공이다 자동으로 JSON데이터 형식으로 변환된다 json()메서드를 사용해야 한다 요청을 취소할 수 있고 타임아웃을 걸 수 있다 해당 기능 존재 하지않음 HTTP 요청을 가로챌수 있음 기본적으로 제공하지 않음 download진행에 대해 기본적인 지원을 함 지원하지 않음 좀더 많은 브라우저에 지원됨 Chrome 42+, Firefox 39+, Edge 14+, and Safari 10.1+이상에 지원 많은 기능들 중, 응답이 자동으로 json 데이터 형식으로 변환된다 status/statusText가 별개로 제공되어 응답 상태별로 좀 더 섬세하게 구분할 수 있다 http 요청을 가로챌 수 있는 interceptor 기능 을 활용했다. 특히 axios interceptor를 이용해 http 요청과 응답을 보내기 전 사전에 지정한 동작을 수행하게끔 만들었다. 프로젝트에서는 dev와 prod 구분을 위해 아래와 같이 BASE_URL을 구분했다. 1234export const BASE_URL: { [key: string]: string } = { development: 'https://nolto-dev.kro.kr', production: 'https://nolto.kro.kr',}; interceptor를 사용해서 요청에 유저의 토큰을 담아 보내주게끔 했다. 1234567891011121314const api = axios.create({ baseURL: BASE_URL[process.env.NODE_ENV] || BASE_URL.development,});api.interceptors.request.use( (config) =&gt; { const accessToken = localStorage.getItem('accessToken'); if (accessToken) { config.headers['Authorization'] = 'Bearer ' + accessToken; } return config; }, (error) =&gt; Promise.reject(error),); 이밖에도 config를 통해 axios의 응답 스키마를 커스터마이징해줄 수 있는 옵션들이 많이 있으니 잘 활용해 보자! ✔️ Refhttps://github.com/axios/axioshttps://kyun2da.dev/라이브러리/axios-개념-정리/ react-queryReact App에서 서버와의 상태 동기화를 위해 사용한다. 서버 데이터를 가져오고, 자동으로 캐싱해주며, 동기화까지 해주는 완전 멋진 라이브러리다! 또 react-query를 사용하면 개발자들이 각기 다르게 사용해왔던 http 응답 상태에 대한 관리를 일관성 있게 처리해줄 수 있다. 상태관리가 메인인 recoil도 도입을 고려했었는데, 커뮤니티형 프로젝트 특성상 상태관리가 필요한 데이터가 많지 않다고 생각했다. 서버와의 비동기 api 통신이 잦은 만큼 서버 데이터를 주로 관리해줄 수 있는 react-query를 최종적으로 결정하게 되었다. 프로젝트 전체의 핵심 기능을 하는 라이브러리 선정을 위한 구체적인 고민과 논의의 과정은 아래와 같다. react query 완전 fancy하고 편리하다. 사용하자 (지그) 우리 앱은 서버와의 즉각적인 통신이 필요하지 않을 것 같으니 recoil로도 충분하다 (미키) react query 완전 편리한 것 같다. 상태관리할 데이터도 딱히 없을 것 같다. (미키) 포코가 상태관리 나중에 하면 힘들어질 거라고 했다. 다른 크루들도 사용할 때 recoil을 사용해보는 게 좋겠다. (지그) recoil 너무 복잡하다. 더군다나 cache된 데이터만 가져오고, 서버에서 신규 데이터를 가져오는 과정이 복잡하다. (미키) 👾 결론: react-query 쓰자! 🙆‍♂️🙆‍♀️ 셀프 출처 기본적으로 useQuery를 사용하여 비동기 데이터를 가져온다. 각 데이터는 유니크한 queryKey값으로 관리되며, 이 key는 앱 내의 컴포넌트들 간에 공유된다. useQuery에 key값과 Promise를 리턴하는 콜백 함수를 인자로 작성해준다. 12345import { useQuery } from 'react-query'function App() { const info = useQuery('todos', fetchTodoList)} 실제 프로젝트에서는 custom hook과 결합하여 아래처럼 query 코드를 작성했다. useQuery가 호출하는 콜백 함수를 별도의 파일에서 관리할 수 있다는 점에서 유용하다. 123const useHotFeedsLoad = ({ ...option }: CustomQueryOption) =&gt; { return useQuery&lt;Feed[], HttpError&gt;(['hotFeeds'], loadHotFeeds, option);}; POST, PUT, DELETE 요청 등 서버 데이터를 변경할 때에는 useQuery 대신 useMutation을 사용한다. 이벤트 핸들러 또는 조건부로 useQuery를 호출 시 hook 규칙에 위반되기 때문에 react-query는 useMutation을 제공한다. 데이터의 수정이나 삭제 발생 시점에 useMutation으로 생성한 인스턴스에서 mutate 메서드를 호출하여 원하는 때에 요청 로직을 수행할 수 있다. 프로젝트에서는 useMutation 역시 useQuery와 마찬가지로 custom hook으로 작성해주고 있다. 123const useFeedModify = () =&gt; { return useMutation&lt;AxiosResponse&lt;unknown&gt;, HttpError, Args&gt;(uploadFeed);}; 사용하는 컴포넌트에서는, 피드 수정 시 사용자가 입력한 데이터를 함께 보내 mutation을 실행해 준다. mutate에 성공하면 사용자에게 snackbar로 알려준다. 123456789101112131415161718const Modify = () =&gt; { const modifyMutation = useFeedModify(); const modifyFeed = (formData: FormData) =&gt; { modifyMutation.mutate( { feedId, formData }, { onSuccess: () =&gt; { snackbar.addSnackbar('success', ALERT_MSG.SUCCESS_MODIFY_FEED); }, }, ); }; return ( // ... )} react-query의 useMutation을 사용하는 경우 onSuccess 옵션을 함께 사용하면 캐시되어 있는 query 데이터를 무효화하는 queryClient.invalidateQueries와 호출 query의 데이터를 업데이트하는 queryClient.setQuerydata를 사용하여 서버에서 업데이트된 데이터를 새로 받아올지 여부를 결정할 수 있다. 👾 Automatic Refetch after Mutation을 자동으로 해주지 않는다는 점은 조금 아쉽다. react-query 공식문서에서는 이를 지원한다고는 하지만, 사용자(개발자)가 별도의 코드를 작성해줘야 한다고 한다. react-query가 제공하는 option들, 예를 들어 요청의 retry 횟수, suspense와 errorBoundary 사용 여부 등을 지정해준다면 앱의 특성에 맞게 커스터마이징할 수 있다. 브라우저에서 다른 탭으로 다시 이동했다가 현재 탭으로 다시 focus되었을 때 데이터를 refetch해오는 옵션(refetchOnWindowFocus) 등 상당히 fancy해 보이는 기능도 있으며 QueryClient가 제공하는 메서드들을 통해 서버의 캐시 데이터를 초기화하거나 fetching을 취소하는 옵션 등 다양한 기능을 활용할 수 있다. 다만 코치님께 react-query보다 용량이 작은 swr도 고려해보면 좋겠다는 조언을 받았다. 하지만 앱 전체를 갈아엎는 시도는 참으로 용기가 필요한 일이다. 그나저나 react-query 공홈에서는 자신들이 SWR, Apollo Client, RTK-Query보다 모든 측면에서 더 낫다는 자료를 공개하고 있다. 선택은 자유지만 저 자신감 부럽다. SWR이 용량 측면에서는 react-query보다 이점이 있지만, 12kB와 4kB의 차이가 그렇게 큰지는 모르겠다. 또 공식 devtools를 제공한다는 점은 큰 장점이라고 생각한다. 마지막으로 react-query는 렌더링 최적화를 수행한다는 점에서 매력적이다. 쿼리가 업데이트되었을 때만 컴포넌트를 리렌더링하며, batching을 사용해서 같은 쿼리를 사용하는 여러 컴포넌트를 실제 업데이트가 발생했을 때 한 번만 렌더링한다고 한다. 그리고 npm-trends에 따르면, 최근에는 react-query의 사용이 증가하고 있다. 용량은 swr이 절반 정도지만, 그렇게 유의미한 차이는 아니라고 생각한다. 또 semver로 봤을 때 아직까지 메이저 버전이 출시되지 않았다! 안정성 측면에서 react-query가 조금 더 매력적으로 보인다. 그나저나 react-query가 7년이나 된 라이브러리였다니 놀랍다. ✔️ Refhttps://react-query.tanstack.com/overviewhttps://maxkim-j.github.io/posts/react-query-preview react-hook-formform input을 다루기 정말 번거로운 React App을 위한 라이브러리다. 사용자가 입력할 form data를 일일이 useState에 담아주는 것이 반복적인 코드를 무한 양성하는, 어찌 보면 무의미한 일이라는 생각이 들었다. 그리고 기존의 작성법에서 input validation을 하나하나 처리해주는 일은 너무나도 귀찮고 까다로웠다. 그런 김에 다른 fancy한 라이브러리를 도입해보자! 고민 끝에 react-hook-form이라는 라이브러리를 발견했다. 공통의 form 안에 있는 각각의 input에 이름을 붙여준다. 여기서는 register의 인자로 input의 이름을 전달하는 방법을 선택했으며, required 옵션과 maxLength 등 input 태그가 기본적으로 제공하는 validation 관련 속성들도 붙여줄 수 있다. form에서 submit 이벤트 발생 시 handleSubmit 메서드(일반적인 form을 submit할 때의 네이밍 컨벤션과 같지만, 여기서 handleSubmit은 useForm hook에서 리턴하는 함수의 이름이다.) 이름이 붙은 input들의 value를 formData에 모아 한번에 가져다 준다. 각 input value는 비제어 컴포넌트의 방식으로 값을 취득하지만, watch 옵션으로 값을 관찰하여 input 이벤트가 발생할 때마다 특정 로직을 수행해줄 수도 있다. 하지만 그로 인해 값이 바뀔 때마다 렌더링이 발생하니 주의하자. 리렌더링을 방지하기 위해서는 callback을 사용하거나 useWatch를 사용할 수 있다. 1234567891011121314151617export default function App() { const { register, handleSubmit, watch, formState: { errors } } = useForm(); const onSubmit = data =&gt; console.log(data); console.log(watch(&quot;example&quot;)); // watch input value by passing the name of it return ( &lt;form onSubmit={handleSubmit(onSubmit)}&gt; &lt;input defaultValue=&quot;test&quot; {...register(&quot;example&quot;)} /&gt; &lt;input {...register(&quot;exampleRequired&quot;, { required: true })} /&gt; {errors.exampleRequired &amp;&amp; &lt;span&gt;This field is required&lt;/span&gt;} &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; );} form 관련 React 라이브러리에서 아직까지는 Formik이 앞서고 있지만, react-hook-form의 깃헙 스타 수도 꾸준히 증가중으로 곧 Formik을 따라잡을 듯 하다. Formik 대신 react-hook-form을 쓰게 된 결정적인 이유는, Formik에서는 input validation 코드가 너무 복잡했다. yup이라는 라이브러리를 추가적으로 쓰지 않는 한, 하나의 input에 걸린 모든 validation을 if~else절로 일일이 분기쳐줘야 한다. 프로젝트에서 제일 골칫거리였던 문제를 해결할 수 없었다! react-hook-form에서는 꽤나 간단하다. 프로젝트에서는 아래와 같이 적용했다. useForm에서 리턴되는 formState의 errors를 통해 form에 포함된 input들에 걸려 있는 validation에서 발생한 error를 가져올 수 있다. 해당 error를 ErrorMessage 컴포넌트에 넘겨줘 에러를 표시하게끔 했다. 12345678910111213141516171819202122const FeedUploadForm = ({ onFeedSubmit, initialFormValue }: Props) =&gt; { const { register, handleSubmit, setValue, watch, formState: { errors }, } = useForm({ shouldUnregister: true, defaultValues: initialFormValue }); return ( &lt;Form onSubmit={handleSubmit(submitFeed)}&gt; &lt;Styled.VerticalWrapper&gt; &lt;Label text=&quot;제목&quot; htmlFor=&quot;title&quot; required={true} /&gt; &lt;FormInput id=&quot;title&quot; {...register('title', { required: UPLOAD_VALIDATION_MSG.TITLE_REQUIRED, })} /&gt; &lt;ErrorMessage targetError={errors.title} /&gt; &lt;/Styled.VerticalWrapper&gt; // ... 아래처럼 귀엽게 표시했다. ✔️ Ref https://react-hook-form.com/ styled-components너무나 익숙해서 썼다…!는 말도 안될 일이고, 아무튼 간에 CSS-in-JS가 편리한 건 어쩔 수 없다. React로 개발을 하며 JavaScript 기반으로 CSS 코드를 작성할 수 있다는 점은 개발자 입장에서 무척 매력적이다. 또 컴포넌트별로 확실하게 스코프가 분리된 스타일 시트를 만들거나 props를 이용하여 스타일링에 변화를 주는 방식도 편리한 styled-components를 사용하게 되었다. CSS-in-JS 방식은 일반적으로 아래와 같은 많은 장점들을 제공한다. Global namespace - class명이 build time에 유니크한 해시값으로 변경되기 때문에 별도의 명명 규칙이 필요하지 않다. Dependencies - CSS가 컴포넌트 단위로 추상화되기 때문에 CSS 파일(모듈)간에 의존성을 신경 쓰지 않아도 된다. Dead Code Elimination - 컴포넌트와 CSS가 동일한 구조로 관리되므로 수정 및 삭제가 용이하다. Minification - 네임스페이스 충돌을 막기위해 BEM 같은 방법론을 사용하면 class 명이 길어질 수 있지만, CSS-in-JS는 짧은 길이의 유니크한 클래스를 자동으로 생성한다. Sharing Constants - CSS 코드를 JS에 작성하므로 컴포넌트의 상태에 따른 동적 코딩이 가능하다. Non-deterministic Resolution - CSS가 컴포넌트 스코프에서만 적용되기 때문에 우선순위에 따른 문제가 발생하지 않는다. Isolation - CSS가 JS와 결합해 있기 때문에 상속에 관한 문제를 신경 쓰지 않아도 된다. 👾 물론, 최종 번들링 크기에 따른 성능상의 문제는 유의미한 차이가 생길 수 있다. CSS-in-JS를 사용하기 위해서는 styled-components와 같은 별도의 라이브러리를 설치해줘야 한다. 라이브러리 추가는 곧 번들 사이즈 크기가 커진다는 말과 같다. 게다가 CSS-in-JS는 JavaScript가 모두 로드된 후에 JavaScript 코드를 생성하기 때문에 더욱 느려질 수밖에 없다. CSS-in-JS는 js 파일에 CSS 코드를 포함하기 때문에, 페이지 전환 또는 컴포넌트 업데이트 시 JavaScript에서 CSS를 추출해야 한다. 반면에, 빌드타임에 CSS 파일이 추출되는 CSS Modules 방식은 JavaScript 평가 과정이 따로 없기 때문에 훨씬 빠르게 페이지가 전환된다. 또 CSS가 먼저 제공되어 렌더링 시 형태가 잡혀있는 CSS Modules 방식과 달리 CSS-in-JS 방식은 컴포넌트가 렌더링되며 형태가 잡혀나가기 때문에 원형의 못생긴(!) 모습이 잠깐 노출되는 문제가 있다. 위와 같은 일부 단점들이 있지만, 개발자의 입장에서 개발의 편리성과 디버깅의 용이성을 놓칠 수 없어서 styled-components를 택하게 되었다. 사용자 인터랙션 측면에서도 아직까지 큰 성능상의 이슈나 병목점을 발견하진 못했기 때문에 우선적으로는 계속 styled-components를 사용할 계획이다. (2021.11.6 추가)어차피 지금은 SSR을 중이고, 프론트엔드 서버에서 styled-components의 ServerStyleSheet을 미리 내려주기 때문에 웹페이지 초기 진입 시 못생긴 원형의 컴포넌트가 노출될 일은 없다고 생각한다. emotion 라이브러리도 styled-components와 같은 기능들을 제공하며 라이브러리의 크기도 작아 많이 사용되는 방식이다. 그러나 주요 작성 관점이 다른 듯하다. emotion의 경우 css 코드를 객체 형태로 제공한다는 점이 특징적이다. 1234567891011121314151617import { css, cx } from '@emotion/css'render( &lt;div className={css` padding: 32px; background-color: hotpink; font-size: 24px; border-radius: 4px; &amp;:hover { color: ${color}; } `} &gt; Hover to change color. &lt;/div&gt;) 그러나 이런 css객체 형태는 styled-components에서도 사용할 수 있는 방식이며, 개인적으로는 각각의 css 객체에 이름을 붙여주는 것보다 DOM 태그 자체에 이름을 붙여주는 방식이 더 편했다. 그리고 emotion을 사용했을 때에도, 결국 styled를 import해서 쓰게 되는 건 똑같더라. 추가적으로 styled-components는 다른 스타일 컴포넌트 뿐 아니라 리액트 컴포넌트도 확장해서 작성할 수 있다는 점이 편리해서, 프로젝트에서 유용하게 사용하고 있다. (아래 예시) 1234export const Stack = styled(TechChip)` font-size: 12px; color: ${PALETTE.PRIMARY_VIOLET_TEXT};`; ✔️ Refhttps://blueshw.github.io/2020/09/27/css-in-js-vs-css-modules/https://ideveloper2.dev/blog/2019-05-05--thinking-about-emotion-js-vs-styled-component/ devDependencieswebpack 관련✅ webpack여러 개의 파일을 하나로 합쳐주는 모듈 번들러 ✅ webpack-cliwebpack의 커맨드 라인 인터페이스다. 즉 터미널에서 webpack 커맨드를 실행할 수 있게 해준다. ✅ webpack-dev-serverwebpack에서 기본으로 제공하는 개발용 서버. 라이브 리로딩을 지원한다. (dev mode에서만 사용해야 한다!) ✅ html-webpack-plugin번들링한 결과의 css와 js파일을 각각 html 파일에 심어주는 과정을 자동화해준다. ✅ @svgr/webpack리액트 앱에서 svgr을 쓸 수 있게 해준다. svgr 로더만 설치 시 리액트 컴포넌트처럼 사용이 가능하다. 사용을 위해서 webpack config에 추가해준다. 12345678910// webpack.config.jsmodule: { rules: [ // ..., { test: /\\.svg$/, use: ['@svgr/webpack'], } ]} ✅ copy-webpack-plugin특정 폴더 또는 파일들을 빌드 폴더로 복사해준다. netlify의 redirect 옵션을 위한 _redirects 파일을 빌드 폴더에도 포함시켜주기 위해 사용했다. ✅ file-loaderimport나 require로 불러온 파일을 읽어 url로 변환하고 해당 파일을 빌드 폴더로 넣어준다. 파일을 모듈로 사용할 수 있게끔 해주는 것이다. webpack config 설정을 통해 test에 포함되는 이미지 확장자 파일을 발견하면 file-loader로 처리한다. 1234567891011121314// webpack.config.jsmodule: { rules: [ // ..., { test: /\\.(png|jpe?g|gif)$/i, use: [ { loader: 'file-loader', }, ], }, ]} 실제 빌드 폴더에 알 수 없는 해시값의 이름으로 된 파일들이 담긴다. 👾 babel v5 이상부터는 deprecated되었으며, asset modules를 사용하면 된다고 한다. ✔️ Ref https://velog.io/@hwang-eunji/svg-파일-react-next에서-사용하기 babel 관련✅ @babel/coreES6 문법을 ES5 문법으로 바꿔준다. ✅ @babel/preset-env타겟 환경에 필요한 구문 변환(syntax transform), 브라우저 폴리필(browser polyfill)을 제공한다. ✅ @babel/preset-reactJSX 코드를 React.CreateElement 호출 코드로 변환한다. 즉 JSX 문법을 JavaScript로 변환한다. ✅ @babel/preset-typescriptTypeScript 사용 시 권장되는 preset이다. @babel/plugin-transform-typescript를 포함하고 있다. 👾 잠깐! TypeScript도 컴파일러(트랜스파일러)가 아닌가? 그렇다. 두 개의 컴파일러(TypeScript와 babel)을 함께 사용하면 컴파일의 흐름은 다음과 같다. TS → TS Compiler → JS → Babel → JS (again) webpack의 TypeScript 로더로 ts-loader를 사용할 수 있지만, 일반적으로 사용하는 babel-loader에 비해 빌드 속도가 느리다. 또한 HMR(Hot Module Replacement)를 지원하지 않는다. 따라서 babel-loader를 사용하되, babel이 TypeScript 문법을 올바르게 해석하고 JavaScript로 트랜스파일링해주기 위해 추가적인 작업이 필요하다. 여기서 필요한 것이 @babel/preset-typescript이다. 이때 TypeScript는 타입 체킹만을 위해 사용된다. ✅ @babel/runtime &amp; @babel/plugin-transform-runtime위 두 모듈은, ReferenceError: regeneratorRuntime is not defined 에러를 해결하기 위해 사용했다. regenerator-runtime은 페이스북에서 내부적으로 만든 generator funtion polyfill로, react에서 ES8 문법인 async-await을 사용할 때 관련된 regenerator를 제공하지 않아서 위와 같은 에러가 발생한다. 원래는 이를 해결하기 위해 @babel/polyfill을 사용했으나, 불필요한 polyfill들도 몽땅 추가되어 번들 파일의 크기가 커지는 이슈와 이로 인한 전역변수 오염 등의 문제로 현재 deprecated되었다. @babel/plugin-transform-runtime은 내부적으로 babel-runtime을 dependency로 갖는다. @babel/plugin-transform-runtime은 트랜스파일링 과정에서 헬퍼들을 babel-runtime 모듈이 참조하도록 변경해주는 역할을 한다. 이렇게 하는 이유는, 컴파일된 결과물에서 헬퍼들의 중복을 피하기 위함이다. 함수들을 모듈화해주는 것이다. 그렇게 babel-runtime은 실제 실행 환경에서 헬퍼함수들이 참조할 수 있는 polyfill을 내장한 모듈로서 동작한다. 그리고 regenerator-runtime의 버전을 포함하고 있다. 👾 인스턴스 메서드 문제로 인해 core-js@3의 사용을 권장하기도 했으나, babel 7.4.0 이후 버전부터 transform-runtime이 core-js@3을 지원한다고 한다. ✅ babel-jestbabel에서 jest를 사용할 수 있게 해주는 플러그인 ✅ babel-loader자바스크립트 파일을 babel/preset/plugin과 webpack을 이용하여 ES5로 컴파일해준다. ✅ babel-plugin-styled-componentsstyled-components 사용 시 권장되는 플러그인이다. 스타일 컴포넌트의 이름을 className의 해시값 앞에 접두사로 붙여서 넣어주어 디버깅을 편리하게 해준다. ✔️ Refhttps://babeljs.io/docs/en/babel-runtimehttps://babeljs.io/docs/en/babel-plugin-transform-runtimehttps://tech.kakao.com/2020/12/01/frontend-growth-02/https://programmingsummaries.tistory.com/401https://velog.io/@pop8682/번역-React-webpack-설정-처음부터-해보기https://ui.toast.com/weekly-pick/ko_20181220https://jeonghwan-kim.github.io/dev/2021/03/08/babel-typescript.html eslint 관련✅ eslint✅ eslint-config-prettier✅ eslint-plugin-prettier✅ eslint-plugin-react✅ prettier 테스트✅ testing-library✅ storybook✅ jest✅ mswmock service worker를 가리킨다. react-testing-library를 사용할 때, 실제 api를 호출을 가로채어 마치 http 통신을 수행하는 것처럼 mocking할 수 있다. ✅ react-test-rendererDOM에 의존하지 않고 리액트 컴포넌트를 순수한 자바스크립트 객체들로 바꿔주는 렌더링 라이브러리다. 즉 브라우저나 jsdom을 사용하지 않고 리액트 DOM에 의해 렌더된 DOM 트리의 스냅샷을 찍어준다. 실험적인 단계라고 한다. Ref https://www.npmjs.com/package/react-test-renderer 기타✅ ts-jestTypeScript로 jest를 작성할 수 있게 해주는 라이브러리 ✅ tsconfig-pathsTypeScript에서 절대경로를 쓸 수 있게 해 준다. tsconfig 설정을 추가해줘야 한다. 123456789// tsconfig.json{ &quot;compilerOptions&quot;: { // ... &quot;baseUrl&quot;: &quot;src&quot;, }, &quot;includes&quot;: [&quot;src&quot;, &quot;custom.d.ts&quot;]} ✅ huskygit hook을 쉽게 사용할 수 있도록 도와주는 툴이다. 루트 디렉토리의 .husky 폴더 안에 필요한 명령어 모음을 파일로 저장해둔다.","link":"/2021/08/19/wtc-lv3-log-1/"},{"title":"우테코 5주차 기록","text":"우아한테크코스 5주차 페어 프로그래밍 새 페어 심바와 매칭이 됐다. 아직 이전 미션의 후유증(?)이 가시지 않은 채로 바로 새 페어와 새 미션을 진행하는 게 걱정이 됐었다. 이번주부터 등교를 시작해서 서로 얼굴 보고 얘기할 수 있게 돼서 그런 걸까? 순식간에 페어와 친해졌다! 페어가 제안한 대로 20분씩 정확히 끊어서 페어 턴을 교체하기로 했다. 그리고 우리 모두 밤늦게까지 일하는 타입은 아니기 때문에 낮에 깨어있을 동안 열심히 하고 제출하기로 다짐했다. 페어 턴 교체는 만나서 웃고 떠드느라 제대로 교체되지 못했는데, 다른 사람 코드 칠 동안 구경만 하는 것이 아니라 계속 생각나는 대로 공유하고 코드를 같이 작성하며 진정한 의미의 페어 프로그래밍을 진행했다. 걱정했던 것보다 더 미션이 어려워서 😵 밤늦게까지 일하지 말자는 다짐은 하루만에 깨지고 말았다. 오랜만에 사람들을 만나 미친 송아지마냥 🐄 이리저리 말 걸고 다니는 내게 한 번도 뭐라고 하지 않고, 정말 특이하고 웃기다며 같이 잘 놀아주기도 하고(?) 피곤해 보이면 잠깐 쉬고 오라고 말해주는 배려심 많은 페어다. 로직을 생각하는 건 좋아하지만 타이핑은 조금 귀찮아하는 페어는 내게 타이핑을 시킬 때도 종종 있는데, 사실 생각하는 것보다 일단 모조리 타이핑을 시작해보는 타입인 나와는 합이 잘 맞는다고 생각한다! 로수타 (+포수타, 2수타) 로이드는 기술이사셨다! 오랜 개발 경력을 쌓아 높은 자리까지 올라가셨는데, 매일같이 회의하고 많은 결정을 내려야 하는 자리도 상당히 피곤할 것 같다. 그리고 포코와의 옥상타임에서 주워들은 바 상당한 내공의 소유자이심을 알 수가 있었다. 아마 우형 프론트 입사는 글렀나 보다 😭 점점 괴상한 밸런스 게임이나, 로이드는 안드로이드만 쓰는지에 대한 질문 등 드립들이 난무하는 시간이었다. 갈수록 크루들이 편해지면서 똘끼와 드립을 마구 던지는 분위기가 아주 좋다 😎 전날 새벽까지 일하고 로수타 시간에 너무 잠이 왔어서, 사실 로수타보다는 2수타(2기와의 수다 타임)와 포(코)수타가 기억이 남는다. 몇 달 뿐이었지만 인턴을 2번 해본 경험에 비추어 봤을 때, 정말 회사 다니면 아무것도 못하게 된다는 말에는 동의한다. 당시 나는 아무것도 책임질게 없는 20대 초반 대학생이었지만, 정말 다른 공부는 아무것도 할 수가 없다.그래서 지금 우테코에 있는 이 기간 동안 모든 시간을 투자해서, 미친 듯이 열심히 해보라는 2기 선배들과 포코의 조언도 이해한다. 그런데 나는 내가 맘 먹어야만 일을 시작하는 사람인 것도 너무 잘 알고,지금도 남들 눈엔 열심히 하고 있어 보이겠지만 있는 힘껏 최선을 다하고 있지 않다는 것도 안다. 자기 생에서 그 누구보다도 열심히 하던 시절을 한 순간 뽑으라면, 언제 물어봐도 나는 “고등학교 3년이었다”고 답할 것이다.그래서 그때의 열정은 다시 오지 않을 것이라고 생각했다. 그때 이미 모든 걸 쏟아버려서, 다신 그렇게까지 쏟지는 못하겠다고. 그런데 최근 생각해보니, 다시 온 정신과 열정을 투자할 때가 ‘아직’ 오지 않은 것 같다. 몸과 정신 건강을 다 잃은 적이 있었기에 아직 회복 중인 걸 수도 있고, 그냥 아직 시기가 아닐 수도 있다. 그렇지만 나는 나를 믿고, 이곳에서의 시간들이 결코 헛되지 않을 것이라고 생각한다. 그리고 아직 나는 20대 중반 젊은이니까 🤓 테코톡그동안 프론트엔드 면접 때마다 가장 많이 공부했지만 가장 헷갈리는 개념 중 하나였던, 그러나 Javascript의 &lt;근본&gt;이라고 할 수 있는 prototype에 대한 테코톡을 진행했다.지난번에 정리한 내용을 참고하면 좋을 것 같다. 😉 (왜 마크다운 링크로 안 걸리는지 모르겠다 😬) Ref https://zigsong.github.io/woowa/woowacourse-3/#prototype--mixin 👨‍🏫 강의로또 미션 공통 피드백 - 3template의 중복 줄이기지금 진행 중인 유튜브 미션에서 중복되는 template을 모아두고 쓰도록 코드를 설계했는데, 지금도 괜찮아 보이지만(?) 앞으로 있을 단계들에서 더욱 고민하여 중복된 긴 template을 처리하도록 해야겠다. let i for문 ❌for 문은 index 변수, 조건, 카운팅 등 휴먼 에러가 날 가능성이 높다! 1234567// index for loop 대신for (let i = 0; i &lt; totalCount; i++) { lottos.push(new Lotto(totalCount.pop()));}// Array 메소드를 사용하자[...Array(totalCount)].map(() =&gt; lotto.push(new Lotto(totalCount.pop())); 매직 넘버에 이름 붙이기귀찮거나 해서 맨날 무시하다가 나중에 더 귀찮아지는 일이다 😵 유지보수를 위해 항상 신경쓰기 만능 함수 쪼개기 점점 미션에서 요구하는 기능들이 많아지면서 함수 하나의 바디가 나도 모르게 커지는 일들이 비일비재하다. handler를 하나 만들고 그 안의 로직을 작은 단위의 함수로 나누는 방법도 있다. 추상화와 단순추출을 구분하자! 반전 불가능 네이밍 대신 검색하기 display와 hide보다는, show와 hide의 네이밍이 적절하다. 적절한 이름을 짓지 못하겠다면 jQuery 등 잘 짜여진 라이브러리를 참고하자 사극에서 벗어나기 최근의 네이밍 컨벤션을 사용하자 헷갈리는 부분들은 react github, 기타 오픈소스 등에서 확인할 수 있다 웹의 동작웹 서버와 클라이언트 client가 요청(request)을 보내면 server가 응답(response)하는 구조로 되어 있다. 웹에서 다양한 콘텐츠를 불특정 다수의 사람에게 공개하려면 콘텐츠를 적절히 정리하고 관리해야 하는데, 그런데 이 콘텐츠들이 여러 곳에 분산돼 있으면 문제가 발생한다. 웹에 존재하는 대부분의 콘텐츠는 업데이트가 이루어지는데, 콘텐츠가 여러곳에 분산돼 있으면 어디에 저장되어있는지 파악하고 동시에 갱신하는 것이 매우 어렵고 비용이 많이 드는 작업이다. 따라서 웹 서버와 같이 컴퓨터 하나에 정보를 모아 두어야 관리하기가 쉬워진다. client(유저)가 콘텐츠를 찾을 수 있도록 인터넷 상의 콘텐츠를 고유하게 지정해 놓은 구조가 URL(Uniform Resource Locator)다. 웹 브라우저에 특정 사이트로 접속하기 위해 주소창에 입력하는 문자열을 가리킨다. HTTP 웹 서버와 웹 클라이언트가 통신하기 위해 어떻게 정보를 주고받을지에 대한 약속을 통신 프로토콜(communication protocol)이라고 한다. 웹의 창시자 버너스 리 박사는 HTML 전송에 적합한 프로토콜을 고안하였고, 그것이 널리 쓰이는 HTTP 프로토콜이 되었다. URL(Uniform Resource Location)은 URI의 하위 개념이지만, 현재 혼용해서 사용하고 있다. https://zigsong.github.io/woowa/woowacourse-5/ 위와 같은 URL에서 https는 ‘스킴’, zigsong.github.io는 ‘호스트명’, woowa/woowacourse-5/는 ‘경로명’으로 구분한다.스킴은 리소스를 획득하기 위한 방법(HTTP 프로토콜), 호스트는 리소스가 존재하는 호스트(컴퓨터)의 이름, 경로는 호스트명에서 지정된 컴퓨터상의 리소스 위치를 나타낸다. HTTP Request는 다음 부분들로 구성된다. HTTP Request는 다음 부분들로 구성된다. 아래는 자주 사용되는 HTTP method의 종류다. Ref https://developer.mozilla.org/ko/docs/Learn/Getting_started_with_the_web/How_the_Web_works AJAX &amp; JSONAJAX(Asynchronous JavaScript and XML)AJAX(또는 XMLHttpRequest)는 비동기 방식으로 데이터를 주고받기 위해 개발된 자바스크립트 기술이다. AJAX는 HTML, XML, JSON 등 다양한 데이터를 주고받을 수 있으며, 최근에는 주로 JSON 데이터 형태로 자리잡았다. AJAX 통신을 위해서 자바스크립트가 사용하는 XMLHttpRequest 객체는 자바스크립트의 내장 객체로 비동기 통신 구현을 위한 객체이며, 이 객체는 서버로 요청을 보내고 요청받은 결과를 비동기로 처리한다. 따라서 요청을 보낸 후 사용자는 UI 화면과 상호작용을 하거나 다른 AJAX 요청을 추가로 보낼 수 있다. 서버에서 응답이 오면 AJAX 요청을 보낼 때 등록한 콜백 함수를 통해 결과 데이터를 처리한다.AJAX의 ‘비동기성’을 이용하여 페이지 전체를 리프레쉬하지 않고서도 DOM에서 수정된 부분만을 업데이트할 수 있다. JSON(JavaScript Object Notation) AJAX로 받아오는 대부분의 데이터는 JSON 포맷이다. JSON으로 전송하는 데이터의 양이 HTML보다 훨씬 적기 때문에 느린 인터넷 환경, 특히 모바일 환경에서 더 빠른 페이지 로딩과 페이지 갱신을 보장할 수 있다. 따라서 동적 웹페이지를 생성하는 데 있어 JSON을 사용한다. 웹에서 오고 가는 데이터의 대부분이 JSON으로 표현이 가능하기 때문에 사실상 JSON 포맷이 표준으로 정착해 있다. AJAX 응답으로 받은 JSON 데이터는 단순 문자열이기 때문에 데이터 변환을 해야 한다. XMLHttpRequest의 응답 객체에는responseText 속성이 있고, 이 속성에 응답으로 받은 JSON 텍스트 데이터가 있다. 이 데이터를 JSON 객체로 변환해서 사용한다. 자바스크립트에는 전역 객체로 JSON 객체가 있으며, JSON 문자열을 객체로 변환해주는 메서드가 제공된다. 1const json = JSON.parse(xhr.responseText) Refhttps://developer.mozilla.org/ko/docs/Web/Guide/AJAX/Getting_Startedhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON RESTful APIREST(Representational State Transfer)는 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다. REST는 HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다. REST는 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하여 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다. REST의 특징은 다음과 같다. Server-Client(서버-클라이언트 구조) Stateless(무상태) Cacheable(캐시 처리 기능) Layered System(계층화) Code-On-Demand(Optional) Uniform Interface(일관성) REST API란 REST 기반으로 서비스 API를 구현한 것으로, 최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다. Refhttps://cloud.google.com/apis/design/resourceshttps://developer.mozilla.org/ko/docs/Glossary/RESThttps://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html Promise비동기적인 함수 실행의 처리를 위해 등장한 callback, 그러나 비동기 함수에서 비동기 함수를 호출하는 일이 반복되어 발생하는 callback 지옥을 벗어나기 위해 Promise의 개념이 등장하였다. 123456789callback1(function(value1) { callback2(value1, function(value2) { callback3(value2, function(value3) { callback4(value3, function(value4) { // ... }); }); });}); Promise는 콜백 함수를 인자로 받는 대신에, 성공과 실패에 대응하는 메서드를 제공한다.그래서 콜백 함수를 중첩하지 않고, 여러 개의 비동기 동작을 연결할 수 있다. Promise는 비동기 작업이 성공(success)하거나 충족(fulfilled)된 경우 .then() 메서드를, 실패(fail)하는 경우에는 .catch() 메서드를 호출한다.이때 두 메서드에 전달되는 함수에는 비동기 작업의 결과인 응답만이 인수로 전달된다. Promise는 두 개의 인자 resolve()와 reject()를 전달 받는다. 코드가 정상적으로 작동하여 resolve()가 반환되면 then()에 전달된 함수가 실행되고,실패한 경우 reject()가 반환되어 catch() 함수를 실행한다. 12345new Promise(function(resolve, reject) { // ...}).then(resolve()).catch(reject()) 주로 사용하는 Promise 도구인 fetch는 아래와 같이 사용한다. 1234567fetch(url) .then(res =&gt; { return res.json() }) .then(post =&gt; { console.log(post.title) }) 😮 이때 주의할 점은 json()메서드도 Promise를 반환하기 때문에 then() 메서드를 추가해야 한다.추가한 then() 메서드에서 콜백에서 파싱된 데이터를 처리할 수 있다. Content-type과 같은 header를 넣어 요청을 보낼 수 있다. 123456789101112131415161718192021const option = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(newPost)}fetch(url, option) .then(res =&gt; { if (!res.ok) { throw new Error(res.status) } return res.json() }) .then(post =&gt; { console.log(post.title) }) .catch(error =&gt; { console.log(error) }) async-await을 사용하여 Promise를 더욱 편리하게 사용할 수 있다. async 키워드를 이용해서 선언한 함수는 비동기 데이터를 사용한다는 것을 의미한다. 비동기 함수의 내부에서 await 키워드를 사용하면 값이 반환될 때까지 함수의 실행을 중지시킨다.await을 호출하는 함수는 반드시 async 함수 안에서 실행되어야 한다 12345async function getUser() { const zig = await getTargetUser(); return zig;} Ref https://joshua1988.github.io/web-development/javascript/promise-for-beginners/ 👀 PR 구경하기는 말도 안 되지만 한 개도 하지 못했다…주말에 몰아서 해도 됐었지만 사람다운 삶을 살기 위해 이번 주말도 잠시 숨을 돌리기로… 📚 배우기90년생 HTML 90년도부터 시작한 html, 고향은 스위스 CERN 연구소 웹의 등장 클라이언트와 서버로 분리한 이유? 데이터의 일관성 유지 웹 서버로 만들어서 인터넷으로 연결하여 사용 원하는 리소스를 찾는 방법 단순히 페이지에서 주소를 치는 것 뿐 아니라, 인터넷 상에 존재하는 콘텐츠의 고유한 값 자원 요청에 대한 구체적인 부분들 데이터를 주고 받는 방법의 진화 AJAX RESTful API 프로그래밍은 상상이다소프트스킬 협력을 통한 추상화 톱니바퀴 실험 규칙을 정하기 위해 추상적 개념을 도입하게 됨 어느 쪽이 좌측/우측인지 서로 다른 시각을 공유 다른 시각을 가진 두 사람이 협력하기 면접 스킬 그림을 그리며 추상화 상대의 질문에 리액션 상대방과 질문 주고 받으며 상자 밖에서 생각하기 “that’s a good question!” function apply, call지난 테코톡 때 this binding을 다루며 나온 주제인데, 막상 쓰려니까 겁이 나기도 하고 😬 적확한 사용이 어려웠다. 코치님의 도움을 받아 페어와의 미션에 적용시켜 보았다. 미션에 작성한 코드는 아래와 같다. 123456789101112131415161718192021222324252627282930313233// viewthis.modalVideos.addEventListener( 'scroll', // 6. 실행되는 순간 이곳에는 setTimeout 함수가 남는다. throttle(function (event) { const { scrollTop, scrollHeight, offsetHeight } = event.target; if (scrollTop === scrollHeight - offsetHeight) { // 7. throttle 함수 안의 callback에서 바인딩해준 this를 가지고 있기 때문에(5번) this는 view를 가리킨다. this.emit('scrollResult', this.searchKeyword); } // 1. 여기서 미리 명시적 binding을 해준다. }, VALUE.THROTTLE_TIME).bind(this), );// throttle.jsexport default function throttle(callback, delay) { // 2. 이 함수 내부에서 this는 view에서 binding해 준 this이다. (view를 가리킴) let ticking; // 3. 함수 내부에서 함수를 리턴하여, view에서 scroll 발생 시 listener 부분에는 아래 setTimeout 함수만 남게 된다. return function () { // 4. 클로저 함수는 위에 선언된 ticking을 참조한다. (기억하고 있다.) if (ticking) return; ticking = setTimeout(() =&gt; { ticking = null; // 5. callback 함수에 this(여기서는 view를 가리킴)를 바인딩해준다. callback.apply(this, arguments); }, delay); };} view에서 throttle 함수를 사용하고 싶은데, 이때 view에서 event target으로 받아오는 scroll data들을 넘겨줘야 했다. throttle 함수는 함수를 리턴하는 클로저 함수다. 따라서 view에서 scroll event가 발생할 때 listener 부분에는 throttle 함수가 리턴하는 setTimeout 함수만 남게 된다.this는 현재 객체(호출하는 객체)를 참조하기 때문에 view에서 호출하는 throttle 함수에서 bind(this)를 해준 후 throttle 함수 내부에서 callback에 apply를 해줌으로써 this binding이 이루어진다.view를 가리키는 this가 view의 bind → throttle의 apply를 한 바퀴 돌아 다시 view에서 사용되고 있다. call과 apply는 명시적 binding으로, this를 강제로 바인딩시켜준다. 아래는 주말 밤 코치님의 특훈쓰… 1234567891011121314151617const zig = { name: 'zig'}function sing(play) { console.log(`${this.name} ${play}`);}// 1. call 사용 console.log(sing.call(zig, 'is singing rollin'));// output: zig is singing rollin// 2. bind 사용const zigSing = sing.bind(zig) // sing 함수에 zig가 바인딩된다. zigSing('is dancing') // 위에서 binding되는 순간에 zigSing은 zig를 기억하고 있다. // output: zig is dancing call의 this에 zig를 넣어주면 sing 메소드의 this는 zig에 바인딩된다.또 인자로 ‘is singing rollin’을 넘겨줌으로써 결과적으로 ‘zig is singing rollin’을 출력하게 된다. 🤓 call과 apply는 거의 비슷하지만, call은 인수 목록을, apply는 인수 배열 하나를 받는다는 점이 차이점이다. mdn에서 call과 apply의 유용한 쓰임들을 확인할 수 있다. Refhttps://jinminkim-50502.medium.com/javascript-debouce-throttle-3f6618c13fb6https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/applyhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call closure currying함수를 반환하는 자바스크립트 closure 특성을 이용하여 currying이라는 패턴을 사용한다.currying은 함수를 즉시 평가하고 반환하는 것을 가리킨다. 1234567891011121314let greeting = function (a) { return function (b) { console.log(a + ' ' + b); }}let hello = greeting('Hello')let morning = greeting('Good morning')hello('Zig') // Hello Zighello('Jay') // Hello Jaymorning('Zig') // Good morning Zigmorning('Jay') // Good morning Jay greeting으로부터 생성된 hello와 morning 함수는 콘솔에 인사말을 찍는 함수를 받는다.그리고 각각은 인사 받을 사람의 이름을 인자(b)로 받고 있다. greeting 함수에서 리턴되는 내부 함수는 greeting이 받는 파라미터(a) 이후에 인자(b)를 받아서 실행할 수도 있다. 12greeting('Hello There')('Zig Song')// Hello There Zig Song ES6의 arrow function을 이용하여 아래와 같이 쓸 수도 있다고 한다. 1234let greeting = (a) =&gt; (b) =&gt; a + ' ' + bgreeting('Hello There')('Zig Song')// Hello There Zig Song 새로운 개념이 아닌, 자바스크립트의 closure 패턴을 활용한 함수의 사용이라고 보면 되겠다.수학적으로 접근하면 이런 느낌 🙄 1f(a, b, c) —&gt; f(a) =&gt; g(b) =&gt; h(c). Refhttps://www.digitalocean.com/community/tutorials/an-introduction-to-closures-and-currying-in-javascript#what-is-curryinghttps://betterprogramming.pub/closures-currying-and-cool-abstractions-89221e565eb0 observer patternobserver pattern은 RxJS나 swift를 할 때 조금씩 사용했던 패턴이다.항상 지켜봐줘야 하는 state를 observable object로 만들고, 비즈니스 로직을 담당하는 여러 controller에서 해당 state를 update시켜주거나 subscribe를 통해 상태의 변화를 항상 추적한다. 즉 controller가 state의 상태를 항상 관찰하는 observer가 되는 것이다. 이번 유튜브 미션은 기능을 수행하는 곳이 다양해진 만큼 controller의 분리와 상태의 관리가 필요해졌다. 개념 자체는 어렵지 않은데 모든 것을 처음부터 vanilla javascript로 구현해야 하는게 어렵다 😱그래두 다른 갓갓 크루들의 코드들을 보며 조금씩 바꿔나가고 있다. 😎 이때 Subject라는 이름으로 명명한 하나의 모듈에 상태 관리가 필요한 대상들을 넣어 대상에 update가 발생할 때마다 연결된 모든 observer에 알려주게끔(notify) 만들 수 있다. 123456789101112131415161718192021class Subject { constructor() { this.observers = []; } registerObserver(observer) { this.observers.push(observer); } unregisterObserver(observer) { this.observers = this.observers.filter(registedObserver =&gt; registedObserver !== observer); } notifyObservers(data) { // 함수로 넣었을 때 // this.observers.forEach(observer =&gt; observer(data)); this.observers.forEach(observer =&gt; observer.notify(data)); }}const subject$ = new Subject(); 사실은 javascript의 addEventListener도 observer pattern을 적용시킨 것이라고 볼 수 있다. 이벤트(Subject)를 구독하여(addEventListenr) 변화를 감지할 때마다 옵저버(callback)에게 알려서 실행하는 것이다. Refhttps://medium.com/@yeon22/design-pattern-observer-pattern-이란-ef4b74303359http://blog.naver.com/PostView.nhn?blogId=c_ist82&amp;logNo=220795909036 netlify 배포 &amp; API key 등록API key를 담은 파일을 올리면 github page로 데모 사이트를 빌드할 수가 없어서, 처음으로 netlify를 통해 배포를 시도했다. netlify를 이용한 정적 페이지는 어렵지 않았다. 다만 빌드 시 echo 명령어를 통해 file에 API key를 입력해주고 있어서, 배포된 페이지의 source tab에 들어가 보면 여전히 key가 노출되어 있다. 😂프론트엔드 구현만으로는 key를 완벽하게 숨길 수 없다. 미션 기능 구현을 마무리하고 다른 크루가 알려준 방식대로 API key를 받는 서버를 따로 만들어야할 것이다. Ref https://www.youtube.com/watch?v=2J3xbMkH2K4 javascript의 함수 vs 메소드등교한 어느날 코치님이 물어보셨는데 아무도 똑바로 대답하지 못했다 😵 🤔 함수는 함수고, 메소드는 클래스에 종속되어 있는 함수 아냐? 틀린 말은 아닌 것 같지만, 제대로 이해를 해보자! 아래는 고개를 끄덕이게 하는 설명들이다. 함수가 메소드를 아우르는 포괄적인 용어이다. 함수는 객체로부터 독립적이며, 메소드는 객체에 종속적이다. 그러면 내 생각이 맞는 것 아닌가?할 수 있지만, 메소드와 함수의 차이를 보다 분명하게 확인해보자. 메소드는 호출된 객체에 암시적으로 전달된다. 메소드는 클래스 안에 있는 data를 조작할 수 있다. You don’t know JS의 카일심슨이 설명하는 내용은 조금 추상적이지만 흥미롭다. 1234567891011function foo() { console.log(&quot;foo&quot;);var someFoo = foo; // 'foo'에 대한 변수 레퍼런스var myObject = { someFoo: foo};foo; // function foo() {...}someFoo; // function foo() {...}myObject.someFoo; // function foo() {...} someFoo나 myObject.someFoo 모두 같은 함수를 가리키는 개별 레퍼런스일뿐, 뭔가 특별한 다른 객체가 ‘소유한’ 함수라는 의미는 아니라는 것이다. 결론적으로 ‘객체(클래스)로부터 독립적인가 아닌가’가 함수와 메소드를 나누는 기준이다.원래 생각과 무슨 차이가 있는지 아직도 잘 모르겠긴 하지만 🙄 다음에 사람들과 토론해봐야겠다. Ref https://sustainable-dev.tistory.com/33 기타srcdoc&lt;iframe&gt; 태그의 srcdoc 속성은 &lt;iframe&gt; 요소에 보일 웹 페이지의 HTML 코드를 명시한다. src 속성보다 우선시되는 속성값이기 때문에, 브라우저가 srcdoc 속성을 지원하면 &lt;iframe&gt; 요소의 src 속성값은 srcdoc 속성값으로 재정의된다. 하지만 srcdoc 속성이 명시되어 있지만 해당 브라우저가 srcdoc 속성을 지원하지 않으면, &lt;iframe&gt;은 src 속성에 명시된 파일을 보여준다. 사용자에게 보다 빠르게 &lt;iframe&gt;을 보여주기 위해, 비동기적으로 불러온 영상의 링크를 아직 받아오지 않았을 때 srcdoc 속성에 영상의 썸네일을 먼저 로딩 후 해당 &lt;iframe&gt;을 클릭하면 비로소 src 속성의 링크가 뜨도록 만들 수 있다. Ref https://www.w3schools.com/tags/att_iframe_srcdoc.asp &lt;button&gt; default type&lt;button&gt; 태그의 default type은 submit이다.&lt;button type=&quot;submit&quot;&gt;을 굳이 넣어줄 필요는 없고, &lt;input type=&quot;submit&quot;&gt;만 잘 챙겨주면 되겠다. Intersection Observer API이미지나 컨텐츠의 지연 로딩, infinite scroll, 광고의 가시성 보고 등에 사용되는 API다.감시하고자 하는 요소가 다른 요소(viewport)에 들어가거나 나갈 때 또는 요청한 부분만큼 두 요소의 교차부분이 변경될 때마다 실행될 콜백 함수를 등록할 수 있게 한다. 1234567let options = { root: document.querySelector('#scrollArea'), rootMargin: '0px', threshold: 1.0}let observer = new IntersectionObserver(callback, options); 🤓 설정한 scroll 영역에서 관찰 대상이 되는 요소가 사용자의 화면에 지금 보이고 있는지 아닌지를 측정하여 infinite scroll 기능을 구현하는 데 사용할 수 있다. Refhttps://developer.mozilla.org/ko/docs/Web/API/IntersectionObserver/IntersectionObserverhttps://heropy.blog/2019/10/27/intersection-observer/ target blank noopener아래와 같이 a 태그를 noopener 옵션 없이 사용했을 경우 연결 중인 페이지는 연결 페이지에 부분적으로 접근할 수 있다. 연결된 페이지의 콘솔에서 window.opener를 찍어서 확인할 수 있다. 이는 악의적인 조작이 가능하다는 것이다! 😱 1&lt;a href=&quot;https://www.zigsong.github.io&quot; target=&quot;_blank&quot;&gt;ziglog&lt;/a&gt; 이때 rel 속성으로 noopener를 넣어주면, 연결된 페이지에 window.opener 객체가 존재하지 않게 된다. 1&lt;a href=&quot;https://www.zigsong.github.io&quot; target=&quot;_blank&quot;&gt;ziglog&lt;/a&gt; noopener와 유사한 기능으로 noreferrer가 있다. noreferrer는 새로 열린 웹사이트가 window.opener 객체를 조작하지 못하게 한다.링크를 클릭할 때 참조자 정보를 숨겨, 클릭한 사용자가 어디서 왔는지 알 수 없게끔 만든다. noopener와 noreferrer 두 가지를 모두 사용하는 것이 좋다고 한다! 😉 Ref https://webruden.tistory.com/262 모달 관련 UX한 리뷰어님께서 모달이 open인 상태에서 document body 의 scroll을 lock 해주는 UX를 생각해보자 고 하셨다. 역시 현업자는 다르다… 섬세한 프론트엔드 엔지니어… CSS grid😵 오랜 시간 elements 탭을 뜯어보게 만들었던 grid…컨테이너에 display: grid를 적용한 후, flex와 마찬가지로 컨테이너에 먹이는 값, grid item 각각에 먹이는 값으로 나뉜다. 내용이 방대하기 때문에 링크 참고 😉 Refhttps://studiomeal.com/archives/533https://code.tutsplus.com/ko/tutorials/introduction-to-css-grid-layout-with-examples--cms-25392 BEM BEM은 CSS 제작 방법론으로, 일종의 네이밍 컨벤션이다. html 요소들을 각각 Block, Element, Modifier 세 가지로 분류해 작명하는 방식이다. ‘목적’에 따라 네이밍하는 것이 특징이다. Block - 독립적으로 존재하고 재사용 가능한 요소를 Block으로 명명한다. 태그 값과 id 대신 클래스로 DOM을 선택한다. 재사용을 위해 position, margin 등의 위치값을 지정하지 않는다. 색상이나 크기 등을 묘사하는 이름은 지양하며, 구조적으로 의미 있는 이름로 작명한다. Element - block 내부에 종속되어 실제 기능을 담당한다. 종속의 의미를 block-name__element-name로 나타낸다.독립적으로 존재하지 않으며, block에 의존적이다. 따라서 block에서 떼내어 다른 곳에서 가져다 쓸 수 없다. Modifier - block이나 element의 속성을 가리킨다. --나 __를 사용하여 표현한다. 결론적으로 block-name--modifier-name, block-name__element-name--modifier-name의 형태로 작성할 수 있다. 123.header__navigation--focused { color: red;} 위와 같은 css 코드가 있을 때 header는 Block, navigation은 Element, focused는 Modifier가 된다.header는 어디에서나 가져다 쓸 수 있으며, navigation은 header에 종속되어 있는 탭들이라고 할 수 있다.focused는 navigation 중에서 조금 다르게 보여질 것이다. 따라서 해당 element의 속성값이다. Refhttps://velog.io/@ylem76/BEMhttps://nykim.work/15 🤔 생각해보기그런 API로 괜찮은가https://tv.naver.com/v/2292653 😎 마무리처음으로 등교를 시작했다. 준비 시간, 이동 시간 합쳐서 하루 3시간은 까먹고 몸의 피로함은 배가 됐지만 너무너무 재밌고 행복하다! 같은 과제를 하고 비슷한 목표를 향해 함께 달려가며 고민하고 웃고 떠드는 과정들이 정말 즐겁다. 취업 안 하고 평생 이렇게만 살아도 좋을 만큼 재미있다 (하지만 돈 벌어야 하기에…😂) 그래서 우테코 2기 선배가 내게 우테코를 추천했던 것보다도 더욱 많이 주변 사람들에게 우테코를 추천하고 싶다. 너무나도 다양한 배경에서, 다양한 이유로 웹개발을 시작하게 된 사람들이지만 그 열정만큼은 정말 눈이 부실 만큼 멋지다. 개발하며 사실 어휘력이 많이 떨어져서, 멋지다는 표현도 너무 부족할 만큼 멋진 크루들이다. 불금에는 같이 불코딩하고 간단히 맥주도 한 잔 했다. 다들 친화력 갑 👍 매주 같이 술 한잔씩 했으면 좋겠다! 5인 제한이 어서 풀려서 조금 더 많은 크루들과 모여 짠하는 날이 빨리 왔으면 좋겠다. 습득력은 빠를지 몰라도 사실 열정은 그렇게 크지 않았던 내게 귀감이 되어주는 소중한 크루들, 그리고 항상 격려해주고 조언을 아끼지 않는 코치님들이 있기 때문에 조금 벅차고 피곤하지만 계속해서 달려나갈 힘이 생기는 것 같다. 때로는 슬럼프도, 번아웃도 오겠지만 끝까지 화이팅할 수 있기를 😎–","link":"/2021/03/06/woowa-week-05/"}],"tags":[],"categories":[{"name":"retrospective","slug":"retrospective","link":"/categories/retrospective/"},{"name":"frontend","slug":"frontend","link":"/categories/frontend/"},{"name":"글또","slug":"글또","link":"/categories/%EA%B8%80%EB%98%90/"},{"name":"wtc-havruta-fe","slug":"wtc-havruta-fe","link":"/categories/wtc-havruta-fe/"},{"name":"troubleshooting","slug":"troubleshooting","link":"/categories/troubleshooting/"},{"name":"oop-true-and-false","slug":"oop-true-and-false","link":"/categories/oop-true-and-false/"},{"name":"refactoring","slug":"refactoring","link":"/categories/refactoring/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"woowacourse","slug":"woowacourse","link":"/categories/woowacourse/"},{"name":"wtc-pr-log","slug":"wtc-pr-log","link":"/categories/wtc-pr-log/"},{"name":"wtc-study-log","slug":"wtc-study-log","link":"/categories/wtc-study-log/"},{"name":"git &amp; github","slug":"git-github","link":"/categories/git-github/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"nestjs","slug":"nestjs","link":"/categories/nestjs/"}]}