{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-function-class-component/","result":{"data":{"site":{"siteMetadata":{"title":"ziglog","author":"zigsong","lang":"en"}},"markdownRemark":{"id":"0036b352-e722-5d46-b439-b47001bf797e","excerpt":"Overreacted Dan abramov의 글, 리액트가 함수 컴포넌트와 클래스 컴포넌트를 구별하는 법을 내 스타일대로 정리해보았다. React는 함수 컴포넌트와 클래스 컴포넌트를 각각 어떻게 호출할까? React…","html":"<p>Overreacted</p>\n<!-- more -->\n<hr>\n<p>Dan abramov의 글, <a href=\"https://overreacted.io/how-does-react-tell-a-class-from-a-function/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">리액트가 함수 컴포넌트와 클래스 컴포넌트를 구별하는 법</a>을 내 스타일대로 정리해보았다.</p>\n<hr>\n<h2 id=\"react는-함수-컴포넌트와-클래스-컴포넌트를-각각-어떻게-호출할까\" style=\"position:relative;\"><a href=\"#react%EB%8A%94-%ED%95%A8%EC%88%98-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EA%B0%81%EA%B0%81-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%98%B8%EC%B6%9C%ED%95%A0%EA%B9%8C\" aria-label=\"react는 함수 컴포넌트와 클래스 컴포넌트를 각각 어떻게 호출할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React는 함수 컴포넌트와 클래스 컴포넌트를 각각 어떻게 호출할까?</h2>\n<p>React의 함수 컴포넌트는 다음과 같이 작성한다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>같은 코드를 클래스 컴포넌트로 작성하면 아래와 같다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Greeting</code> 컴포넌트를 함수 컴포넌트로 작성하든, 클래스 컴포넌트로 작성하든 상관은 없다.</p>\n<p>만약 <code class=\"language-text\">Greeting</code>이 함수라면, 리액트는 이를 내부적으로 아래와 같이 호출할 것이다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>하지만 만약 <code class=\"language-text\">Greeting</code>이 클래스라면, 리액트는 이를 <code class=\"language-text\">new</code> 키워드를 통해 인스턴스를 만들고 <code class=\"language-text\">render</code> 메서드를 호출해야 한다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>그런데, 리액트는 컴포넌트가 클래스인지 함수인지 어떻게 아는 걸까? 🤔</p>\n<p>물론 이는 리액트가 알아서 해주기 때문에 사용하는 입장에서 반드시 알아야 할 필요는 없다. 하지만 궁금하지 않은가?!</p>\n<h3 id=\"추측-1-모두-new-키워드로-인스턴스화-해준다\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%B8%A1-1-%EB%AA%A8%EB%91%90-new-%ED%82%A4%EC%9B%8C%EB%93%9C%EB%A1%9C-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94-%ED%95%B4%EC%A4%80%EB%8B%A4\" aria-label=\"추측 1 모두 new 키워드로 인스턴스화 해준다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추측 1: 모두 <code class=\"language-text\">new</code> 키워드로 인스턴스화 해준다.</h3>\n<p>리액트가 모든 컴포넌트를 <code class=\"language-text\">new</code> 키워드로 인스턴스화해준다면 어떨까?</p>\n<p>클래스 컴포넌트의 경우 인스턴스를 만드는 것이 기본이므로 문제없이 동작할 것이다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi, I am \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Fred\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>JavaScript에서 클래스 문법의 전신(?)인 생성자 함수의 경우에도 <code class=\"language-text\">new</code> 키워드를 통해 인스턴스를 만들고, prototype method를 상속받아 사용할 수는 있다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi, I am \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Fred\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 리액트 컴포넌트는 화살표 함수로도 선언이 가능하다는 점을 잊어서는 안 된다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Greeting</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🚨 Greeting is not a constructor</span></code></pre></div>\n<p>리액트 문법을 떠나서, JavaScript의 화살표 함수는 자체적인 <code class=\"language-text\">this</code>를 갖지 않는다. <code class=\"language-text\">prototype</code>도 생성하지 않으며, <code class=\"language-text\">constructor</code>가 없어 생성자 함수로 동작할 수도 없다. <code class=\"language-text\">new</code> 키워드를 통해 인스턴스를 만들 수 없는 것이다.</p>\n<p>또, (약간 억지긴 하지만) instance object를 리턴하지 않는 함수가 있을 수도 있다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 'Hello'</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Greeting {}</span></code></pre></div>\n<p><code class=\"language-text\">Greeting</code>을 마치 생성자 함수처럼 선언해 놓고, 인스턴스가 아닌 원시값을 리턴한다면 인스턴스를 반환하지 않게 된다. <code class=\"language-text\">new</code> 연산자를 사용하는 의미가 없다!</p>\n<h3 id=\"추측-2-그렇다면-new-키워드-없이-그냥-함수-호출하듯-호출해준다면\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%B8%A1-2-%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-new-%ED%82%A4%EC%9B%8C%EB%93%9C-%EC%97%86%EC%9D%B4-%EA%B7%B8%EB%83%A5-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%ED%95%98%EB%93%AF-%ED%98%B8%EC%B6%9C%ED%95%B4%EC%A4%80%EB%8B%A4%EB%A9%B4\" aria-label=\"추측 2 그렇다면 new 키워드 없이 그냥 함수 호출하듯 호출해준다면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추측 2: 그렇다면 <code class=\"language-text\">new</code> 키워드 없이 그냥 함수 호출하듯 호출해준다면?</h3>\n<p>안 된다.</p>\n<p>JavaScript의 클래스는 인스턴스를 만드는 것이 주요 목적이기 때문에, <code class=\"language-text\">new</code> 키워드를 통해 인스턴스를 생성해주지 않으면 에러가 발생한다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi, I am \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"George\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 🚨 Uncaught TypeError: Class constructor Person cannot be invoked without 'new'</span></code></pre></div>\n<p>생성자 함수에서도 위험하긴 마찬가지다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi, I am \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"George\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">Person</code> 함수를 <code class=\"language-text\">new</code> 키워드 없이 호출할 수는 있지만, 인스턴스가 생성되지 않는다. 이때 <code class=\"language-text\">this</code>는 인스턴스가 아닌 <code class=\"language-text\">window</code>(또는 <code class=\"language-text\">undefined</code>)를 가리키게 된다. 정확한 동작을 예측할 수 없게 되는 것이다.</p>\n<h3 id=\"그래서-컴포넌트의-형태를-어떻게-구분하는-걸까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%ED%98%95%ED%83%9C%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C\" aria-label=\"그래서 컴포넌트의 형태를 어떻게 구분하는 걸까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래서, 컴포넌트의 형태를 어떻게 구분하는 걸까?</h3>\n<p>컴포넌트를 클래스로 정의하면 <code class=\"language-text\">React.Component</code>를 상속(<code class=\"language-text\">extends</code>)받게 된다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>클래스를 상속한다는 것은, 부모 클래스의 <code class=\"language-text\">prototype</code>의 인스턴스가 된다는 말로도 이해할 수 있다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>클래스나 생성자 함수를 <code class=\"language-text\">new</code> 키워드로 호출하여 생성한 인스턴스들은 해당 클래스(또는 함수)의 <code class=\"language-text\">prototype</code>을 상속받게 되는 것이다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi, I am \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Fred\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// fred.__proto__ === Person.prototype</span></code></pre></div>\n<p>모든 클래스 컴포넌트는 <code class=\"language-text\">React.Component</code>를 상속받는다. 클래스 컴포넌트 내부에서 <code class=\"language-text\">setState</code> 등의 메서드를 사용할 수 있는 것도 이 때문이다.</p>\n<p>즉 클래스 컴포넌트를 사용하면, 인스턴스의 <code class=\"language-text\">__proto__</code> 체인이 클래스 계층 구조를 가리키게 된다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `extends` chain</span>\nGreeting\n  → React<span class=\"token punctuation\">.</span>Component\n    → <span class=\"token function\">Object</span> <span class=\"token punctuation\">(</span>implicitly<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// `__proto__` chain</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>따라서 <code class=\"language-text\">instanceof</code> 메서드를 통해 현재 클래스 컴포넌트가 <code class=\"language-text\">React.Component</code>의 자식 객체, 즉 인스턴스인지 확인하는 방법을 사용할 수 있다.</p>\n<p>컴포넌트의 형태를 확인하는 또 다른 방법으로, 리액트는 베이스 컴포넌트에 특별한 flag, <code class=\"language-text\">isReactComponent</code>를 추가했다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// We can check it like this</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Yes</span></code></pre></div>\n<p><code class=\"language-text\">React.Component</code>를 상속받는 클래스의 경우 리액트는 프로토타입 체인 상에서 <code class=\"language-text\">isReactComponent</code> 프로퍼티를 찾게될 것이다. (<code class=\"language-text\">isReactComponent</code>의 값을 boolean이 아닌 object 타입으로 설정한 것은 Jest의 초기 버전에서 자동 mocking된 결과라고 한다.)</p>\n<p>이 방법은 <a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">실제 리액트 코드</a>에서 사용되고 있다. 😮</p>\n<hr>\n<h2 id=\"생각\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EA%B0%81\" aria-label=\"생각 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생각</h2>\n<p>클래스 컴포넌트는 인스턴스를 생성하기 때문에, 컴포넌트에서 지속적으로 유지되는 상태를 만들 수 있다.</p>\n<p>반면 함수 컴포넌트는 호출된 후 사라지며 렌더링할 때마다 다시 생성된다. 따라서 상태를 가질 수 없으며, 상태를 흉내내기 위해 컴포넌트와 별도로 구현한 것이 hook이다.</p>\n<p>이렇듯 클래스 컴포넌트와 함수 컴포넌트는 리액트에서 호출되고 소멸하기까지의 과정에서 큰 차이가 있는데, 리액트에서 이 둘을 어떻게 구분하여 관리하는지는 생각해보지 못한 것 같다.</p>\n<p>실제 내용은 생각보다 간단한 JavaScript의 기본 원리(프로토타입 체인, 클래스 상속)로 컴포넌트를 구분해서 호출하고 있었다. 역시 리액트를 잘 하려면 JavaScript에 대한 깊은 이해가 필요하겠다.</p>\n<p>앞으로 더 많은 의심을 하고 궁금증을 갖는 개발자가 되자! 🤩</p>\n<hr>\n<p><strong>Ref</strong> <a href=\"https://overreacted.io/how-does-react-tell-a-class-from-a-function/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://overreacted.io/how-does-react-tell-a-class-from-a-function/</a></p>","timeToRead":6,"frontmatter":{"title":"리액트가 함수 컴포넌트와 클래스 컴포넌트를 구별하는 법","date":"November 16, 2021","description":null,"tags":["react"],"disqus":null},"fields":{"langKey":"en"}}},"pageContext":{"slug":"/react/react-function-class-component/","previous":{"fields":{"slug":"/wtc/wtc-week-40-41/","langKey":"en","directoryName":"wtc"},"frontmatter":{"date":"November 26, 2021","description":null,"title":"우테코 마지막 주차 기록","tags":["woowacourse"]}},"next":{"fields":{"slug":"/wtc/wtc-week-38-39/","langKey":"en","directoryName":"wtc"},"frontmatter":{"date":"November 13, 2021","description":null,"title":"우테코 38~39주차 기록","tags":["woowacourse"]}},"previousInSameTag":{"fields":{"slug":"/react/betray-of-useRef/","langKey":"en","directoryName":"react"},"frontmatter":{"date":"June 28, 2023","description":null,"title":"useRef의 배신","tags":["react"]}},"nextInSameTag":{"fields":{"slug":"/react/await-setstate/","langKey":"en","directoryName":"react"},"frontmatter":{"date":"October 16, 2021","description":null,"title":"React의 setState에 await을 붙이면?","tags":["react"]}},"translationsLink":[]}},"staticQueryHashes":["1522010811","2466007692","2894998521","3765107650","683610688"]}