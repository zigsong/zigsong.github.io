{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/betray-of-useRef/","result":{"data":{"site":{"siteMetadata":{"title":"ziglog","author":"zigsong","lang":"en"}},"markdownRemark":{"id":"c42914f2-fad6-524b-bcf1-f2933398b3ac","excerpt":"useRef는 첫 렌더링 시 값을 가지지 않을 수도 있다 🙀 가 비어있다! 특정 DOM 요소의 height를 구할 때, 를 사용하여 DOM에 ref를 붙일 수 있다. 요렇게… 🚨 그런데! 가 가져온 DOM element의 height…","html":"<p>useRef는 첫 렌더링 시 값을 가지지 않을 수도 있다</p>\n<!-- more -->\n<hr>\n<h3 id=\"-useref가-비어있다\" style=\"position:relative;\"><a href=\"#-useref%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8B%A4\" aria-label=\" useref가 비어있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🙀 <code class=\"language-text\">useRef</code>가 비어있다!</h3>\n<p>특정 DOM 요소의 height를 구할 때, <code class=\"language-text\">useRef</code>를 사용하여 DOM에 ref를 붙일 수 있다.</p>\n<p>요렇게…</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">MenuItem</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> menuItemRef <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useRef</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>HTMLDivElement<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>menuItemRef<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token comment\">/* ... */</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>🚨 그런데!</p>\n<p><code class=\"language-text\">menuItemRef</code>가 가져온 DOM element의 height를 구하려 했는데, 첫 번째 렌더 시에 <code class=\"language-text\">menuItemRef.current</code>의 값이 null이 나온다.</p>\n<p><strong>🤔 왜 첫 번째 렌더링에서 Ref의 값이 비어있을까?</strong></p>\n<p>리액트에서 업데이트는 두 단계로 이루어진다.</p>\n<ol>\n<li><strong>render phase</strong> - 무엇이 스크린에 그려져야 할지 알아내기 위해 리액트는 컴포넌트를 호출한다</li>\n<li><strong>commit phase</strong> - 리액트는 변경사항을 DOM에 반영한다</li>\n</ol>\n<p>일반적으로, render phase에서 ref에 접근하지는 않는다. (특히 ref가 DOM에 붙은 경우) 첫 번째 렌더 시에, DOM node들이 아직 생성되지 않았기 때문에 <code class=\"language-text\">ref.current</code>의 값은 <code class=\"language-text\">null</code>이 될 수 있다.</p>\n<p>리액트는 commit phase에서 <code class=\"language-text\">ref.current</code>의 값을 설정한다. 그리고 DOM을 업데이트하기 전에, 리액트는 <code class=\"language-text\">ref.current</code>의 값을 <code class=\"language-text\">null</code>로 설정한다. DOM 업데이트가 완료된 후에, 리액트는 즉시 <code class=\"language-text\">ref.current</code>의 값을 DOM node의 값으로 설정한다.</p>\n<p><code class=\"language-text\">ref.current</code> 값이 변경되더라도 리렌더링을 유발하지 않기 때문에, <code class=\"language-text\">useRef</code>는 컴포넌트의 내용이 바뀌어도 변경사항을 알려주지 않는다. 즉 첫 번째 렌더 시에 <code class=\"language-text\">ref={menuItemRef}</code>는 업데이트되겠지만, 새로운 리렌더링을 유발하진 않는다.</p>\n<p>(🙃 TanStack Query의 메인테이너도 <code class=\"language-text\">useRef</code>의 동작 방식에 가스라이팅 당했다고 한다 (<a href=\"https://twitter.com/tannerlinsley/status/1641548458526908417\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처 - 트위터</a>))</p>\n<p><strong>💡 <code class=\"language-text\">ref.current</code> 값의 업데이트에 따라 리렌더링을 하고 싶다면 ref 대신 <code class=\"language-text\">useCallback</code>을 사용하는 방법도 있다 (<a href=\"https://legacy.reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React 공식 문서 - How can I measure a DOM node?</a>)</strong></p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">MenuList</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> menuItemRef <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> HTMLDivElement <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setMenuHeight</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span><span class=\"token function\">getBoundingClientRect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>menuItemRef<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token comment\">/* ... */</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>리액트는 ref가 새로운 노드에 붙을 때마다 callback을 수행한다. 그렇기 때문에 callback ref를 사용하면 자식 컴포넌트가 ref가 붙은 노드를 나중에 표시할 때도(ex. 사용자의 인터랙션 이후) 업데이트된 값을 제공한다.</p>\n<p><code class=\"language-text\">useCallback</code>의 deps로 빈 배열(<code class=\"language-text\">[]</code>)을 넣어서 ref callback이 리렌더링 사이에 바뀌지 않도록 한다. 예제에서, ref가 붙은 <code class=\"language-text\">&lt;div></code> 요소는 리렌더링 간에도 계속 존재하기 때문에 callback ref는 오직 컴포넌트 마운트/언마운트 시에만 호출된다.</p>\n<h3 id=\"useref의-구현-방식\" style=\"position:relative;\"><a href=\"#useref%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D\" aria-label=\"useref의 구현 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🔍 <code class=\"language-text\">useRef</code>의 구현 방식</h3>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// Inside of React</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span>initialValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>ref<span class=\"token punctuation\">,</span> unused<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> current<span class=\"token operator\">:</span> initialValue <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>첫 번째 렌더 시에, <code class=\"language-text\">useRef</code>는 <code class=\"language-text\">{ current: initialValue }</code>를 반환한다. 이 객체는 리액트에 저장되고, 따라서 다음 렌더 시에도 같은 객체(참조값)가 반환된다. <code class=\"language-text\">useRef</code>는 항상 같은 객체를 반환하기 때문에 <code class=\"language-text\">useState</code>의 setter는 사용되지 않는다. (unused)</p>\n<h3 id=\"useeffect의-deps에refcurrent값을-넣고refcurrent값이-바뀌면useeffect가-호출될까\" style=\"position:relative;\"><a href=\"#useeffect%EC%9D%98-deps%EC%97%90refcurrent%EA%B0%92%EC%9D%84-%EB%84%A3%EA%B3%A0refcurrent%EA%B0%92%EC%9D%B4-%EB%B0%94%EB%80%8C%EB%A9%B4useeffect%EA%B0%80-%ED%98%B8%EC%B6%9C%EB%90%A0%EA%B9%8C\" aria-label=\"useeffect의 deps에refcurrent값을 넣고refcurrent값이 바뀌면useeffect가 호출될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 <code class=\"language-text\">useEffect</code>의 deps에 <code class=\"language-text\">ref.current</code> 값을 넣고 <code class=\"language-text\">ref.current</code> 값이 바뀌면 <code class=\"language-text\">useEffect</code>가 호출될까?</h3>\n<ul>\n<li>정답은 🙅‍♂️\n<ul>\n<li><code class=\"language-text\">.current</code>값은 의도적으로 변경 가능하게(mutable) 설계되었다.\n→ 값이 변경되어도 리렌더링되지 않는다.</li>\n</ul>\n</li>\n<li>리렌더링이 발생하여 <code class=\"language-text\">useEffect</code>가 호출되는 경우는 다음 경우 뿐이다.\n<ul>\n<li>state가 바뀌었을 때</li>\n<li>prop이 바뀌었을때</li>\n<li>부모 컴포넌트가 리렌더링했을 때</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ref\" style=\"position:relative;\"><a href=\"#ref\" aria-label=\"ref permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ref</h3>\n<ul>\n<li><a href=\"https://react.dev/learn/manipulating-the-dom-with-refs#when-react-attaches-the-refs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">When React attaches the refs</a></li>\n<li><a href=\"https://react.dev/learn/lifecycle-of-reactive-effects#can-global-or-mutable-values-be-dependencies\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Can global or mutable values be dependencies?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/65941536/useref-value-is-undefined-on-initial-render\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>useRef 대신 useCallback 사용하기 출처(stackoverflow)</strong></a></li>\n</ul>","timeToRead":3,"frontmatter":{"title":"useRef의 배신","date":"June 28, 2023","description":null,"tags":["react"],"disqus":null},"fields":{"langKey":"en"}}},"pageContext":{"slug":"/react/betray-of-useRef/","previous":{"fields":{"slug":"/weekly/2023-6-week-5/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"June 30, 2023","description":"weekly-i-learned","title":"6월 5주차 기록","tags":["weekly"]}},"next":{"fields":{"slug":"/weekly/2023-6-week-4/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"June 24, 2023","description":"weekly-i-learned","title":"6월 4주차 기록","tags":["weekly"]}},"previousInSameTag":null,"nextInSameTag":{"fields":{"slug":"/react/react-function-class-component/","langKey":"en","directoryName":"react"},"frontmatter":{"date":"November 16, 2021","description":null,"title":"리액트가 함수 컴포넌트와 클래스 컴포넌트를 구별하는 법","tags":["react"]}},"translationsLink":[]}},"staticQueryHashes":["1522010811","2466007692","2894998521","3765107650","683610688"]}