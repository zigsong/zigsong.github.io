{"componentChunkName":"component---src-templates-blog-post-js","path":"/weekly/2022-12-week-2/","result":{"data":{"site":{"siteMetadata":{"title":"ziglog","author":"zigsong","lang":"en"}},"markdownRemark":{"id":"ba18c630-9e7c-5c02-afb7-85a7adf42a54","excerpt":"올해 아직 남았다 배워가기 react-query에서 stale의 의미 react-query에서 별 다른 설정이 없으면, 캐시된 데이터는 바로 stale(=신선하지 않다고)하다고 판단한다. 그래서 1초 전에 fetching한 데이터라도 devtools에서는 해당 쿼리가 stale…","html":"<p>올해 아직 남았다</p>\n<!-- more -->\n<hr>\n<h2 id=\"배워가기\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%9B%8C%EA%B0%80%EA%B8%B0\" aria-label=\"배워가기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배워가기</h2>\n<h3 id=\"react-query에서-stale의-의미\" style=\"position:relative;\"><a href=\"#react-query%EC%97%90%EC%84%9C-stale%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"react query에서 stale의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>react-query에서 stale의 의미</h3>\n<p>react-query에서 별 다른 설정이 없으면, 캐시된 데이터는 바로 stale(=신선하지 않다고)하다고 판단한다. 그래서 1초 전에 fetching한 데이터라도 devtools에서는 해당 쿼리가 stale한 상태라고 판단하게 된다.</p>\n<p>데이터를 불러오자마자 stale 상태가 되지만, 곧바로 refetch를 수행하는 것은 아니다. 여전히 캐시에서 데이터를 불러올 수 있으며, 특정 상황에서만 백그라운드에서 refetch가 수행된다.</p>\n<blockquote>\n<p><code class=\"language-text\">staleTime</code> config를 추가하면, 데이터를 fetching하자마자 해당 시간동안 fresh한 상태가 된다.</p>\n</blockquote>\n<p><strong>Ref</strong></p>\n<ul>\n<li><a href=\"https://tanstack.com/query/v4/docs/guides/important-defaults\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://tanstack.com/query/v4/docs/guides/important-defaults</a></li>\n<li><a href=\"https://stackoverflow.com/questions/72828361/what-are-staletime-and-cachetime-in-react-query\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stackoverflow.com/questions/72828361/what-are-staletime-and-cachetime-in-react-query</a></li>\n</ul>\n<h3 id=\"react-query의-invalidatequeries-vs-removequeries\" style=\"position:relative;\"><a href=\"#react-query%EC%9D%98-invalidatequeries-vs-removequeries\" aria-label=\"react query의 invalidatequeries vs removequeries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>react-query의 <code class=\"language-text\">invalidateQueries</code> vs <code class=\"language-text\">removeQueries</code></h3>\n<ul>\n<li><code class=\"language-text\">invalidateQueries</code>: 쿼리를 무효화한다.\n<ul>\n<li>쿼리가 무효화되지만, 그 다음 refetch나 리렌더링이 일어나기 전까지는 기존의 데이터가 UI에 노출될 수 있다.</li>\n<li>refetch 시에 기존 캐시의 유효성에 따라 캐시값을 사용할지 판단하는 용도로 사용되기 때문에, 캐싱된 데이터를 stale한 상태로 유지한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">removeQueries</code>: 캐시 삭제 + 쿼리 자체를 삭제\n<ul>\n<li>캐시와 쿼리가 모두 무효화되기 때문에, 쿼리로 불러온 데이터 캐시도 완전히 제거한다.</li>\n<li><code class=\"language-text\">invalidateQueries</code>와는 달리, stale한 캐시 데이터를 저장하지 않는다.</li>\n<li><code class=\"language-text\">keepPreviousData</code> 옵션이 false라면, UI에서 데이터가 즉각적으로 사라진다.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">keepPreviousData</code> 옵션</p>\n<ul>\n<li>이전 fetch 데이터를 화면에 유지시킬 것인지를 결정한다.</li>\n<li>true라면 <code class=\"language-text\">invalidateQueries</code> 혹은 <code class=\"language-text\">removeQueries</code>를 호출하더라도, refetch 전까지는 기존의 데이터가 보일 수 있다.</li>\n</ul>\n</blockquote>\n<h3 id=\"npm-vs-yarn\" style=\"position:relative;\"><a href=\"#npm-vs-yarn\" aria-label=\"npm vs yarn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>npm vs yarn</h3>\n<p>npm에서 yarn으로 넘어가고 싶은데… 넘어가는 것에 대한 타당한 근거를 마련해보자.</p>\n<p><strong>1️⃣ packages 병렬 설치</strong></p>\n<p>npm에서는 여러 패키지를 설치할 때, 패키지가 완전히 설치 될 때까지 기다린 후 다른 패키지를 설치한다. 즉, 작업은 패키지별로 순차적으로 실행된다.</p>\n<p>하지만 yarn은 이러한 작업을 병렬로 설치하므로 퍼포먼스와 속도가 증가한다.</p>\n<p>ex) React를 설치했을 때, npm은 3.572초, yarn은 1.44초가 소요된다.</p>\n<blockquote>\n<p>추가로,` caret(^)이 붙은 패키지 버전을 관리하는 방식의 차이?</p>\n</blockquote>\n<p><strong>2️⃣ 자동 lock 파일 생성</strong></p>\n<p>npm과 yarn 모두 패키지에서 프로젝트의 종속성과 버전 번호를 추적한다.</p>\n<p>종속성이 추가되면 yarn은 yarn.lock 파일을 자동으로 추가한다.\nnpm은 <code class=\"language-text\">npm shrinkwrap</code> 명령어로 lock 파일을 생성한다.\n차이점은 npm이 기본적으로 lock 파일을 생성하지 않을 때, yarn은 항상 yarn.lock 파일을 생성하고 업데이트한다는 것이다.</p>\n<p><code class=\"language-text\">yarn install</code> 명령어를 실행하면 lockfile에 명시된 패키지의 정확한 버전을 설치하기 때문에 프로젝트를 개발하는 모든 구성원이 동일한 패키지 버전을 사용할 수 있다.</p>\n<p>하지만 npm은 lockfile을 자동으로 생성하지 않기 때문에, <code class=\"language-text\">^</code>(caret)이 붙은 패키지의 경우 서로 다른 버전이 설치돼버릴 수도 있다.</p>\n<p>예) <code class=\"language-text\">^3.1.4</code>는 <code class=\"language-text\">>= 3.1.4 ~ &lt; 4.0.0</code>을 의미한다.</p>\n<p>npm v5.0은 lock.json 파일로 명명된 새로운 패키지와 함께 제공되며 npm-lapwrap 시스템을 완전히 폐기했다. 이것은 설치 과정과 성능을 효율적으로 향상시켰지만, 아직 yarn의 속도 수준에는 도달하지 못했다.</p>\n<p><strong>3️⃣ 보안</strong></p>\n<p>npm은 다른 패키지를 즉시 포함시킬 수 있는 코드를 자동으로 실행하므로, 보안 시스템에 여러 가지 취약성이 발생한다. 반면에, yarn은 yarn.lock 또는 package.json 파일에 있는 파일만 설치한다. 따라서 yarn이 npm 패키지보다 보안이 강화된 것으로 간주된다.</p>\n<p>음~ yarn을 안 쓸 이유가 없잖아?</p>\n<p><strong>Ref</strong></p>\n<ul>\n<li><a href=\"https://developer0809.tistory.com/128\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://developer0809.tistory.com/128</a></li>\n<li><a href=\"https://joshua1988.github.io/vue-camp/package-manager/npm-vs-yarn.html#yarn\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://joshua1988.github.io/vue-camp/package-manager/npm-vs-yarn.html#yarn</a></li>\n</ul>\n<hr>\n<h2 id=\"이것저것\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EA%B2%83%EC%A0%80%EA%B2%83\" aria-label=\"이것저것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이것저것</h2>\n<ul>\n<li>Antd는 V5를 출시하면서 CSS-in-JS를 도입했다. 기존 CSS-in-JS가 가지고 있던 딜레마(css가 삽입되었는지 여부를 판단하기 위해 css가 변경될 때마다 해시 값을 만드는 것)를 해결하기 위해 “컴포넌트 레벨” CSS-in-JS를 도입했다. 모든 antd component에 같은 해시 값을 부여하고, 현재 버전과 테마 변수(theme variables)에 대해서만 해시를 다시 계산하는 방식으로 성능을 개선했다. (<a href=\"https://ant.design/docs/blog/css-in-js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ref</a>)</li>\n<li>여러 요소를 한번에 바꿀 때 대/소문자를 기억해서 대/소문자에 맞게 변환해주는 익스텐션 - <a href=\"https://marketplace.visualstudio.com/items?itemName=Cardinal90.multi-cursor-case-preserve\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">multi-cursor-case-preserve</a> 굉장히 유용하다!</li>\n<li>html <code class=\"language-text\">kbd</code>\n<ul>\n<li>사용자의 입력(키보드 입력, 음성 입력)을 나타낸다.</li>\n<li>스타일링은 따로 해줘야한다.</li>\n</ul>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Please press <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>kbd</span><span class=\"token punctuation\">></span></span>Ctrl<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>kbd</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span></code></pre></div>\n</li>\n<li>react-hook-form의 controller 이벤트인 <code class=\"language-text\">onChange</code>는 <code class=\"language-text\">undefined</code> 값을 허용하지 않는다. <code class=\"language-text\">undefined</code>를 넣으면 자동으로 <code class=\"language-text\">defaultValues</code> 값이 반영된다.</li>\n<li>next/router는 replace 시 내부적으로 context의 상태를 변경하기 때문에 page rerender가 일어난다 (<code class=\"language-text\">shallow</code> 옵션을 켜도 마찬가지)</li>\n<li>react-router-dom 6.4 버전부터 <code class=\"language-text\">useSearchParams</code> 에서 functional update를 지원한다 (<a href=\"https://github.com/remix-run/react-router/commit/7b6feec2cf6d242df2751a4aae8992552775bda8\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ref</a>) - 이는 queryParam을 set하는 동작이 하나의 사이클에서 두 번이상 동작할 때, 서로의 변경점을 기반으로 반영할 수 없었던 문제를 해결해준다.</li>\n<li>styled-component로 React 컴포넌트를 감싸고 스타일 컴포넌트에서만 사용되는 props를 넘기면 ‘Unknown Prop Warning’이 발생한다. 이는 스타일 컴포넌트가 모든 props를 자식 컴포넌트에 넘겨서 발생하는 문제로, <code class=\"language-text\">withConfig</code> 메서드로 해당 prop만 빼고 자식 컴포넌트에 넘기거나 props 앞에 <code class=\"language-text\">$</code> prefix를 붙여서 해결할 수 있다. (cf. ver 5.1부터 도입된 transient props)</li>\n<li>react로 개발할때, 변경을 트리거하는게 effect인지 event인지 명확히 구분하자</li>\n</ul>\n<hr>\n<h2 id=\"기타\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%ED%83%80\" aria-label=\"기타 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기타</h2>\n<h3 id=\"vscode-sticky-scroll\" style=\"position:relative;\"><a href=\"#vscode-sticky-scroll\" aria-label=\"vscode sticky scroll permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>vscode sticky scroll</h3>\n<p>vscode 익스텐션인데, 스크롤을 내려도 상단의 클래스 이름이나 함수명을 sticky하게 고정시켜준다. 이런 게 있었으면 좋겠다고 생각은 했는데, 막상 모든 것들이 sticky하게 걸리면 더 혼란스러울 것 같기도? 🤔</p>\n<p><strong>Ref</strong></p>\n<ul>\n<li><a href=\"https://code.visualstudio.com/updates/v1_70#_editor-sticky-scroll\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://code.visualstudio.com/updates/v1_70#_editor-sticky-scroll</a></li>\n<li><a href=\"https://www.youtube.com/shorts/AxB3_vkEsqQ\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/shorts/AxB3_vkEsqQ</a></li>\n</ul>\n<h3 id=\"eslint-환경의-변화-목표-10가지\" style=\"position:relative;\"><a href=\"#eslint-%ED%99%98%EA%B2%BD%EC%9D%98-%EB%B3%80%ED%99%94-%EB%AA%A9%ED%91%9C-10%EA%B0%80%EC%A7%80\" aria-label=\"eslint 환경의 변화 목표 10가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>eslint 환경의 변화 목표 10가지</h3>\n<p>eslint가 2013년에 첫 릴리즈 된 후 개발 환경이 계속 고수되어 유지보수가 되어 왔는데, 향후 10년을 위해서는 환경의 변경이 필요할 것이라는 내용과 그 것을 위한 목표 10가지에 대해 설명 하는 글이다.</p>\n<ol>\n<li>완전히 새로운 코드베이스</li>\n<li>ESM 타입 체킹 지원</li>\n<li>모든 런타임 환경 지원</li>\n<li>모든 언어 지원</li>\n<li>새로운 public API</li>\n<li>Rust 기반으로 교체</li>\n<li>모든 코드를 비동기로</li>\n<li>플러그인 형식의 소스 코드 포맷터</li>\n<li>결과 리포트</li>\n<li>자동 수정을 위한 AST 구조 변형</li>\n</ol>\n<p><strong>Ref</strong> <a href=\"https://github.com/eslint/eslint/discussions/16557\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/eslint/eslint/discussions/16557</a></p>\n<h3 id=\"구글-모바일-이어-pc에도-연속-스크롤-기능-도입\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EA%B8%80-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%9D%B4%EC%96%B4-pc%EC%97%90%EB%8F%84-%EC%97%B0%EC%86%8D-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B8%B0%EB%8A%A5-%EB%8F%84%EC%9E%85\" aria-label=\"구글 모바일 이어 pc에도 연속 스크롤 기능 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구글, 모바일 이어 PC에도 연속 스크롤 기능 도입</h3>\n<p>오… 개인적으로 연속 스크롤을 아주 선호하지는 않는 입장으로서 맞는 선택지인진 모르겠다 🤔 연속 스크롤에 대한 니즈가 그렇게 컸다니</p>\n<p><strong>Ref</strong> <a href=\"https://www.itworld.co.kr/news/268185#csidxc049eca5dfbf1e3a77f06c7b719d839\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.itworld.co.kr/news/268185#csidxc049eca5dfbf1e3a77f06c7b719d839</a></p>\n<h3 id=\"vite-40-출시\" style=\"position:relative;\"><a href=\"#vite-40-%EC%B6%9C%EC%8B%9C\" aria-label=\"vite 40 출시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>vite 4.0 출시</h3>\n<ul>\n<li>개발 단계에서 사용할 수 있는 SWC 기반의 플러그인\n<ul>\n<li>Babel을 SWC로 대체하는 플러그인(<code class=\"language-text\">@vitejs/plugin-react-swc</code>)이 나왔다.</li>\n</ul>\n</li>\n<li>브라우저 호환성\n<ul>\n<li>ES2020 호환성을 맞추기 위해 모던 브라우저는 safari14를 타겟으로 한다.</li>\n</ul>\n</li>\n<li>CSS를 string으로 import하기\n<ul>\n<li>vite 4.0에서는 css default export 대신 <code class=\"language-text\">?</code> 인라인 쿼리 suffix를 사용하여 css 스타일의 중복 로드를 방지한다. (ex. <code class=\"language-text\">import stuff from './global.css?inline'</code>))</li>\n</ul>\n</li>\n<li>환경변수\n<ul>\n<li>vite 4.0에서는 <code class=\"language-text\">dotenv</code> 16 버전과 <code class=\"language-text\">dotenv-expand</code> 9 버전을 사용한다.</li>\n</ul>\n</li>\n<li>패키지 사이즈 축소</li>\n</ul>\n<p>등의 변화가 있다!</p>\n<p><strong>Ref</strong> <a href=\"https://vitejs.dev/blog/announcing-vite4.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://vitejs.dev/blog/announcing-vite4.html</a></p>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>어떻게 시간 가는지 모르고 보내는 날들이다. 짐 한가득 들고 이리저리 뛰어다녔던 날들이 많았다 😵‍💫</p>\n<p>우테코 4기의 우형 최종 합격이 발표되었다. 잠깐 이야기 나누고 도움 줬던 크루가 같은 팀에 합류하게 돼서 기쁘다 🤩</p>","timeToRead":7,"frontmatter":{"title":"12월 2주차 기록","date":"December 10, 2022","description":"weekly-i-learned","tags":["weekly"],"disqus":null},"fields":{"langKey":"en"}}},"pageContext":{"slug":"/weekly/2022-12-week-2/","previous":{"fields":{"slug":"/weekly/2022-12-week-3/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"December 17, 2022","description":"weekly-i-learned","title":"12월 3주차 기록","tags":["weekly"]}},"next":{"fields":{"slug":"/frontend/lottie/","langKey":"en","directoryName":"frontend"},"frontmatter":{"date":"December 08, 2022","description":null,"title":"로티로 애니메이션 만들기","tags":["frontend"]}},"previousInSameTag":{"fields":{"slug":"/weekly/2022-12-week-3/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"December 17, 2022","description":"weekly-i-learned","title":"12월 3주차 기록","tags":["weekly"]}},"nextInSameTag":{"fields":{"slug":"/weekly/2022-12-week-1/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"December 04, 2022","description":"weekly-i-learned","title":"12월 1주차 기록","tags":["weekly"]}},"translationsLink":[]}},"staticQueryHashes":["1522010811","1615650028","2894998521","3765107650","683610688"]}