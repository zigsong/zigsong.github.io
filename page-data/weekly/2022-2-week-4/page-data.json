{"componentChunkName":"component---src-templates-blog-post-js","path":"/weekly/2022-2-week-4/","result":{"data":{"site":{"siteMetadata":{"title":"ziglog","author":"zigsong","lang":"en"}},"markdownRemark":{"id":"b61ef8f9-4cb7-5b0c-8616-7d9d3c77fc41","excerpt":"첫 월급 flex~ 배워가기  에 대한 공식문서 설명을 아래와 같다. element를 기준으로 새로운 React 엘리먼트를 복사하고 반환합니다. config는 key\n와 ref 그리고 모든 새로운 props를 포함합니다. 새로운 엘리먼트에는 원본 엘리먼트가 가졌던 props…","html":"<p>첫 월급 flex~</p>\n<!-- more -->\n<hr>\n<h2 id=\"배워가기\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%9B%8C%EA%B0%80%EA%B8%B0\" aria-label=\"배워가기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배워가기</h2>\n<h3 id=\"reactcloneelement\" style=\"position:relative;\"><a href=\"#reactcloneelement\" aria-label=\"reactcloneelement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">React.cloneElement()</code></h3>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">React<span class=\"token punctuation\">.</span><span class=\"token function\">cloneElement</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>config<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>children<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">React.cloneElement()</code>에 대한 공식문서 설명을 아래와 같다.</p>\n<blockquote>\n<p>element를 기준으로 새로운 React 엘리먼트를 복사하고 반환합니다. config는 key\n와 ref 그리고 모든 새로운 props를 포함합니다. 새로운 엘리먼트에는 원본 엘리먼트가 가졌던 props가 새로운 props와 얕게 합쳐진 뒤 주어집니다. 새로운 자식들은 기존의 자식들을 대체합니다. config에 key와 ref가 없다면 원본 엘리먼트의 key와 ref는 그대로 유지됩니다.</p>\n</blockquote>\n<p>그냥 <code class=\"language-text\">children</code>을 렌더링하는 것과 대체 어떤 차이가 있는지 궁금했었는데, 코드 사례를 보고 나니 조금 이해가 되었다!</p>\n<p><code class=\"language-text\">inGroup</code>이라는 이름의 prop을 받는 <code class=\"language-text\">Button</code> 컴포넌트가 있다고 치자. (이때 <code class=\"language-text\">inGroup = true</code>일 경우 레이아웃이 달라진다.)</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Button</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> inGroup<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>inGroup <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Group Button</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Solo Button</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이때 <code class=\"language-text\">ButtonGroup</code>이라는 상위 컴포넌트 안에 렌더링하는 <code class=\"language-text\">Button</code> 컴포넌트의 경우 <code class=\"language-text\">inGroup</code> 프로퍼티를 반드시 <code class=\"language-text\">true</code>로 강제하고 싶다면, 아래와 같이 작성할 수 있다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ButtonGroup</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> direction<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">,</span> align <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 렌더링하는 children에 대해서 inGroup props를 강제해줌</span>\n  <span class=\"token keyword\">const</span> childProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    inGroup<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>React<span class=\"token punctuation\">.</span>Children<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>children<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>React<span class=\"token punctuation\">.</span><span class=\"token function\">cloneElement</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> childProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>주로 위와 같이 동일한 React element를 반복해서 렌더링할 때, 그리고 그때 렌더링되는 자식 요소들이 특정한 prop을 가져야 할 때 사용할 수 있다.</p>\n<h3 id=\"typescript-omit-vs-exclude\" style=\"position:relative;\"><a href=\"#typescript-omit-vs-exclude\" aria-label=\"typescript omit vs exclude permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript <code class=\"language-text\">Omit</code> vs <code class=\"language-text\">Exclude</code></h3>\n<ul>\n<li><code class=\"language-text\">Omit&lt;Type, Keys></code> - <code class=\"language-text\">Type</code>의 프로퍼티에서 <code class=\"language-text\">Keys</code>를 제거한다.</li>\n<li><code class=\"language-text\">Exclude&lt;UnionType, ExcludedMembers></code> - <code class=\"language-text\">UnionType</code>에서 <code class=\"language-text\">ExcludedMembers</code>에 할당할 수 있는 모든 유니언 집합을 제외한 타입을 반환한다.</li>\n</ul>\n<p>얼핏 보면 <code class=\"language-text\">Omit</code>에서 베이스가 되는 타입은 하나의 명시적인 타입(<code class=\"language-text\">Type</code>)이고, <code class=\"language-text\">Exclude</code>에서 베이스가 되는 타입은 어떤 교차 타입(<code class=\"language-text\">UnionType</code>)이라는 차이처럼 보인다. 둘의 차이를 좀 더 명확히 알아보자.</p>\n<p><code class=\"language-text\">Omit</code>은 <code class=\"language-text\">Pick</code>에 대응되는 유틸리티 타입으로, 베이스가 되는 객체 타입에서 특정한 프로퍼티들을 제거한다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">Omit<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'a'</span><span class=\"token operator\">></span> <span class=\"token operator\">===</span> <span class=\"token punctuation\">{</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Exclude</code>는 유니언 타입을 베이스로, 그 유니언의 특정한 조합을 제거한다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">Exclude<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">===</span> <span class=\"token builtin\">number</span></code></pre></div>\n<p><code class=\"language-text\">Exclude</code>의 타입 시그니처는 아래와 같다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Exclude<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token constant\">U</span></span> <span class=\"token operator\">?</span> <span class=\"token builtin\">never</span> <span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">T</code>가 <code class=\"language-text\">U</code>를 <code class=\"language-text\">extends</code>한다면, <code class=\"language-text\">never</code> 타입을 반환할 것이다.</p>\n<p>같은 타입을 제공했을 때 <code class=\"language-text\">Omit</code>과 <code class=\"language-text\">Exclude</code>가 반환하는 타입이 달라지는 경우가 생긴다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T0</span></span> <span class=\"token operator\">=</span> Omit<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1️⃣</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T1</span></span> <span class=\"token operator\">=</span> Exclude<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span> a<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2️⃣</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T2</span></span> <span class=\"token operator\">=</span> Omit<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3️⃣</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">T3</span></span> <span class=\"token operator\">=</span> Exclude<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 4️⃣</span></code></pre></div>\n<p>1️⃣ <code class=\"language-text\">a</code>가 제거되어 <code class=\"language-text\">{ b: string }</code> 타입을 반환한다.\n2️⃣ <code class=\"language-text\">a</code>는 <code class=\"language-text\">{ a: string, b: string }</code>를 <code class=\"language-text\">extends</code>하지 않기 때문에, <code class=\"language-text\">{ a: string, b: string }</code> 타입을 반환한다.\n3️⃣ <code class=\"language-text\">string | number</code>에서 모든 <code class=\"language-text\">string</code> key를 제거하기 때문에 (결국 모든 key를 제거하게 된다.) <code class=\"language-text\">{}</code> 타입이 반환된다.\n4️⃣ <code class=\"language-text\">string</code>은 <code class=\"language-text\">string</code>을 <code class=\"language-text\">extends</code>하므로 제거되고, <code class=\"language-text\">number</code> 타입을 반환한다.</p>\n<p><strong>Ref</strong> <a href=\"https://stackoverflow.com/questions/56916532/difference-b-w-only-exclude-and-omit-pick-exclude-typescript\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stackoverflow.com/questions/56916532/difference-b-w-only-exclude-and-omit-pick-exclude-typescript</a></p>\n<h3 id=\"딥링크\" style=\"position:relative;\"><a href=\"#%EB%94%A5%EB%A7%81%ED%81%AC\" aria-label=\"딥링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>딥링크</h3>\n<p>웹에서 http 혹은 https로 시작하는 주소로 특정 서비스의 웹페이지로 이동할 수 있듯이, 모바일 앱에서 특정 주소 혹은 값을 입력하여 앱 내부의 특정 주소로 이동하는 방법이다. 웹에서 바로 모바일 앱으로 이동할 때 이 모바일 딥링크를 사용한다.</p>\n<p>앱은 <code class=\"language-text\">youtube://</code>처럼 주로 애플리케이션의 이름이 프로토콜이 되는 경우가 일반적이다. 이러한 방식을 URI 스킴 방식이라고 하는데, 스킴값이 서로 중복되는 문제가 발생한다. 이를 근본적으로 해결하기 위해 유니버셜 링크(iOS)와 앱링크(Android)가 탄생했다. 유니버셜 링크는 애플에서 만든 앱에서만, 앱링크는 구글에서 만든 앱만 지원하기 때문에 원활한 광고 운영을 위해서는 URI 스킴 방식을 적절히 활용해야 한다.</p>\n<p><strong>Ref</strong> <a href=\"https://help.dfinery.io/hc/ko/articles/360039757433-%EB%94%A5%EB%A7%81%ED%81%AC-Deeplink-URI%EC%8A%A4%ED%82%B4-%EC%9C%A0%EB%8B%88%EB%B2%84%EC%85%9C-%EB%A7%81%ED%81%AC-%EC%95%B1%EB%A7%81%ED%81%AC-%EA%B5%AC%EB%B6%84%EA%B3%BC-%EC%9D%B4%ED%95%B4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://help.dfinery.io/hc/ko/articles/360039757433-딥링크-Deeplink-URI스킴-유니버셜-링크-앱링크-구분과-이해</a></p>\n<h3 id=\"배열의-원소-타입을-추론하는-코드\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%9B%90%EC%86%8C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%B6%94%EB%A1%A0%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C\" aria-label=\"배열의 원소 타입을 추론하는 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열의 원소 타입을 추론하는 코드</h3>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">/** 배열의 원소 타입을 추론한다.\n * ex. ElementOf&lt;string[]> === string\n */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">ElementOf<span class=\"token operator\">&lt;</span>ArrayType <span class=\"token keyword\">extends</span> <span class=\"token keyword\">readonly</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span>\n  ArrayType <span class=\"token keyword\">extends</span> <span class=\"token class-name\"><span class=\"token keyword\">readonly</span></span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">infer</span> ElementType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> ElementType <span class=\"token operator\">:</span> <span class=\"token builtin\">never</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">infer</code>와 <code class=\"language-text\">never</code> 키워드를 이런 경우 사용할 수 있다. 또, 배열 원소 타입을 추론할 때 원소는 추론하고자 하는 배열 타입에 <code class=\"language-text\">readonly</code>를 붙여야 한다.</p>\n<h3 id=\"type-predicate\" style=\"position:relative;\"><a href=\"#type-predicate\" aria-label=\"type predicate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Predicate</h3>\n<p>Type Predicate를 활용하면 효과적으로 타입을 좁힐 수 있다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">isFish</span><span class=\"token punctuation\">(</span>pet<span class=\"token operator\">:</span> Fish <span class=\"token operator\">|</span> Bird<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> pet <span class=\"token keyword\">is</span> Fish <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>pet <span class=\"token keyword\">as</span> Fish<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>swim <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 사용자 정의 타입 가드를 만들어 사용하면 <code class=\"language-text\">as</code> 키워드로 타입 단언을 사용하지 않아도 타입 추론을 잘할 수 있다.</p>\n<h3 id=\"git-submodule\" style=\"position:relative;\"><a href=\"#git-submodule\" aria-label=\"git submodule permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>git submodule</h3>\n<p>submodule이란 git 저장소 안에 다른 git 저장소를 디렉토리로 분리해 넣는 것이다. 다른 독립된 git 저장소를 clone 해서 내 git 저장소 안에 포함할 수 있으며 각 저장소의 커밋은 독립적으로 관리한다.</p>\n<p>코어 로직들을 별도의 레포로 구성하고 이를 submodule로 가져와서 사용할 수 있다, 이때 submodule 레포를 수정한 후 이를 import 해와서 쓰는 경우, merge 순서가 중요하다(submodule 레포를 먼저 merge해야 한다.)</p>\n<p><strong>Ref</strong> <a href=\"https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-%EC%84%9C%EB%B8%8C%EB%AA%A8%EB%93%88\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://git-scm.com/book/ko/v2/Git-도구-서브모듈</a></p>\n<h3 id=\"perl\" style=\"position:relative;\"><a href=\"#perl\" aria-label=\"perl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Perl</h3>\n<p>Perl은 High Level에서 동작하는 동적 타입 언어이며, 쉘 스크립트에서 기원했기 때문에 시스템 관리에 사용하기 좋은 언어이다. 특히 텍스트 데이터 처리에 용이하다.</p>\n<p>정규 표현식과 Perl의 패턴 매치 연산자를 이용하여 특정 문자열에 대해 replace 동작도 수행할 수 있다. 예를 들어 <code class=\"language-text\">s/(^|-)./uc($&amp;)/ge;s/-//g</code> 는 kebab-case를 PascalCase로 변환한다.</p>\n<ul>\n<li><code class=\"language-text\">s/A/B/g</code> : 모든 A를 B로 변환한다</li>\n<li><code class=\"language-text\">s/A/B/ge</code> : 모든 A를 B로 변환하는데 eval을 wrapping한다</li>\n<li><code class=\"language-text\">(^|-).</code> : 문자열의 시작 부분 혹은 “ 가 앞에 있는 모든 문자열의 경우 (1번째 그룹)</li>\n<li><code class=\"language-text\">uc($&amp;)</code> : 대문자로 변환한다</li>\n<li><code class=\"language-text\">;</code> : 식의 끝. 이후에 이어서 작성하면 새로운 식 적용 가능 (세미콜론 역할)</li>\n<li><code class=\"language-text\">s/-//g</code> : 모든 “를 빈 문자로 변환한다</li>\n</ul>\n<h3 id=\"모노레포-빌드-도구\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-%EB%B9%8C%EB%93%9C-%EB%8F%84%EA%B5%AC\" aria-label=\"모노레포 빌드 도구 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모노레포 빌드 도구</h3>\n<p>모노레포 빌드를 도와주는 대표적인 도구로 <a href=\"https://lerna.js.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lerna</a>가 있으며, 이밖에도 Nx, Turborepo 등 모노레포 빌드를 돕기 위한 다양한 툴들이 있다. 해당 툴들은 아래와 같은 기능들을 제공한다.</p>\n<ul>\n<li>로컬 작업 오케스트레이션</li>\n<li>변화된 패키지(와 그로부터 영향을 받는 패키지)를 감지</li>\n<li>컴퓨테이션 캐싱</li>\n<li>패키지간 의존성 시각화</li>\n</ul>\n<p>이러한 툴들을 사용하지 않고 직접 yml 파일을 수정 할 수도 있다. yml 파일의 <code class=\"language-text\">rules</code>를 수정하여 해당 패키지에 변화가 있을 때에만 <code class=\"language-text\">script</code>를 실행하도록 설정할 수도 있ek.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">rules</span><span class=\"token punctuation\">:</span>\n <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'BRANCH_NAME'</span>\n    <span class=\"token key atrule\">changes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> packages/common/<span class=\"token important\">**/*</span>\n<span class=\"token key atrule\">script</span><span class=\"token punctuation\">:</span> yarn build</code></pre></div>\n<p>하지만 이 경우에 변화된 패키지를 의존하는 패키지들은 변화 감지가 되지 않아 공통 패키지의 변경사항(공용 컴포넌트의 스타일이 변경되는 등)이 다른 패키지에 반영되지 않을 수 있다.</p>\n<h3 id=\"ddl-vs-dml-vs-dcl\" style=\"position:relative;\"><a href=\"#ddl-vs-dml-vs-dcl\" aria-label=\"ddl vs dml vs dcl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DDL vs DML vs DCL</h3>\n<ul>\n<li>DDL(Data Define Language, 데이터 정의어)\n<ul>\n<li>예) Create, Alter, Drop, Truncate</li>\n<li>데이터베이스를 정의하는 언어</li>\n<li>데이터를 생성, 수정, 삭제하는 등의 데이터 전체 골격을 결정</li>\n</ul>\n</li>\n<li>DML(Data Manipulation Language, 데이터 조작어)\n<ul>\n<li>예) Select, Insert, Update, Delete</li>\n<li>데이터베이스 사용자가 데이터를 실질적으로 처리하는데 사용</li>\n<li>데이터베이스에 입력된 레코드를 조회, 수정, 삭제</li>\n</ul>\n</li>\n<li>DCL(Data Control Language, 데이터 제어어)\n<ul>\n<li>예) Grant, Revoke, Commit, Rollback</li>\n<li>데이터의 보안, 무결성 등을 정의하는 언어</li>\n<li>데이터베이스에 접근하거나 객체에 권한을 줄 때 사용</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"superstruct\" style=\"position:relative;\"><a href=\"#superstruct\" aria-label=\"superstruct permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Superstruct</h3>\n<p>TypeScript를 사용하며 무려 <strong>런타임</strong>에 데이터를 검증할 수 있도록 설계된 라이브러리다! 인터페이스를 보다 쉽게 정의하고, 그 인터페이스에 대한 JavaScript 데이터 검증을 할 수 있다. API로 받아온 임의의 값을 필요할 때, <strong>런타임에서</strong> 데이터의 구조를 검증할 때 유용하다.</p>\n<p>object, number, string 등 함수로 타입을 정의하고 assert 함수로 검증을 실행하며, 실패 시 Error를 throw한다</p>\n<p><strong>Ref</strong> <a href=\"https://docs.superstructjs.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.superstructjs.org/</a></p>\n<h3 id=\"정규표현식의-lookahead와-lookbehind\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%98-lookahead%EC%99%80-lookbehind\" aria-label=\"정규표현식의 lookahead와 lookbehind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정규표현식의 <code class=\"language-text\">Lookahead</code>와 <code class=\"language-text\">Lookbehind</code></h3>\n<ul>\n<li><code class=\"language-text\">X(?=Y)</code> (Positive Lookahead) : 본래 패턴에 맞는 곳을 우선 찾고, Lookaround 조건이 맞으면 매칭한다.</li>\n<li><code class=\"language-text\">X(?!Y)</code> (Negative Lookahead) : Positive Lookahead와 다르게 조건에 충족하지 않으면 매칭된다.</li>\n<li><code class=\"language-text\">(?&lt;=Y)X</code> (Positive Lookbehind) : Positive Lookahead와 반대로 조건 Y에 충족하는지 먼저 체크하고 맞는 패턴 X를 찾는다.</li>\n<li><code class=\"language-text\">(?&lt;!Y)X</code> (Negative Lookbehind) : 조건 Y에 충족하지 않는지 체크하고 맞는 패턴 X를 찾는다.</li>\n</ul>\n<p>Lookaround는 조건을 겹칠 필요가 있을 때 유용하게 사용할 수 있다. 예를 들어, 숫자와 영문자와 특수문자 3종류가 모두 포함된 문자열을 찾아야 할 때, 즉 3가지 조건에 충족하는 문자열을 매칭할 때 다음과 같이 작성할 수 있었다. 특수문자의 경우 일일이 모든 경우의 수를 입력해주어야 하기 때문에 정규식이 좀 길어질 수밖에 없었다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^(?=.*[A-Za-z])(?=.*[0-9])(?=.*[!@#$%^&amp;*()_+\\-=\\[\\]\\{\\}\\;\\'\\,\\.\\/\\&lt;\\>\\?\\~\\`])[A-Za-z0-9!@#$%^&amp;*()_+\\-=\\[\\]\\{\\}\\;\\'\\,\\.\\/\\&lt;\\>\\?\\~\\`]{0,}$</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Ref</strong> <a href=\"https://ko.javascript.info/regexp-lookahead-lookbehind\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.javascript.info/regexp-lookahead-lookbehind</a></p>\n<h3 id=\"typescript의-객체-키-추론-방식\" style=\"position:relative;\"><a href=\"#typescript%EC%9D%98-%EA%B0%9D%EC%B2%B4-%ED%82%A4-%EC%B6%94%EB%A1%A0-%EB%B0%A9%EC%8B%9D\" aria-label=\"typescript의 객체 키 추론 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript의 객체 키 추론 방식</h3>\n<p>TypeScript는 <code class=\"language-text\">Record&lt;Key, Value></code> 타입의 객체에 대해 <code class=\"language-text\">Object.keys()</code>나 <code class=\"language-text\">Object.entries()</code>의 키타입이 무조건 <code class=\"language-text\">Key[]</code>가 아니라 <code class=\"language-text\">string[]</code>을 추론하게 된다.</p>\n<p><code class=\"language-text\">Object.entries</code>에서 key를 string 타입으로 지정하는 이유는 <a href=\"https://stackoverflow.com/questions/55012174/why-doesnt-object-keys-return-a-keyof-type-in-typescript/55012175#55012175\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기</a>서 찾을 수 있다. <code class=\"language-text\">Object.entries</code>를 순회할 대상이 되는 객체가 특정 객체를 확장한 타입의 객체일 때, key의 타입 추론에 실패하기 때문이다.</p>\n<p><strong>Ref</strong> <a href=\"https://www.reddit.com/r/typescript/comments/rc1wwd/objectentries_on_record_type_is_incorrect_and/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.reddit.com/r/typescript/comments/rc1wwd/objectentries_on_record_type_is_incorrect_and/</a></p>\n<h3 id=\"lock-파일의-중요성\" style=\"position:relative;\"><a href=\"#lock-%ED%8C%8C%EC%9D%BC%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1\" aria-label=\"lock 파일의 중요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">lock</code> 파일의 중요성</h3>\n<p><code class=\"language-text\">package.json</code>에 명시되어있지 않은 라이브러리어도 <code class=\"language-text\">lock</code> 파일에 포함되어 있으면 설치된다. 하지만 그러면 버전 관리를 하기 힘들 것이다.</p>\n<p>ex) emoji-regex 라이브러리를 통해 이모지 정규식을 사용하는데, 이모지를 제대로 잡아내지 못하길래 보니 emoji-regex 라이브러리가 <code class=\"language-text\">package.json</code> 파일에 명시되어 있지 않았고 <code class=\"language-text\">lock</code> 파일에만 존재했다. 버전이 낮아서 제대로 잡아내지 못했던 것이다.</p>\n<blockquote>\n<p><strong>💡 lock 파일을 정리하는 법</strong></p>\n</blockquote>\n<ul>\n<li>yarn v2 : <a href=\"https://yarnpkg.com/cli/dedupe\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yarn dedupe</a> 명령어를 통해 중복 dependency를 정리할 수 있다. 번들 사이즈도 줄여주는 효과가 있다.</li>\n<li>yarn v1 : <code class=\"language-text\">yarn dedupe</code> 명령어는 v2부터 지원한다. v1에서는 <a href=\"https://www.npmjs.com/package/yarn-deduplicate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yarn-deduplicate</a> 라이브러리가 지원한다</li>\n</ul>\n<h3 id=\"settimeout-vs-setinterval\" style=\"position:relative;\"><a href=\"#settimeout-vs-setinterval\" aria-label=\"settimeout vs setinterval permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">setTimeout</code> vs <code class=\"language-text\">setInterval</code></h3>\n<p><code class=\"language-text\">setTimeout</code>과 <code class=\"language-text\">setInterval</code>의 차이는 콜백함수를 실행시키는 간격이다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">cbFn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>cbFn<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">setInterval</code>은 1초가 지날 때마다 콜백함수를 바로바로 호출한다. 콜백함수의 종료는 신경쓰지 않고, 그냥 냅다 실행만 시키고 시간은 흘러간다.</p>\n<p>반면 <code class=\"language-text\">setTimeout</code>은 <code class=\"language-text\">setTimeout</code>이 재귀 호출되기 전에 fn함수가 실행 및 종료가 된 후에 <code class=\"language-text\">setTimeout</code>을 다시 호출한다. 즉, 함수가 종료된 후에 다시 1초를 기다리기 때문에 정확히 1초 간격으로 진행된다.</p>\n<p>그렇기 때문에 잘못 사용(ex. 잘못된 위치에서 interval을 clear)하면 더이상 요청하지 않아도 되는 요청을 엄청 많이 실행하게 될 수도 있다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> counter <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">></span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">dialog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'다이얼로그 확인'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">//...</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>counter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// dialog 지옥이 펼쳐짐!</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>Ref</strong> <a href=\"https://velog.io/@proshy/JS%EC%9D%BC%EC%A0%95-%EA%B0%84%EA%B2%A9%EC%9C%BC%EB%A1%9C-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C-setTimeout-vs-setInterval\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@proshy/JS일정-간격으로-함수를-호출할-때-setTimeout-vs-setInterval</a></p>\n<h3 id=\"dot-notation\" style=\"position:relative;\"><a href=\"#dot-notation\" aria-label=\"dot notation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>dot notation</h3>\n<p>antd 라이브러리 일부 컴포넌트의 네이밍은 같은 결의 컴포넌트를 응집하여 정의한다.</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">Typography<span class=\"token punctuation\">.</span>Text<span class=\"token punctuation\">;</span>\nTypography<span class=\"token punctuation\">.</span>Title<span class=\"token punctuation\">;</span>\nTypography<span class=\"token punctuation\">.</span>Paragraph<span class=\"token punctuation\">;</span></code></pre></div>\n<p>notation의 최상단 컴포넌트는 하위 컴포넌트들이 공유할 state와 update logic을 추상적으로 제공하고, 하위 컴포넌트에서는 공유되는 값을 이용해서 원하는 대로 렌더링 제어를 할 수 있게되는 구조로 이해할 수 있다.</p>\n<h3 id=\"compound-components\" style=\"position:relative;\"><a href=\"#compound-components\" aria-label=\"compound components permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compound Components</h3>\n<p><a href=\"https://kentcdodds.com/blog/compound-components-with-react-hooks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Kent C. Dodds</a>가 제시한.. 건진 모르겠지만 작성한 포스팅에서 등장하는 개념이다.</p>\n<p>HTML에서 제공하는 기본 태그인 <code class=\"language-text\">&lt;select></code>와 <code class=\"language-text\">&lt;option></code>은, 암묵적으로 로직을 공유하는 부분이 있는 컴포넌트의 관계로 생각해볼 수 있다. Dodds는 이를 활용하여 같은 context를 공유하는 <code class=\"language-text\">Toggle</code> 컴포넌트와 <code class=\"language-text\">Toggle.On</code>, <code class=\"language-text\">Toggle.Off</code>, <code class=\"language-text\">Toggle.Button</code> 컴포넌트의 예시를 제공하고 있다.</p>\n<h3 id=\"중재자-패턴-mediator-pattern\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4-mediator-pattern\" aria-label=\"중재자 패턴 mediator pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중재자 패턴 (Mediator Pattern)</h3>\n<p>객체들이 서로 직접 통신하지 않고 중재자를 통해서 통신하도록 구성하는 패턴으로, 각 객체 간의 의존성을 줄여 결합도를 감소시킬 수 있다.</p>\n<p>채팅을 할 때 사람들끼리 모두 직접적으로 연결되어 있는 것이 아니라, 채팅방이라는 매개체를 통해서 통신하는 구조와 같다. (M:N → M:1)</p>\n<hr>\n<h2 id=\"이것저것\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EA%B2%83%EC%A0%80%EA%B2%83\" aria-label=\"이것저것 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이것저것</h2>\n<ul>\n<li>\n<p>stale-while-revalidation 캐시전략 - API 요청에 대해 캐시된 데이터가 있는 경우 캐시 데이터를 사용하여 사용자에게 화면을 제공하고, 후에 도착한 최신 API응답을 사용해서 화면을 최신화하는 캐시 전략</p>\n</li>\n<li>\n<p>Recoil과 jotai의 데이터 관리법은 다르다. Recoil은 문자열 키값, jotai는 object reference를 통해 데이터를 관리한다.</p>\n</li>\n<li>\n<p>도메인 계층은 뒤에서부터 순차적으로 탐색을 진행하기 때문에 AWS Route 53에서 도메인 확인을 할 때에도 devbaemin.in 처럼 뒤에서부터 검색해야한다.</p>\n</li>\n<li>\n<p>Optimistic UI(낙관적인 UI)란, 특정 요청이 성공할 것이라 가정하고 먼저 그 요청의 결과를 보여주는 방식이다. 페이스북의 좋아요 버튼을 누르면 바로 좋아요 누르기에 성공한 것처럼 UI에 표시되지만, 실제 네트워크 탭을 보면 요청과 완료는 그보다 늦게 진행되는 것이 그 예시다. 반대로 비관적 업데이트는 서버의 응답을 기다리고 처리하는 방식이다.</p>\n</li>\n<li>\n<p>blue-green 배포란, blue(원본), green(대체) 두 버전 모두 실행 상태를 유지시켜 놓고 blue에 배포가 진행되면 green으로 잠시 사용자 트래픽을 이전해두는 방식의 무중단 배포 아키텍쳐다.</p>\n</li>\n<li>\n<p>심볼릭 링크란, 링크를 연결하여 원본 파일을 직접 사용하는 것과 같은 효과를 내는 링크이다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">package.json</code>에 패키지 의존성을 추가할 때, <code class=\"language-text\">^</code>(캐럿)을 붙임으로써 자동 업데이트의 위험성은 존재하지 않는지 고려해봐야 한다. 또, yarn에서는 패키지 버전에 <code class=\"language-text\">^</code>을 붙여도 자동 업데이트를 하지 않는다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">outline-offset</code> - outline과 요소의 border 영역 사이의 여백을 정의할 수 있는 속성이다.</p>\n</li>\n<li>\n<p>Next.js(10 버전 이상)에서는 이미지 lazy loading이 자동으로 적용되어 있다.</p>\n</li>\n<li>\n<p>core-js는 폴리필 라이브러리로 ES 최신 문법에 대한 폴리필을 지원한다. 단독으로 사용할 수도 있지만, babel이나 swc에 통합되어 있기 때문에 자연스럽게 같이 사용할 수 있다.</p>\n</li>\n<li>\n<p>개발자를 농락하는 이모지의 재미있는 사실</p>\n\n          <div class=\"gatsby-remark-prismjs-copy-button-container\">\n            <div class=\"gatsby-remark-prismjs-copy-button\" tabindex=\"0\" role=\"button\" aria-pressed=\"false\" onclick=\"gatsbyRemarkCopyToClipboard(this, this.parentNode.nextElementSibling)\">\n              Copy\n            </div>\n          </div>\n          \n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> test <span class=\"token operator\">=</span> <span class=\"token string\">\"해피👨‍👨‍👧‍👦뉴이어\"</span><span class=\"token punctuation\">;</span>\ntest<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// '해피👨'</span>\ntest<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// '해피👨‍👨'</span></code></pre></div>\n<p>이모지를 포함한 문자열을 원하는 길이로 자를 때는 반드시 주의하자! (이모지를 제거 후에 순수한 문자열을 자르는 것도 좋은 방법이다.)</p>\n</li>\n<li>\n<p>optionalDependencies - <code class=\"language-text\">npm install --no-optional</code> 명령어로 실행하며, <code class=\"language-text\">optionalDependencies</code>에 추가한 디펜던시는 설치되지 않는다.</p>\n</li>\n<li>\n<p>네이밍에 대한 컨벤션을 강제할 수 있는 <a href=\"https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/naming-convention.md#enforce-that-boolean-variables-are-prefixed-with-an-allowed-verb\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lint rule</a>이 있다.</p>\n</li>\n<li>\n<p><a href=\"https://getcssscan.com/css-box-shadow-examples\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CSS shadow 모아보기</a></p>\n</li>\n</ul>\n<p><strong>Ref</strong>\n<a href=\"https://kdydesign.github.io/2020/08/25/mono-repo-lerna/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kdydesign.github.io/2020/08/25/mono-repo-lerna/</a>\n<a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.typescriptlang.org/docs/handbook/advanced-types.html</a>\n<a href=\"https://docs.npmjs.com/cli/v6/configuring-npm/package-json#optionaldependencies\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.npmjs.com/cli/v6/configuring-npm/package-json#optionaldependencies</a></p>\n<hr>\n<h2 id=\"기타\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%ED%83%80\" aria-label=\"기타 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기타</h2>\n<p>요번주는 읎당 ㅎㅎ 이번주에 읽은 &#x26; 본 것들을 모아보자.</p>\n<ul>\n<li><code class=\"language-text\">React.cloneElement()</code>\n<a href=\"https://blog.logrocket.com/using-react-cloneelement-function/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.logrocket.com/using-react-cloneelement-function/</a></li>\n<li>Headless 컴포넌트\n<a href=\"https://medium.com/@nirbenyair/headless-components-in-react-and-why-i-stopped-using-ui-libraries-a8208197c268\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@nirbenyair/headless-components-in-react-and-why-i-stopped-using-ui-libraries-a8208197c268</a></li>\n<li>TypeScript로 React Generic Component 정의하기\n<a href=\"https://medium.com/@hamzazaheer721/generic-components-in-react-typescript-ea8e77735f84\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://medium.com/@hamzazaheer721/generic-components-in-react-typescript-ea8e77735f84</a></li>\n<li>svg viewport * viewbox\n<a href=\"https://puterism.com/svg-viewport-and-viewbox/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://puterism.com/svg-viewport-and-viewbox/</a></li>\n<li>‘세이클럽의 아버지’ 남세동 대표의 인공지능 강의①\n<a href=\"https://www.youtube.com/watch?v=mDqCC3i14bI\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=mDqCC3i14bI</a></li>\n</ul>\n<hr>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>첫 월급을 받았다! 많이 주는 줄 알았지만 진짜 많이 줘서… 이래도 되나 싶고… 그만큼 또 열심히 해야겠당. ‘나에게 주는 선물’ 중독자는 이틀동안 2만 보 가까이 걸으며 알차게 플렉스를 즐기고 앓아눕진 않았다. 고작 지난 2주 운동한 게 효과가 있나보다 ㅎㅎ 운동 더 열심히 해서 짱 쎄져야겠다고 다짐했다.</p>","timeToRead":14,"frontmatter":{"title":"2월 4주차 기록","date":"February 27, 2022","description":"weekly-i-learned","tags":["weekly"],"disqus":null},"fields":{"langKey":"en"}}},"pageContext":{"slug":"/weekly/2022-2-week-4/","previous":{"fields":{"slug":"/oop-true-or-false/oop-true-and-false-5/","langKey":"en","directoryName":"oop-true-or-false"},"frontmatter":{"date":"March 05, 2022","description":null,"title":"객체지향의 사실과 오해 - 5장","tags":["oop-true-and-false"]}},"next":{"fields":{"slug":"/oop-true-or-false/oop-true-and-false-4/","langKey":"en","directoryName":"oop-true-or-false"},"frontmatter":{"date":"February 27, 2022","description":null,"title":"객체지향의 사실과 오해 - 4장","tags":["oop-true-and-false"]}},"previousInSameTag":{"fields":{"slug":"/weekly/2022-3-week-1/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"March 05, 2022","description":"weekly-i-learned","title":"3월 첫주차 기록","tags":["weekly"]}},"nextInSameTag":{"fields":{"slug":"/weekly/2022-2-week-3/","langKey":"en","directoryName":"weekly"},"frontmatter":{"date":"February 19, 2022","description":"weekly-i-learned","title":"2월 3주차 기록","tags":["weekly"]}},"translationsLink":[]}},"staticQueryHashes":["1522010811","2466007692","2894998521","3765107650","683610688"]}