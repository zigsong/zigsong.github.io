<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>UI runtime으로서의 리액트 - zig-log</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="zig-log"><meta name="msapplication-TileImage" content="/images/balloon-favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="zig-log"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="UI runtime으로서의 리액트"><meta property="og:type" content="blog"><meta property="og:title" content="UI runtime으로서의 리액트"><meta property="og:url" content="https://zigsong.github.io/2021/09/26/fe-react-as-ui-runtime/"><meta property="og:site_name" content="zig-log"><meta property="og:description" content="UI runtime으로서의 리액트"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zigsong.github.io/images/mac-thumbnail.jpeg"><meta property="article:published_time" content="2021-09-26T00:14:09.000Z"><meta property="article:modified_time" content="2021-11-07T05:17:58.345Z"><meta property="article:author" content="jieun song"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/mac-thumbnail.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zigsong.github.io/2021/09/26/fe-react-as-ui-runtime/"},"headline":"UI runtime으로서의 리액트","image":[],"datePublished":"2021-09-26T00:14:09.000Z","dateModified":"2021-11-07T05:17:58.345Z","author":{"@type":"Person","name":"jieun song"},"description":"UI runtime으로서의 리액트"}</script><link rel="canonical" href="https://zigsong.github.io/2021/09/26/fe-react-as-ui-runtime/"><link rel="icon" href="/images/balloon-favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">ZIG-LOG</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zigsong"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-09-26T00:14:09.000Z" title="2021. 9. 26. 오전 9:14:09">2021-09-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-07T05:17:58.345Z" title="2021. 11. 7. 오후 2:17:58">2021-11-07</time></span><span class="level-item"><a class="link-muted" href="/categories/frontend/">frontend</a></span><span class="level-item">41 minutes read (About 6103 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">UI runtime으로서의 리액트</h1><div class="content"><h3 id="UI-runtime으로서의-리액트"><a href="#UI-runtime으로서의-리액트" class="headerlink" title="UI runtime으로서의 리액트"></a>UI runtime으로서의 리액트</h3><img class="preview" src="/images/mac-thumbnail.jpeg">

<span id="more"></span>

<br />
<br />

<p>어쩌다 보니 <a target="_blank" rel="noopener" href="https://overreacted.io/react-as-a-ui-runtime/">Dan Abramov의 글</a>을 모두 번역해 버린 포스팅</p>
<hr>
<h3 id="Host-Tree"><a href="#Host-Tree" class="headerlink" title="Host Tree"></a>Host Tree</h3><p>리액트는 시간이 지나면서 바뀔 수 있는 트리를 반환한다. 이 트리는 UI와 함께 그려지는데, 이를 ‘호스트 트리’라고 한다. 이 트리는 DOM 등의 형태로 리액트의 바깥에 위치한다. 리액트는 그의 상단에 놓인 레이어일 뿐이다.</p>
<p>리액트는 두 가지 원칙을 기반으로 한다.</p>
<ul>
<li>안정성 - 호스트 트리는 안정적이며 전체적인 구조를 급진적으로 바꾸지 않는다.</li>
<li>규칙성 - 호스트 트리는 일관적인 UI 패턴들로 나눠진다. </li>
</ul>
<h3 id="Host-Instances"><a href="#Host-Instances" class="headerlink" title="Host Instances"></a>Host Instances</h3><p>호스트 트리는 노드들로 구성되는데, 이를 ‘호스트 인스턴스’라고 한다. DOM 환경에서 호스트 인스턴스들은 일반적인 DOM 노드를 가리킨다. 호스트 인스턴스는 자신만의 프로퍼티들을 가지고 있으며, 다른 호스트 인스턴스들을 자식으로 가질 수 있다.</p>
<p>호스트 인스턴스를 조작할 수 있는 API들이 있다(ex. <code>appendChild</code>, <code>removeChild</code>, <code>setAttribute</code>). 리액트 앱을 만들 때는 이 API들을 직접적으로 호출하지 않는다. 리액트는 이 일을 대신 해준다!</p>
<h3 id="Renderers"><a href="#Renderers" class="headerlink" title="Renderers"></a>Renderers</h3><p>렌더러는 리액트가 특정한 호스트 환경을 파악하고 호스트 인스턴스를 관리하게끔 해준다. React DOM 등이 리액트의 렌더러다. (자신만의 리액트 렌더러를 만들 수도 있다.)</p>
<p>렌더러의 대부분은 ‘변화 모드’(mutating mode)로 동작한다. 우리는 노드를 생성하고, 프로퍼티를 할당하고, 자식 요소를 추가하거나 삭제할 수 있다. 호스트 인스턴스는 변경 가능한 요소다.</p>
<p>리액트는 ‘지속 모드’(persistent mode)로도 동작한다. 부모 트리를 복제하여 항상 최상위 자식 요소를 대체하는 호스트 환경에서 사용한다. 호스트 트리의 불변성은 멀티쓰레딩을 도와준다. (cf. <a target="_blank" rel="noopener" href="https://reactnative.dev/blog/2018/06/14/state-of-react-native-2018">React Fabric</a>)</p>
<h3 id="React-Elements"><a href="#React-Elements" class="headerlink" title="React Elements"></a>React Elements</h3><p>호스트 환경에서, DOM 노드와 같은 호스트 인스턴스는 구성 요소의 최소 단위다. 이를 ‘리액트 엘리먼트’라고 한다. 리액트 엘리먼트는 순수한 자바스크립트 객체다. 이는 호스트 인스턴스를 설명한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX is a syntax sugar for these objects.</span></span><br><span class="line"><span class="comment">// &lt;button className=&quot;blue&quot; /&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">  props: &#123; <span class="attr">className</span>: <span class="string">&#x27;blue&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>호스트 인스턴스와 마찬가지로, 리액트 엘리먼트는 트리를 형성할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX is a syntax sugar for these objects.</span></span><br><span class="line"><span class="comment">// &lt;dialog&gt;</span></span><br><span class="line"><span class="comment">//   &lt;button className=&quot;blue&quot; /&gt;</span></span><br><span class="line"><span class="comment">//   &lt;button className=&quot;red&quot; /&gt;</span></span><br><span class="line"><span class="comment">// &lt;/dialog&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&#x27;dialog&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: [&#123;</span><br><span class="line">      type: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">      props: &#123; <span class="attr">className</span>: <span class="string">&#x27;blue&#x27;</span> &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      type: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">      props: &#123; <span class="attr">className</span>: <span class="string">&#x27;red&#x27;</span> &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러나, 리액트 엘리먼트는 자체적으로 동일성을 지속하는 방법이 없다. 언제나 재생성되고 사라질 수 있다.</p>
<p>리액트 엘리먼트는 불변성을 유지한다. 따라서 리액트 엘리먼트의 자식 요소나 프로퍼티를 직접 바꿀 수 없다. 다른 것을 렌더링하고 싶다면, 새로운 리액트 엘리먼트 트리를 다시 만들어야 한다.</p>
<p>리액트 엘리먼트는 특정한 순간의 UI를 스냅샷처럼 캡쳐할 뿐, 스스로 바뀌지는 않는다!</p>
<h3 id="Entry-Point"><a href="#Entry-Point" class="headerlink" title="Entry Point"></a>Entry Point</h3><p>각각의 리액트 렌더러는 ‘엔트리 포인트’가 있다. 이는 리액트에게 컨테이너 호스트 인스턴스 내부에 리액트 엘리먼트 트리를 렌더하도록 지시한다. </p>
<p>ReactDOM의 엔트리 포인트는 <code>ReactDOM.render</code>로 작성한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// &#123; type: &#x27;button&#x27;, props: &#123; className: &#x27;blue&#x27; &#125; &#125;</span></span><br><span class="line">  &lt;button className=<span class="string">&quot;blue&quot;</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>ReactDOM.render(reactElement, domContainer)</code>과 같은 코드는 리액트에게 <code>domContainer</code>라는 호스트 트리를 <code>reactElement</code>에 대응하게끔 만들 것을 지시한다.</p>
<h3 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h3><p><code>ReactDOM.render()</code>로 동일한 컨테이너를 두 번 호출하면 어떻게 될까?</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">&quot;blue&quot;</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... later ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Should this *replace* the button host instance</span></span><br><span class="line"><span class="comment">// or merely update a property on an existing one?</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">&quot;red&quot;</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;containe&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>호스트 트리를 주어진 리액트 엘리먼트 트리와 동일하게 만드는 것은 리액트의 역할이다. 새로운 정보에 따라 호스트 인스턴스 트리를 구성하는 작업을 ‘재조정(reconciliation)’이라고 한다.</p>
<p>호스트 인스턴스 트리를 업데이트하는 간단한 방법은 기존 트리를 모두 날리고 처음부터 다시 만드는 것이겠지만, 실제 DOM에서 이 과정은 느리게 동작하며 중요한 정보들을 잃을 수도 있다.</p>
<p>리액트는 기존의 호스트 인스턴스를 언제 새로운 리액트 엘리먼트로 업데이트해야 하는지, 그리고 언제 새로 만들어야 하는지 결정한다. 이전과 이후의 렌더에서 요소가 트리에서 동일한 위치에 있다면, 리액트는 기존의 호스트 인스턴스를 그대로 재사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let domNode = document.createElement(&#x27;button&#x27;);</span></span><br><span class="line"><span class="comment">// domNode.className = &#x27;blue&#x27;;</span></span><br><span class="line"><span class="comment">// domContainer.appendChild(domNode);</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">&quot;blue&quot;</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can reuse host instance? Yes! (button → button)</span></span><br><span class="line"><span class="comment">// domNode.className = &#x27;red&#x27;;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">&quot;red&quot;</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>HTML 태그의 타입이 일치하여 재사용할 수 있는 호스트 인스턴스의 경우 리액트는 해당 인스턴스를 재사용하며, 타입이 바뀌었을 경우 새로 생성한다. </p>
<p>그런데 특정 시점에 생성되는 조건부 요소라면 어떨까?</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params">&#123; showMessage &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> message = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (showMessage) &#123;</span><br><span class="line">    message = <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I was just added here!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;dialog&gt;</span><br><span class="line">      &#123;message&#125;</span><br><span class="line">      &lt;input /&gt;</span><br><span class="line">    &lt;/dialog&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제에서 <code>&lt;input /&gt;</code> 요소는 <code>showMessage</code>값이 변화할 때 새롭게 추가되는 <code>&lt;p&gt;</code> 요소에 의해 위치가 밀려나게 된다. 이때 단순히 위치의 이동이 필요한 요소의 경우 제거 후 다시 생성하지 않는다. <code>&lt;input /&gt;</code> 요소는 렌더 간에 항상 동일한 위치를 유지할 것이다.</p>
<p><code>showMessage</code>의 값이 <code>true</code>이든 <code>false</code>이든 상관없이, <code>message</code> 요소가 <code>&lt;dialog&gt;</code>의 첫 번째 자식으로 들어가있을 것이기 때문이다. <code>showMessage</code>의 값이 <code>false</code>일 때, <code>message</code> 요소는 <code>null</code>을 반환한다.</p>
<p>리액트는 <code>insertBefore</code> 등의 DOM API를 사용하여 해당하는 위치에 새로운 요소를 삽입한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inputNode = dialogNode.firstChild;</span><br><span class="line"><span class="keyword">let</span> pNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">pNode.textContent = <span class="string">&#x27;I was just added here!&#x27;</span>;</span><br><span class="line">dialogNode.insertBefore(pNode, inputNode);</span><br></pre></td></tr></table></figure>

<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>호스트 인스턴스의 재사용과 재생성 여부를 판단하기 위해서는 트리에에서 같은 위치에 있는 요소의 타입을 비교하는 것으로 충분하지만, 이는 자식 요소들의 위치가 정적일 때만 정상적으로 동작한다. 동적인 리스트에서, 순서는 항상 보장되지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingList</span>(<span class="params">&#123; list &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &#123;list.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          You bought &#123;item.name&#125;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          Enter how many <span class="keyword">do</span> you want: <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 아래로 변환될 것이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> pNode = formNode.childNodes[i];</span><br><span class="line">  <span class="keyword">let</span> textNode = pNode.firstChild;</span><br><span class="line">  textNode.textContent = <span class="string">&#x27;You bought &#x27;</span> + items[i].name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아이템이 추가되는 등 정렬이 바뀔 때, 위 과정을 매번 반복해야 한다.</p>
<p>그러나 리액트는 모든 리스트 아이템들을 다시 정렬하는 대신, 각 요소를 성능상으로 효과적으로 업데이트한다. 리액트가 이 작업을 수행하기 위해 우리는 배열의 요소들에 <code>key</code> prop을 전달해야 한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingList</span>(<span class="params">&#123; list &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &#123;list.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;p key=&#123;item.productId&#125;&gt;</span><br><span class="line">          You bought &#123;item.name&#125;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          Enter how many <span class="keyword">do</span> you want: <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>key</code>를 통해 리액트는 동일한 부모 요소의 안에서 렌더 사이에 위치가 바뀌는 자식 요소들이 개념적으로는 동일하다는 것을 알 수 있다. 렌더 이후에 동일한 키를 가진 호스트 인스턴스가 있다면 리액트는 이를 재사용하고, 이에 따라 형제 요소들을 재정렬한다.</p>
<p><code>key</code>는 특정한 부모 요소 안에서만 유효하다. <code>key</code>는 리스트의 순서가 바뀌어도 아이템이 동일함을 보장해야 하기 때문에, 고유한 ID 값을 사용하는 것이 바람직하다.</p>
<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>컴포넌트는 객체 해쉬(object hash)라는 하나의 값을 갖는다. 이는 props를 포함한다.</p>
<h3 id="Purity"><a href="#Purity" class="headerlink" title="Purity"></a>Purity</h3><p>리액트 컴포넌트는 그들의 props에 대해서 순수함을 보장한다. 즉 리액트에서 props는 변경할 수 없다. </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 🔴 Doesn&#x27;t work</span></span><br><span class="line">  props.isActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러나 지역 변수의 변경은 가능하다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendList</span>(<span class="params">&#123; friends &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; friends.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> friend = friends[i];</span><br><span class="line">    items.push(</span><br><span class="line">      &lt;Friend key=&#123;friend.id&#125; friend=&#123;friend&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;items&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제에서 <code>items</code>는 렌더링 과정에서 생성되었으며, 다른 컴포넌트들에 영향을 미치지 않기 때문에 직접 변경할 수 있다. </p>
<p>컴포넌트를 여러 번 호출하는 것이 안전하고 다른 컴포넌트들의 렌더링에 영향을 주지 않는다면, 리액트는 해당 컴포넌트가 100% 순수함을 보장하지 않는다. 리액트에서는 순수성보다 멱등성(Idempotence)이 더 중요하다.</p>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><p>컴포넌트들은 함수이므로 우리는 이를 호출할 수 있다. </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reactElement = Form(&#123; <span class="attr">showMessage</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">ReactDOM.render(reactElement, domContainer);</span><br></pre></td></tr></table></figure>

<p>그러나 런타임에서 우리는 컴포넌트 함수를 직접 호출하지 않는다. 이는 리액트가 할 일이다. 우리는 React Element를 이용하여 컴포넌트의 호출을 리액트에게 위임한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; type: Form, props: &#123; showMessage: true &#125; &#125;</span></span><br><span class="line"><span class="keyword">let</span> reactElement = <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">showMessage</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span>;</span><br><span class="line">ReactDOM.render(reactElement, domContainer);</span><br></pre></td></tr></table></figure>

<p>컴포넌트 함수들은 대문자로 시작해야 한다는 규칙이 있다. JSX는 대문자로 시작하는 요소들만을 리액트 컴포넌트로 인식한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="xml"><span class="tag">&lt;<span class="name">form</span> /&gt;</span></span>.type); <span class="comment">// &#x27;form&#x27; string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="xml"><span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span>.type); <span class="comment">// Form function</span></span><br></pre></td></tr></table></figure>

<p>리액트는 컴포넌트를 호출하고, 그 컴포넌트가 어떤 요소를 렌더하고 싶은지 파악한다. 이 과정은 컴포넌트가 렌더하는 자식 컴포넌트들에 대해서 재귀적으로 반복된다. </p>
<p>재조정 과정이 재귀적인 이유다. 리액트는 요소 트리를 탐색하면서. <code>type</code>이 컴포넌트인 요소를 만나게 된다. 리액트는 해당 요소를 호출하고 반환된 리액트 엘리먼트 트리를 따라 계속 내려간다. 모든 컴포넌트에 다다르면, 리액트 트리는 호스트 트리에서 무엇을 바꿔야 하는지 알게 된다. (이 과정에서 같은 위치에 있던 요소의 <code>type</code>이 바뀌면 호스트 인스턴스를 제거하고 재생성하는 것이다!)</p>
<h3 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a>Inversion of Control</h3><p>왜 컴포넌트를 직접적으로 호출하지 않을까? </p>
<p>리액트가 컴포넌트들의 관계를 잘 알고 있기만 하다면, 우리보다 이 일을 훨씬 더 잘 수행하기 때문이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🔴 React has no idea Layout and Article exist.</span></span><br><span class="line"><span class="comment">// You&#x27;re calling them.</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  Layout(&#123; <span class="attr">children</span>: Article() &#125;),</span><br><span class="line">  domContainer</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ React knows Layout and Article exist.</span></span><br><span class="line"><span class="comment">// React calls them.</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Layout&gt;<span class="xml"><span class="tag">&lt;<span class="name">Article</span> /&gt;</span></span>&lt;/Layout&gt;,</span><br><span class="line">  domContainer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>이는 대표적인 <strong>제어의 역전(inversion of control)</strong> 의 사례다. </p>
<ul>
<li>컴포넌트는 함수보다 할 수 있는 것이 많다. 리액트는 트리에서 컴포넌트의 로컬 변수를 다룰 수 있으며, 기본적인 추상화를 해준다. 리액트는 UI 트리를 렌더하고 사용자 인터랙션에 반응한다. 만약 컴포넌트를 직접 호출한다면, 이 모든 기능들을 스스로 구현해야 할 것이다.</li>
<li>컴포넌트 타입은 재조정 과정에 관여한다. 리액트가 모든 컴포넌트를 호출하게 함으로써, 트리의 개념적인 구조를 리액트에게 알려줄 수 있다.</li>
<li>리액트는 재조정을 지연시킬 수 있다. 리액트가 우리의 컴포넌트에 대해 제어권을 갖는다면, 많은 일들을 할 수 있다. 예를 들면, 컴포넌트 호출 간 브라우저에게 다른 일을 시켜 큰 컴포넌트 트리가 리렌더되는 동안 메인 쓰레드를 블라킹하지 않게 해준다.</li>
<li>디버깅 히스토리가 남는다. JavaScript 함수로 구현한 컴포넌트는 많은 라이브러리들이 두러워하는 일급 객체(🤔)인데, 리액트를 사요하면 개발 단계에서 훌륭한 디버깅 툴을 활용할 수 있다.</li>
</ul>
<h3 id="Lazy-Evaluation"><a href="#Lazy-Evaluation" class="headerlink" title="Lazy Evaluation"></a>Lazy Evaluation</h3><p>자바스크립트에서 함수를 호출하면, 인자들은 호출 이전에 평가된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (2) This gets computed second</span></span><br><span class="line">eat(</span><br><span class="line">  <span class="comment">// (1) This gets computed first</span></span><br><span class="line">  prepareMeal()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>하지만 리액트 컴포넌트들은 상대적으로 순수(pure)하다. 컴포넌트를 스크린에 렌더하기 전까지는 실행시킬 이유가 없다. 만약 컴포넌트를 함수처럼 호출한다면, 해당 자식 컴포넌트를 렌더하는 부모 컴포넌트가 해당 컴포넌트를 조건부로 렌더링하고 싶은 상황에서도 무조건적으로 자식 컴포넌트를 호출할 것이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">&#123; currentUser &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Page user=&#123;currentUser&#125;&gt;</span><br><span class="line">      &lt;Comments /&gt;</span><br><span class="line">    &lt;/Page&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">&#123; user, children &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// early exit</span></span><br><span class="line">  <span class="keyword">if</span> (!user.isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please log in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Comments</code> 컴포넌트에는 early exit 조건이 존재한다. <code>user.isLoggedIn</code>의 값이 <code>false</code>라면 <code>Layout</code>과 <code>children</code>을 렌더링하지 않아도 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Page&gt;</span><br><span class="line">      &#123;Comments()&#125;</span><br><span class="line">    &lt;/Page&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러나 위처럼 <code>Comments</code> 컴포넌트를 함수로 호출하면, <code>Comments</code> 내부의 조건에 상관없이 우선 평가되어 실행된다.</p>
<p>하지만 리액트 엘리먼트에서는, 개발자가 컴포넌트를 직접 호출하지 않는다. 컴포넌트의 호출 시점을 결정하는 것은 리액트의 책임이다. 위 예제에서 <code>Page</code> 컴포넌트가 children prop을 렌더하기 전에 early exit하게 된다면, 리액트는 <code>Comments</code> 함수를 호출하지 않을 것이다. 이는 불필요한 렌더링을 줄여주고, 코드의 안전성을 보장해 준다!</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>호스트 인스턴스는 모든 종류의 로컬 상태(local state)을 가질 수 있다. 이 값들은 컴포넌트의 업데이트 이후 동일한 UI를 렌더 시 유지되어야 한다. 반면 개념적으로 다른 내용을 렌더할 때 요소를 제거할 수도 있어야 한다.</p>
<p>리액트의 컴포넌트는 로컬 상태를 가질 수 있다. 이를 ‘hooks’라고 부른다.</p>
<p>리액트에서 기본으로 제공하는 <code>useState</code> hook은 값과 해당 값을 업데이트할 수 있는 함수를 반환한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p>재조정 과정을 논-블로킹 작업으로 분리하고 싶어도, 실제 호스트 트리에서는 이를 단일한 동기적인 과정으로 구현해야 한다. 그렇게 해야 절반만 업데이트된 UI를 렌더링하지 않을 수 있고, 브라우저가 불필요한 레이아웃과 스타일 재계산의 과정을 거치지 않음을 보장할 수 있다.</p>
<p>이것이 리액트가 모든 작업을 ‘렌더 단계(render phase)’와 ‘commit phase(커밋 단계)’로 나누는 이유다. 렌더 단계에서 리액트는 컴포넌트를 호출하고 재조정을 실행한다. 커밋 단계에서 리액트는 호스트 트리를 조작한다. 이 과정은 항상 동기적이다.</p>
<h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><p>부모 컴포넌트가 <code>setState</code>를 호출하여 업데이트를 발생시킨다면, 리액트는 모든 자식 서브트리에 대해 재조정을 실시한다. 리액트는 부모의 업데이트가 자식을 언제 업데이트시키는지 모르기 때문이다.</p>
<p>트리가 너무 깊거나 넓으면, 리액트가 서브트리를 메모(memoize)할 수 있게끔 만들어줄 수 있다. 리액트는 렌더 이전의 결과와 prop 간의 얕은 비교를 통해 서브트리를 재사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Row</span>(<span class="params">&#123; item &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Row);</span><br></pre></td></tr></table></figure>

<p>각각의 표현식에 대해 <code>useMemo</code> hook을 사용할 수도 있다. 메모이제이션이 기억하는 캐시는 컴포넌트 트리에 한정적이며, 지역 변수와 함께 사라진다. 메모이제이션은 오직 마지막 값만 기억하고 있다.</p>
<h3 id="Raw-Models"><a href="#Raw-Models" class="headerlink" title="Raw Models"></a>Raw Models</h3><p>아이러니하게도, 리액트는 ‘반응형(reactivity)’이 아니다. 상위에서의 모든 업데이트는 변화가 필요한 컴포넌트 뿐 아니라 모든 컴포넌트에 재조정을 유발한다.</p>
<p>웹앱에서는 TTI(Time To Interactive)가 중요하고, 이벤트 리스너를 등록하기 위해 모든 모델을 탐색(traverse)하는 것은 시간 낭비다. 많은 앱에서, 상호작용은 UI 업데이트를 유발하고, 세밀하게 설계된 구독(subscription) 시스템에서 이는 메모리 낭비로 이어진다.</p>
<p>리액트의 핵심 디자인 원칙 중 하나는 리액트는 날 것(raw)의 데이터를 다룬다는 것이다. 네트워크에서 받은 자바스크립트 객체들이 있다면, 이를 어떤 전처리 과정 없이 컴포넌트로 직접 연결할 수 있다. 직접 프로퍼티에 접근할 수 없으며, 구조 변경 시 예측 불가능한 성능 절벽이 발생하지 않는다. </p>
<p>주식 티커와 같은 경우 세밀하게 설계된 구독 시스템이 유리할 수도 있다. 이는 모든 것이 동일한 시점에 지속적으로 업데이트되어야 하는 경우 사용된다. 리액트는 이런 경우에는 최선의 선택지가 아니다.</p>
<h3 id="Batching"><a href="#Batching" class="headerlink" title="Batching"></a>Batching</h3><p>하나의 이벤트에 대해 여러 컴포넌트가 상태를 업데이트하고 싶을 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">      Parent clicked &#123;count&#125; times</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">      Child clicked &#123;count&#125; times</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제에서 Child의 <code>onClick</code>이 먼저 실행되어 <code>setState</code>를 호출하고, Parent의 <code>onClick</code>이 실행되어 <code>setState</code>가 호출될 때 리액트가 각각의 <code>setState</code> 호출에 대해 즉시 컴포넌트를 리렌더한다면 Child 컴포넌트는 두 번 리렌더될 것이다. 이때 Child 컴포넌트의 첫 번째 렌더링은 낭비된다.</p>
<p>리액트는 이벤트 핸들러들 안에서 업데이트를 그룹화(batch)한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*** Entering React&#39;s browser click event handler ***</span><br><span class="line">Child (onClick)</span><br><span class="line">  - setState</span><br><span class="line">Parent (onClick)</span><br><span class="line">  - setState</span><br><span class="line">*** Processing state updates                     ***</span><br><span class="line">  - re-render Parent</span><br><span class="line">  - re-render Child</span><br><span class="line">*** Exiting React&#39;s browser click event handler  ***</span><br></pre></td></tr></table></figure>

<p><code>setState</code> 호출은 즉시 리렌더를 유발하지 않는다. 리액트는 모든 이벤트 핸들러를 우선 실행한 후, 그에 해당하는 업데이트들을 묶어서 한번 리렌더한다.</p>
<p>batching은 성능상으로 효과적이지만, 아래와 같은 코드에서는 예측이 어려울 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setCount(count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  increment();</span><br><span class="line">  increment();</span><br><span class="line">  increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleClick</code> 내부에서 호출되는 <code>increment</code> 작업들은 모두 하나로 묶여 실행되기 때문에, <code>setCount(1)</code>을 세 번 호출하게 된다.</p>
<p>이런 문제를 해결하기 위해 리액트는 <code>setState</code>에 updater 함수를 전달하는 것을 권장한다. </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// count의 이전 상태(업데이트 이후의 상태)를 보장한다.</span></span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  increment();</span><br><span class="line">  increment();</span><br><span class="line">  increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useState</code> 호출이 복잡해진다면, <code>useReducer</code> hook을 사용하여 로컬의 상태를 표현하는 것을 권장한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [counter, dispatch] = useReducer(<span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action === <span class="string">&#x27;increment&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dispatch(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">    dispatch(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">    dispatch(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Call-Tree"><a href="#Call-Tree" class="headerlink" title="Call Tree"></a>Call Tree</h3><p>프로그래밍 언어는 종종 콜 스택을 가진다. 리액트는 자바스크립트 기반으로 동작하기 때문에 자바스크립트의 규칙을 따른다. 리액트는 내부적으로 현재 렌더중인 컴포넌트를 기억하는 콜 스택을 가진다.</p>
<p>리액트는 UI 트리의 렌더링을 목적으로 하기 때문에, 일반적인 언어들의 런타임과는 다르다. 이 트리들은 사용자와의 인터랙션을 위해 ‘stay alive’해야 한다. DOM은 첫 번째 <code>ReactDOM.render</code> 호출 이후 사라지지 않아야 한다.</p>
<p>리액트 컴포넌트를 ‘콜 스택’보다는 ‘콜 트리’로 생각하는 것이 좋다. 특정 컴포넌트 바깥으로 나가더라도, 리액트 ‘콜 트리’는 제거되지 않아야 한다. (콜 스택에서는 함수가 호출되면 해당 함수는 콜 스택에서 사라진다.) 어디선가는 로컬 상태값과 호스트 인스턴스에 대한 참조를 유지하고 있어야 한다. (cf. <a target="_blank" rel="noopener" href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7">React Fiber</a>)</p>
<p>이 ‘콜 트리’ 프레임은 재조정이 필요하다고 판단될 때에 로컬 상태와 호스트 인스턴스와 같이 제거된다. Fiber는 로컬 상태가 실제로 살아있는 고간이다. 상태가 변경되면, 리액트는 Fiber에 재조정이 필요함을 마킹하고, 컴포넌트들을 호출한다.</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>리액트에서는 다른 컴포넌트에게 props를 통해 데이터를 전달한다. 하지만 모든 계층을 따라 props를 전달하는 것은 귀찮은 일이다. </p>
<p>리액트는 이에 대한 대안으로 Context API를 제공한다. Context는 컴포넌트들에게 동적인 스코프를 제공하는 것과 같다. 상위(Context Provider)에 데이터를 위치시키면, 자식 요소(Context Consumer)들에서 해당 데이터에 접근하거나 데이터의 변경에 따라 리렌더를 할 수 있다.</p>
<h3 id="Effects"><a href="#Effects" class="headerlink" title="Effects"></a>Effects</h3><p>리액트 컴포넌트의 리렌더링 시에는 사이드 이펙트가 있어서는 안되지만, 때때로 사이드 이펙트가 필요한 경우가 있다. focus를 조절하거나, canvas를 그리거나, 데이터의 원천을 구독할 경우 등이다. 이 경우 <code>useEffect</code> hook을 사용할 수 있다.</p>
<p>리액트는 브라우저가 스크린을 리페인트할 때까지 effect의 실행을 가능한 지연시킨다. 이로써 데이터 구독과 같은 코드가 TTI(Time to Interactive)와 TTFP(Time to First Paint)를 저하시키지 않음을 보장한다. (모든 것을 동기적으로 동작시키는 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect">useLayoutEffect hook</a>도 있다.)</p>
<p>effect는 디펜던시 배열에 따라 컴포넌트의 마운트 후에도 여러 번 실행될 수 있으며, cleanup 함수를 통해 컴포넌트 언마운트(제거) 시 실행할 동작을 정의할 수도 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  DataSource.addSubscription(handleChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> DataSource.removeSubscription(handleChange);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>특정한 변수값을 넣어 해당 값이 바뀔 때만 리렌더링을 수행할 수도 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>

<h3 id="Custom-Hooks"><a href="#Custom-Hooks" class="headerlink" title="Custom Hooks"></a>Custom Hooks</h3><p><code>useState</code>와 <code>useEffect</code> 등의 hook들은 모두 함수 호출이기 때문에, 우리는 이것들을 우리만의 hook으로 조합할 수 있다. </p>
<p>custom hook은 서로 다른 컴포넌트들이 상태를 포함하고 있는, 재사용 가능한 로직을 공유하도록 해준다. 이때 상태(state) 자체는 공유되지 않는다. 각각의 hook 호출은 독립적인 상태를 가진다.</p>
<h3 id="Static-Use-Order"><a href="#Static-Use-Order" class="headerlink" title="Static Use Order"></a>Static Use Order</h3><p>리액트에서 상태는 컴포넌트에 국한된다. <code>use</code> prefix는 문법은 아니지만, hooks의 네이밍 컨벤션이다.</p>
<p>또한 hook은 오직 컴포넌트 내부에서 선언되어야 하며, 조건부로 선언되어서는 안 된다. (cf. <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-rules.html">Rules of Hooks</a>)</p>
<p>각 hook은 linked list의 형태로 호출된다. <code>useState</code>를 호출하면, 다음 아이템으로 포인터를 옮긴다. 컴포넌트의 ‘콜 트리’를 벗어나면, 다음 렌더가 있을 때까지 hook 호출의 결과들을 리스트로 관리한다.</p>
<h3 id="What’s-Left-Out"><a href="#What’s-Left-Out" class="headerlink" title="What’s Left Out"></a>What’s Left Out</h3><p>리액트 잘 쓰자! 😜</p>
<hr>
<p><strong>Ref</strong> <a target="_blank" rel="noopener" href="https://overreacted.io/react-as-a-ui-runtime/">https://overreacted.io/react-as-a-ui-runtime/</a> </p>
</div><div class="article-licensing box"><div class="licensing-title"><p>UI runtime으로서의 리액트</p><p><a href="https://zigsong.github.io/2021/09/26/fe-react-as-ui-runtime/">https://zigsong.github.io/2021/09/26/fe-react-as-ui-runtime/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>jieun song</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-09-26</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-11-07</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/10/02/woowa-week-33/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">우테코 33주차 기록</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/18/fe-apple-clone/"><span class="level-item">애플 클론코딩(을 빙자한 복제)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/profile_hexo.jpeg" alt="zig song"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zig song</p><p class="is-size-6 is-block">FE Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">158</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-info is-outlined is-rounded" href="/" target="_self" rel="noopener">Home</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zigsong"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:wldms5764@gmail.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#UI-runtime으로서의-리액트"><span class="level-left"><span class="level-item">1</span><span class="level-item">UI runtime으로서의 리액트</span></span></a></li><li><a class="level is-mobile" href="#Host-Tree"><span class="level-left"><span class="level-item">2</span><span class="level-item">Host Tree</span></span></a></li><li><a class="level is-mobile" href="#Host-Instances"><span class="level-left"><span class="level-item">3</span><span class="level-item">Host Instances</span></span></a></li><li><a class="level is-mobile" href="#Renderers"><span class="level-left"><span class="level-item">4</span><span class="level-item">Renderers</span></span></a></li><li><a class="level is-mobile" href="#React-Elements"><span class="level-left"><span class="level-item">5</span><span class="level-item">React Elements</span></span></a></li><li><a class="level is-mobile" href="#Entry-Point"><span class="level-left"><span class="level-item">6</span><span class="level-item">Entry Point</span></span></a></li><li><a class="level is-mobile" href="#Reconciliation"><span class="level-left"><span class="level-item">7</span><span class="level-item">Reconciliation</span></span></a></li><li><a class="level is-mobile" href="#Conditions"><span class="level-left"><span class="level-item">8</span><span class="level-item">Conditions</span></span></a></li><li><a class="level is-mobile" href="#Lists"><span class="level-left"><span class="level-item">9</span><span class="level-item">Lists</span></span></a></li><li><a class="level is-mobile" href="#Components"><span class="level-left"><span class="level-item">10</span><span class="level-item">Components</span></span></a></li><li><a class="level is-mobile" href="#Purity"><span class="level-left"><span class="level-item">11</span><span class="level-item">Purity</span></span></a></li><li><a class="level is-mobile" href="#Recursion"><span class="level-left"><span class="level-item">12</span><span class="level-item">Recursion</span></span></a></li><li><a class="level is-mobile" href="#Inversion-of-Control"><span class="level-left"><span class="level-item">13</span><span class="level-item">Inversion of Control</span></span></a></li><li><a class="level is-mobile" href="#Lazy-Evaluation"><span class="level-left"><span class="level-item">14</span><span class="level-item">Lazy Evaluation</span></span></a></li><li><a class="level is-mobile" href="#State"><span class="level-left"><span class="level-item">15</span><span class="level-item">State</span></span></a></li><li><a class="level is-mobile" href="#Consistency"><span class="level-left"><span class="level-item">16</span><span class="level-item">Consistency</span></span></a></li><li><a class="level is-mobile" href="#Memoization"><span class="level-left"><span class="level-item">17</span><span class="level-item">Memoization</span></span></a></li><li><a class="level is-mobile" href="#Raw-Models"><span class="level-left"><span class="level-item">18</span><span class="level-item">Raw Models</span></span></a></li><li><a class="level is-mobile" href="#Batching"><span class="level-left"><span class="level-item">19</span><span class="level-item">Batching</span></span></a></li><li><a class="level is-mobile" href="#Call-Tree"><span class="level-left"><span class="level-item">20</span><span class="level-item">Call Tree</span></span></a></li><li><a class="level is-mobile" href="#Context"><span class="level-left"><span class="level-item">21</span><span class="level-item">Context</span></span></a></li><li><a class="level is-mobile" href="#Effects"><span class="level-left"><span class="level-item">22</span><span class="level-item">Effects</span></span></a></li><li><a class="level is-mobile" href="#Custom-Hooks"><span class="level-left"><span class="level-item">23</span><span class="level-item">Custom Hooks</span></span></a></li><li><a class="level is-mobile" href="#Static-Use-Order"><span class="level-left"><span class="level-item">24</span><span class="level-item">Static Use Order</span></span></a></li><li><a class="level is-mobile" href="#What’s-Left-Out"><span class="level-left"><span class="level-item">25</span><span class="level-item">What’s Left Out</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/frontend/"><span class="level-start"><span class="level-item">frontend</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/categories/git-github/"><span class="level-start"><span class="level-item">git &amp; github</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nestjs/"><span class="level-start"><span class="level-item">nestjs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/oop-true-and-false/"><span class="level-start"><span class="level-item">oop-true-and-false</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/refactoring/"><span class="level-start"><span class="level-item">refactoring</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/retrospective/"><span class="level-start"><span class="level-item">retrospective</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/categories/troubleshooting/"><span class="level-start"><span class="level-item">troubleshooting</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/woowacourse/"><span class="level-start"><span class="level-item">woowacourse</span></span><span class="level-end"><span class="level-item tag">35</span></span></a></li><li><a class="level is-mobile" href="/categories/wtc-havruta-fe/"><span class="level-start"><span class="level-item">wtc-havruta-fe</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/wtc-pr-log/"><span class="level-start"><span class="level-item">wtc-pr-log</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/wtc-study-log/"><span class="level-start"><span class="level-item">wtc-study-log</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%EA%B8%80%EB%98%90/"><span class="level-start"><span class="level-item">글또</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/07/16/2022-7-week-3/"><img src="/images/retrospective-thumbnail.jpeg" alt="7월 3주차 기록"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-15T23:40:20.000Z">2022-07-16</time></p><p class="title"><a href="/2022/07/16/2022-7-week-3/">7월 3주차 기록</a></p><p class="categories"><a href="/categories/retrospective/">retrospective</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/10/npm-troubleshooting/"><img src="/images/troubleshooting-thumbnail.jpeg" alt="legacy-peer-deps 너 뭐 돼?"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-10T13:51:13.000Z">2022-07-10</time></p><p class="title"><a href="/2022/07/10/npm-troubleshooting/">legacy-peer-deps 너 뭐 돼?</a></p><p class="categories"><a href="/categories/troubleshooting/">troubleshooting</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/09/2022-7-week-2/"><img src="/images/retrospective-thumbnail.jpeg" alt="7월 2주차 기록"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-08T23:39:54.000Z">2022-07-09</time></p><p class="title"><a href="/2022/07/09/2022-7-week-2/">7월 2주차 기록</a></p><p class="categories"><a href="/categories/retrospective/">retrospective</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/07/02/2022-7-week-1/"><img src="/images/retrospective-thumbnail.jpeg" alt="7월 1주차 기록"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-07-02T05:50:48.000Z">2022-07-02</time></p><p class="title"><a href="/2022/07/02/2022-7-week-1/">7월 1주차 기록</a></p><p class="categories"><a href="/categories/retrospective/">retrospective</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/06/25/2022-6-week-4/"><img src="/images/retrospective-thumbnail.jpeg" alt="6월 4주차 기록"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-06-25T04:59:05.000Z">2022-06-25</time></p><p class="title"><a href="/2022/06/25/2022-6-week-4/">6월 4주차 기록</a></p><p class="categories"><a href="/categories/retrospective/">retrospective</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">September 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">June 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">March 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">ZIG-LOG</a><p class="is-size-7"><span>&copy; 2022 jieun song</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>